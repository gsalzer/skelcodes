{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n}\n\ninterface IComptroller {\n    /**\n     * @notice Marker function used for light validation when updating the comptroller of a market\n     * @dev Implementations should simply return true.\n     * @return true\n     */\n    function isComptroller() external view returns (bool);\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n    function exitMarket(address cToken) external returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\n    function getAssetsIn(address account) external view returns (address[] memory);\n\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;\n\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) external;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) external returns (uint);\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount,\n        uint borrowerIndex) external;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) external returns (uint);\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        uint seizeTokens) external;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) external returns (uint);\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) external;\n\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint repayAmount) external view returns (uint, uint);\n}\n\ncontract ICEther {\n    function mint() external payable;\n    function borrow(uint borrowAmount) external returns (uint);\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function repayBorrow() external payable;\n    function repayBorrowBehalf(address borrower) external payable;\n    function borrowBalanceCurrent(address account) external returns (uint);\n    function borrowBalanceStored(address account) external view returns (uint256);\n    function balanceOfUnderlying(address account) external returns (uint);\n    function balanceOf(address owner) external view returns (uint256);\n}\n\ninterface ICToken {\n    function mint(uint mintAmount) external returns (uint);\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function borrow(uint borrowAmount) external returns (uint);\n    function repayBorrow(uint repayAmount) external returns (uint);\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\n    function exchangeRateCurrent() external returns (uint);\n    function borrowBalanceCurrent(address account) external returns (uint);\n    function borrowBalanceStored(address account) external view returns (uint256);\n    function balanceOfUnderlying(address account) external returns (uint);\n    \n    function underlying() external view returns (address);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function allowance(address, address) external view returns (uint);\n    function approve(address, uint) external;\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ncontract ILendingPoolAddressesProvider {\n\n    function getLendingPool() public view returns (address);\n    function setLendingPoolImpl(address _pool) public;\n\n    function getLendingPoolCore() public view returns (address payable);\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\n\n    function getLendingPoolConfigurator() public view returns (address);\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\n\n    function getLendingPoolDataProvider() public view returns (address);\n    function setLendingPoolDataProviderImpl(address _provider) public;\n\n    function getLendingPoolParametersProvider() public view returns (address);\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\n\n    function getTokenDistributor() public view returns (address);\n    function setTokenDistributor(address _tokenDistributor) public;\n\n    function getFeeProvider() public view returns (address);\n    function setFeeProviderImpl(address _feeProvider) public;\n\n    function getLendingPoolLiquidationManager() public view returns (address);\n    function setLendingPoolLiquidationManager(address _manager) public;\n\n    function getLendingPoolManager() public view returns (address);\n    function setLendingPoolManager(address _lendingPoolManager) public;\n\n    function getPriceOracle() public view returns (address);\n    function setPriceOracle(address _priceOracle) public;\n\n    function getLendingRateOracle() public view returns (address);\n    function setLendingRateOracle(address _lendingRateOracle) public;\n\n}\n\ninterface ILendingPool {\n  function addressesProvider () external view returns ( address );\n  function deposit ( address _reserve, uint256 _amount, uint16 _referralCode ) external payable;\n  function redeemUnderlying ( address _reserve, address _user, uint256 _amount ) external;\n  function borrow ( address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode ) external;\n  function repay ( address _reserve, uint256 _amount, address _onBehalfOf ) external payable;\n  function swapBorrowRateMode ( address _reserve ) external;\n  function rebalanceFixedBorrowRate ( address _reserve, address _user ) external;\n  function setUserUseReserveAsCollateral ( address _reserve, bool _useAsCollateral ) external;\n  function liquidationCall ( address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveAToken ) external payable;\n  function flashLoan ( address _receiver, address _reserve, uint256 _amount, bytes calldata _params ) external;\n  function getReserveConfigurationData ( address _reserve ) external view returns ( uint256 ltv, uint256 liquidationThreshold, uint256 liquidationDiscount, address interestRateStrategyAddress, bool usageAsCollateralEnabled, bool borrowingEnabled, bool fixedBorrowRateEnabled, bool isActive );\n  function getReserveData ( address _reserve ) external view returns ( uint256 totalLiquidity, uint256 availableLiquidity, uint256 totalBorrowsFixed, uint256 totalBorrowsVariable, uint256 liquidityRate, uint256 variableBorrowRate, uint256 fixedBorrowRate, uint256 averageFixedBorrowRate, uint256 utilizationRate, uint256 liquidityIndex, uint256 variableBorrowIndex, address aTokenAddress, uint40 lastUpdateTimestamp );\n  function getUserAccountData ( address _user ) external view returns ( uint256 totalLiquidityETH, uint256 totalCollateralETH, uint256 totalBorrowsETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );\n  function getUserReserveData ( address _reserve, address _user ) external view returns ( uint256 currentATokenBalance, uint256 currentUnderlyingBalance, uint256 currentBorrowBalance, uint256 principalBorrowBalance, uint256 borrowRateMode, uint256 borrowRate, uint256 liquidityRate, uint256 originationFee, uint256 variableBorrowIndex, uint256 lastUpdateTimestamp, bool usageAsCollateralEnabled );\n  function getReserves () external view;\n}\n\ncontract ILendingPoolParametersProvider {\n    function getFlashLoanFeesInBips() public view returns (uint256, uint256);\n}\n\ncontract IUniswapExchange {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n    // Provide Liquidity\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\n    // ERC20 comaptibility for liquidity tokens\n    bytes32 public name;\n    bytes32 public symbol;\n    uint256 public decimals;\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    // Never use\n    function setup(address token_addr) external;\n}\n\ncontract IUniswapFactory {\n    // Public Variables\n    address public exchangeTemplate;\n    uint256 public tokenCount;\n    // Create Exchange\n    function createExchange(address token) external returns (address exchange);\n    // Get Exchange and Token Info\n    function getExchange(address token) external view returns (address exchange);\n    function getToken(address exchange) external view returns (address token);\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\n    // Never use\n    function initializeFactory(address template) external;\n}\n\ncontract UniswapLiteBase {\n    // Uniswap Mainnet factory address\n    address constant UniswapFactoryAddress = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\n\n    function _getUniswapExchange(address tokenAddress) internal view returns (address) {\n        return IUniswapFactory(UniswapFactoryAddress).getExchange(tokenAddress);\n    }\n\n    function _ethToToken(address tokenAddress, uint ethAmount)\n        internal returns (uint) {\n        return _ethToToken(tokenAddress, ethAmount, uint(1));\n    }\n\n    function _ethToToken(address tokenAddress, uint ethAmount, uint minTokenAmount)\n        internal returns (uint) {\n        return IUniswapExchange(_getUniswapExchange(tokenAddress))\n            .ethToTokenSwapInput.value(ethAmount)(minTokenAmount, uint(now + 60));\n    }\n\n    function _tokenToEth(address tokenAddress, uint tokenAmount) internal returns (uint) {\n        return _tokenToEth(tokenAddress, tokenAmount, uint(1));\n    }\n\n    function _tokenToEth(address tokenAddress, uint tokenAmount, uint minEthAmount) internal returns (uint) {\n        address exchange = _getUniswapExchange(tokenAddress);\n\n        IERC20(tokenAddress).approve(exchange, tokenAmount);\n\n        return IUniswapExchange(exchange)\n            .tokenToEthSwapInput(tokenAmount, minEthAmount, uint(now + 60));\n    }\n\n    function _tokenToToken(address from, address to, uint tokenInAmount, uint minTokenOut) internal returns (uint) {\n        uint ethAmount = _tokenToEth(from, tokenInAmount);\n        return _ethToToken(to, ethAmount, minTokenOut);\n    }\n\n    function _tokenToToken(address from, address to, uint tokenAmount) internal returns (uint) {\n        return _tokenToToken(from, to, tokenAmount, uint(1));\n    }\n\n    function _getTokenToEthInput(address tokenAddress, uint tokenAmount) internal view returns (uint) {\n        return IUniswapExchange(_getUniswapExchange(tokenAddress)).getTokenToEthInputPrice(tokenAmount);\n    }\n\n    function _getEthToTokenInput(address tokenAddress, uint ethAmount) internal view returns (uint) {\n        return IUniswapExchange(_getUniswapExchange(tokenAddress)).getEthToTokenInputPrice(ethAmount);\n    }\n\n    function _getTokenToEthOutput(address tokenAddress, uint ethAmount) internal view returns (uint) {\n        return IUniswapExchange(_getUniswapExchange(tokenAddress)).getTokenToEthOutputPrice(ethAmount);\n    }\n\n    function _getEthToTokenOutput(address tokenAddress, uint tokenAmount) internal view returns (uint) {\n        return IUniswapExchange(_getUniswapExchange(tokenAddress)).getEthToTokenOutputPrice(tokenAmount);\n    }\n\n    function _getTokenToTokenInput(address from, address to, uint fromAmount) internal view returns (uint) {\n        uint ethAmount = _getTokenToEthInput(from, fromAmount);\n        return _getEthToTokenInput(to, ethAmount);\n    }\n}\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (address(authority) == address(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\ncontract DSGuardEvents {\n    event LogPermit(\n        bytes32 indexed src,\n        bytes32 indexed dst,\n        bytes32 indexed sig\n    );\n\n    event LogForbid(\n        bytes32 indexed src,\n        bytes32 indexed dst,\n        bytes32 indexed sig\n    );\n}\n\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\n    bytes32 constant public ANY = bytes32(uint(-1));\n\n    mapping (bytes32 => mapping (bytes32 => mapping (bytes32 => bool))) acl;\n\n    function canCall(\n        address src_, address dst_, bytes4 sig\n    ) public view returns (bool) {\n        bytes32 src = bytes32(bytes20(src_));\n        bytes32 dst = bytes32(bytes20(dst_));\n\n        return acl[src][dst][sig]\n            || acl[src][dst][ANY]\n            || acl[src][ANY][sig]\n            || acl[src][ANY][ANY]\n            || acl[ANY][dst][sig]\n            || acl[ANY][dst][ANY]\n            || acl[ANY][ANY][sig]\n            || acl[ANY][ANY][ANY];\n    }\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\n        acl[src][dst][sig] = true;\n        emit LogPermit(src, dst, sig);\n    }\n\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\n        acl[src][dst][sig] = false;\n        emit LogForbid(src, dst, sig);\n    }\n\n    function permit(address src, address dst, bytes32 sig) public {\n        permit(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\n    }\n    function forbid(address src, address dst, bytes32 sig) public {\n        forbid(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\n    }\n\n}\n\ncontract DSGuardFactory {\n    mapping (address => bool)  public  isGuard;\n\n    function newGuard() public returns (DSGuard guard) {\n        guard = new DSGuard();\n        guard.setOwner(msg.sender);\n        isGuard[address(guard)] = true;\n    }\n}\n\ncontract AddressRegistry {\n    // Aave\n    address public AaveLendingPoolAddressProviderAddress = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n    address public AaveEthAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // Uniswap\n    address public UniswapFactoryAddress = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\n\n    // Compound\n    address public CompoundPriceOracleAddress = 0x1D8aEdc9E924730DD3f9641CDb4D1B92B848b4bd;\n    address public CompoundComptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address public CEtherAddress = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public CUSDCAddress = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\n    address public CDaiAddress = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n    address public CSaiAddress = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\n\n    // Token(s)\n    address public DaiAddress = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public BatAddress = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;\n    address public UsdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    // MakerDAO\n    // https://changelog.makerdao.com/\n    // https://changelog.makerdao.com/releases/mainnet/1.0.4/contracts.json\n    address public EthJoinAddress = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;\n    address public UsdcJoinAddress = 0xA191e578a6736167326d05c119CE0c90849E84B7;\n    address public BatJoinAddress = 0x3D0B1912B66114d4096F48A8CEe3A56C231772cA;\n    address public DaiJoinAddress = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address public JugAddress = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\n    address public DssProxyActionsAddress = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;\n    address public DssCdpManagerAddress = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n}\n\ncontract BytesLibLite {\n    // A lite version of the ByteLib, containing only the \"slice\" function we need\n\n    function sliceToEnd(\n        bytes memory _bytes,\n        uint256 _start\n    ) internal pure returns (bytes memory) {\n        require(_start < _bytes.length, \"bytes-read-out-of-bounds\");\n\n        return slice(\n            _bytes,\n            _start,\n            _bytes.length - _start\n        );\n    }\n    \n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length), \"bytes-read-out-of-bounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function bytesToAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= (_start + 20), \"Read out of bounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface IFlashLoanReceiver {\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\n}\n\ncontract FlashLoanReceiverBase is IFlashLoanReceiver {\n    using SafeMath for uint256;\n\n    address constant ETHADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    ILendingPoolAddressesProvider public addressesProvider = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    function () external payable {    }\n\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {\n        address payable core = addressesProvider.getLendingPoolCore();\n        transferInternal(core,_reserve, _amount);\n    }\n\n    function transferInternal(address payable _destination, address _reserve, uint256  _amount) internal {\n        if(_reserve == ETHADDRESS) {\n            //solium-disable-next-line\n            _destination.call.value(_amount)(\"\");\n            return;\n        }\n\n        IERC20(_reserve).transfer(_destination, _amount);\n    }\n\n    function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {\n        if(_reserve == ETHADDRESS) {\n\n            return _target.balance;\n        }\n\n        return IERC20(_reserve).balanceOf(_target);\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\ncontract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache;  // global cache for contracts\n\n    constructor(address _cacheAddr) public {\n        setCache(_cacheAddr);\n    }\n\n    function() external payable {\n    }\n\n    // use the proxy to execute calldata _data on contract _code\n    function execute(bytes memory _code, bytes memory _data)\n        public\n        payable\n        returns (address target, bytes memory response)\n    {\n        target = cache.read(_code);\n        if (target == address(0)) {\n            // deploy contract & store its address in cache\n            target = cache.write(_code);\n        }\n\n        response = execute(target, _data);\n    }\n\n    function execute(address _target, bytes memory _data)\n        public\n        auth\n        note\n        payable\n        returns (bytes memory response)\n    {\n        require(_target != address(0), \"ds-proxy-target-address-required\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n            let size := returndatasize\n\n            response := mload(0x40)\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                revert(add(response, 0x20), size)\n            }\n        }\n    }\n\n    //set new cache\n    function setCache(address _cacheAddr)\n        public\n        auth\n        note\n        returns (bool)\n    {\n        require(_cacheAddr != address(0), \"ds-proxy-cache-address-required\");\n        cache = DSProxyCache(_cacheAddr);  // overwrite cache\n        return true;\n    }\n}\n\ncontract DSProxyFactory {\n    event Created(address indexed sender, address indexed owner, address proxy, address cache);\n    mapping(address=>address) public proxies;\n    DSProxyCache public cache;\n\n    constructor() public {\n        cache = new DSProxyCache();\n    }\n\n    // deploys a new proxy instance\n    // sets owner of proxy to caller\n    function build() public returns (address payable proxy) {\n        proxy = build(msg.sender);\n    }\n\n    // deploys a new proxy instance\n    // sets custom owner of proxy\n    function build(address owner) public returns (address payable proxy) {\n        proxy = address(new DSProxy(address(cache)));\n        emit Created(msg.sender, owner, address(proxy), address(cache));\n        DSProxy(proxy).setOwner(owner);\n        proxies[owner] = proxy;\n    }\n}\n\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n            case 1 {\n                // throw if contract failed to deploy\n                revert(0, 0)\n            }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}\n\ncontract DACProxy is\n    DSProxy(address(1)),\n    FlashLoanReceiverBase,\n    BytesLibLite\n{\n    // TODO: Change this value\n    address payable constant protocolFeePayoutAddress1 = 0x773CCbFB422850617A5680D40B1260422d072f41;\n    address payable constant protocolFeePayoutAddress2 = 0xAbcCB8f0a3c206Bb0468C52CCc20f3b81077417B;\n\n    constructor(address _cacheAddr) public {\n        setCache(_cacheAddr);\n    }\n\n    function() external payable {}\n\n    // This is for Aave flashloans\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params\n    ) external\n        auth\n    {\n        // Assumes that once the action(s) are performed\n        // we will have totalDebt would of _reserve to repay\n        // aave and the protocol\n        uint protocolFee = _fee.div(2);\n\n        // Re-encodes new data \n        // Function signature should conform to:\n        /* (\n                // Note: for address, as abiEncoder pads it to 32 bytes our starting position is 12\n                // due to addresses having 20 bytes in length\n                address     - Address to call        | start: 12;  (20 bytes)\n                bytes       - Function sig           | start: 32;  (4 bytes)\n                uint        - Data of _amount        | start: 36;  (32 bytes)\n                uint        - Data of _aaveFee       | start: 68;  (32 bytes)\n                uint        - Data of _protocolFee   | start: 100; (32 bytes)\n                bytes       - Data of _data          | start: 132; (dynamic length)\n            )\n\n            i.e.\n\n            function myFunction(\n                uint amount,\n                uint aaveFee,\n                uint protocolFee,\n                bytes memory _data\n            ) { ... }\n        */\n        address targetAddress = bytesToAddress(_params, 12);\n        bytes memory fSig     = slice(_params, 32, 4);\n        bytes memory data     = sliceToEnd(_params, 132);\n\n        // Re-encodes function signature and injects new\n        // _amount, _fee, and _protocolFee into _data\n        bytes memory newData = abi.encodePacked(\n            fSig,\n            abi.encode(_amount),\n            abi.encode(_fee),\n            abi.encode(protocolFee),\n            data\n        );\n\n        // Executes new target\n        execute(targetAddress, newData);\n\n        // Repays protocol fee\n        if (_reserve == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            protocolFeePayoutAddress1.call.value(protocolFee.div(2))(\"\");\n            protocolFeePayoutAddress2.call.value(protocolFee.div(2))(\"\");\n        } else {\n            IERC20(_reserve).transfer(protocolFeePayoutAddress1, protocolFee.div(2));\n            IERC20(_reserve).transfer(protocolFeePayoutAddress2, protocolFee.div(2));\n        }\n\n        // Repays aave\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n    }\n}\n\ncontract DedgeExitManager is UniswapLiteBase {\n    using SafeMath for uint256;\n\n    function() external payable {}\n\n    constructor() public {}\n\n    struct DebtMarket {\n        address cToken;\n        uint256 amount;\n    }\n\n    struct CollateralMarket {\n        address cToken;\n        uint256 amount;\n    }\n\n    struct ExitPositionCalldata {\n        address payable exitUserAddress;\n        address addressRegistryAddress;\n        DebtMarket[] debtMarket;\n        CollateralMarket[] collateralMarket;\n    }\n\n    function _proxyGuardPermit(address payable proxyAddress, address src)\n        internal\n    {\n        address g = address(DACProxy(proxyAddress).authority());\n\n        DSGuard(g).permit(\n            bytes32(bytes20(address(src))),\n            DSGuard(g).ANY(),\n            DSGuard(g).ANY()\n        );\n    }\n\n    function _proxyGuardForbid(address payable proxyAddress, address src)\n        internal\n    {\n        address g = address(DACProxy(proxyAddress).authority());\n\n        DSGuard(g).forbid(\n            bytes32(bytes20(address(src))),\n            DSGuard(g).ANY(),\n            DSGuard(g).ANY()\n        );\n    }\n\n    function _approve(address cToken, uint256 amount) public {\n        // Approves CToken contract to call `transferFrom`\n        address underlying = ICToken(cToken).underlying();\n        require(\n            IERC20(underlying).approve(cToken, amount) == true,\n            \"cmpnd-mgr-ctoken-approved-failed\"\n        );\n    }\n\n    function _transfer(\n        address CEtherAddress,\n        address cToken,\n        address recipient,\n        uint256 amount\n    ) internal {\n        if (cToken == CEtherAddress) {\n            recipient.call.value(amount)(\"\");\n        } else {\n            require(\n                IERC20(ICToken(cToken).underlying()).transfer(\n                    recipient,\n                    amount\n                ),\n                \"cmpnd-mgr-transfer-failed\"\n            );\n        }\n    }\n\n    function _repayBorrow(address CEtherAddress, address cToken, uint256 amount)\n        internal\n    {\n        if (cToken == CEtherAddress) {\n            ICEther(cToken).repayBorrow.value(amount)();\n        } else {\n            _approve(cToken, amount);\n            require(\n                ICToken(cToken).repayBorrow(amount) == 0,\n                \"cmpnd-mgr-ctoken-repay-failed\"\n            );\n        }\n    }\n\n    function _redeemUnderlying(address cToken, uint256 redeemTokens) internal {\n        uint a = ICToken(cToken).redeemUnderlying(redeemTokens);\n        require(\n            a == 0,\n            \"cmpnd-mgr-ctoken-redeem-underlying-failed\"\n        );\n    }\n\n    function _repayDebt(address CEtherAddress, address cToken, uint256 amount)\n        internal\n    {\n        // Always assume we have enough ETH to repay debt\n        if (cToken != CEtherAddress) {\n            address underlying = ICToken(cToken).underlying();\n\n            // Get ETH needed to get ERC20\n            uint256 ethAmount = _getEthToTokenOutput(underlying, amount);\n\n            // Convert ETH to token\n            _ethToToken(underlying, ethAmount);\n        }\n\n        _repayBorrow(CEtherAddress, cToken, amount);\n    }\n\n    function _retrieveCollateral(\n        address CEtherAddress,\n        address cToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        // Redeems token\n        _redeemUnderlying(cToken, amount);\n\n        if (cToken == CEtherAddress) {\n            return amount;\n        }\n\n        address underlying = ICToken(cToken).underlying();\n        return _tokenToEth(underlying, amount);\n    }\n\n    function exitPositionsPostLoan(\n        uint256 _amount,\n        uint256 _fee,\n        uint256 _protocolFee,\n        bytes calldata _params\n    ) external {\n        // We should now have funds\n        ExitPositionCalldata memory epCalldata = abi.decode(\n            _params,\n            (ExitPositionCalldata)\n        );\n\n        AddressRegistry addressRegistry = AddressRegistry(\n            epCalldata.addressRegistryAddress\n        );\n        address CEtherAddress = addressRegistry.CEtherAddress();\n\n        // Repay debt and retrieve collateral\n        for (uint256 i = 0; i < epCalldata.debtMarket.length; i++) {\n            _repayDebt(\n                CEtherAddress,\n                epCalldata.debtMarket[i].cToken,\n                epCalldata.debtMarket[i].amount\n            );\n        }\n\n        uint256 totalEthAmount;\n        for (uint256 i = 0; i < epCalldata.collateralMarket.length; i++) {\n            totalEthAmount += _retrieveCollateral(\n                CEtherAddress,\n                epCalldata.collateralMarket[i].cToken,\n                epCalldata.collateralMarket[i].amount\n            );\n        }\n\n        // Repays (ETH - fees) back to exitAddress\n        epCalldata.exitUserAddress.call.value(\n            totalEthAmount.sub(_amount).sub(_fee).sub(_protocolFee)\n        )(\"\");\n    }\n\n    function exitPositions(\n        uint256 totalEthDebtAmount,\n        address dedgeExitManagerAddress,\n        address payable dacProxyAddress,\n        address addressRegistryAddress,\n        bytes calldata executeOperationCalldataParams\n    ) external {\n        AddressRegistry addressRegistry = AddressRegistry(\n            addressRegistryAddress\n        );\n\n        // Injects target address into calldataParams\n        bytes memory addressAndExecuteOperationCalldataParams = abi\n            .encodePacked(\n            abi.encode(dedgeExitManagerAddress),\n            executeOperationCalldataParams\n        );\n\n        ILendingPool lendingPool = ILendingPool(\n            ILendingPoolAddressesProvider(\n                addressRegistry.AaveLendingPoolAddressProviderAddress()\n            )\n                .getLendingPool()\n        );\n\n        // Approve lendingPool to call proxy\n        _proxyGuardPermit(dacProxyAddress, address(lendingPool));\n\n        // 3. Flashloan ETH with relevant data\n        lendingPool.flashLoan(\n            dacProxyAddress,\n            addressRegistry.AaveEthAddress(),\n            totalEthDebtAmount,\n            addressAndExecuteOperationCalldataParams\n        );\n\n        // Forbids lendingPool to call proxy\n        _proxyGuardForbid(dacProxyAddress, address(lendingPool));\n    }\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalEthDebtAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dedgeExitManagerAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"dacProxyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addressRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"executeOperationCalldataParams\",\"type\":\"bytes\"}],\"name\":\"exitPositions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"exitPositionsPostLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DedgeExitManager","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}]}