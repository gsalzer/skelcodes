{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n\r\n * Orbs Staking Smart Contract\r\n \r\n *************************************************************************\r\n *\r\n * CAUTION:\r\n *   Staking must be done only using the contract interface functions.\r\n *   Do NOT transfer tokens directly to the contract address.\r\n *   Tokens transferred directly to the contract address are NOT staked \r\n *   and CANNOT be recovered.\r\n *\r\n *************************************************************************\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**/\r\n\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/IMigratableStakingContract.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title An interface for staking contracts which support stake migration.\r\ninterface IMigratableStakingContract {\r\n    /// @dev Returns the address of the underlying staked token.\r\n    /// @return IERC20 The address of the token.\r\n    function getToken() external view returns (IERC20);\r\n\r\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\r\n    /// the required amount using ERC20 approve.\r\n    /// @param _stakeOwner address The specified stake owner.\r\n    /// @param _amount uint256 The number of tokens to stake.\r\n    function acceptMigration(address _stakeOwner, uint256 _amount) external;\r\n\r\n    event AcceptedMigration(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n}\r\n\r\n// File: contracts/IStakingContract.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title An interface for staking contracts.\r\ninterface IStakingContract {\r\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\r\n    /// the required amount using ERC20 approve.\r\n    /// @param _amount uint256 The amount of tokens to stake.\r\n    function stake(uint256 _amount) external;\r\n\r\n    /// @dev Unstakes ORBS tokens from msg.sender. If successful, this will start the cooldown period, after which\r\n    /// msg.sender would be able to withdraw all of his tokens.\r\n    /// @param _amount uint256 The amount of tokens to unstake.\r\n    function unstake(uint256 _amount) external;\r\n\r\n    /// @dev Requests to withdraw all of staked ORBS tokens back to msg.sender. Stake owners can withdraw their ORBS\r\n    /// tokens only after previously unstaking them and after the cooldown period has passed (unless the contract was\r\n    /// requested to release all stakes).\r\n    function withdraw() external;\r\n\r\n    /// @dev Restakes unstaked ORBS tokens (in or after cooldown) for msg.sender.\r\n    function restake() external;\r\n\r\n    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\r\n    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\r\n    /// convenience method, we aren't concerned about reaching block gas limit by using large lists. We assume that\r\n    /// callers will be able to properly batch/paginate their requests.\r\n    /// @param _totalAmount uint256 The total amount of rewards to distributes.\r\n    /// @param _stakeOwners address[] The addresses of the stake owners.\r\n    /// @param _amounts uint256[] The amounts of the rewards.\r\n    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external;\r\n\r\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\r\n    /// @param _stakeOwner address The address to check.\r\n    /// @return uint256 The total stake.\r\n    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);\r\n\r\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\r\n    /// @return uint256 The total staked tokens of all stake owners.\r\n    function getTotalStakedTokens() external view returns (uint256);\r\n\r\n    /// @dev Returns the time that the cooldown period ends (or ended) and the amount of tokens to be released.\r\n    /// @param _stakeOwner address The address to check.\r\n    /// @return cooldownAmount uint256 The total tokens in cooldown.\r\n    /// @return cooldownEndTime uint256 The time when the cooldown period ends (in seconds).\r\n    function getUnstakeStatus(address _stakeOwner) external view returns (uint256 cooldownAmount,\r\n        uint256 cooldownEndTime);\r\n\r\n    /// @dev Migrates the stake of msg.sender from this staking contract to a new approved staking contract.\r\n    /// @param _newStakingContract IMigratableStakingContract The new staking contract which supports stake migration.\r\n    /// @param _amount uint256 The amount of tokens to migrate.\r\n    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external;\r\n\r\n    event Staked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event Unstaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event Withdrew(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event Restaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event MigratedStake(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n}\r\n\r\n// File: contracts/IStakeChangeNotifier.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title An interface for notifying of stake change events (e.g., stake, unstake, partial unstake, restate, etc.).\r\ninterface IStakeChangeNotifier {\r\n    /// @dev Notifies of stake change event.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The difference in the total staked amount.\r\n    /// @param _sign bool The sign of the added (true) or subtracted (false) amount.\r\n    /// @param _updatedStake uint256 The updated total staked amount.\r\n    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) external;\r\n\r\n    /// @dev Notifies of multiple stake change events.\r\n    /// @param _stakeOwners address[] The addresses of subject stake owners.\r\n    /// @param _amounts uint256[] The differences in total staked amounts.\r\n    /// @param _signs bool[] The signs of the added (true) or subtracted (false) amounts.\r\n    /// @param _updatedStakes uint256[] The updated total staked amounts.\r\n    function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs,\r\n        uint256[] calldata _updatedStakes) external;\r\n\r\n    /// @dev Notifies of stake migration event.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The migrated amount.\r\n    function stakeMigration(address _stakeOwner, uint256 _amount) external;\r\n}\r\n\r\n// File: contracts/StakingContract.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n/// @title Orbs staking smart contract.\r\ncontract StakingContract is IStakingContract, IMigratableStakingContract {\r\n    using SafeMath for uint256;\r\n\r\n    struct Stake {\r\n        uint256 amount;\r\n        uint256 cooldownAmount;\r\n        uint256 cooldownEndTime;\r\n    }\r\n\r\n    struct WithdrawResult {\r\n        uint256 withdrawnAmount;\r\n        uint256 stakedAmount;\r\n        uint256 stakedAmountDiff;\r\n    }\r\n\r\n    // The version of the smart contract.\r\n    uint public constant VERSION = 1;\r\n\r\n    // The maximum number of approved staking contracts as migration destinations.\r\n    uint public constant MAX_APPROVED_STAKING_CONTRACTS = 10;\r\n\r\n    // The mapping between stake owners and their data.\r\n    mapping(address => Stake) internal stakes;\r\n\r\n    // Total amount of staked tokens (not including unstaked tokes in cooldown or pending withdrawal).\r\n    uint256 internal totalStakedTokens;\r\n\r\n    // The period (in seconds) between a stake owner's request to stop staking and being able to withdraw them.\r\n    uint256 public cooldownPeriodInSec;\r\n\r\n    // The address responsible for managing migration to a new staking contract.\r\n    address public migrationManager;\r\n\r\n    // The address responsible for emergency operations and graceful return of staked tokens back to their owners.\r\n    address public emergencyManager;\r\n\r\n    // The list of staking contracts that are approved by this contract. It would be only allowed to migrate a stake to\r\n    // one of these contracts.\r\n    IMigratableStakingContract[] public approvedStakingContracts;\r\n\r\n    // The address of the contract responsible for publishing stake change notifications.\r\n    IStakeChangeNotifier public notifier;\r\n\r\n    // The address of the ORBS token.\r\n    IERC20 internal token;\r\n\r\n    // Represents whether the contract accepts new staking requests. Please note, that even when it's turned off,\r\n    // it'd be still possible to unstake or withdraw tokens.\r\n    //\r\n    // Note: This can be turned off only once by the emergency manager of the contract.\r\n    bool public acceptingNewStakes = true;\r\n\r\n    // Represents whether this staking contract allows releasing all unstaked tokens unconditionally. When it's turned\r\n    // on, stake owners could release their staked tokens, without explicitly requesting to unstake them, and their\r\n    // previously unstaked tokens, regardless of the cooldown period. This also stops the contract from accepting new\r\n    // stakes.\r\n    //\r\n    // Note: This can be turned off only once by the emergency manager of the contract.\r\n    bool public releasingAllStakes = false;\r\n\r\n    event MigrationManagerUpdated(address indexed migrationManager);\r\n    event MigrationDestinationAdded(IMigratableStakingContract indexed stakingContract);\r\n    event MigrationDestinationRemoved(IMigratableStakingContract indexed stakingContract);\r\n    event EmergencyManagerUpdated(address indexed emergencyManager);\r\n    event StakeChangeNotifierUpdated(IStakeChangeNotifier indexed notifier);\r\n    event StoppedAcceptingNewStake();\r\n    event ReleasedAllStakes();\r\n\r\n    modifier onlyMigrationManager() {\r\n        require(msg.sender == migrationManager, \"StakingContract: caller is not the migration manager\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyEmergencyManager() {\r\n        require(msg.sender == emergencyManager, \"StakingContract: caller is not the emergency manager\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenAcceptingNewStakes() {\r\n        require(acceptingNewStakes && !releasingAllStakes, \"StakingContract: not accepting new stakes\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenStakesReleased() {\r\n        require(releasingAllStakes, \"StakingContract: not releasing all stakes\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenStakesNotReleased() {\r\n        require(!releasingAllStakes, \"StakingContract: releasing all stakes\");\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Initializes the staking contract.\r\n    /// @param _cooldownPeriodInSec uint256 The period (in seconds) between a stake owner's request to stop staking and being\r\n    /// able to withdraw them.\r\n    /// @param _migrationManager address The address responsible for managing migration to a new staking contract.\r\n    /// @param _emergencyManager address The address responsible for emergency operations and graceful return of staked\r\n    /// tokens back to their owners.\r\n    /// @param _token IERC20 The address of the ORBS token.\r\n    constructor(uint256 _cooldownPeriodInSec, address _migrationManager, address _emergencyManager, IERC20 _token) public {\r\n        require(_cooldownPeriodInSec > 0, \"StakingContract::ctor - cooldown period must be greater than 0\");\r\n        require(_migrationManager != address(0), \"StakingContract::ctor - migration manager must not be 0\");\r\n        require(_emergencyManager != address(0), \"StakingContract::ctor - emergency manager must not be 0\");\r\n        require(address(_token) != address(0), \"StakingContract::ctor - ORBS token must not be 0\");\r\n\r\n        cooldownPeriodInSec = _cooldownPeriodInSec;\r\n        migrationManager = _migrationManager;\r\n        emergencyManager = _emergencyManager;\r\n        token = _token;\r\n    }\r\n\r\n    /// @dev Sets the address of the migration manager.\r\n    /// @param _newMigrationManager address The address of the new migration manager.\r\n    function setMigrationManager(address _newMigrationManager) external onlyMigrationManager {\r\n        require(_newMigrationManager != address(0), \"StakingContract::setMigrationManager - address must not be 0\");\r\n        require(migrationManager != _newMigrationManager,\r\n            \"StakingContract::setMigrationManager - address must be different than the current address\");\r\n\r\n        migrationManager = _newMigrationManager;\r\n\r\n        emit MigrationManagerUpdated(_newMigrationManager);\r\n    }\r\n\r\n    /// @dev Sets the address of the emergency manager.\r\n    /// @param _newEmergencyManager address The address of the new emergency manager.\r\n    function setEmergencyManager(address _newEmergencyManager) external onlyEmergencyManager {\r\n        require(_newEmergencyManager != address(0), \"StakingContract::setEmergencyManager - address must not be 0\");\r\n        require(emergencyManager != _newEmergencyManager,\r\n            \"StakingContract::setEmergencyManager - address must be different than the current address\");\r\n\r\n        emergencyManager = _newEmergencyManager;\r\n\r\n        emit EmergencyManagerUpdated(_newEmergencyManager);\r\n    }\r\n\r\n    /// @dev Sets the address of the stake change notifier contract.\r\n    /// @param _newNotifier IStakeChangeNotifier The address of the new stake change notifier contract.\r\n    ///\r\n    /// Note: it's allowed to reset the notifier to a zero address.\r\n    function setStakeChangeNotifier(IStakeChangeNotifier _newNotifier) external onlyMigrationManager {\r\n        require(notifier != _newNotifier,\r\n            \"StakingContract::setStakeChangeNotifier - address must be different than the current address\");\r\n\r\n        notifier = _newNotifier;\r\n\r\n        emit StakeChangeNotifierUpdated(notifier);\r\n    }\r\n\r\n    /// @dev Adds a new contract to the list of approved staking contracts migration destinations.\r\n    /// @param _newStakingContract IMigratableStakingContract The new contract to add.\r\n    function addMigrationDestination(IMigratableStakingContract _newStakingContract) external onlyMigrationManager {\r\n        require(address(_newStakingContract) != address(0),\r\n            \"StakingContract::addMigrationDestination - address must not be 0\");\r\n\r\n        uint length = approvedStakingContracts.length;\r\n        require(length + 1 <= MAX_APPROVED_STAKING_CONTRACTS,\r\n            \"StakingContract::addMigrationDestination - can't add more staking contracts\");\r\n\r\n        // Check for duplicates.\r\n        for (uint i = 0; i < length; ++i) {\r\n            require(approvedStakingContracts[i] != _newStakingContract,\r\n                \"StakingContract::addMigrationDestination - can't add a duplicate staking contract\");\r\n        }\r\n\r\n        approvedStakingContracts.push(_newStakingContract);\r\n\r\n        emit MigrationDestinationAdded(_newStakingContract);\r\n    }\r\n\r\n    /// @dev Removes a contract from the list of approved staking contracts migration destinations.\r\n    /// @param _stakingContract IMigratableStakingContract The contract to remove.\r\n    function removeMigrationDestination(IMigratableStakingContract _stakingContract) external onlyMigrationManager {\r\n        require(address(_stakingContract) != address(0),\r\n            \"StakingContract::removeMigrationDestination - address must not be 0\");\r\n\r\n        // Check for existence.\r\n        (uint i, bool exists) = findApprovedStakingContractIndex(_stakingContract);\r\n        require(exists, \"StakingContract::removeMigrationDestination - staking contract doesn't exist\");\r\n\r\n        // Swap the requested element with the last element and then delete it using pop/\r\n        approvedStakingContracts[i] = approvedStakingContracts[approvedStakingContracts.length - 1];\r\n        approvedStakingContracts.pop();\r\n\r\n        emit MigrationDestinationRemoved(_stakingContract);\r\n    }\r\n\r\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\r\n    /// the required amount using ERC20 approve.\r\n    /// @param _amount uint256 The amount of tokens to stake.\r\n    function stake(uint256 _amount) external onlyWhenAcceptingNewStakes {\r\n        address stakeOwner = msg.sender;\r\n\r\n        uint256 totalStakedAmount = stake(stakeOwner, _amount);\r\n\r\n        emit Staked(stakeOwner, _amount, totalStakedAmount);\r\n\r\n        // Note: we aren't concerned with reentrancy since:\r\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\r\n        //   2. The notifier is set and managed by the migration manager.\r\n        stakeChange(stakeOwner, _amount, true, totalStakedAmount);\r\n    }\r\n\r\n    /// @dev Unstakes ORBS tokens from msg.sender. If successful, this will start the cooldown period, after which\r\n    /// msg.sender would be able to withdraw all of his tokens.\r\n    /// @param _amount uint256 The amount of tokens to unstake.\r\n    function unstake(uint256 _amount) external {\r\n        require(_amount > 0, \"StakingContract::unstake - amount must be greater than 0\");\r\n\r\n        address stakeOwner = msg.sender;\r\n        Stake storage stakeData = stakes[stakeOwner];\r\n        uint256 stakedAmount = stakeData.amount;\r\n        uint256 cooldownAmount = stakeData.cooldownAmount;\r\n        uint256 cooldownEndTime = stakeData.cooldownEndTime;\r\n\r\n        require(_amount <= stakedAmount, \"StakingContract::unstake - can't unstake more than the current stake\");\r\n\r\n        // If any tokens in cooldown are ready for withdrawal - revert. Stake owner should withdraw their unstaked\r\n        // tokens first.\r\n        require(cooldownAmount == 0 || cooldownEndTime > now,\r\n            \"StakingContract::unstake - unable to unstake when there are tokens pending withdrawal\");\r\n\r\n        // Update the amount of tokens in cooldown. Please note that this will also restart the cooldown period of all\r\n        // tokens in cooldown.\r\n        stakeData.amount = stakedAmount.sub(_amount);\r\n        stakeData.cooldownAmount = cooldownAmount.add(_amount);\r\n        stakeData.cooldownEndTime = now.add(cooldownPeriodInSec);\r\n\r\n        totalStakedTokens = totalStakedTokens.sub(_amount);\r\n\r\n        uint256 totalStakedAmount = stakeData.amount;\r\n\r\n        emit Unstaked(stakeOwner, _amount, totalStakedAmount);\r\n\r\n        // Note: we aren't concerned with reentrancy since:\r\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\r\n        //   2. The notifier is set and managed by the migration manager.\r\n        stakeChange(stakeOwner, _amount, false, totalStakedAmount);\r\n    }\r\n\r\n    /// @dev Requests to withdraw all of staked ORBS tokens back to msg.sender. Stake owners can withdraw their ORBS\r\n    /// tokens only after previously unstaking them and after the cooldown period has passed (unless the contract was\r\n    /// requested to release all stakes).\r\n    function withdraw() external {\r\n        address stakeOwner = msg.sender;\r\n\r\n        WithdrawResult memory res = withdraw(stakeOwner);\r\n\r\n        emit Withdrew(stakeOwner, res.withdrawnAmount, res.stakedAmount);\r\n\r\n        // Trigger staking state change notifications only if the staking amount was changed.\r\n        if (res.stakedAmountDiff == 0) {\r\n            return;\r\n        }\r\n\r\n        // Note: we aren't concerned with reentrancy since:\r\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\r\n        //   2. The notifier is set and managed by the migration manager.\r\n        stakeChange(stakeOwner, res.stakedAmountDiff, false, res.stakedAmount);\r\n    }\r\n\r\n    /// @dev Restakes unstaked ORBS tokens (in or after cooldown) for msg.sender.\r\n    function restake() external onlyWhenAcceptingNewStakes {\r\n        address stakeOwner = msg.sender;\r\n        Stake storage stakeData = stakes[stakeOwner];\r\n        uint256 cooldownAmount = stakeData.cooldownAmount;\r\n\r\n        require(cooldownAmount > 0, \"StakingContract::restake - no unstaked tokens\");\r\n\r\n        stakeData.amount = stakeData.amount.add(cooldownAmount);\r\n        stakeData.cooldownAmount = 0;\r\n        stakeData.cooldownEndTime = 0;\r\n\r\n        totalStakedTokens = totalStakedTokens.add(cooldownAmount);\r\n\r\n        uint256 totalStakedAmount = stakeData.amount;\r\n\r\n        emit Restaked(stakeOwner, cooldownAmount, totalStakedAmount);\r\n\r\n        // Note: we aren't concerned with reentrancy since:\r\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\r\n        //   2. The notifier is set and managed by the migration manager.\r\n        stakeChange(stakeOwner, cooldownAmount, true, totalStakedAmount);\r\n    }\r\n\r\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\r\n    /// the required amount using ERC20 approve.\r\n    /// @param _stakeOwner address The specified stake owner.\r\n    /// @param _amount uint256 The amount of tokens to stake.\r\n    function acceptMigration(address _stakeOwner, uint256 _amount) external onlyWhenAcceptingNewStakes {\r\n        uint256 totalStakedAmount = stake(_stakeOwner, _amount);\r\n\r\n        emit AcceptedMigration(_stakeOwner, _amount, totalStakedAmount);\r\n\r\n        // Note: we aren't concerned with reentrancy since:\r\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\r\n        //   2. The notifier is set and managed by the migration manager.\r\n        stakeChange(_stakeOwner, _amount, true, totalStakedAmount);\r\n    }\r\n\r\n    /// @dev Migrates the stake of msg.sender from this staking contract to a new approved staking contract.\r\n    /// @param _newStakingContract IMigratableStakingContract The new staking contract which supports stake migration.\r\n    /// @param _amount uint256 The amount of tokens to migrate.\r\n    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external\r\n        onlyWhenStakesNotReleased {\r\n        require(isApprovedStakingContract(_newStakingContract),\r\n            \"StakingContract::migrateStakedTokens - migration destination wasn't approved\");\r\n        require(_amount > 0, \"StakingContract::migrateStakedTokens - amount must be greater than 0\");\r\n\r\n        address stakeOwner = msg.sender;\r\n        Stake storage stakeData = stakes[stakeOwner];\r\n        uint256 stakedAmount = stakeData.amount;\r\n\r\n        require(stakedAmount > 0, \"StakingContract::migrateStakedTokens - no staked tokens\");\r\n        require(_amount <= stakedAmount, \"StakingContract::migrateStakedTokens - amount exceeds staked token balance\");\r\n\r\n        stakeData.amount = stakedAmount.sub(_amount);\r\n\r\n        totalStakedTokens = totalStakedTokens.sub(_amount);\r\n\r\n        require(_newStakingContract.getToken() == token,\r\n            \"StakingContract::migrateStakedTokens - staked tokens must be the same\");\r\n        require(token.approve(address(_newStakingContract), _amount),\r\n            \"StakingContract::migrateStakedTokens - couldn't approve transfer\");\r\n\r\n        emit MigratedStake(stakeOwner, _amount, stakeData.amount);\r\n\r\n        _newStakingContract.acceptMigration(stakeOwner, _amount);\r\n\r\n        // Note: we aren't concerned with reentrancy since:\r\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\r\n        //   2. The notifier is set and managed by the migration manager.\r\n        stakeMigration(stakeOwner, _amount);\r\n    }\r\n\r\n    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\r\n    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\r\n    /// convenience method, we aren't concerned about reaching block gas limit by using large lists. We assume that\r\n    /// callers will be able to batch/paginate their requests properly.\r\n    /// @param _totalAmount uint256 The total amount of rewards to distributes.\r\n    /// @param _stakeOwners address[] The addresses of the stake owners.\r\n    /// @param _amounts uint256[] The amounts of the rewards.\r\n    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external\r\n        onlyWhenAcceptingNewStakes {\r\n        require(_totalAmount > 0, \"StakingContract::distributeRewards - total amount must be greater than 0\");\r\n\r\n        uint256 stakeOwnersLength = _stakeOwners.length;\r\n        uint256 amountsLength = _amounts.length;\r\n\r\n        require(stakeOwnersLength > 0 && amountsLength > 0,\r\n            \"StakingContract::distributeRewards - lists can't be empty\");\r\n        require(stakeOwnersLength == amountsLength,\r\n            \"StakingContract::distributeRewards - lists must be of the same size\");\r\n\r\n        // Transfer all the tokens to the smart contract and update the stake owners list accordingly.\r\n        require(token.transferFrom(msg.sender, address(this), _totalAmount),\r\n            \"StakingContract::distributeRewards - insufficient allowance\");\r\n\r\n        bool[] memory signs = new bool[](amountsLength);\r\n        uint256[] memory totalStakedAmounts = new uint256[](amountsLength);\r\n\r\n        uint256 expectedTotalAmount = 0;\r\n        for (uint i = 0; i < stakeOwnersLength; ++i) {\r\n            address stakeOwner = _stakeOwners[i];\r\n            uint256 amount = _amounts[i];\r\n\r\n            require(stakeOwner != address(0), \"StakingContract::distributeRewards - stake owner can't be 0\");\r\n            require(amount > 0, \"StakingContract::distributeRewards - amount must be greater than 0\");\r\n\r\n            Stake storage stakeData = stakes[stakeOwner];\r\n            stakeData.amount = stakeData.amount.add(amount);\r\n\r\n            expectedTotalAmount = expectedTotalAmount.add(amount);\r\n\r\n            uint256 totalStakedAmount = stakeData.amount;\r\n            signs[i] = true;\r\n            totalStakedAmounts[i] = totalStakedAmount;\r\n\r\n            emit Staked(stakeOwner, amount, totalStakedAmount);\r\n        }\r\n\r\n        require(_totalAmount == expectedTotalAmount, \"StakingContract::distributeRewards - incorrect total amount\");\r\n\r\n        totalStakedTokens = totalStakedTokens.add(_totalAmount);\r\n\r\n        // Note: we aren't concerned with reentrancy since:\r\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\r\n        //   2. The notifier is set and managed by the migration manager.\r\n        stakeChangeBatch(_stakeOwners, _amounts, signs, totalStakedAmounts);\r\n    }\r\n\r\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\r\n    /// @param _stakeOwner address The address to check.\r\n    /// @return uint256 The stake of the stake owner.\r\n    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256) {\r\n        return stakes[_stakeOwner].amount;\r\n    }\r\n\r\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\r\n    /// @return uint256 The total staked tokens of all stake owners.\r\n    function getTotalStakedTokens() external view returns (uint256) {\r\n        return totalStakedTokens;\r\n    }\r\n\r\n    /// @dev Returns the time that the cooldown period ends (or ended) and the amount of tokens to be released.\r\n    /// @param _stakeOwner address The address to check.\r\n    /// @return cooldownAmount uint256 The total tokens in cooldown.\r\n    /// @return cooldownEndTime uint256 The time when the cooldown period ends (in seconds).\r\n    function getUnstakeStatus(address _stakeOwner) external view returns (uint256 cooldownAmount,\r\n        uint256 cooldownEndTime) {\r\n        Stake memory stakeData = stakes[_stakeOwner];\r\n        cooldownAmount = stakeData.cooldownAmount;\r\n        cooldownEndTime = stakeData.cooldownEndTime;\r\n    }\r\n\r\n    /// @dev Returns the address of the underlying staked token.\r\n    /// @return IERC20 The address of the token.\r\n    function getToken() external view returns (IERC20) {\r\n        return token;\r\n    }\r\n\r\n    /// @dev Requests the contract to stop accepting new staking requests.\r\n    function stopAcceptingNewStakes() external onlyEmergencyManager onlyWhenAcceptingNewStakes {\r\n        acceptingNewStakes = false;\r\n\r\n        emit StoppedAcceptingNewStake();\r\n    }\r\n\r\n    /// @dev Requests the contract to release all stakes.\r\n    function releaseAllStakes() external onlyEmergencyManager onlyWhenStakesNotReleased {\r\n        releasingAllStakes = true;\r\n\r\n        emit ReleasedAllStakes();\r\n    }\r\n\r\n    /// @dev Requests withdraw of released tokens for a list of addresses.\r\n    /// @param _stakeOwners address[] The addresses of the stake owners.\r\n    function withdrawReleasedStakes(address[] calldata _stakeOwners) external onlyWhenStakesReleased {\r\n        uint256 stakeOwnersLength = _stakeOwners.length;\r\n        uint256[] memory stakedAmountDiffs = new uint256[](stakeOwnersLength);\r\n        bool[] memory signs = new bool[](stakeOwnersLength);\r\n        uint256[] memory totalStakedAmounts = new uint256[](stakeOwnersLength);\r\n\r\n        for (uint i = 0; i < stakeOwnersLength; ++i) {\r\n            address stakeOwner = _stakeOwners[i];\r\n\r\n            WithdrawResult memory res = withdraw(stakeOwner);\r\n            stakedAmountDiffs[i] = res.stakedAmountDiff;\r\n            signs[i] = false;\r\n            totalStakedAmounts[i] = res.stakedAmount;\r\n\r\n            emit Withdrew(stakeOwner, res.withdrawnAmount, res.stakedAmount);\r\n        }\r\n\r\n        // Note: we aren't concerned with reentrancy since:\r\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\r\n        //   2. The notifier is set and managed by the migration manager.\r\n        stakeChangeBatch(_stakeOwners, stakedAmountDiffs, signs, totalStakedAmounts);\r\n    }\r\n\r\n    /// @dev Returns whether a specific staking contract was approved as a migration destination.\r\n    /// @param _stakingContract IMigratableStakingContract The staking contract to look for.\r\n    /// @return exists bool The approval status.\r\n    function isApprovedStakingContract(IMigratableStakingContract _stakingContract) public view returns (bool exists) {\r\n        (, exists) = findApprovedStakingContractIndex(_stakingContract);\r\n    }\r\n\r\n    /// @dev Returns whether stake change notification is enabled.\r\n    function shouldNotifyStakeChange() view internal returns (bool) {\r\n        return address(notifier) != address(0);\r\n    }\r\n\r\n    /// @dev Notifies of stake change events.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount int256 The difference in the total staked amount.\r\n    /// @param _sign bool The sign of the added (true) or subtracted (false) amount.\r\n    /// @param _updatedStake uint256 The updated total staked amount.\r\n    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) internal {\r\n        if (!shouldNotifyStakeChange()) {\r\n            return;\r\n        }\r\n\r\n        notifier.stakeChange(_stakeOwner, _amount, _sign, _updatedStake);\r\n    }\r\n\r\n    /// @dev Notifies of multiple stake change events.\r\n    /// @param _stakeOwners address[] The addresses of subject stake owners.\r\n    /// @param _amounts uint256[] The differences in total staked amounts.\r\n    /// @param _signs bool[] The signs of the added (true) or subtracted (false) amounts.\r\n    /// @param _updatedStakes uint256[] The updated total staked amounts.\r\n    function stakeChangeBatch(address[] memory _stakeOwners, uint256[] memory _amounts, bool[] memory _signs,\r\n        uint256[] memory _updatedStakes) internal {\r\n        if (!shouldNotifyStakeChange()) {\r\n            return;\r\n        }\r\n\r\n        notifier.stakeChangeBatch(_stakeOwners, _amounts, _signs, _updatedStakes);\r\n    }\r\n\r\n    /// @dev Notifies of stake migration event.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The migrated amount.\r\n    function stakeMigration(address _stakeOwner, uint256 _amount) internal {\r\n        if (!shouldNotifyStakeChange()) {\r\n            return;\r\n        }\r\n\r\n        notifier.stakeMigration(_stakeOwner, _amount);\r\n    }\r\n\r\n    /// @dev Stakes amount of ORBS tokens on behalf of the specified stake owner.\r\n    /// @param _stakeOwner address The specified stake owner.\r\n    /// @param _amount uint256 The amount of tokens to stake.\r\n    /// @return totalStakedAmount uint256 The total stake of the stake owner.\r\n    function stake(address _stakeOwner, uint256 _amount) private returns (uint256 totalStakedAmount) {\r\n        require(_stakeOwner != address(0), \"StakingContract::stake - stake owner can't be 0\");\r\n        require(_amount > 0, \"StakingContract::stake - amount must be greater than 0\");\r\n\r\n        Stake storage stakeData = stakes[_stakeOwner];\r\n        stakeData.amount = stakeData.amount.add(_amount);\r\n\r\n        totalStakedTokens = totalStakedTokens.add(_amount);\r\n\r\n        totalStakedAmount = stakeData.amount;\r\n\r\n        // Transfer the tokens to the smart contract and update the stake owners list accordingly.\r\n        require(token.transferFrom(msg.sender, address(this), _amount),\r\n            \"StakingContract::stake - insufficient allowance\");\r\n    }\r\n\r\n    /// @dev Requests to withdraw all of staked ORBS tokens back to the specified stake owner. Stake owners can withdraw\r\n    /// their ORBS tokens only after previously unstaking them and after the cooldown period has passed (unless the\r\n    /// contract was requested to release all stakes).\r\n    /// @return res WithdrawResult The result of the withdraw operation.\r\n    function withdraw(address _stakeOwner) private returns (WithdrawResult memory res) {\r\n        require(_stakeOwner != address(0), \"StakingContract::withdraw - stake owner can't be 0\");\r\n\r\n        Stake storage stakeData = stakes[_stakeOwner];\r\n        res.stakedAmount = stakeData.amount;\r\n        res.withdrawnAmount = stakeData.cooldownAmount;\r\n        res.stakedAmountDiff = 0;\r\n\r\n        if (!releasingAllStakes) {\r\n            require(res.withdrawnAmount > 0, \"StakingContract::withdraw - no unstaked tokens\");\r\n            require(stakeData.cooldownEndTime <= now, \"StakingContract::withdraw - tokens are still in cooldown\");\r\n        } else {\r\n            // If the contract was requested to release all stakes - allow to withdraw all staked and unstaked tokens.\r\n            res.withdrawnAmount = res.withdrawnAmount.add(res.stakedAmount);\r\n            res.stakedAmountDiff = res.stakedAmount;\r\n\r\n            require(res.withdrawnAmount > 0, \"StakingContract::withdraw - no staked or unstaked tokens\");\r\n\r\n            stakeData.amount = 0;\r\n\r\n            totalStakedTokens = totalStakedTokens.sub(res.stakedAmount);\r\n\r\n            res.stakedAmount = 0;\r\n        }\r\n\r\n        stakeData.cooldownAmount = 0;\r\n        stakeData.cooldownEndTime = 0;\r\n\r\n        require(token.transfer(_stakeOwner, res.withdrawnAmount),\r\n            \"StakingContract::withdraw - couldn't transfer stake\");\r\n    }\r\n\r\n    /// @dev Returns an index of an existing approved staking contract.\r\n    /// @param _stakingContract IMigratableStakingContract The staking contract to look for.\r\n    /// @return index uint The index of the located staking contract (in the case that it was found).\r\n    /// @return exists bool The search result.\r\n    function findApprovedStakingContractIndex(IMigratableStakingContract _stakingContract) private view returns\r\n        (uint index, bool exists) {\r\n        uint length = approvedStakingContracts.length;\r\n        for (index = 0; index < length; ++index) {\r\n            if (approvedStakingContracts[index] == _stakingContract) {\r\n                exists = true;\r\n                return (index, exists);\r\n            }\r\n        }\r\n\r\n        exists = false;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cooldownPeriodInSec\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_migrationManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_emergencyManager\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"AcceptedMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"emergencyManager\",\"type\":\"address\"}],\"name\":\"EmergencyManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"MigratedStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"stakingContract\",\"type\":\"address\"}],\"name\":\"MigrationDestinationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"stakingContract\",\"type\":\"address\"}],\"name\":\"MigrationDestinationRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"migrationManager\",\"type\":\"address\"}],\"name\":\"MigrationManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ReleasedAllStakes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"Restaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IStakeChangeNotifier\",\"name\":\"notifier\",\"type\":\"address\"}],\"name\":\"StakeChangeNotifierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StoppedAcceptingNewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrew\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_APPROVED_STAKING_CONTRACTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"acceptMigration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"acceptingNewStakes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"_newStakingContract\",\"type\":\"address\"}],\"name\":\"addMigrationDestination\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedStakingContracts\",\"outputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooldownPeriodInSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_stakeOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeOwner\",\"type\":\"address\"}],\"name\":\"getStakeBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeOwner\",\"type\":\"address\"}],\"name\":\"getUnstakeStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cooldownAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownEndTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"_stakingContract\",\"type\":\"address\"}],\"name\":\"isApprovedStakingContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"_newStakingContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"migrateStakedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"notifier\",\"outputs\":[{\"internalType\":\"contract IStakeChangeNotifier\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseAllStakes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releasingAllStakes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"_stakingContract\",\"type\":\"address\"}],\"name\":\"removeMigrationDestination\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newEmergencyManager\",\"type\":\"address\"}],\"name\":\"setEmergencyManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMigrationManager\",\"type\":\"address\"}],\"name\":\"setMigrationManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IStakeChangeNotifier\",\"name\":\"_newNotifier\",\"type\":\"address\"}],\"name\":\"setStakeChangeNotifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopAcceptingNewStakes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_stakeOwners\",\"type\":\"address[]\"}],\"name\":\"withdrawReleasedStakes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakingContract","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000001baf80000000000000000000000000b7d1068f267ab092973108f0f8cd914830cc1795000000000000000000000000b7d1068f267ab092973108f0f8cd914830cc1795000000000000000000000000ff56cc6b1e6ded347aa0b7676c85ab0b3d08b0fa","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://8532a51ebdf403ebe2950030aa735d5a9df31fb41ad5b47939d6a8e1d505a5ab"}]}