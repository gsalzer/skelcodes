{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/roles/MinterRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract MinterRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () internal {\r\n        _addMinter(_msgSender());\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(_msgSender());\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Mintable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\r\n * which have permission to mint (create) new tokens as they see fit.\r\n *\r\n * At construction, the deployer of the contract is the only minter.\r\n */\r\ncontract ERC20Mintable is ERC20, MinterRole {\r\n    /**\r\n     * @dev See {ERC20-_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the {MinterRole}.\r\n     */\r\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\r\n        _mint(account, amount);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Capped.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20Mintable} that adds a cap to the supply of tokens.\r\n */\r\ncontract ERC20Capped is ERC20Mintable {\r\n    uint256 private _cap;\r\n\r\n    /**\r\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\r\n     * set once during construction.\r\n     */\r\n    constructor (uint256 cap) public {\r\n        require(cap > 0, \"ERC20Capped: cap is 0\");\r\n        _cap = cap;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the cap on the token's total supply.\r\n     */\r\n    function cap() public view returns (uint256) {\r\n        return _cap;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20Mintable-mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `value` must not cause the total supply to go over the cap.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(totalSupply().add(value) <= _cap, \"ERC20Capped: cap exceeded\");\r\n        super._mint(account, value);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/roles/PauserRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract PauserRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(_msgSender());\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(_msgSender()), \"PauserRole: caller does not have the Pauser role\");\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(_msgSender());\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is Context, PauserRole {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to pause, triggers stopped state.\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to unpause, returns to normal state.\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: contracts/purchase/ReferrableSale.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ReferrableSale\r\n * @dev Implements the base elements for a sales referral system.\r\n * It is supposed to be inherited by a sales contract.\r\n * The referrals are expressed in percentage * 100, for example 1000 represents 10% and 555 represents 5.55%.\r\n */\r\ncontract ReferrableSale is Ownable {\r\n\r\n    event DefaultReferralSet(\r\n        uint256 percentage\r\n    );\r\n\r\n    event CustomReferralSet(\r\n        address indexed referrer,\r\n        uint256 percentage\r\n    );\r\n\r\n    uint256 public _defaultReferralPercentage;\r\n    mapping (address => uint256) public _customReferralPercentages;\r\n\r\n    function setDefaultReferral(uint256 defaultReferralPercentage) public onlyOwner {\r\n        require(defaultReferralPercentage < 10000, \"Referral must be less than 100 percent\");\r\n        require(defaultReferralPercentage != _defaultReferralPercentage, \"New referral must be different from the previous\");\r\n        _defaultReferralPercentage = defaultReferralPercentage;\r\n        emit DefaultReferralSet(defaultReferralPercentage);\r\n    }\r\n\r\n    function setCustomReferral(address _referrer, uint256 customReferralPercentage) public onlyOwner {\r\n        require(customReferralPercentage < 10000, \"Referral must be less than 100 percent\");\r\n        require(customReferralPercentage != _customReferralPercentages[_referrer], \"New referral must be different from the previous\");\r\n        _customReferralPercentages[_referrer] = customReferralPercentage;\r\n        emit CustomReferralSet(_referrer, customReferralPercentage);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/IRelayRecipient.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Base interface for a contract that will be called via the GSN from {IRelayHub}.\r\n *\r\n * TIP: You don't need to write an implementation yourself! Inherit from {GSNRecipient} instead.\r\n */\r\ninterface IRelayRecipient {\r\n    /**\r\n     * @dev Returns the address of the {IRelayHub} instance this recipient interacts with.\r\n     */\r\n    function getHubAddr() external view returns (address);\r\n\r\n    /**\r\n     * @dev Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the\r\n     * recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not).\r\n     *\r\n     * The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call\r\n     * calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas,\r\n     * and the transaction executed with a gas price of at least `gasPrice`. `relay`'s fee is `transactionFee`, and the\r\n     * recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for\r\n     * replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature\r\n     * over all or some of the previous values.\r\n     *\r\n     * Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code,\r\n     * values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions.\r\n     *\r\n     * {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered\r\n     * rejected. A regular revert will also trigger a rejection.\r\n     */\r\n    function acceptRelayedCall(\r\n        address relay,\r\n        address from,\r\n        bytes calldata encodedFunction,\r\n        uint256 transactionFee,\r\n        uint256 gasPrice,\r\n        uint256 gasLimit,\r\n        uint256 nonce,\r\n        bytes calldata approvalData,\r\n        uint256 maxPossibleCharge\r\n    )\r\n        external\r\n        view\r\n        returns (uint256, bytes memory);\r\n\r\n    /**\r\n     * @dev Called by {IRelayHub} on approved relay call requests, before the relayed call is executed. This allows to e.g.\r\n     * pre-charge the sender of the transaction.\r\n     *\r\n     * `context` is the second value returned in the tuple by {acceptRelayedCall}.\r\n     *\r\n     * Returns a value to be passed to {postRelayedCall}.\r\n     *\r\n     * {preRelayedCall} is called with 100k gas: if it runs out during exection or otherwise reverts, the relayed call\r\n     * will not be executed, but the recipient will still be charged for the transaction's cost.\r\n     */\r\n    function preRelayedCall(bytes calldata context) external returns (bytes32);\r\n\r\n    /**\r\n     * @dev Called by {IRelayHub} on approved relay call requests, after the relayed call is executed. This allows to e.g.\r\n     * charge the user for the relayed call costs, return any overcharges from {preRelayedCall}, or perform\r\n     * contract-specific bookkeeping.\r\n     *\r\n     * `context` is the second value returned in the tuple by {acceptRelayedCall}. `success` is the execution status of\r\n     * the relayed call. `actualCharge` is an estimate of how much the recipient will be charged for the transaction,\r\n     * not including any gas used by {postRelayedCall} itself. `preRetVal` is {preRelayedCall}'s return value.\r\n     *\r\n     *\r\n     * {postRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call\r\n     * and the call to {preRelayedCall} will be reverted retroactively, but the recipient will still be charged for the\r\n     * transaction's cost.\r\n     */\r\n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/IRelayHub.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface for `RelayHub`, the core contract of the GSN. Users should not need to interact with this contract\r\n * directly.\r\n *\r\n * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on\r\n * how to deploy an instance of `RelayHub` on your local test network.\r\n */\r\ninterface IRelayHub {\r\n    // Relay management\r\n\r\n    /**\r\n     * @dev Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller\r\n     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay\r\n     * cannot be its own owner.\r\n     *\r\n     * All Ether in this function call will be added to the relay's stake.\r\n     * Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one.\r\n     *\r\n     * Emits a {Staked} event.\r\n     */\r\n    function stake(address relayaddr, uint256 unstakeDelay) external payable;\r\n\r\n    /**\r\n     * @dev Emitted when a relay's stake or unstakeDelay are increased\r\n     */\r\n    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);\r\n\r\n    /**\r\n     * @dev Registers the caller as a relay.\r\n     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).\r\n     *\r\n     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received\r\n     * `transactionFee` is not enforced by {relayCall}.\r\n     *\r\n     * Emits a {RelayAdded} event.\r\n     */\r\n    function registerRelay(uint256 transactionFee, string calldata url) external;\r\n\r\n    /**\r\n     * @dev Emitted when a relay is registered or re-registerd. Looking at these events (and filtering out\r\n     * {RelayRemoved} events) lets a client discover the list of available relays.\r\n     */\r\n    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);\r\n\r\n    /**\r\n     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.\r\n     *\r\n     * Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be\r\n     * callable.\r\n     *\r\n     * Emits a {RelayRemoved} event.\r\n     */\r\n    function removeRelayByOwner(address relay) external;\r\n\r\n    /**\r\n     * @dev Emitted when a relay is removed (deregistered). `unstakeTime` is the time when unstake will be callable.\r\n     */\r\n    event RelayRemoved(address indexed relay, uint256 unstakeTime);\r\n\r\n    /** Deletes the relay from the system, and gives back its stake to the owner.\r\n     *\r\n     * Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called.\r\n     *\r\n     * Emits an {Unstaked} event.\r\n     */\r\n    function unstake(address relay) external;\r\n\r\n    /**\r\n     * @dev Emitted when a relay is unstaked for, including the returned stake.\r\n     */\r\n    event Unstaked(address indexed relay, uint256 stake);\r\n\r\n    // States a relay can be in\r\n    enum RelayState {\r\n        Unknown, // The relay is unknown to the system: it has never been staked for\r\n        Staked, // The relay has been staked for, but it is not yet active\r\n        Registered, // The relay has registered itself, and is active (can relay calls)\r\n        Removed    // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function\r\n     * to return an empty entry.\r\n     */\r\n    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);\r\n\r\n    // Balance management\r\n\r\n    /**\r\n     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.\r\n     *\r\n     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.\r\n     *\r\n     * Emits a {Deposited} event.\r\n     */\r\n    function depositFor(address target) external payable;\r\n\r\n    /**\r\n     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.\r\n     */\r\n    event Deposited(address indexed recipient, address indexed from, uint256 amount);\r\n\r\n    /**\r\n     * @dev Returns an account's deposits. These can be either a contracts's funds, or a relay owner's revenue.\r\n     */\r\n    function balanceOf(address target) external view returns (uint256);\r\n\r\n    /**\r\n     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and\r\n     * contracts can use it to reduce their funding.\r\n     *\r\n     * Emits a {Withdrawn} event.\r\n     */\r\n    function withdraw(uint256 amount, address payable dest) external;\r\n\r\n    /**\r\n     * @dev Emitted when an account withdraws funds from `RelayHub`.\r\n     */\r\n    event Withdrawn(address indexed account, address indexed dest, uint256 amount);\r\n\r\n    // Relaying\r\n\r\n    /**\r\n     * @dev Checks if the `RelayHub` will accept a relayed operation.\r\n     * Multiple things must be true for this to happen:\r\n     *  - all arguments must be signed for by the sender (`from`)\r\n     *  - the sender's nonce must be the current one\r\n     *  - the recipient must accept this transaction (via {acceptRelayedCall})\r\n     *\r\n     * Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error\r\n     * code if it returns one in {acceptRelayedCall}.\r\n     */\r\n    function canRelay(\r\n        address relay,\r\n        address from,\r\n        address to,\r\n        bytes calldata encodedFunction,\r\n        uint256 transactionFee,\r\n        uint256 gasPrice,\r\n        uint256 gasLimit,\r\n        uint256 nonce,\r\n        bytes calldata signature,\r\n        bytes calldata approvalData\r\n    ) external view returns (uint256 status, bytes memory recipientContext);\r\n\r\n    // Preconditions for relaying, checked by canRelay and returned as the corresponding numeric values.\r\n    enum PreconditionCheck {\r\n        OK,                         // All checks passed, the call can be relayed\r\n        WrongSignature,             // The transaction to relay is not signed by requested sender\r\n        WrongNonce,                 // The provided nonce has already been used by the sender\r\n        AcceptRelayedCallReverted,  // The recipient rejected this call via acceptRelayedCall\r\n        InvalidRecipientStatusCode  // The recipient returned an invalid (reserved) status code\r\n    }\r\n\r\n    /**\r\n     * @dev Relays a transaction.\r\n     *\r\n     * For this to succeed, multiple conditions must be met:\r\n     *  - {canRelay} must `return PreconditionCheck.OK`\r\n     *  - the sender must be a registered relay\r\n     *  - the transaction's gas price must be larger or equal to the one that was requested by the sender\r\n     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the\r\n     * recipient) use all gas available to them\r\n     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is\r\n     * spent)\r\n     *\r\n     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded\r\n     * function and {postRelayedCall} will be called in that order.\r\n     *\r\n     * Parameters:\r\n     *  - `from`: the client originating the request\r\n     *  - `to`: the target {IRelayRecipient} contract\r\n     *  - `encodedFunction`: the function call to relay, including data\r\n     *  - `transactionFee`: fee (%) the relay takes over actual gas cost\r\n     *  - `gasPrice`: gas price the client is willing to pay\r\n     *  - `gasLimit`: gas to forward when calling the encoded function\r\n     *  - `nonce`: client's nonce\r\n     *  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses\r\n     *  - `approvalData`: dapp-specific data forwared to {acceptRelayedCall}. This value is *not* verified by the\r\n     * `RelayHub`, but it still can be used for e.g. a signature.\r\n     *\r\n     * Emits a {TransactionRelayed} event.\r\n     */\r\n    function relayCall(\r\n        address from,\r\n        address to,\r\n        bytes calldata encodedFunction,\r\n        uint256 transactionFee,\r\n        uint256 gasPrice,\r\n        uint256 gasLimit,\r\n        uint256 nonce,\r\n        bytes calldata signature,\r\n        bytes calldata approvalData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Emitted when an attempt to relay a call failed.\r\n     *\r\n     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The\r\n     * actual relayed call was not executed, and the recipient not charged.\r\n     *\r\n     * The `reason` parameter contains an error code: values 1-10 correspond to `PreconditionCheck` entries, and values\r\n     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.\r\n     */\r\n    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);\r\n\r\n    /**\r\n     * @dev Emitted when a transaction is relayed. \r\n     * Useful when monitoring a relay's operation and relayed calls to a contract\r\n     *\r\n     * Note that the actual encoded function might be reverted: this is indicated in the `status` parameter.\r\n     *\r\n     * `charge` is the Ether value deducted from the recipient's balance, paid to the relay's owner.\r\n     */\r\n    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);\r\n\r\n    // Reason error codes for the TransactionRelayed event\r\n    enum RelayCallStatus {\r\n        OK,                      // The transaction was successfully relayed and execution successful - never included in the event\r\n        RelayedCallFailed,       // The transaction was relayed, but the relayed call failed\r\n        PreRelayedFailed,        // The transaction was not relayed due to preRelatedCall reverting\r\n        PostRelayedFailed,       // The transaction was relayed and reverted due to postRelatedCall reverting\r\n        RecipientBalanceChanged  // The transaction was relayed and reverted due to the recipient's balance changing\r\n    }\r\n\r\n    /**\r\n     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will\r\n     * spend up to `relayedCallStipend` gas.\r\n     */\r\n    function requiredGas(uint256 relayedCallStipend) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.\r\n     */\r\n    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) external view returns (uint256);\r\n\r\n     // Relay penalization. \r\n     // Any account can penalize relays, removing them from the system immediately, and rewarding the\r\n    // reporter with half of the relay's stake. The other half is burned so that, even if the relay penalizes itself, it\r\n    // still loses half of its stake.\r\n\r\n    /**\r\n     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and\r\n     * different data (gas price, gas limit, etc. may be different).\r\n     *\r\n     * The (unsigned) transaction data and signature for both transactions must be provided.\r\n     */\r\n    function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) external;\r\n\r\n    /**\r\n     * @dev Penalize a relay that sent a transaction that didn't target `RelayHub`'s {registerRelay} or {relayCall}.\r\n     */\r\n    function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) external;\r\n\r\n    /**\r\n     * @dev Emitted when a relay is penalized.\r\n     */\r\n    event Penalized(address indexed relay, address sender, uint256 amount);\r\n\r\n    /**\r\n     * @dev Returns an account's nonce in `RelayHub`.\r\n     */\r\n    function getNonce(address from) external view returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/GSNRecipient.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Base GSN recipient contract: includes the {IRelayRecipient} interface\r\n * and enables GSN support on all contracts in the inheritance tree.\r\n *\r\n * TIP: This contract is abstract. The functions {IRelayRecipient-acceptRelayedCall},\r\n *  {_preRelayedCall}, and {_postRelayedCall} are not implemented and must be\r\n * provided by derived contracts. See the\r\n * xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategies] for more\r\n * information on how to use the pre-built {GSNRecipientSignature} and\r\n * {GSNRecipientERC20Fee}, or how to write your own.\r\n */\r\ncontract GSNRecipient is IRelayRecipient, Context {\r\n    // Default RelayHub address, deployed on mainnet and all testnets at the same address\r\n    address private _relayHub = 0xD216153c06E857cD7f72665E0aF1d7D82172F494;\r\n\r\n    uint256 constant private RELAYED_CALL_ACCEPTED = 0;\r\n    uint256 constant private RELAYED_CALL_REJECTED = 11;\r\n\r\n    // How much gas is forwarded to postRelayedCall\r\n    uint256 constant internal POST_RELAYED_CALL_MAX_GAS = 100000;\r\n\r\n    /**\r\n     * @dev Emitted when a contract changes its {IRelayHub} contract to a new one.\r\n     */\r\n    event RelayHubChanged(address indexed oldRelayHub, address indexed newRelayHub);\r\n\r\n    /**\r\n     * @dev Returns the address of the {IRelayHub} contract for this recipient.\r\n     */\r\n    function getHubAddr() public view returns (address) {\r\n        return _relayHub;\r\n    }\r\n\r\n    /**\r\n     * @dev Switches to a new {IRelayHub} instance. This method is added for future-proofing: there's no reason to not\r\n     * use the default instance.\r\n     *\r\n     * IMPORTANT: After upgrading, the {GSNRecipient} will no longer be able to receive relayed calls from the old\r\n     * {IRelayHub} instance. Additionally, all funds should be previously withdrawn via {_withdrawDeposits}.\r\n     */\r\n    function _upgradeRelayHub(address newRelayHub) internal {\r\n        address currentRelayHub = _relayHub;\r\n        require(newRelayHub != address(0), \"GSNRecipient: new RelayHub is the zero address\");\r\n        require(newRelayHub != currentRelayHub, \"GSNRecipient: new RelayHub is the current one\");\r\n\r\n        emit RelayHubChanged(currentRelayHub, newRelayHub);\r\n\r\n        _relayHub = newRelayHub;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the version string of the {IRelayHub} for which this recipient implementation was built. If\r\n     * {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.\r\n     */\r\n    // This function is view for future-proofing, it may require reading from\r\n    // storage in the future.\r\n    function relayHubVersion() public view returns (string memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return \"1.0.0\";\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws the recipient's deposits in `RelayHub`.\r\n     *\r\n     * Derived contracts should expose this in an external interface with proper access control.\r\n     */\r\n    function _withdrawDeposits(uint256 amount, address payable payee) internal {\r\n        IRelayHub(_relayHub).withdraw(amount, payee);\r\n    }\r\n\r\n    // Overrides for Context's functions: when called from RelayHub, sender and\r\n    // data require some pre-processing: the actual sender is stored at the end\r\n    // of the call data, which in turns means it needs to be removed from it\r\n    // when handling said data.\r\n\r\n    /**\r\n     * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,\r\n     * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).\r\n     *\r\n     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.sender`, and use {_msgSender} instead.\r\n     */\r\n    function _msgSender() internal view returns (address payable) {\r\n        if (msg.sender != _relayHub) {\r\n            return msg.sender;\r\n        } else {\r\n            return _getRelayedCallSender();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for msg.data. Returns the actual calldata of a transaction: msg.data for regular transactions,\r\n     * and a reduced version for GSN relayed calls (where msg.data contains additional information).\r\n     *\r\n     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.data`, and use {_msgData} instead.\r\n     */\r\n    function _msgData() internal view returns (bytes memory) {\r\n        if (msg.sender != _relayHub) {\r\n            return msg.data;\r\n        } else {\r\n            return _getRelayedCallData();\r\n        }\r\n    }\r\n\r\n    // Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the\r\n    // internal hook.\r\n\r\n    /**\r\n     * @dev See `IRelayRecipient.preRelayedCall`.\r\n     *\r\n     * This function should not be overriden directly, use `_preRelayedCall` instead.\r\n     *\r\n     * * Requirements:\r\n     *\r\n     * - the caller must be the `RelayHub` contract.\r\n     */\r\n    function preRelayedCall(bytes calldata context) external returns (bytes32) {\r\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\r\n        return _preRelayedCall(context);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IRelayRecipient.preRelayedCall`.\r\n     *\r\n     * Called by `GSNRecipient.preRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts\r\n     * must implement this function with any relayed-call preprocessing they may wish to do.\r\n     *\r\n     */\r\n    function _preRelayedCall(bytes memory context) internal returns (bytes32);\r\n\r\n    /**\r\n     * @dev See `IRelayRecipient.postRelayedCall`.\r\n     *\r\n     * This function should not be overriden directly, use `_postRelayedCall` instead.\r\n     *\r\n     * * Requirements:\r\n     *\r\n     * - the caller must be the `RelayHub` contract.\r\n     */\r\n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external {\r\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\r\n        _postRelayedCall(context, success, actualCharge, preRetVal);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IRelayRecipient.postRelayedCall`.\r\n     *\r\n     * Called by `GSNRecipient.postRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts\r\n     * must implement this function with any relayed-call postprocessing they may wish to do.\r\n     *\r\n     */\r\n    function _postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) internal;\r\n\r\n    /**\r\n     * @dev Return this in acceptRelayedCall to proceed with the execution of a relayed call. Note that this contract\r\n     * will be charged a fee by RelayHub\r\n     */\r\n    function _approveRelayedCall() internal pure returns (uint256, bytes memory) {\r\n        return _approveRelayedCall(\"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See `GSNRecipient._approveRelayedCall`.\r\n     *\r\n     * This overload forwards `context` to _preRelayedCall and _postRelayedCall.\r\n     */\r\n    function _approveRelayedCall(bytes memory context) internal pure returns (uint256, bytes memory) {\r\n        return (RELAYED_CALL_ACCEPTED, context);\r\n    }\r\n\r\n    /**\r\n     * @dev Return this in acceptRelayedCall to impede execution of a relayed call. No fees will be charged.\r\n     */\r\n    function _rejectRelayedCall(uint256 errorCode) internal pure returns (uint256, bytes memory) {\r\n        return (RELAYED_CALL_REJECTED + errorCode, \"\");\r\n    }\r\n\r\n    /*\r\n     * @dev Calculates how much RelayHub will charge a recipient for using `gas` at a `gasPrice`, given a relayer's\r\n     * `serviceFee`.\r\n     */\r\n    function _computeCharge(uint256 gas, uint256 gasPrice, uint256 serviceFee) internal pure returns (uint256) {\r\n        // The fee is expressed as a percentage. E.g. a value of 40 stands for a 40% fee, so the recipient will be\r\n        // charged for 1.4 times the spent amount.\r\n        return (gas * gasPrice * (100 + serviceFee)) / 100;\r\n    }\r\n\r\n    function _getRelayedCallSender() private pure returns (address payable result) {\r\n        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array\r\n        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing\r\n        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would\r\n        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20\r\n        // bytes. This can always be done due to the 32-byte prefix.\r\n\r\n        // The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the\r\n        // easiest/most-efficient way to perform this operation.\r\n\r\n        // These fields are not accessible from assembly\r\n        bytes memory array = msg.data;\r\n        uint256 index = msg.data.length;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\r\n            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _getRelayedCallData() private pure returns (bytes memory) {\r\n        // RelayHub appends the sender address at the end of the calldata, so in order to retrieve the actual msg.data,\r\n        // we must strip the last 20 bytes (length of an address type) from it.\r\n\r\n        uint256 actualDataLength = msg.data.length - 20;\r\n        bytes memory actualData = new bytes(actualDataLength);\r\n\r\n        for (uint256 i = 0; i < actualDataLength; ++i) {\r\n            actualData[i] = msg.data[i];\r\n        }\r\n\r\n        return actualData;\r\n    }\r\n}\r\n\r\n// File: contracts/purchase/ICrateOpenEmitter.sol\r\n\r\npragma solidity = 0.5.16;\r\n\r\n\r\ninterface ICrateOpenEmitter {\r\n    function openCrate(address from, uint256 lotId, uint256 amount) external;\r\n}\r\n\r\n// File: contracts/purchase/F1DeltaCrate.sol\r\n\r\npragma solidity = 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// crate token. 0 decimals - crates can't be fractional\r\ncontract F1DeltaCrate is ERC20Capped, ERC20Detailed, GSNRecipient, Ownable {\r\n    enum ErrorCodes {\r\n        RESTRICTED_METHOD,\r\n        INSUFFICIENT_BALANCE\r\n    }\r\n\r\n    struct AcceptRelayedCallVars {\r\n        bytes4 methodId;\r\n        bytes ef;\r\n    }\r\n\r\n    string _uri;\r\n    address _crateOpener;\r\n    uint256 _lotId;\r\n    uint256 public _cratesIssued;\r\n\r\n    constructor(\r\n        uint256 lotId, \r\n        uint256 cap,\r\n        string memory name, \r\n        string memory symbol,\r\n        string memory uri,\r\n        address crateOpener\r\n    ) ERC20Capped(cap) ERC20Detailed(name, symbol, 0) public {\r\n        require(crateOpener != address(0));\r\n\r\n        _uri = uri;\r\n        _crateOpener = crateOpener;\r\n        _lotId = lotId;\r\n    }\r\n\r\n    function burn(uint256 amount) public {\r\n        _burn(_msgSender(), amount);\r\n        ICrateOpenEmitter(_crateOpener).openCrate(_msgSender(), _lotId, amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) public {\r\n        _burnFrom(account, amount);\r\n        ICrateOpenEmitter(_crateOpener).openCrate(account, _lotId, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        _cratesIssued = _cratesIssued + amount; // not enough money in the world to cover 2 ^ 256 - 1 increments\r\n        require(_cratesIssued <= cap(), \"cratesIssued exceeded cap\");\r\n        super._mint(account, amount);\r\n    }\r\n\r\n    function tokenURI() public view returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    function setURI(string memory uri) public onlyOwner {\r\n        _uri = uri;\r\n    }\r\n\r\n    /////////////////////////////////////////// GSNRecipient implementation ///////////////////////////////////\r\n    /**\r\n     * @dev Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.\r\n     */\r\n    function acceptRelayedCall(\r\n        address /*relay*/,\r\n        address from,\r\n        bytes calldata encodedFunction,\r\n        uint256 /*transactionFee*/,\r\n        uint256 /*gasPrice*/,\r\n        uint256 /*gasLimit*/,\r\n        uint256 /*nonce*/,\r\n        bytes calldata /*approvalData*/,\r\n        uint256 /*maxPossibleCharge*/\r\n    )\r\n        external\r\n        view\r\n        returns (uint256, bytes memory mem)\r\n    {\r\n        // restrict to burn function only\r\n        // load methodId stored in first 4 bytes https://solidity.readthedocs.io/en/v0.5.16/abi-spec.html#function-selector-and-argument-encoding\r\n        // load amount stored in the next 32 bytes https://solidity.readthedocs.io/en/v0.5.16/abi-spec.html#function-selector-and-argument-encoding\r\n        // 32 bytes offset is required to skip array length\r\n        bytes4 methodId;\r\n        uint256 amountParam;\r\n        mem = encodedFunction;\r\n        assembly {\r\n            let dest := add(mem, 32)\r\n            methodId := mload(dest)\r\n            dest := add(dest, 4)\r\n            amountParam := mload(dest)\r\n        }\r\n\r\n        // bytes4(keccak256(\"burn(uint256)\")) == 0x42966c68\r\n        if (methodId != 0x42966c68) {\r\n            return _rejectRelayedCall(uint256(ErrorCodes.RESTRICTED_METHOD));\r\n        }\r\n\r\n        // Check that user has enough crates to burn\r\n        if (balanceOf(from) < amountParam) {\r\n            return _rejectRelayedCall(uint256(ErrorCodes.INSUFFICIENT_BALANCE));\r\n        }\r\n\r\n        return _approveRelayedCall();\r\n    }\r\n\r\n    function _preRelayedCall(bytes memory) internal returns (bytes32) {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    function _postRelayedCall(bytes memory, bool, uint256, bytes32) internal {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws the recipient's deposits in `RelayHub`.\r\n     */\r\n    function withdrawDeposits(uint256 amount, address payable payee) external onlyOwner {\r\n        _withdrawDeposits(amount, payee);\r\n    }\r\n}\r\n\r\n// File: contracts/purchase/IKyber.sol\r\n\r\npragma solidity = 0.5.16;\r\n\r\n\r\n\r\n// https://github.com/KyberNetwork/smart-contracts/blob/master/contracts/KyberNetworkProxy.sol\r\ninterface IKyber {\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function trade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n    external\r\n    payable\r\n        returns(uint);\r\n}\r\n\r\n// File: contracts/purchase/KyberAdapter.sol\r\n\r\npragma solidity = 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\ncontract KyberAdapter {\r\n    using SafeMath for uint256;\r\n\r\n    IKyber public kyber;\r\n    \r\n    ERC20 public ETH_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n    constructor(address _kyberProxy) public {\r\n        kyber = IKyber(_kyberProxy);\r\n    }\r\n\r\n    function () external payable {}\r\n\r\n    function _getTokenDecimals(ERC20 _token) internal view returns (uint8 _decimals) {\r\n        return _token != ETH_ADDRESS ? ERC20Detailed(address(_token)).decimals() : 18;\r\n    }\r\n\r\n    function _getTokenBalance(ERC20 _token, address _account) internal view returns (uint256 _balance) {\r\n        return _token != ETH_ADDRESS ? _token.balanceOf(_account) : _account.balance;\r\n    }\r\n\r\n    function ceilingDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        return a.div(b).add(a.mod(b) > 0 ? 1 : 0);\r\n    }\r\n\r\n    function _fixTokenDecimals(\r\n        ERC20 _src,\r\n        ERC20 _dest,\r\n        uint256 _unfixedDestAmount,\r\n        bool _ceiling\r\n    )\r\n    internal\r\n    view\r\n    returns (uint256 _destTokenAmount)\r\n    {\r\n        uint256 _unfixedDecimals = _getTokenDecimals(_src) + 18; // Kyber by default returns rates with 18 decimals.\r\n        uint256 _decimals = _getTokenDecimals(_dest);\r\n\r\n        if (_unfixedDecimals > _decimals) {\r\n            // Divide token amount by 10^(_unfixedDecimals - _decimals) to reduce decimals.\r\n            if (_ceiling) {\r\n                return ceilingDiv(_unfixedDestAmount, (10 ** (_unfixedDecimals - _decimals)));\r\n            } else {\r\n                return _unfixedDestAmount.div(10 ** (_unfixedDecimals - _decimals));\r\n            }\r\n        } else {\r\n            // Multiply token amount with 10^(_decimals - _unfixedDecimals) to increase decimals.\r\n            return _unfixedDestAmount.mul(10 ** (_decimals - _unfixedDecimals));\r\n        }\r\n    }\r\n\r\n    function _convertToken(\r\n        ERC20 _src,\r\n        uint256 _srcAmount,\r\n        ERC20 _dest\r\n    )\r\n    internal\r\n    view\r\n    returns (\r\n        uint256 _expectedAmount,\r\n        uint256 _slippageAmount\r\n    )\r\n    {\r\n        (uint256 _expectedRate, uint256 _slippageRate) = kyber.getExpectedRate(_src, _dest, _srcAmount);\r\n\r\n        return (\r\n            _fixTokenDecimals(_src, _dest, _srcAmount.mul(_expectedRate), false),\r\n            _fixTokenDecimals(_src, _dest, _srcAmount.mul(_slippageRate), false)\r\n        );\r\n    }\r\n\r\n    function _swapTokenAndHandleChange(\r\n        ERC20 _src,\r\n        uint256 _maxSrcAmount,\r\n        ERC20 _dest,\r\n        uint256 _maxDestAmount,\r\n        uint256 _minConversionRate,\r\n        address payable _initiator,\r\n        address payable _receiver\r\n    )\r\n    internal\r\n    returns (\r\n        uint256 _srcAmount,\r\n        uint256 _destAmount\r\n    )\r\n    {\r\n        if (_src == _dest) {\r\n            // payment is made with DAI\r\n            require(_maxSrcAmount >= _maxDestAmount, \"not enough erc20 src coin 1\");\r\n            _destAmount = _srcAmount = _maxDestAmount;\r\n            require(IERC20(_src).balanceOf(_initiator) >= _destAmount, \"not enough erc20 src coin 2\");\r\n            require(IERC20(_src).transferFrom(_initiator, address(this), _destAmount), \"not enough erc20 src coin 3\");\r\n        } else {\r\n            require(_src == ETH_ADDRESS ? msg.value >= _maxSrcAmount : msg.value == 0, \"weird check\");\r\n\r\n            // Prepare for handling back the change if there is any.\r\n            uint256 _balanceBefore = _getTokenBalance(_src, address(this));\r\n\r\n            if (_src != ETH_ADDRESS) {\r\n                require(IERC20(_src).transferFrom(_initiator, address(this), _maxSrcAmount), \"failed erc20 transfer\");\r\n                require(IERC20(_src).approve(address(kyber), _maxSrcAmount), \"faild erc20 approve\");\r\n            } else {\r\n                // Since we are going to transfer the source amount to Kyber.\r\n                _balanceBefore = _balanceBefore.sub(_maxSrcAmount);\r\n            }\r\n\r\n            _destAmount = kyber.trade.value(\r\n                _src == ETH_ADDRESS ? _maxSrcAmount : 0\r\n            )(\r\n                _src,\r\n                _maxSrcAmount,\r\n                _dest,\r\n                _receiver,\r\n                _maxDestAmount,\r\n                _minConversionRate,\r\n                address(0)\r\n            );\r\n            \r\n            uint256 _balanceAfter = _getTokenBalance(_src, address(this));\r\n            _srcAmount = _maxSrcAmount;\r\n\r\n            // Handle back the change, if there is any, to the message sender.\r\n            if (_balanceAfter > _balanceBefore) {\r\n                uint256 _change = _balanceAfter - _balanceBefore;\r\n                _srcAmount = _srcAmount.sub(_change);\r\n\r\n                if (_src != ETH_ADDRESS) {\r\n                    require(IERC20(_src).transfer(_initiator, _change), \"final transfer\");\r\n                } else {\r\n                    _initiator.transfer(_change);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/purchase/FixedSupplyCratesSale.sol\r\n\r\npragma solidity = 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FixedSupplyCratesSale is ReferrableSale, Pausable, KyberAdapter, ICrateOpenEmitter {\r\n    using SafeMath for uint256;\r\n\r\n    struct Lot {\r\n        F1DeltaCrate crateToken;\r\n        uint256 price; // in stable coin\r\n    }\r\n\r\n    struct PurchaseForVars {\r\n        Lot lot;\r\n        uint256 discount;\r\n        uint256 price;\r\n        uint256 referralReward;\r\n        uint256 tokensSent;\r\n        uint256 tokensReceived;\r\n    }\r\n\r\n    event Purchased (\r\n        address indexed owner,\r\n        address operator,\r\n        uint256 indexed lotId,\r\n        uint256 indexed quantity,\r\n        uint256 pricePaid,\r\n        address tokenAddress,\r\n        uint256 tokensSent,\r\n        uint256 tokensReceived,\r\n        uint256 discountApplied,\r\n        address referrer,\r\n        uint256 referralRewarded\r\n    );\r\n\r\n    event LotCreated (\r\n        uint256 lotId,\r\n        uint256 supply,\r\n        uint256 price,\r\n        string uri,\r\n        ERC20 crateToken\r\n    );\r\n\r\n    event LotPriceUpdated (\r\n        uint256 lotId,\r\n        uint256 price\r\n    );\r\n\r\n    event CrateOpened(address indexed from, uint256 lotId, uint256 amount);\r\n\r\n    uint256 private constant PERCENT_PRECISION = 10000;\r\n    uint256 private constant MULTI_PURCHASE_DISCOUNT_STEP = 5;\r\n\r\n    ERC20 public _stableCoinAddress;\r\n    address payable public _payoutWallet;\r\n\r\n    mapping (uint256 => Lot) public _lots; // lotId => lot\r\n    mapping (uint256 => mapping (address => address)) public _referrersByLot; // lotId => (buyer => referrer)\r\n    mapping (address => mapping(uint256 => uint256)) public _cratesPurchased; // owner => (lot id => quantity)\r\n\r\n    uint256 public _initialDiscountPercentage;\r\n    uint256 public _initialDiscountPeriod;\r\n    uint256 public _startedAt;\r\n    uint256 public _multiPurchaseDiscount;\r\n\r\n    modifier whenStarted() {\r\n        require(_startedAt != 0);\r\n        _;\r\n    }\r\n\r\n    modifier whenNotStarted() {\r\n        require(_startedAt == 0);\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address payable payoutWallet, \r\n        address kyberProxy, \r\n        ERC20 stableCoinAddress\r\n    ) KyberAdapter(kyberProxy) public {\r\n        require(payoutWallet != address(0));\r\n        require(stableCoinAddress != ERC20(address(0)));\r\n        setPayoutWallet(payoutWallet); \r\n\r\n        _stableCoinAddress = stableCoinAddress;\r\n        pause();\r\n    }\r\n\r\n    function setPayoutWallet(address payable payoutWallet) public onlyOwner {\r\n        require(payoutWallet != address(uint160(address(this))));\r\n        _payoutWallet = payoutWallet;\r\n    }\r\n\r\n    function start(\r\n        uint256 initialDiscountPercentage, \r\n        uint256 initialDiscountPeriod, \r\n        uint256 multiPurchaseDiscount\r\n    ) \r\n    public \r\n    onlyOwner \r\n    whenNotStarted\r\n    {\r\n        require(initialDiscountPercentage < PERCENT_PRECISION);\r\n        require(multiPurchaseDiscount < PERCENT_PRECISION);\r\n\r\n        _initialDiscountPercentage = initialDiscountPercentage;\r\n        _initialDiscountPeriod = initialDiscountPeriod;\r\n        _multiPurchaseDiscount = multiPurchaseDiscount;\r\n        \r\n        // solium-disable-next-line security/no-block-members\r\n        _startedAt = now;\r\n        unpause();\r\n    }\r\n\r\n    function initialDiscountActive() public view returns (bool) {\r\n        if (_initialDiscountPeriod == 0 || _initialDiscountPercentage == 0 || _startedAt == 0) {\r\n            // No discount set or sale not started\r\n            return false;\r\n        }\r\n\r\n        // solium-disable-next-line security/no-block-members\r\n        uint256 elapsed = (now - _startedAt);\r\n        return elapsed < _initialDiscountPeriod;\r\n    }\r\n\r\n    // owner can provide crate contract address which is compatible with F1DeltaCrate interface \r\n    // Make sure that crate contract has FixedSupplyCratesSale contract as minter.\r\n    // if crate contract isn't provided sales contract will create simple F1DeltaCrate on it's own\r\n    function createLot(\r\n        uint256 lotId,\r\n        uint256 supply,\r\n        uint256 price,\r\n        string memory name,\r\n        string memory symbol,\r\n        string memory uri,\r\n        F1DeltaCrate crateToken\r\n    ) \r\n        public \r\n        onlyOwner \r\n    {\r\n        require(price != 0 && supply != 0);\r\n        require(_lots[lotId].price == 0);\r\n        \r\n        Lot memory lot;\r\n        lot.price = price;\r\n        if (crateToken == F1DeltaCrate(address(0))) {\r\n            lot.crateToken = new F1DeltaCrate(lotId, supply, name, symbol, uri, address(this));\r\n            lot.crateToken.transferOwnership(owner());\r\n            lot.crateToken.addMinter(owner());\r\n        } else {\r\n            lot.crateToken = crateToken;\r\n        }\r\n        \r\n        _lots[lotId] = lot;\r\n\r\n        emit LotCreated(lotId, supply, price, uri, ERC20(address(lot.crateToken)));\r\n    }\r\n\r\n    function updateLotPrice(uint256 lotId, uint128 price) external onlyOwner whenPaused {\r\n        require(price != 0);\r\n        require(_lots[lotId].price != 0);\r\n        require(_lots[lotId].price != price);\r\n\r\n        _lots[lotId].price = price;\r\n\r\n        emit LotPriceUpdated(lotId, price);\r\n    }\r\n\r\n    function _nthPurchaseDiscount(uint lotPrice, uint quantity, uint cratesPurchased) private view returns(uint) {\r\n        uint discountsApplied = cratesPurchased / MULTI_PURCHASE_DISCOUNT_STEP;\r\n        uint discountsToApply = (cratesPurchased + quantity) / MULTI_PURCHASE_DISCOUNT_STEP - discountsApplied;\r\n\r\n        return lotPrice.mul(discountsToApply).mul(_multiPurchaseDiscount).div(PERCENT_PRECISION);\r\n    }\r\n\r\n    function _getPriceWithDiscounts(Lot memory lot, uint quantity, uint cratesPurchased) private view returns(uint price, uint discount) {\r\n        price = lot.price.mul(quantity);\r\n        // Discounts are additive\r\n\r\n        // apply early bird discount\r\n        if (initialDiscountActive()) {\r\n            discount = price.mul(_initialDiscountPercentage).div(PERCENT_PRECISION);\r\n        }\r\n\r\n        // apply multi purchase discount if any\r\n        discount += _nthPurchaseDiscount(lot.price, quantity, cratesPurchased);\r\n        price = price.sub(discount);\r\n    }\r\n\r\n    function purchaseFor(\r\n        address payable destination,\r\n        uint256 lotId,\r\n        ERC20Capped tokenAddress,\r\n        uint256 quantity,\r\n        uint256 maxTokenAmount,\r\n        uint256 minConversionRate,\r\n        address payable referrer\r\n    )\r\n        external \r\n        payable\r\n        whenNotPaused \r\n        whenStarted\r\n    {\r\n        require (quantity > 0, \"Wrong qty\");\r\n        require (referrer != destination && referrer != msg.sender, \"Wrong referrer\"); //Inefficient\r\n\r\n        // hack to fit as many variables on stack as required.\r\n        PurchaseForVars memory vars;\r\n\r\n        vars.lot = _lots[lotId];\r\n        require(vars.lot.price != 0, \"Lot doesn't exist\");\r\n\r\n        (vars.price, vars.discount) = _getPriceWithDiscounts(vars.lot, quantity, _cratesPurchased[destination][lotId]);\r\n\r\n        (vars.tokensSent, vars.tokensReceived) = _swapTokenAndHandleChange(\r\n            tokenAddress,\r\n            maxTokenAmount,\r\n            _stableCoinAddress,\r\n            vars.price,\r\n            minConversionRate,\r\n            msg.sender,\r\n            address(uint160(address(this)))\r\n        );\r\n\r\n        // Check if received enough tokens.\r\n        require(vars.tokensReceived >= vars.price, \"Not enough tokens received\");\r\n\r\n        if (referrer != address(0)) {\r\n            bool sendReferral = true;\r\n            if (_customReferralPercentages[referrer] == 0) {\r\n                // not a VIP\r\n                if (_referrersByLot[lotId][destination] == referrer) { \r\n                    // buyer already used a referrer for this item before\r\n                    sendReferral = false;\r\n                }\r\n            }\r\n\r\n            if (sendReferral) {\r\n                vars.referralReward = vars.tokensReceived\r\n                    .mul(Math.max(_customReferralPercentages[referrer], _defaultReferralPercentage))\r\n                    .div(PERCENT_PRECISION);\r\n\r\n                if (vars.referralReward > 0) {\r\n                    _referrersByLot[lotId][destination] = referrer;\r\n                    // send stable coin as reward\r\n                    require(_stableCoinAddress.transfer(referrer, vars.referralReward), \"referral payout failed\");\r\n                }\r\n            }\r\n        }\r\n\r\n        vars.tokensReceived = vars.tokensReceived.sub(vars.referralReward);\r\n\r\n        require(vars.lot.crateToken.mint(destination, quantity), \"Minting fail\"); \r\n        require(_stableCoinAddress.transfer(_payoutWallet, vars.tokensReceived), \"payout failed\");\r\n        _cratesPurchased[destination][lotId] += quantity;\r\n\r\n        emit Purchased(\r\n            destination,\r\n            msg.sender,\r\n            lotId,\r\n            quantity,\r\n            vars.price,\r\n            address(tokenAddress),\r\n            vars.tokensSent,\r\n            vars.tokensReceived,\r\n            vars.discount,\r\n            referrer,\r\n            vars.referralReward\r\n        );\r\n    }\r\n\r\n    function getPrice(\r\n        uint256 lotId,\r\n        uint256 quantity,\r\n        ERC20 tokenAddress,\r\n        address destination\r\n    )\r\n    external\r\n    view\r\n    returns (\r\n        uint256 minConversionRate,\r\n        uint256 lotPrice,\r\n        uint256 lotPriceWithoutDiscount\r\n    )\r\n    {\r\n        // convert Stable Coin -> Target Token (ETH is included)\r\n        lotPriceWithoutDiscount = _lots[lotId].price.mul(quantity);\r\n        (uint totalPrice, ) = _getPriceWithDiscounts(_lots[lotId], quantity, _cratesPurchased[destination][lotId]);\r\n\r\n        (, uint tokenAmount) = _convertToken(_stableCoinAddress, totalPrice, tokenAddress);\r\n        (, minConversionRate) = kyber.getExpectedRate(tokenAddress, _stableCoinAddress, tokenAmount);\r\n        lotPrice = ceilingDiv(totalPrice.mul(10**36), minConversionRate);\r\n        lotPrice = _fixTokenDecimals(_stableCoinAddress, tokenAddress, lotPrice, true);\r\n\r\n        lotPriceWithoutDiscount = ceilingDiv(lotPriceWithoutDiscount.mul(10**36), minConversionRate);\r\n        lotPriceWithoutDiscount = _fixTokenDecimals(_stableCoinAddress, tokenAddress, lotPriceWithoutDiscount, true);\r\n    }\r\n\r\n    function openCrate(address from, uint256 lotId, uint256 amount) external {\r\n        require(address(_lots[lotId].crateToken) == msg.sender);\r\n        for (uint256 i = 0; i < amount; i++ ) {\r\n            emit CrateOpened(from, lotId, 1);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/purchase/AltcoinsPurchaseProxy.sol\r\n\r\npragma solidity = 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AltcoinsPurchaseProxy is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event PurchasedViaProxy (\r\n        address indexed owner,\r\n        address operator,\r\n        uint256 indexed lotId,\r\n        uint256 indexed quantity,\r\n        uint256 pricePaid,\r\n        address tokenAddress,\r\n        address referrer\r\n    );\r\n\r\n    struct PurchaseForVars {\r\n        uint256 altcoinConversionRate;\r\n        uint256 altcoinPrice;\r\n        uint256 altcoinPriceWithoutDiscount;\r\n        uint256 stablecoinConversionRate;\r\n        uint256 stablecoinPrice;\r\n        uint256 stablecoinPriceWithoutDiscount;\r\n    }\r\n\r\n    uint256 private constant PERCENT_PRECISION = 10000;\r\n    uint256 private constant MULTI_PURCHASE_DISCOUNT_STEP = 5;\r\n\r\n    FixedSupplyCratesSale _saleContract;\r\n    mapping (address => uint256) public _stableCoinRates;\r\n\r\n    constructor(FixedSupplyCratesSale saleContract) public {\r\n        require(saleContract != FixedSupplyCratesSale(address(0)));\r\n        _saleContract = saleContract;\r\n    }\r\n\r\n    function addAltcoin(address altcoinAddress, uint256 stableCoinRate) external onlyOwner {\r\n        require(altcoinAddress != address(0));\r\n        _stableCoinRates[altcoinAddress] = stableCoinRate;\r\n    }\r\n\r\n    function purchaseFor(\r\n        address payable destination,\r\n        uint256 lotId,\r\n        ERC20Capped altcoinAddress,\r\n        uint256 quantity,\r\n        uint256 maxTokenAmount,\r\n        uint256 minConversionRate,\r\n        address payable referrer\r\n    ) external {\r\n        PurchaseForVars memory vars;\r\n\r\n        (\r\n            vars.altcoinConversionRate,\r\n            vars.altcoinPrice,\r\n            vars.altcoinPriceWithoutDiscount\r\n        ) = getPrice(lotId, quantity, ERC20(address(altcoinAddress)), destination);\r\n\r\n        require(vars.altcoinConversionRate != 0, \"Altcoin not supported\");\r\n        require(minConversionRate >= vars.altcoinConversionRate, \"Min rate too low\"); //TODO check it's correct\r\n        require(vars.altcoinPrice <= maxTokenAmount, \"Price above max token amount\");\r\n\r\n        (\r\n            vars.stablecoinConversionRate,\r\n            vars.stablecoinPrice,\r\n            vars.stablecoinPriceWithoutDiscount\r\n        ) = getPrice(lotId, quantity, _saleContract._stableCoinAddress(), destination);\r\n\r\n        require(altcoinAddress.transferFrom(msg.sender, _saleContract._payoutWallet(), vars.altcoinPrice), \"Altcoin transfer failed\");\r\n        require(ERC20(address(_saleContract._stableCoinAddress())).approve(address(_saleContract), vars.stablecoinPrice), \"Approval failed\");\r\n        _saleContract.purchaseFor(\r\n            destination,\r\n            lotId,\r\n            ERC20Capped(address(_saleContract._stableCoinAddress())),\r\n            quantity,\r\n            vars.stablecoinPrice,\r\n            vars.stablecoinConversionRate,\r\n            referrer\r\n        );\r\n\r\n        emit PurchasedViaProxy(\r\n            destination,\r\n            msg.sender,\r\n            lotId,\r\n            quantity,\r\n            vars.altcoinPrice,\r\n            address(altcoinAddress),\r\n            referrer\r\n        );\r\n    }\r\n\r\n    function getPrice(\r\n        uint256 lotId,\r\n        uint256 quantity,\r\n        ERC20 tokenAddress,\r\n        address destination\r\n    )\r\n    public\r\n    view\r\n    returns (\r\n        uint256 minConversionRate,\r\n        uint256 lotPrice,\r\n        uint256 lotPriceWithoutDiscount\r\n    )\r\n    {\r\n        minConversionRate = 1000000000000000000;\r\n        (, uint256 singleLotPrice) = _saleContract._lots(lotId);\r\n        lotPriceWithoutDiscount = singleLotPrice.mul(quantity);\r\n        (lotPrice, ) = _getPriceWithDiscounts(singleLotPrice, quantity, _saleContract._cratesPurchased(destination, lotId));\r\n        if (tokenAddress != _saleContract._stableCoinAddress()) {\r\n            minConversionRate = _stableCoinRates[address(tokenAddress)];\r\n            require(minConversionRate != 0, \"Altcoin not supported\");\r\n            lotPrice = ceilingDiv(lotPrice.mul(10**36), minConversionRate);\r\n            lotPrice = _fixTokenDecimals(_saleContract._stableCoinAddress(), tokenAddress, lotPrice, true);\r\n            lotPriceWithoutDiscount = ceilingDiv(lotPriceWithoutDiscount.mul(10**36), minConversionRate);\r\n            lotPriceWithoutDiscount = _fixTokenDecimals(_saleContract._stableCoinAddress(), tokenAddress, lotPriceWithoutDiscount, true);\r\n        }\r\n    }\r\n\r\n    function ceilingDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        return a.div(b).add(a.mod(b) > 0 ? 1 : 0);\r\n    }\r\n\r\n    function _nthPurchaseDiscount(uint lotPrice, uint quantity, uint cratesPurchased) private view returns(uint) {\r\n        uint discountsApplied = cratesPurchased / MULTI_PURCHASE_DISCOUNT_STEP;\r\n        uint discountsToApply = (cratesPurchased + quantity) / MULTI_PURCHASE_DISCOUNT_STEP - discountsApplied;\r\n\r\n        return lotPrice.mul(discountsToApply).mul(_saleContract._multiPurchaseDiscount()).div(PERCENT_PRECISION);\r\n    }\r\n\r\n    function _getPriceWithDiscounts(uint256 lotPrice, uint quantity, uint cratesPurchased) private view returns(uint price, uint discount) {\r\n        price = lotPrice.mul(quantity);\r\n        // Discounts are additive\r\n\r\n        // apply early bird discount\r\n        if (_saleContract.initialDiscountActive()) {\r\n            discount = price.mul(_saleContract._initialDiscountPercentage()).div(PERCENT_PRECISION);\r\n        }\r\n\r\n        // apply multi purchase discount if any\r\n        discount += _nthPurchaseDiscount(lotPrice, quantity, cratesPurchased);\r\n        price = price.sub(discount);\r\n    }\r\n\r\n    function _fixTokenDecimals(\r\n        ERC20 _src,\r\n        ERC20 _dest,\r\n        uint256 _unfixedDestAmount,\r\n        bool _ceiling\r\n    )\r\n    internal\r\n    view\r\n    returns (uint256 _destTokenAmount)\r\n    {\r\n        uint256 _unfixedDecimals = ERC20Detailed(address(_src)).decimals() + 18; // Kyber by default returns rates with 18 decimals.\r\n        uint256 _decimals = ERC20Detailed(address(_dest)).decimals();\r\n\r\n        if (_unfixedDecimals > _decimals) {\r\n            // Divide token amount by 10^(_unfixedDecimals - _decimals) to reduce decimals.\r\n            if (_ceiling) {\r\n                return ceilingDiv(_unfixedDestAmount, (10 ** (_unfixedDecimals - _decimals)));\r\n            } else {\r\n                return _unfixedDestAmount.div(10 ** (_unfixedDecimals - _decimals));\r\n            }\r\n        } else {\r\n            // Multiply token amount with 10^(_decimals - _unfixedDecimals) to increase decimals.\r\n            return _unfixedDestAmount.mul(10 ** (_decimals - _unfixedDecimals));\r\n        }\r\n    }\r\n\r\n    function balance() external view returns(uint256) {\r\n        return ERC20(_saleContract._stableCoinAddress()).balanceOf(address(this));\r\n    }\r\n\r\n    function withdraw(address to, uint256 quantity) external onlyOwner {\r\n        if (quantity == 0) { // Withdraw all\r\n            quantity = ERC20(_saleContract._stableCoinAddress()).balanceOf(address(this));\r\n        }\r\n        require(ERC20(_saleContract._stableCoinAddress()).transfer(to, quantity));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract FixedSupplyCratesSale\",\"name\":\"saleContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"PurchasedViaProxy\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_stableCoinRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"altcoinAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stableCoinRate\",\"type\":\"uint256\"}],\"name\":\"addAltcoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minConversionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lotPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lotPriceWithoutDiscount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lotId\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20Capped\",\"name\":\"altcoinAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minConversionRate\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"purchaseFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AltcoinsPurchaseProxy","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002e61c63e045a978b51c6517c79c2592fcfbc82cd","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://874722d94b8c582cfcba50f72a558019c5ca102764f610a316e42f0e21bbd619"}]}