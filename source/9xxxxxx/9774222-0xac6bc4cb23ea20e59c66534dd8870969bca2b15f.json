{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"petersburg\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/AverageBlockTime.sol\": {\r\n      \"content\": \"pragma solidity 0.5.9;\\n\\ncontract AverageBlockTime {\\n    struct Snapshot {\\n        uint128 timestamp;\\n        uint128 blockNumber;\\n    }\\n    Snapshot snapshot0;\\n    Snapshot snapshot1;\\n    uint256 minUpdateDelay;\\n\\n    constructor(uint256 _minUpdateDelay, uint128 _snapshotTimestamp, uint128 _snapshotBlockNumber) public {\\n        require(block.timestamp - _snapshotTimestamp >= _minUpdateDelay, \\\"require an older snapshot\\\");\\n        require(_snapshotBlockNumber < block.number, \\\"can't use a future snapshot\\\");\\n        minUpdateDelay = _minUpdateDelay;\\n        snapshot0.timestamp = _snapshotTimestamp;\\n        snapshot0.blockNumber = _snapshotBlockNumber;\\n    }\\n\\n    function update() external {\\n        Snapshot memory _snapshot0 = snapshot0;\\n        Snapshot memory _snapshot1 = snapshot1;\\n        if(_snapshot0.timestamp > _snapshot1.timestamp) {\\n            if(block.timestamp - _snapshot1.timestamp >= minUpdateDelay) {\\n                snapshot1.timestamp = uint128(block.timestamp);\\n                snapshot1.blockNumber = uint128(block.number);\\n            }\\n        } else {\\n            if(block.timestamp - _snapshot0.timestamp >= minUpdateDelay) {\\n                snapshot0.timestamp = uint128(block.timestamp);\\n                snapshot0.blockNumber = uint128(block.number);\\n            }\\n        }\\n    }\\n\\n    function getAverageBlockTimeInMicroSeconds() external view returns (uint256) {\\n        Snapshot storage snapshot = snapshot0;\\n        if(snapshot.timestamp > snapshot1.timestamp) {\\n            if(block.timestamp - snapshot.timestamp < minUpdateDelay) {\\n                snapshot = snapshot1;\\n            }\\n        } else {\\n            if(block.timestamp - snapshot1.timestamp >= minUpdateDelay) {\\n                snapshot = snapshot1;\\n            }\\n        }\\n        return ((block.timestamp - snapshot.timestamp) * 1000) / (block.number - snapshot.blockNumber);\\n    }\\n}\",\r\n      \"keccak256\": \"0xc4125a97f1c27cfd931a1d72d641115a540a22454ea9bb363ce803f7011c9adc\"\r\n    },\r\n    \"src/Interfaces/ERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/// @title ERC-721 Non-Fungible Token Standard\\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\\ninterface ERC721 /* is ERC165 */ {\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n    ///  may be created and assigned without emitting Transfer. At the time of\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /// @dev This emits when the approved address for an NFT is changed or\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\n    ///  When a Transfer event emits, this also indicates that the approved\\n    ///  address for that NFT (if any) is reset to none.\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\n    ///  The operator can manage all NFTs of the owner.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /// @notice Count all NFTs assigned to an owner\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\n    ///  function throws for queries about the zero address.\\n    /// @param _owner An address for whom to query the balance\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Find the owner of an NFT\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\n    ///  about them do throw.\\n    /// @param _tokenId The identifier for an NFT\\n    /// @return The address of the owner of the NFT\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev This works identically to the other function with an extra data parameter,\\n    ///  except this function just sets data to \\\"\\\"\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\\n\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    ///  THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\\n\\n    /// @notice Set or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    ///  operator of the current owner.\\n    /// @param _approved The new approved NFT controller\\n    /// @param _tokenId The NFT to approve\\n    function approve(address _approved, uint256 _tokenId) external;\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    ///  all of `msg.sender`'s assets.\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    ///  multiple operators per owner.\\n    /// @param _operator Address to add to the set of authorized operators.\\n    /// @param _approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /// @notice Get the approved address for a single NFT\\n    /// @dev Throws if `_tokenId` is not a valid NFT\\n    /// @param _tokenId The NFT to find the approved address for\\n    /// @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param _owner The address that owns the NFTs\\n    /// @param _operator The address that acts on behalf of the owner\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n\\n    function name() external view returns (string memory _name);\\n    function symbol() external view returns (string memory _symbol);\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\ninterface ERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\\ninterface ERC721TokenReceiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the\\n    /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\\n    /// of other than the magic value MUST result in the transaction being reverted.\\n    /// @notice The contract address is always the message sender.\\n    /// @param _operator The address which called `safeTransferFrom` function\\n    /// @param _from The address which previously owned the token\\n    /// @param _tokenId The NFT identifier which is being transferred\\n    /// @param _data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    /// unless throwing\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\n}\",\r\n      \"keccak256\": \"0x778a8310081ace360ead2c697769dfccf9fb4dfc615e826779047997113077c2\"\r\n    },\r\n    \"src/MysteryBoxSales.sol\": {\r\n      \"content\": \"pragma solidity 0.5.9;\\n\\nimport \\\"./Interfaces/ERC721.sol\\\";\\nimport \\\"./AverageBlockTime.sol\\\";\\n\\ncontract MysteryBoxSales is ERC721 {\\n\\n    uint256 lastSaleId;\\n    struct Sale {\\n        ERC721[] nftContracts;\\n        uint256[] tokenIds;\\n        address payable seller;\\n        uint96 revealTime;\\n        address priceToken;\\n        uint128 price;\\n        uint128 fee;\\n        address[] participants;\\n        address payable revealer;\\n        string metadata;\\n    }\\n\\n    mapping (uint256 => Sale) private sales;\\n\\n    // revealTime => revealer => whether revealer was able to reveal in time\\n    mapping (uint256 => mapping(address => bool)) canGetReward;\\n\\n    // revealTime => revealer => priceToken => fee to collect\\n    mapping (uint256 => mapping(address => mapping(address => uint256))) blockHashReward;\\n\\n    AverageBlockTime averageBlockTimeOracle;\\n\\n    constructor(AverageBlockTime _averageBlockTimeOracle) public {\\n        averageBlockTimeOracle = _averageBlockTimeOracle;\\n    }\\n\\n    event MysteryBoxSaleCreated(\\n        uint256 saleId,\\n        string name,\\n        address indexed seller,\\n        uint96 revealTime,\\n        address priceToken,\\n        uint128 price,\\n        uint256[] tokenIds,\\n        ERC721[] tokenContracts,\\n        address indexed revealer,\\n        uint128 fee,\\n        string metadataURI\\n    );\\n    event BlockHash(uint256 indexed revealTime, bytes32 hash); // TODO separate contrat\\n    event MysteryBoxSaleWithdrawn(uint256 indexed saleId, address indexed seller);\\n    event MysteryBoxSaleProceedsWithdrawn(uint256 indexed saleId, address indexed seller, uint256 pay);\\n\\n    event MysteryBoxBought(uint256 indexed saleId, uint256 participantIndex, address indexed buyer);\\n    event MysteryBoxWithdrawn(uint256 indexed saleId, uint256 participantIndex, address indexed buyer);\\n\\n    function createSale(\\n        string calldata _name,\\n        ERC721[] calldata _nftContracts,\\n        uint256[] calldata _tokenIds,\\n        uint96 _revealTime,\\n        address payable _priceToken,\\n        uint128 _price,\\n        address payable _revealer,\\n        uint128 _fee,\\n        string calldata _metadata\\n    )\\n    external {\\n        require(_nftContracts.length == _tokenIds.length, \\\"tokenIds length != nftContracts length\\\");\\n        require(_fee <= _price, \\\"fee too high\\\");\\n        // solium-disable-next-line security/no-block-members\\n        require(_revealTime > block.timestamp, \\\"revealTime in the past\\\");\\n\\n        _escrow(msg.sender, _nftContracts, _tokenIds, _tokenIds.length);\\n        address payable[3] memory addrs;\\n        addrs[0] = msg.sender;\\n        addrs[1] = _priceToken;\\n        addrs[2] = _revealer;\\n        _createSale(_name, _nftContracts, _tokenIds, addrs, [_revealTime, _price, _fee], _metadata);\\n    }\\n\\n    function _createSale(\\n        string memory _name,\\n        ERC721[] memory _nftContracts,\\n        uint256[] memory _tokenIds,\\n        address payable[3] memory _addresses, // seller, priceToken, revealer\\n        uint128[3] memory _values, // _revealTime, price, fee\\n        string memory _metadata\\n    ) internal {\\n        uint256 saleId = ++lastSaleId;\\n        sales[saleId] = Sale(\\n            _nftContracts,\\n            _tokenIds,\\n            _addresses[0],\\n            uint96(_values[0]),\\n            _addresses[1],\\n            uint128(_values[1]),\\n            uint128(_values[2]),\\n            new address[](0),\\n            _addresses[2],\\n            _metadata\\n        );\\n        emit MysteryBoxSaleCreated(\\n            saleId,\\n            _name,\\n            _addresses[0],\\n            uint96(_values[0]),\\n            _addresses[1],\\n            uint128(_values[1]),\\n            _tokenIds,\\n            _nftContracts,\\n            _addresses[2],\\n            uint128(_values[2]),\\n            _metadata\\n        );\\n    }\\n\\n\\n    function buy(uint256 _saleId) public payable {\\n        gift(msg.sender, _saleId);\\n    }\\n\\n    function numBoxesLeftToBuy(uint256 _saleId) external view returns(uint256) {\\n        // solium-disable-next-line security/no-block-members\\n        if(block.timestamp < sales[_saleId].revealTime) {\\n            return sales[_saleId].tokenIds.length - sales[_saleId].participants.length;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function gift(address recipient, uint256 _saleId) public payable { // TODO support erc20 native meta transaction ?\\n        Sale storage sale = sales[_saleId];\\n        address priceToken = sale.priceToken;\\n        uint256 numTokens = sale.tokenIds.length;\\n        uint256 numParticipants = sale.participants.length;\\n        uint256 revealTime = sale.revealTime;\\n        // solium-disable-next-line security/no-block-members\\n        require(block.timestamp < revealTime, \\\"not on sale\\\");\\n        require(numParticipants < numTokens, \\\"all mystery boxes has been purchased\\\");\\n\\n        sale.participants.push(recipient);\\n        // shuffling as we go by swapping tokenIds + corresponding nftContracts\\n        if(numTokens > 2) {\\n            bytes32 lastBlockHash = blockhash(block.number-1);\\n            uint256 swap1 = uint256(keccak256(abi.encodePacked(lastBlockHash, uint8(1)))) % numTokens;\\n            uint256 swap2 = uint256(keccak256(abi.encodePacked(lastBlockHash, uint8(2)))) % numTokens;\\n            if(swap1 == swap2) {\\n                swap1 = (swap2 + 1) % numTokens;\\n            }\\n            uint256 t1 = sale.tokenIds[swap1];\\n            sale.tokenIds[swap1] = sale.tokenIds[swap2];\\n            sale.tokenIds[swap2] = t1;\\n            ERC721 c1 = sale.nftContracts[swap1];\\n            ERC721 c2 = sale.nftContracts[swap2];\\n            if(c1 != c2) {\\n                sale.nftContracts[swap1] = c2;\\n                sale.nftContracts[swap2] = c1;\\n            }\\n        }\\n\\n        {\\n            uint256 price = sale.price;\\n            // record fee to be rewarded to revealer once blockHash is saved\\n            blockHashReward[revealTime][sale.revealer][priceToken] += sale.fee;\\n\\n            if(priceToken == address(0)) {\\n                require(msg.value == price, \\\"msg.value != price\\\");\\n            } else {\\n                require(transferTokenFrom(priceToken, msg.sender, address(this), price), \\\"failed to transfer price\\\");\\n            }\\n        }\\n\\n        emit MysteryBoxBought(_saleId, numParticipants, recipient); // TODO remove and use ERC721 Transfer event below\\n\\n        // ERC721\\n        numBoxes[recipient] ++;\\n        emit Transfer(address(0), recipient, _saleId * 2**128 + numParticipants); // MINT\\n    }\\n\\n    mapping(uint256 => bytes32) blockHashes;\\n\\n    function getBlockHash(uint256 time) external returns(bytes32) {\\n        return blockHashes[time]; // TODO rename blockHashes to blockHashesAtTime\\n    }\\n\\n    function getRevealerReward(uint256 revealTime, address revealer, address priceToken) external returns(uint256) {\\n        return blockHashReward[revealTime][revealer][priceToken];\\n    }\\n\\n    function withdrawRevealerReward(uint256 revealTime, address priceToken) external {\\n        require(canGetReward[revealTime][msg.sender], \\\"did not reveal in time\\\");\\n        uint256 reward = blockHashReward[revealTime][msg.sender][priceToken];\\n        require(reward > 0, \\\"not reward to collect\\\");\\n        blockHashReward[revealTime][msg.sender][priceToken] = 0;\\n        canGetReward[revealTime][msg.sender] = false;\\n        if (priceToken == address(0)) {\\n            msg.sender.transfer(reward);\\n        } else {\\n            require(transferToken(priceToken, msg.sender, reward), \\\"failed to transfer fee to revealer\\\");\\n        }\\n        // TODO event ?\\n    }\\n\\n    function recordBlockHash(uint256 revealTime) external{\\n        _recordBlockHash(revealTime, msg.sender);\\n    }\\n\\n    function _recordBlockHash(uint256 revealTime, address revealer) internal returns(bytes32) {\\n        // solium-disable-next-line security/no-block-members\\n        require(revealTime < block.timestamp, \\\"cannot record a future or present reveal\\\");\\n        // solium-disable-next-line security/no-block-members\\n        uint256 delay = block.timestamp - revealTime;\\n        uint256 averageBlockTimeInMicroSeconds = averageBlockTimeOracle.getAverageBlockTimeInMicroSeconds();\\n        uint256 blockDelay = ((delay * 1000) / averageBlockTimeInMicroSeconds );\\n        require(blockDelay > 0, \\\"cannot get current blockHash, retry later\\\");\\n        uint256 blockNumber = block.number - blockDelay;\\n        bytes32 blockHash = blockHashes[revealTime];\\n\\n        // blockHash > 0 allows revealer to get the reward later of someone alreayd revealed\\n        if (revealer != address(0) && (blockHash > 0 || blockDelay < 256) && !canGetReward[revealTime][revealer]) {\\n            canGetReward[revealTime][revealer] = true;\\n        }\\n\\n        if (blockHash > 0) {\\n            return blockHash; // already recorded\\n        }\\n\\n        if(blockDelay < 256) {\\n            blockHash = blockhash(blockNumber);\\n        } else {\\n            blockHash = blockhash(block.number - (((blockDelay - 1) % 255) + 1));\\n        }\\n        blockHashes[revealTime] = blockHash;\\n        emit BlockHash(revealTime, blockHash);\\n        return blockHash;\\n    }\\n\\n    function withdrawToSeller(uint256 _saleId) external {\\n        withdrawToSellerRange(_saleId, 0, 2**256-1);\\n    }\\n\\n    // solium-disable-next-line security/no-assign-params\\n    function withdrawToSellerRange(uint256 _saleId, uint256 start, uint256 end) public {\\n        Sale storage sale = sales[_saleId];\\n        bytes32 blockHash = blockHashes[sale.revealTime];\\n        address payable seller = sale.seller;\\n        require(blockHash != 0, \\\"sale has not been revealed\\\");\\n        require(seller != address(0), \\\"sale already withdrawn\\\");\\n\\n        uint256 numParticipants = sale.participants.length;\\n        uint256 price = sale.price;\\n        if(price > 0 && numParticipants > 0) {\\n            uint256 pay = numParticipants * (price - sale.fee);\\n            address priceToken = sale.priceToken;\\n            if(address(priceToken) == address(0)) {\\n                seller.transfer(pay);\\n            } else {\\n                require(transferToken(priceToken, seller, pay), \\\"cannot transfer pay to seller\\\");\\n            }\\n            sale.price = 0;\\n            emit MysteryBoxSaleProceedsWithdrawn(_saleId, seller, pay);\\n        }\\n\\n        uint256 numTokens = sale.tokenIds.length;\\n        uint256 firstTokenIndex = getTokenIndexReceived(blockHash, _saleId, numParticipants);\\n        if(end > numTokens - numParticipants) {\\n            end = numTokens - numParticipants;\\n        }\\n        for(uint256 i = start; i < end; i++) {\\n            uint256 tokenIndex = (firstTokenIndex + i) % numTokens;\\n            sale.nftContracts[tokenIndex].transferFrom(address(this), seller, sale.tokenIds[tokenIndex]);\\n            sale.nftContracts[tokenIndex] = ERC721(0);\\n            sale.tokenIds[tokenIndex] = 0;\\n        }\\n\\n        if(end == numTokens - numParticipants) {\\n            emit MysteryBoxSaleWithdrawn(_saleId, seller);\\n            sale.seller = address(0);\\n        }\\n    }\\n\\n    function _splitID(uint256 _tokenId) internal pure returns(uint256 saleId, uint256 participantIndex) {\\n        saleId = _tokenId / 2**128;\\n        participantIndex = uint128(_tokenId);\\n    }\\n\\n    // ERC721 BOX STANDARD ? ////////////////////////////////////////////////\\n    function open(uint256 _tokenId) external {\\n        (uint256 saleId, uint256 participantIndex) = _splitID(_tokenId);\\n        withdrawToken(saleId, participantIndex);\\n    }\\n\\n    function peek(uint256 _tokenId) external view returns(ERC721 nftContract, uint256 tokenId) {\\n        (uint256 saleId, uint256 participantIndex) = _splitID(_tokenId);\\n        bytes32 blockHash = blockHashes[sales[saleId].revealTime];\\n        if(blockHash == 0) {\\n            return (ERC721(0),0);\\n        }\\n        return getTokenReceived(saleId, participantIndex);\\n    }\\n    //////////////////////////////////////////////////////////////////////////\\n\\n    function withdrawTokensInBatch(uint256 _saleId, uint256[] calldata _participantIndices) external {\\n        bytes32 blockHash;\\n        {\\n            uint256 revealTime = sales[_saleId].revealTime;\\n            blockHash = blockHashes[revealTime];\\n            if( blockHash == 0) {\\n                blockHash = _recordBlockHash(revealTime, address(0)); // if no blockHash make it yourself but do not record reward\\n            }\\n        }\\n\\n        uint256 numParticipants = sales[_saleId].participants.length;\\n        uint256 numIndices = _participantIndices.length;\\n        for(uint256 i = 0; i < numIndices; i++) {\\n            uint256 _participantIndex = _participantIndices[i];\\n            require(_participantIndex < numParticipants, \\\"particpantIndex too big\\\");\\n            address participant = sales[_saleId].participants[_participantIndex];\\n            require(participant == msg.sender, \\\"participants not matching\\\");\\n            sales[_saleId].participants[_participantIndex] = address(0);\\n            {\\n                uint256 tokenIndex = getTokenIndexReceived(blockHash, _saleId, _participantIndex);\\n                sales[_saleId].nftContracts[tokenIndex].transferFrom(address(this), participant, sales[_saleId].tokenIds[tokenIndex]);\\n                sales[_saleId].nftContracts[tokenIndex] = ERC721(0);\\n                sales[_saleId].tokenIds[tokenIndex] = 0;\\n                emit MysteryBoxWithdrawn(_saleId, _participantIndex, participant); // TODO remove and use ERC721 Transfer event below ?\\n            }\\n\\n            // ERC721\\n            emit Transfer(participant, address(0), _saleId * 2**128 + _participantIndex); // BURN // no need to reset operator\\n        }\\n        // ERC721\\n        numBoxes[msg.sender] -= numIndices;\\n    }\\n\\n    function withdrawToken(uint256 _saleId, uint256 _participantIndex) public {\\n        uint256 revealTime = sales[_saleId].revealTime;\\n        bytes32 blockHash = blockHashes[revealTime];\\n        if( blockHash == 0) {\\n            blockHash = _recordBlockHash(revealTime, address(0)); // if no blockHash make it yourself but do not record reward\\n        }\\n        require(_participantIndex < sales[_saleId].participants.length, \\\"particpantIndex too big\\\");\\n        address participant = sales[_saleId].participants[_participantIndex];\\n        require(participant == msg.sender, \\\"only participant can withdrawn\\\");\\n        sales[_saleId].participants[_participantIndex] = address(0);\\n        uint256 tokenIndex = getTokenIndexReceived(blockHash, _saleId, _participantIndex);\\n        sales[_saleId].nftContracts[tokenIndex].transferFrom(address(this), participant, sales[_saleId].tokenIds[tokenIndex]);\\n        sales[_saleId].nftContracts[tokenIndex] = ERC721(0);\\n        sales[_saleId].tokenIds[tokenIndex] = 0;\\n        emit MysteryBoxWithdrawn(_saleId, _participantIndex, participant); // TODO remove and use ERC721 Transfer event below ?\\n\\n        // ERC721\\n        numBoxes[participant] --;\\n        emit Transfer(participant, address(0), _saleId * 2**128 + _participantIndex); // BURN\\n    }\\n\\n    function getTokenIndexReceived(bytes32 blockHash, uint256 _saleId, uint256 _participantIndex) internal view returns(uint256 tokenIndex) {\\n        return (uint256(keccak256(abi.encodePacked(blockHash, _saleId))) + _participantIndex) % sales[_saleId].tokenIds.length;\\n    }\\n\\n    function getTokenReceived(uint256 _saleId, uint256 _participantIndex) internal view returns(ERC721 nftContract, uint256 tokenId) {\\n        uint256 index = getTokenIndexReceived(blockHashes[sales[_saleId].revealTime], _saleId, _participantIndex);\\n        return (sales[_saleId].nftContracts[index], sales[_saleId].tokenIds[index]);\\n    }\\n\\n     function isReadyForReveal(\\n        uint256 _saleId\\n    )\\n        external\\n        view\\n        returns\\n    (bool) {\\n        bytes32 blockHash = blockHashes[sales[_saleId].revealTime];\\n        // solium-disable-next-line security/no-block-members\\n        return sales[_saleId].revealTime > 0 && blockHash == 0 && block.timestamp > sales[_saleId].revealTime;\\n    }\\n\\n    function exists(uint256 _saleId) external view returns (bool) {\\n        return sales[_saleId].revealTime > 0;\\n    }\\n\\n    function getRevealedToken(\\n        uint256 _saleId,\\n        uint256 _participantIndex\\n    ) external view returns (ERC721 nftContract, uint256 tokenId){\\n        bytes32 blockHash = blockHashes[sales[_saleId].revealTime];\\n        if(blockHash == 0) {\\n            return (ERC721(0),0);\\n        }\\n        return getTokenReceived(_saleId, _participantIndex);\\n    }\\n\\n    function _escrow(\\n        address _seller,\\n        ERC721[] memory _nftContracts,\\n        uint256[] memory _tokenIds,\\n        uint256 _numToEscrow\\n    ) internal {\\n        for(uint256 i = 0; i < _numToEscrow; i++){\\n            address ownerOfToken = _nftContracts[i].ownerOf(_tokenIds[i]);\\n            require(ownerOfToken == _seller, \\\"only the owner can be seller\\\");\\n            _nftContracts[i].transferFrom(ownerOfToken, address(this), _tokenIds[i]);\\n        }\\n    }\\n\\n    /// ERC721 ///////////////\\n    mapping(uint256 => address) operators;\\n    mapping(address => mapping(address => bool)) operatorsForAll;\\n    mapping(address => uint256) numBoxes;\\n\\n    function balanceOf(address _owner) external view returns (uint256) {\\n        require(_owner != address(0), \\\"token does not exist\\\");\\n        return numBoxes[_owner];\\n    }\\n\\n    function ownerOf(uint256 _tokenId) public view returns (address){\\n        (uint256 saleId, uint256 participantIndex) = _splitID(_tokenId);\\n        address[] storage participants = sales[saleId].participants;\\n        address owner = participants[participantIndex];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external {\\n        _transferFrom(_from, _to, _tokenId);\\n        require(_checkERC721Receiver(_from, _to, _tokenId, data), \\\"erc721 transfer rejected\\\");\\n    }\\n\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\\n        _transferFrom(_from, _to, _tokenId);\\n        require(_checkERC721Receiver(_from, _to, _tokenId, \\\"\\\"), \\\"erc721 transfer rejected\\\");\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external {\\n        _transferFrom(_from, _to, _tokenId);\\n    }\\n\\n    function _transferFrom(address _from, address _to, uint256 _tokenId) internal {\\n        require(_to != address(0), \\\"token does not exist\\\");\\n        require(_from != address(0), \\\"from is zero address\\\");\\n        address operator = operators[_tokenId];\\n        require(msg.sender == _from || operatorsForAll[_from][msg.sender] || msg.sender == operator, \\\"not approved\\\");\\n        (uint256 saleId, uint256 participantIndex) = _splitID(_tokenId);\\n        require(sales[saleId].participants[participantIndex] == _from, \\\"current owner != _from\\\");\\n        sales[saleId].participants[participantIndex] = _to;\\n        if (operator != address(0)) {\\n            operators[_tokenId] = address(0);\\n        }\\n        numBoxes[_from] --;\\n        numBoxes[_to] ++;\\n        emit Transfer(_from, _to, _tokenId);\\n    }\\n\\n    function approve(address _approved, uint256 _tokenId) external {\\n        (uint256 saleId, uint256 participantIndex) = _splitID(_tokenId);\\n        require(sales[saleId].participants[participantIndex] == msg.sender, \\\"current owner != msg.sender\\\");\\n        operators[_tokenId] = _approved;\\n        emit Approval(msg.sender, _approved, _tokenId);\\n    }\\n\\n    function setApprovalForAll(address _operator, bool _approved) external{\\n        require(_operator != address(0), \\\"operator is zero address\\\");\\n        operatorsForAll[msg.sender][_operator] = _approved;\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\n    }\\n\\n    function getApproved(uint256 _tokenId) external view returns (address){\\n        ownerOf(_tokenId);\\n        return operators[_tokenId];\\n    }\\n\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool){\\n        require(_owner != address(0), \\\"token does not exist\\\");\\n        require(_operator != address(0), \\\"operator is zero address\\\");\\n        return operatorsForAll[_owner][_operator];\\n    }\\n\\n    bytes4 constant ERC721_RECEIVED = 0x150b7a02;\\n    function _checkERC721Receiver(address _from, address _to, uint256 _id, bytes memory _data) internal returns (bool) {\\n        if (!isContract(_to)) {\\n            return true;\\n        }\\n        return (ERC721TokenReceiver(_to).onERC721Received(_from, _from, _id, _data) == ERC721_RECEIVED);\\n    }\\n\\n    /// ERC721 Metadata\\n    function name() external view returns (string memory _name) {\\n        return \\\"Mystery Market\\\";\\n    }\\n\\n    function symbol() external view returns (string memory _symbol) {\\n        return \\\"MYSTERY\\\";\\n    }\\n\\n    function toHexString(uint256 x) internal pure returns (string memory) {\\n        uint256 numZeroes = numZeroesFor(x);\\n        bytes memory s = new bytes(64 - numZeroes);\\n        uint256 start = numZeroes / 2;\\n        for (uint i = start; i < 32; i++) {\\n            byte b = byte(uint8(uint(x) / (2**(8*(31 - i)))));\\n            byte hi = byte(uint8(b) / 16);\\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\\n\\n            uint256 index = 2*(i-start);\\n            s[index] = char(hi);\\n            s[index+1] = char(lo);\\n        }\\n        return string(s);\\n    }\\n\\n    function numZeroesFor(uint256 x) internal pure returns (uint256) {\\n        uint256 numZeroes = 0;\\n        for (uint256 i = 0; i < 32; i++) {\\n            byte b = byte(uint8(uint(x) / (2**(8*(31 - i)))));\\n            if (b != 0) {\\n                break;\\n            }\\n            numZeroes += 2;\\n        }\\n        return numZeroes;\\n    }\\n\\n    function char(byte b) internal pure returns (byte c) {\\n        if (uint8(b) < 10) return byte(uint8(b) + 0x30);\\n        else return byte(uint8(b) + 0x57);\\n    }\\n\\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\\n        ownerOf(_tokenId);\\n        (uint256 saleId, uint256 participantIndex) = _splitID(_tokenId);\\n        string memory metadataURI = sales[saleId].metadata;\\n        bytes memory bs = bytes(metadataURI);\\n        if (bs.length > 7 &&\\n            bs[0] == 'h' &&\\n            bs[1] == 't' &&\\n            bs[2] == 't' &&\\n            bs[3] == 'p'\\n        ) {\\n            return\\n            string(\\n                abi.encodePacked(\\n                    metadataURI,\\n                    \\\"/metadata_0x\\\",toHexString(_tokenId),\\n                    \\\".json\\\"\\n                )\\n            );\\n        } else {\\n            return metadataURI;\\n        }\\n    }\\n\\n    function peekTokenURI(uint256 _tokenId) external view returns (string memory) {\\n        ownerOf(_tokenId);\\n        (uint256 saleId, uint256 participantIndex) = _splitID(_tokenId);\\n        bytes32 blockHash = blockHashes[sales[saleId].revealTime];\\n        if(blockHash != 0) {\\n            (ERC721 nftContract, uint256 tokenId) = getTokenReceived(saleId, participantIndex);\\n            return nftContract.tokenURI(tokenId);\\n        }\\n        return sales[saleId].metadata;\\n    }\\n\\n    /// ERC165\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool){\\n        return interfaceID == 0x01ffc9a7 || interfaceID == 0x80ac58cd || interfaceID == 0x5b5e139f;\\n    }\\n\\n    /// UTILS\\n    function isContract(address addr) internal view returns (bool) {\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        bytes32 codehash;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(addr)\\n        }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n\\n    function transferToken (\\n        address token,\\n        address receiver,\\n        uint256 amount\\n    )\\n        internal\\n        returns (bool transferred)\\n    {\\n        bytes memory data = abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", receiver, amount);\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize)\\n            switch returndatasize\\n            case 0 { transferred := success }\\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\\n            default { transferred := 0 }\\n        }\\n    }\\n\\n    function transferTokenFrom (\\n        address token,\\n        address from,\\n        address receiver,\\n        uint256 amount\\n    )\\n        internal\\n        returns (bool transferred)\\n    {\\n        bytes memory data = abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", from, receiver, amount);\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize)\\n            switch returndatasize\\n            case 0 { transferred := success }\\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\\n            default { transferred := 0 }\\n        }\\n    }\\n\\n}\\n\",\r\n      \"keccak256\": \"0xe1483ee7d0f5b4e5f7dc60f3bc766d121b1ff123c1ee6b264051f5f544bfe871\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_saleId\",\"type\":\"uint256\"},{\"name\":\"_participantIndex\",\"type\":\"uint256\"}],\"name\":\"getRevealedToken\",\"outputs\":[{\"name\":\"nftContract\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_nftContracts\",\"type\":\"address[]\"},{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_revealTime\",\"type\":\"uint96\"},{\"name\":\"_priceToken\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint128\"},{\"name\":\"_revealer\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint128\"},{\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"createSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_saleId\",\"type\":\"uint256\"}],\"name\":\"numBoxesLeftToBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_saleId\",\"type\":\"uint256\"}],\"name\":\"isReadyForReveal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_saleId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleId\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"withdrawToSellerRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"peekTokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"revealTime\",\"type\":\"uint256\"},{\"name\":\"priceToken\",\"type\":\"address\"}],\"name\":\"withdrawRevealerReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"open\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"peek\",\"outputs\":[{\"name\":\"nftContract\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleId\",\"type\":\"uint256\"},{\"name\":\"_participantIndices\",\"type\":\"uint256[]\"}],\"name\":\"withdrawTokensInBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"revealTime\",\"type\":\"uint256\"}],\"name\":\"recordBlockHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"revealTime\",\"type\":\"uint256\"},{\"name\":\"revealer\",\"type\":\"address\"},{\"name\":\"priceToken\",\"type\":\"address\"}],\"name\":\"getRevealerReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"_saleId\",\"type\":\"uint256\"}],\"name\":\"gift\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"getBlockHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleId\",\"type\":\"uint256\"}],\"name\":\"withdrawToSeller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleId\",\"type\":\"uint256\"},{\"name\":\"_participantIndex\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_averageBlockTimeOracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"saleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"revealTime\",\"type\":\"uint96\"},{\"indexed\":false,\"name\":\"priceToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"tokenContracts\",\"type\":\"address[]\"},{\"indexed\":true,\"name\":\"revealer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"metadataURI\",\"type\":\"string\"}],\"name\":\"MysteryBoxSaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"revealTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"BlockHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"saleId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"MysteryBoxSaleWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"saleId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pay\",\"type\":\"uint256\"}],\"name\":\"MysteryBoxSaleProceedsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"saleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participantIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"MysteryBoxBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"saleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participantIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"MysteryBoxWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"MysteryBoxSales","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000013027e80fafa82f70ee77dc2ab1dbf91246d85e5","Library":"","LicenseType":"None","SwarmSource":"bzzr://bc7b9226aa4db006842bdaba7dbdfba0a551eafa4b2e0d42a9fe64a07d65411a"}]}