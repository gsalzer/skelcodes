{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Copyright ©️ 2018-2020 Galt•Project Society Construction and Terraforming Company\r\n * (Founded by [Nikolai Popeka](https://github.com/npopeka)\r\n *\r\n * Copyright ©️ 2018-2020 Galt•Core Blockchain Company\r\n * (Founded by [Nikolai Popeka](https://github.com/npopeka) by\r\n * [Basic Agreement](ipfs/QmaCiXUmSrP16Gz8Jdzq6AJESY1EAANmmwha15uR3c1bsS)).\r\n * \r\n * 🌎 Galt Project is an international decentralized land and real estate property registry\r\n * governed by DAO (Decentralized autonomous organization) and self-governance platform for communities\r\n * of homeowners on Ethereum.\r\n * \r\n * 🏡 https://galtproject.io\r\n */\r\n\r\npragma solidity ^0.5.13;\r\n\r\nlibrary CPointUtils {\r\n\r\n  uint256 public constant XYZ_MASK =    uint256(0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff);\r\n  uint256 public constant XY_MASK =     uint256(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\r\n  uint256 public constant HEIGHT_MASK = uint256(0x000000000000000000000000ffffffff00000000000000000000000000000000);\r\n  uint256 public constant LAT_MASK =    uint256(0x00000000000000000000000000000000ffffffffffffffff0000000000000000);\r\n  uint256 public constant LON_MASK =    uint256(0x000000000000000000000000000000000000000000000000ffffffffffffffff);\r\n  uint256 public constant INT64_MASK =  uint256(0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000);\r\n  uint256 public constant INT32_MASK =  uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000);\r\n\r\n  // -2_147_483_648\r\n  int256 constant Z_MIN = int256(-2147483648);\r\n  // 2_147_483_647\r\n  int256 constant Z_MAX = int256(2147483647);\r\n\r\n  int256 constant DECIMALS = 10 ** 8;\r\n\r\n  // LAT/LON/HEIGHT\r\n\r\n  function cPointToLat(uint256 _cPoint) internal pure returns (int256) {\r\n    return int256(int64(((_cPoint & LAT_MASK) >> 64) ^ INT64_MASK)) * DECIMALS;\r\n  }\r\n\r\n  function cPointToLon(uint256 _cPoint) internal pure returns (int256) {\r\n    return int256(int64((_cPoint & LON_MASK) ^ INT64_MASK)) * DECIMALS;\r\n  }\r\n\r\n  function cPointToHeight(uint256 _cPoint) internal pure returns (int256) {\r\n    return int32(((_cPoint & HEIGHT_MASK) >> 128) ^ INT32_MASK);\r\n  }\r\n\r\n  // COMBINATIONS\r\n\r\n  function cPointToLatLonHeight(uint256 _cPoint) internal pure returns (int256 lat, int256 lon, int256 height) {\r\n    lat = cPointToLat(_cPoint);\r\n    lon = cPointToLon(_cPoint);\r\n    height = cPointToHeight(_cPoint);\r\n  }\r\n\r\n  function cPointToLatLonArr(uint256 _cPoint) internal pure returns (int256[2] memory) {\r\n    return [\r\n      cPointToLat(_cPoint),\r\n      cPointToLon(_cPoint)\r\n    ];\r\n  }\r\n\r\n  function cPointToLatLon(uint256 _cPoint) internal pure returns (int256 lat, int256 lon) {\r\n    lat = cPointToLat(_cPoint);\r\n    lon = cPointToLon(_cPoint);\r\n  }\r\n\r\n  function latLonHeightToCPoint(int256 _lat, int256 _lon, int256 _height) internal pure returns (uint256 cPoint) {\r\n    requireHeightValid(_height);\r\n\r\n    int256 lat = (_lat / DECIMALS) << 64;\r\n    int256 height = _height << 128;\r\n\r\n    return uint256(((((bytes32(_lon / DECIMALS) & bytes32(LON_MASK)) ^ bytes32(lat)) & bytes32(XY_MASK)) ^ bytes32(height)) & bytes32(XYZ_MASK));\r\n  }\r\n\r\n  function requireHeightValid(int256 _height) pure internal {\r\n    require(Z_MIN <= _height && _height <= Z_MAX, \"CPointUtils: height overflow\");\r\n  }\r\n\r\n  function isHeightValid(int256 _height) pure internal returns (bool) {\r\n    return (Z_MIN <= _height && _height <= Z_MAX);\r\n  }\r\n}\r\n\r\nlibrary MathUtils {\r\n  int256 constant public longer_fixed_log_e_1_5 = 405465108108164381978013115464349137;\r\n  int256 constant public longer_fixed_1 = 1000000000000000000000000000000000000;\r\n  int256 constant public longer_fixed_log_e_10 = 2302585092994045684017991454684364208;\r\n\r\n  int256 constant fixed_1 = 1000000000000000000;\r\n  int256 constant fixed_e = 2718281828459045400;\r\n\r\n  int256 constant ln_2 = 693147180559945300;\r\n  int256 constant ln_10 = 2302585092994046000;\r\n\r\n  uint256 constant e = 2718281828459045000;\r\n\r\n  function INT256_MIN() internal pure returns (int256) {\r\n    return int256((uint256(1) << 255));\r\n  }\r\n\r\n  function INT256_MAX() internal pure returns (int256) {\r\n    return int256(~((uint256(1) << 255)));\r\n  }\r\n\r\n  function UINT256_MIN() internal pure returns (uint256) {\r\n    return 0;\r\n  }\r\n\r\n  function UINT256_MAX() internal pure returns (uint256) {\r\n    return ~uint256(0);\r\n  }\r\n\r\n  function EPS() internal pure returns (int256) {\r\n    return 1000000000;\r\n  }\r\n\r\n  function abs(int number) internal pure returns (int) {\r\n    return number > 0 ? number : number * (- 1);\r\n  }\r\n\r\n  function between(int a, int b, int c) internal pure returns (bool) {\r\n    return (a - EPS() <= b) && (b <= c + EPS());\r\n  }\r\n\r\n  function minInt(int a, int b) internal pure returns (int) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function maxInt(int a, int b) internal pure returns (int) {\r\n    return a > b ? a : b;\r\n  }\r\n\r\n  /**\r\n  * Limitations:\r\n  * - positive values\r\n  **/\r\n  function sqrt(int x) internal pure returns (int y) {\r\n    int z = (x + 1) / 2;\r\n    y = x;\r\n    while (abs(z) < abs(y)) {\r\n      y = z;\r\n      z = (x / z + z) / 2;\r\n    }\r\n    y *= 10 ** 9;\r\n  }\r\n\r\n  function floorInt(int x) internal pure returns (int) {\r\n    return (x / 1 ether) * 1 ether;\r\n  }\r\n\r\n  function toFixedInt(int x, int precision) internal pure returns (int) {\r\n    if (precision == 18) {\r\n      return x;\r\n    }\r\n    return (x / int(10 ** uint(18 - precision))) * int(10 ** uint(18 - precision));\r\n  }\r\n\r\n  /**\r\n  * Limitations:\r\n  * - positive values\r\n  **/\r\n  function logE(int256 x) internal pure returns (int256) {\r\n    if (x > 1.999 ether) {\r\n      int256 newX = x;\r\n      int256 power = 0;\r\n      while (newX > 1.999 ether) {\r\n        newX /= 10;\r\n        power += 1;\r\n      }\r\n      return logOfAroundOne(newX) + power * ln_10;\r\n    } else {\r\n      return logOfAroundOne(x);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Limitations:\r\n  * - positive values\r\n  * - no more than 1.999(9) ether\r\n  **/\r\n  function logOfAroundOne(int256 x) internal pure returns (int256) {\r\n    int256 r = 0;\r\n    int256 v = x;\r\n    while (v <= fixed_1 / 10) {\r\n      v = v * 10;\r\n      r -= longer_fixed_log_e_10;\r\n    }\r\n    while (v >= 10 * fixed_1) {\r\n      v = v / 10;\r\n      r += longer_fixed_log_e_10;\r\n    }\r\n    while (v < fixed_1) {\r\n      v = v * fixed_e;\r\n      r -= longer_fixed_1;\r\n    }\r\n    while (v > fixed_e) {\r\n      v = v / fixed_e;\r\n      r += longer_fixed_1;\r\n    }\r\n    if (v == fixed_1) {\r\n      return round_off(r) / fixed_1;\r\n    }\r\n    if (v == fixed_e) {\r\n      return fixed_1 + round_off(r) / fixed_1;\r\n    }\r\n    v *= fixed_1;\r\n    v = v - 3 * longer_fixed_1 / 2;\r\n    r = r + longer_fixed_log_e_1_5;\r\n    int256 m = longer_fixed_1 * v / (v + 3 * longer_fixed_1);\r\n    r = r + 2 * m;\r\n    int256 m_2 = m * m / longer_fixed_1;\r\n    int256 i = 3;\r\n    while (true) {\r\n      m = m * m_2 / longer_fixed_1;\r\n      r = r + 2 * m / i;\r\n      i += 2;\r\n      if (i >= 3 + 2 * 18)\r\n        break;\r\n    }\r\n    return round_off(r) / fixed_1;\r\n  }\r\n\r\n  function logAny(int256 v, int256 base) internal pure returns (int256) {\r\n    return (logE(v) * 1 ether) / logE(base);\r\n  }\r\n\r\n  // https://solidity.readthedocs.io/en/v0.5.3/assembly.html\r\n  /**\r\n  * Limitations:\r\n  * - positive values\r\n  **/\r\n  function log2(int256 v) internal pure returns (int256) {\r\n    return (logE(v) * 1 ether) / ln_2;\r\n  }\r\n\r\n  /**\r\n  * Limitations:\r\n  * - positive values\r\n  **/\r\n  function log10(int256 v) internal pure returns (int256) {\r\n    return (logE(v) * 1 ether) / ln_10;\r\n  }\r\n\r\n  function round_off(int256 x) public pure returns (int256) {\r\n    int8 sign = 1;\r\n    int v = x;\r\n    if (v < 0) {\r\n      sign = - 1;\r\n      v = - v;\r\n    }\r\n    if (v % fixed_1 >= fixed_1 / 2)\r\n      v = v + fixed_1 - v % fixed_1;\r\n    return v * sign;\r\n  }\r\n\r\n  /**\r\n  * Limitations: positive values\r\n  **/\r\n  function exp(int x) internal pure returns (int) {\r\n    int sum = 1 ether;\r\n    sum = 1 ether + x * sum / 14 ether;\r\n    sum = 1 ether + x * sum / 13 ether;\r\n    sum = 1 ether + x * sum / 12 ether;\r\n    sum = 1 ether + x * sum / 11 ether;\r\n    sum = 1 ether + x * sum / 10 ether;\r\n    sum = 1 ether + x * sum / 9 ether;\r\n    sum = 1 ether + x * sum / 8 ether;\r\n    sum = 1 ether + x * sum / 7 ether;\r\n    sum = 1 ether + x * sum / 6 ether;\r\n    sum = 1 ether + x * sum / 5 ether;\r\n    sum = 1 ether + x * sum / 4 ether;\r\n    sum = 1 ether + x * sum / 3 ether;\r\n    sum = 1 ether + x * sum / 2 ether;\r\n    sum = 1 ether + x * sum / 1 ether;\r\n\r\n    return sum;\r\n  }\r\n}\r\n\r\nlibrary VectorUtils {\r\n  function onSegment(int[2] memory a, int[2] memory b, int[2] memory c) internal pure returns (bool) {\r\n    /* solium-disable-next-line */\r\n    return (MathUtils.minInt(a[0], b[0]) <= c[0]) && (c[0] <= MathUtils.maxInt(a[0], b[0])) &&\r\n    /* solium-disable-next-line */\r\n    (MathUtils.minInt(a[1], b[1]) <= c[1]) && (c[1] <= MathUtils.maxInt(a[1], b[1]));\r\n  }\r\n\r\n  function direction(int[2] memory a, int[2] memory b, int[2] memory c) internal pure returns (int256) {\r\n    return (c[0] - a[0]) * (b[1] - a[1]) - (b[0] - a[0]) * (c[1] - a[1]);\r\n  }\r\n}\r\n\r\nlibrary SegmentUtils {\r\n\r\n  int256 internal constant EPS = 1000000000;\r\n  int256 internal constant POS_EPS = 10000000000000000000000;\r\n\r\n  enum Position {\r\n    BEFORE,\r\n    AFTER\r\n  }\r\n\r\n  struct Sweepline {\r\n    int256 x;\r\n    Position position;\r\n  }\r\n\r\n  function segmentsIntersect(int[2][2] memory a, int[2][2] memory b) internal pure returns (bool) {\r\n    int256 d1 = VectorUtils.direction(b[0], b[1], a[0]);\r\n    int256 d2 = VectorUtils.direction(b[0], b[1], a[1]);\r\n    int256 d3 = VectorUtils.direction(a[0], a[1], b[0]);\r\n    int256 d4 = VectorUtils.direction(a[0], a[1], b[1]);\r\n\r\n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\r\n      return true;\r\n    } else if (d1 == 0 && VectorUtils.onSegment(b[0], b[1], a[0])) {\r\n      return true;\r\n    } else if (d2 == 0 && VectorUtils.onSegment(b[0], b[1], a[1])) {\r\n      return true;\r\n    } else if (d3 == 0 && VectorUtils.onSegment(a[0], a[1], b[0])) {\r\n      return true;\r\n    } else if (d4 == 0 && VectorUtils.onSegment(a[0], a[1], b[1])) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function findSegmentsIntersection(int[2][2] memory a, int[2][2] memory b) internal pure returns (int256[2] memory) {\r\n    int xDivide = ((a[0][0] - a[1][0]) * (b[0][1] - b[1][1]) - (a[0][1] - a[1][1]) * (b[0][0] - b[1][0]));\r\n    if (xDivide == 0) {\r\n      return int256[2]([int256(0), 0]);\r\n    }\r\n\r\n    int x = ((a[0][0] * a[1][1] - a[0][1] * a[1][0]) * (b[0][0] - b[1][0]) - (a[0][0] - a[1][0]) * (b[0][0] * b[1][1] - b[0][1] * b[1][0])) /\r\n    xDivide;\r\n\r\n    int yDivide = ((a[0][0] - a[1][0]) * (b[0][1] - b[1][1]) - (a[0][1] - a[1][1]) * (b[0][0] - b[1][0]));\r\n    if (yDivide == 0) {\r\n      return int256[2]([int256(0), 0]);\r\n    }\r\n\r\n    int y = ((a[0][0] * a[1][1] - a[0][1] * a[1][0]) * (b[0][1] - b[1][1]) - (a[0][1] - a[1][1]) * (b[0][0] * b[1][1] - b[0][1] * b[1][0])) /\r\n    yDivide;\r\n\r\n    if (a[0][0] >= a[1][0]) {\r\n      if (!MathUtils.between(a[1][0], x, a[0][0])) {return int256[2]([int256(0), 0]);}\r\n    } else {\r\n      if (!MathUtils.between(a[0][0], x, a[1][0])) {return int256[2]([int256(0), 0]);}\r\n    }\r\n    if (a[0][1] >= a[1][1]) {\r\n      if (!MathUtils.between(a[1][1], y, a[0][1])) {return int256[2]([int256(0), 0]);}\r\n    } else {\r\n      if (!MathUtils.between(a[0][1], y, a[1][1])) {return int256[2]([int256(0), 0]);}\r\n    }\r\n    if (b[0][0] >= b[1][0]) {\r\n      if (!MathUtils.between(b[1][0], x, b[0][0])) {return int256[2]([int256(0), 0]);}\r\n    } else {\r\n      if (!MathUtils.between(b[0][0], x, b[1][0])) {return int256[2]([int256(0), 0]);}\r\n    }\r\n    if (b[0][1] >= b[1][1]) {\r\n      if (!MathUtils.between(b[1][1], y, b[0][1])) {return int256[2]([int256(0), 0]);}\r\n    } else {\r\n      if (!MathUtils.between(b[0][1], y, b[1][1])) {return int256[2]([int256(0), 0]);}\r\n    }\r\n    return [x, y];\r\n  }\r\n\r\n  function isEqual(int[2][2] memory a, int[2][2] memory b) internal pure returns (bool) {\r\n    return b[0][0] == a[0][0] && b[0][1] != a[0][1] && b[1][0] == a[1][0] && b[1][1] != a[1][1];\r\n  }\r\n\r\n  function compareSegments(Sweepline storage sweepline, int[2][2] memory a, int[2][2] memory b) internal view returns (int8) {\r\n    if (isEqual(a, b)) {\r\n      return int8(0);\r\n    }\r\n\r\n    int deltaY = getY(a, sweepline.x) - getY(b, sweepline.x);\r\n\r\n    if (MathUtils.abs(deltaY) > EPS) {\r\n      return deltaY < 0 ? int8(- 1) : int8(1);\r\n    } else {\r\n      int aSlope = getSlope(a);\r\n      int bSlope = getSlope(b);\r\n\r\n      if (aSlope != bSlope) {\r\n        if (sweepline.position == Position.BEFORE) {\r\n          return aSlope > bSlope ? int8(- 1) : int8(1);\r\n        } else {\r\n          return aSlope > bSlope ? int8(1) : int8(- 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (a[0][0] - b[0][0] != 0) {\r\n      return a[0][0] - b[0][0] < 0 ? int8(- 1) : int8(1);\r\n    }\r\n\r\n    if (a[1][0] - b[1][0] != 0) {\r\n      return a[1][0] - b[1][0] < 0 ? int8(- 1) : int8(1);\r\n    }\r\n\r\n    return int8(0);\r\n  }\r\n\r\n  function getSlope(int[2][2] memory segment) internal pure returns (int) {\r\n    if (segment[0][0] == segment[1][0]) {\r\n      return (segment[0][1] < segment[1][1]) ? MathUtils.INT256_MAX() : MathUtils.INT256_MIN();\r\n    } else {\r\n      return (segment[1][1] - segment[0][1]) / (segment[1][0] - segment[0][0]);\r\n    }\r\n  }\r\n\r\n  function getY(int[2][2] memory segment, int x) internal pure returns (int) {\r\n    if (x <= segment[0][0]) {\r\n      return segment[0][1];\r\n    } else if (x >= segment[1][0]) {\r\n      return segment[1][1];\r\n    }\r\n\r\n    if ((x - segment[0][0]) > (segment[1][0] - x)) {\r\n      int ifac = 1 ether * (x - segment[0][0]) / (segment[1][0] - segment[0][0]);\r\n      return ((segment[0][1] * (1 ether - ifac)) / 1 ether) + ((segment[1][1] * ifac) / 1 ether);\r\n    } else {\r\n      int fac = 1 ether * (segment[1][0] - x) / (segment[1][0] - segment[0][0]);\r\n      return ((segment[0][1] * fac) / 1 ether) + ((segment[1][1] * (1 ether - fac)) / 1 ether);\r\n    }\r\n  }\r\n\r\n  function cmp(int x, int y) internal pure returns (int) {\r\n    if (x == y) {\r\n      return 0;\r\n    }\r\n    if (x < y) {\r\n      return - 1;\r\n    } else {\r\n      return 1;\r\n    }\r\n  }\r\n\r\n  function pointOnSegment(int[2] memory point, int[2] memory sp1, int[2] memory sp2) internal pure returns (bool) {\r\n    // compare versus epsilon for floating point values, or != 0 if using integers\r\n    if (MathUtils.abs((point[1] - sp1[1]) * (sp2[0] - sp1[0]) - (point[0] - sp1[0]) * (sp2[1] - sp1[1])) > POS_EPS) {\r\n      return false;\r\n    }\r\n\r\n    int dotproduct = (point[0] - sp1[0]) * (sp2[0] - sp1[0]) + (point[1] - sp1[1]) * (sp2[1] - sp1[1]);\r\n    if (dotproduct < 0) {\r\n      return false;\r\n    }\r\n\r\n    int squaredlengthba = (sp2[0] - sp1[0]) * (sp2[0] - sp1[0]) + (sp2[1] - sp1[1]) * (sp2[1] - sp1[1]);\r\n    if (dotproduct > squaredlengthba) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nlibrary PPContourVerificationLib {\r\n  enum InclusionType {\r\n    A_POINT_INSIDE_B,\r\n    B_POINT_INSIDE_A\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if two given contour segment intersect each other\r\n   * @param _excludeCollinear will return false if two segments are collinear\r\n   */\r\n  function contourSegmentsIntersects(\r\n    uint256[] memory _contourA,\r\n    uint256[] memory _contourB,\r\n    uint256 _aSegmentFirstPointIndex,\r\n    uint256 _bSegmentFirstPointIndex,\r\n    bool _excludeCollinear\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint contourAlen = _contourA.length;\r\n    uint contourBlen = _contourB.length;\r\n\r\n    uint256 _aSegmentFirstPoint = _contourA[_aSegmentFirstPointIndex];\r\n    uint256 _aSegmentSecondPoint = _aSegmentFirstPointIndex + 1 == contourAlen ? _contourA[0] : _contourA[_aSegmentFirstPointIndex + 1];\r\n\r\n    uint256 _bSegmentFirstPoint = _contourB[_bSegmentFirstPointIndex];\r\n    uint256 _bSegmentSecondPoint = _bSegmentFirstPointIndex + 1 == contourBlen ? _contourB[0] : _contourB[_bSegmentFirstPointIndex + 1];\r\n\r\n    bool isCollinear = segmentsAreCollinear(\r\n      _aSegmentFirstPoint,\r\n      _aSegmentSecondPoint,\r\n      _bSegmentSecondPoint,\r\n      _bSegmentFirstPoint\r\n    );\r\n\r\n    if (_excludeCollinear && isCollinear) {\r\n      return false;\r\n    }\r\n\r\n    return SegmentUtils.segmentsIntersect(\r\n      getLatLonSegment(\r\n        _aSegmentFirstPoint,\r\n        _aSegmentSecondPoint\r\n      ),\r\n      getLatLonSegment(\r\n        _bSegmentFirstPoint,\r\n        _bSegmentSecondPoint\r\n      )\r\n    );\r\n  }\r\n\r\n  function pointInsideContour(\r\n    uint256[] memory _contourA,\r\n    uint256[] memory _contourB,\r\n    uint256 _includingPoint\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return isInsideWithoutCache(_includingPoint, _contourA, true) && isInsideWithoutCache(_includingPoint, _contourB, true);\r\n  }\r\n\r\n  function isInsideWithoutCache(\r\n    uint256 _cPoint,\r\n    uint256[] memory _polygon,\r\n    bool _excludeCollinear\r\n  )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    (int256 x, int256 y) = CPointUtils.cPointToLatLon(_cPoint);\r\n\r\n    bool inside = false;\r\n    uint256 j = _polygon.length - 1;\r\n\r\n    for (uint256 i = 0; i < _polygon.length; i++) {\r\n      (int256 xi, int256 yi) = CPointUtils.cPointToLatLon(_polygon[i]);\r\n      (int256 xj, int256 yj) = CPointUtils.cPointToLatLon(_polygon[j]);\r\n\r\n      bool intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\r\n      if (_excludeCollinear) {\r\n        if (SegmentUtils.pointOnSegment([x, y], [xi, yi], [xj, yj])) {\r\n          return false;\r\n        }\r\n      }\r\n      if (intersect) {\r\n        inside = !inside;\r\n      }\r\n      j = i;\r\n    }\r\n\r\n    return inside;\r\n  }\r\n\r\n  function segmentsAreCollinear(\r\n    uint256 _a1,\r\n    uint256 _b1,\r\n    uint256 _a2,\r\n    uint256 _b2\r\n  )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    int256[2] memory a1 = toLatLonPoint(_a1);\r\n    int256[2] memory b1 = toLatLonPoint(_b1);\r\n    int256[2] memory a2 = toLatLonPoint(_a2);\r\n    int256[2] memory b2 = toLatLonPoint(_b2);\r\n\r\n    return SegmentUtils.pointOnSegment(a2, a1, b1) ||\r\n    SegmentUtils.pointOnSegment(b2, a1, b1) ||\r\n    SegmentUtils.pointOnSegment(a1, b1, b2) ||\r\n    SegmentUtils.pointOnSegment(a2, b1, b2) ||\r\n    SegmentUtils.pointOnSegment(b1, a1, a2) ||\r\n    SegmentUtils.pointOnSegment(b2, a1, a2);\r\n  }\r\n\r\n  function getLatLonSegment(\r\n    uint256 _aPoint,\r\n    uint256 _bPoint\r\n  )\r\n    internal\r\n    pure\r\n    returns (int256[2][2] memory)\r\n  {\r\n    return int256[2][2]([\r\n      toLatLonPoint(_aPoint),\r\n      toLatLonPoint(_bPoint)\r\n    ]);\r\n  }\r\n\r\n  function toLatLonPoint(\r\n    uint256 _cPoint\r\n  )\r\n    internal\r\n    pure\r\n    returns (int256[2] memory)\r\n  {\r\n    return CPointUtils.cPointToLatLonArr(_cPoint);\r\n  }\r\n\r\n  function checkForRoomVerticalIntersection(\r\n    uint256[] memory _validContour,\r\n    uint256[] memory _invalidContour,\r\n    int256 _vHP,\r\n    int256 _iHP\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    int256 vLP = getLowestElevation(_validContour);\r\n    int256 iLP = getLowestElevation(_invalidContour);\r\n\r\n    return checkVerticalIntersection(_vHP, vLP, _iHP, iLP);\r\n  }\r\n\r\n  function getLowestElevation(\r\n    uint256[] memory _contour\r\n  )\r\n    internal\r\n    pure\r\n    returns (int256)\r\n  {\r\n    uint256 len = _contour.length;\r\n    require(len > 2, \"Empty contour passed in\");\r\n\r\n    int256 theLowest = CPointUtils.cPointToHeight(_contour[0]);\r\n\r\n    for (uint256 i = 1; i < len; i++) {\r\n      int256 elevation = CPointUtils.cPointToHeight(_contour[i]);\r\n      if (elevation < theLowest) {\r\n        theLowest = elevation;\r\n      }\r\n    }\r\n\r\n    return theLowest;\r\n  }\r\n\r\n  function checkVerticalIntersection(int256 _aHP, int256 _aLP, int256 _bHP, int256 _bLP) internal pure returns (bool) {\r\n    if (_aHP == _bHP && _aLP == _bLP) {\r\n      return true;\r\n    }\r\n\r\n    if (_aHP < _bHP && _aHP > _bLP) {\r\n      return true;\r\n    }\r\n\r\n    if (_bHP < _aHP && _bHP > _aLP) {\r\n      return true;\r\n    }\r\n\r\n    if (_aLP < _bHP && _aLP > _bLP) {\r\n      return true;\r\n    }\r\n\r\n    if (_bLP < _aHP && _bLP > _aLP) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\ncontract PPContourVerificationPublicLib {\r\n  function contourSegmentsIntersects(\r\n    uint256[] memory _contourA,\r\n    uint256[] memory _contourB,\r\n    uint256 _aSegmentFirstPointIndex,\r\n    uint256 _bSegmentFirstPointIndex,\r\n    bool _excludeCollinear\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return PPContourVerificationLib.contourSegmentsIntersects(\r\n      _contourA,\r\n      _contourB,\r\n      _aSegmentFirstPointIndex,\r\n      _bSegmentFirstPointIndex,\r\n      _excludeCollinear\r\n    );\r\n  }\r\n\r\n  function checkForRoomVerticalIntersection(\r\n    uint256[] memory _validContour,\r\n    uint256[] memory _invalidContour,\r\n    int256 _vHP,\r\n    int256 _iHP\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return PPContourVerificationLib.checkForRoomVerticalIntersection(\r\n      _validContour,\r\n      _invalidContour,\r\n      _vHP,\r\n      _iHP\r\n    );\r\n  }\r\n\r\n  function pointInsideContour(\r\n    uint256[] memory _contourA,\r\n    uint256[] memory _contourB,\r\n    uint256 _includingPoint\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return PPContourVerificationLib.pointInsideContour(_contourA, _contourB, _includingPoint);\r\n  }\r\n\r\n  function segmentsAreCollinear(\r\n    uint256 _a1g,\r\n    uint256 _b1g,\r\n    uint256 _a2g,\r\n    uint256 _b2g\r\n  )\r\n    public\r\n    view\r\n    returns(bool)\r\n  {\r\n    return PPContourVerificationLib.segmentsAreCollinear(\r\n      _a1g,\r\n      _b1g,\r\n      _a2g,\r\n      _b2g\r\n    );\r\n  }\r\n\r\n  function getLowestElevation(uint256[] memory _contour) public pure returns (int256) {\r\n    return PPContourVerificationLib.getLowestElevation(_contour);\r\n  }\r\n\r\n  function checkVerticalIntersection(int256 _aHP, int256 _aLP, int256 _bHP, int256 _bLP) public pure returns (bool) {\r\n    return PPContourVerificationLib.checkVerticalIntersection(_aHP, _aLP, _bHP, _bLP);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_validContour\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_invalidContour\",\"type\":\"uint256[]\"},{\"internalType\":\"int256\",\"name\":\"_vHP\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_iHP\",\"type\":\"int256\"}],\"name\":\"checkForRoomVerticalIntersection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_aHP\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_aLP\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_bHP\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_bLP\",\"type\":\"int256\"}],\"name\":\"checkVerticalIntersection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_contourA\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_contourB\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_aSegmentFirstPointIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bSegmentFirstPointIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_excludeCollinear\",\"type\":\"bool\"}],\"name\":\"contourSegmentsIntersects\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_contour\",\"type\":\"uint256[]\"}],\"name\":\"getLowestElevation\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_contourA\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_contourB\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_includingPoint\",\"type\":\"uint256\"}],\"name\":\"pointInsideContour\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_a1g\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_b1g\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_a2g\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_b2g\",\"type\":\"uint256\"}],\"name\":\"segmentsAreCollinear\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PPContourVerificationPublicLib","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://7cd397b717abb9ec2cbdca50a489a66ba568ec79d6577b269506fd6a78c929d3"}]}