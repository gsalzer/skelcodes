{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Util {\r\n    struct User {\r\n        bool isExist;\r\n        uint256 id;\r\n        uint256 origRefID;\r\n        uint256 referrerID;\r\n        uint256 balance;\r\n        uint256 lastActivity;\r\n        address payable wallet;\r\n        address[] referral;\r\n        uint256[] expiring;\r\n\r\n    }\r\n\r\n}\r\n\r\ncontract IOCrypto {\r\n    using SafeMath for uint256;\r\n    /////////////////////\r\n    // Events\r\n    /////////////////////\r\n    event registered(address indexed user, address indexed referrer, uint indexed userId, uint refId);\r\n    event levelBought(address indexed user, uint256 level);\r\n    event receivedEther(address indexed user, address indexed referral, uint256 level);\r\n    event lostEther(address indexed user, address indexed referral, uint256 level);\r\n\r\n    /////////////////////\r\n    // Storage variables\r\n    /////////////////////\r\n    address payable public wallet;\r\n    address payable public reserveWallet;\r\n\r\n    uint256 constant MAX_REFERRERS = 2;\r\n    uint256 LEVEL_PERIOD = 36500 days;\r\n\r\n    /////////////////////\r\n    // User structure and mappings\r\n    /////////////////////\r\n\r\n    mapping(address => Util.User) public users;\r\n    mapping(uint256 => address) public userList;\r\n    uint256 public userIDCounter = 0;\r\n\r\n\r\n    /////////////////////\r\n    // Code\r\n    /////////////////////\r\n    constructor() public {\r\n        wallet = 0x52b8Fca60C96b2285E7476Ab541B3d7731aE5210;\r\n        reserveWallet = 0x3609D284e92Cc543ab0F4d9cB7645aA5B676fedC;\r\n\r\n        Util.User memory user;\r\n        userIDCounter++;\r\n\r\n        user = Util.User({\r\n            isExist : true,\r\n            id : userIDCounter,\r\n            origRefID: 0,\r\n            referrerID : 0,\r\n            balance: 0,\r\n            lastActivity: now,\r\n            wallet : 0xafbC755494A47eb0c5200ac94BCdd162fD031937,\r\n            referral : new address[](0),\r\n            expiring : new uint256[](9)\r\n            });\r\n\r\n        user.expiring[1] = 101010101010;\r\n        user.expiring[2] = 101010101010;\r\n        user.expiring[3] = 101010101010;\r\n        user.expiring[4] = 101010101010;\r\n        user.expiring[5] = 101010101010;\r\n        user.expiring[6] = 101010101010;\r\n        user.expiring[7] = 101010101010;\r\n        user.expiring[8] = 101010101010;\r\n\r\n        userList[userIDCounter] = wallet;\r\n        users[wallet] = user;\r\n    }\r\n\r\n\r\n    function() external payable {\r\n        require(users[msg.sender].isExist, '00 user not exist');\r\n        if (msg.value > 0) {\r\n            users[msg.sender].balance = users[msg.sender].balance.add(msg.value);\r\n            emit receivedEther(msg.sender, msg.sender, 0);\r\n        }\r\n    }\r\n\r\n\r\n    function register(address payable _wallet, uint256 referrerID) public payable {\r\n        require(_wallet != address(0), '01 zero wallet');\r\n        require(!users[msg.sender].isExist, '02 user exist');\r\n        require(referrerID > 0 && referrerID <= userIDCounter, '03 wrong referrer ID');\r\n        require(getLevel(msg.value) == 1, '04 wrong value');\r\n\r\n\r\n        uint origRefID = referrerID;\r\n        if (users[userList[referrerID]].referral.length >= MAX_REFERRERS)\r\n        {\r\n            referrerID = users[findReferrer(userList[referrerID])].id;\r\n        }\r\n\r\n        Util.User memory user;\r\n        userIDCounter++;\r\n\r\n        user = Util.User({\r\n            isExist : true,\r\n            id : userIDCounter,\r\n            origRefID : origRefID,\r\n            referrerID : referrerID,\r\n            balance : msg.value,\r\n            lastActivity : now,\r\n            wallet : _wallet,\r\n            referral : new address[](0),\r\n            expiring : new uint256[](9)\r\n            });\r\n\r\n        user.expiring[1] = now + LEVEL_PERIOD;\r\n        user.expiring[2] = 0;\r\n        user.expiring[3] = 0;\r\n        user.expiring[4] = 0;\r\n        user.expiring[5] = 0;\r\n        user.expiring[6] = 0;\r\n        user.expiring[7] = 0;\r\n        user.expiring[8] = 0;\r\n\r\n        userList[userIDCounter] = msg.sender;\r\n        users[msg.sender] = user;\r\n\r\n        users[userList[referrerID]].referral.push(msg.sender);\r\n\r\n        payForLevel(msg.sender, 1, msg.value, true);\r\n\r\n        emit registered(msg.sender, userList[referrerID], userIDCounter, referrerID);\r\n    }\r\n\r\n    function buy(uint256 level) public {\r\n        require(users[msg.sender].isExist, '06 user not exist');\r\n        require(level > 0 && level <= 8, '07 wrong level');\r\n        require(users[msg.sender].balance >= getPrice(level), '08 wrong value');\r\n\r\n        for (uint256 l = level - 1; l > 0; l--) {\r\n            require(users[msg.sender].expiring[l] >= now, '09 buy level');\r\n        }\r\n\r\n        if (users[msg.sender].expiring[level] == 0) {\r\n            users[msg.sender].expiring[level] = now + LEVEL_PERIOD;\r\n        } else {\r\n            users[msg.sender].expiring[level] += LEVEL_PERIOD;\r\n        }\r\n\r\n        users[msg.sender].lastActivity = now;\r\n\r\n        payForLevel(msg.sender, level, getPrice(level), true);\r\n        emit levelBought(msg.sender, level);\r\n    }\r\n\r\n    function payForLevel(address user, uint256 level, uint256 price, bool _checkCanBuy) internal {\r\n        address referrer;\r\n        uint256 above = level > 4 ? level - 4 : level;\r\n\r\n        if (1 < level && level < 4 && _checkCanBuy) {\r\n            checkCanBuy(user, level);\r\n        }\r\n\r\n        if (above == 1) {\r\n            referrer = userList[users[user].referrerID];\r\n        } else if (above == 2) {\r\n            referrer = userList[users[user].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n        } else if (above == 3) {\r\n            referrer = userList[users[user].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n        } else if (above == 4) {\r\n            referrer = userList[users[user].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n        }\r\n\r\n\r\n        if (!users[referrer].isExist) {\r\n            referrer = userList[1];\r\n        }\r\n\r\n\r\n        if (users[referrer].expiring[level] >= now) {\r\n            require(users[msg.sender].balance >= price, '10 not enough balance');\r\n            users[msg.sender].balance = users[msg.sender].balance.sub(price);\r\n            uint ownerPercent = price.mul(1).div(100);\r\n            users[wallet].balance = users[wallet].balance.add(ownerPercent);\r\n            users[referrer].balance = users[referrer].balance.add(price.sub(ownerPercent));\r\n            emit receivedEther(referrer, msg.sender, level);\r\n        } else {\r\n            emit lostEther(referrer, msg.sender, level);\r\n            payForLevel(referrer, level, price, false);\r\n        }\r\n    }\r\n\r\n    function checkCanBuy(address user, uint256 level) private view {\r\n        if (level == 1) return;\r\n        address[] memory referral = users[user].referral;\r\n        require(referral.length == MAX_REFERRERS, '11 not enough referrals');\r\n\r\n        if (level == 2) return;\r\n        checkCanBuy(referral[0], level - 1);\r\n        checkCanBuy(referral[1], level - 1);\r\n    }\r\n\r\n\r\n    function findReferrer(address user) public view returns (address) {\r\n        address[] memory referral = users[user].referral;\r\n        if (referral.length < MAX_REFERRERS) {\r\n            return user;\r\n        }\r\n\r\n        address[] memory referrals = new address[](1024);\r\n        referrals[0] = referral[0];\r\n        referrals[1] = referral[1];\r\n\r\n        address freeReferrer;\r\n        bool hasFreeReferrer = false;\r\n\r\n        for (uint256 i = 0; i < 1024; i++) {\r\n            referral = users[referrals[i]].referral;\r\n            if (referral.length == MAX_REFERRERS) {\r\n                if (i < 512) {\r\n                    uint256 pos = (i + 1) * 2;\r\n                    referrals[pos] = referral[0];\r\n                    referrals[pos + 1] = referral[1];\r\n                }\r\n            } else {\r\n                hasFreeReferrer = true;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n        require(hasFreeReferrer, '12 no free referrer');\r\n        return freeReferrer;\r\n    }\r\n\r\n\r\n    function withdraw(uint _val) public {\r\n        require(users[msg.sender].isExist, '13 user not exist');\r\n        require(users[msg.sender].balance >= _val, '14 not enough balance');\r\n        users[msg.sender].balance = users[msg.sender].balance.sub(_val);\r\n        users[msg.sender].wallet.transfer(_val);\r\n        users[msg.sender].lastActivity = now;\r\n    }\r\n\r\n\r\n    function claim(address _user) public {\r\n        require(msg.sender == reserveWallet);\r\n        require(users[_user].lastActivity + 730 days < now);\r\n        reserveWallet.transfer(users[_user].balance);\r\n        users[_user].balance = 0;\r\n    }\r\n\r\n\r\n    function getLevel(uint256 price) public pure returns (uint8) {\r\n        if (price == 0.1 ether) {\r\n            return 1;\r\n        } else if (price == 0.15 ether) {\r\n            return 2;\r\n        } else if (price == 0.35 ether) {\r\n            return 3;\r\n        } else if (price == 2 ether) {\r\n            return 4;\r\n        } else if (price == 5 ether) {\r\n            return 5;\r\n        } else if (price == 9 ether) {\r\n            return 6;\r\n        } else if (price == 35 ether) {\r\n            return 7;\r\n        } else if (price == 100 ether) {\r\n            return 8;\r\n        } else {\r\n            revert('15 wrong value');\r\n        }\r\n    }\r\n\r\n    function getPrice(uint256 level) public pure returns (uint) {\r\n        if (level == 1) {\r\n            return 0.1 ether;\r\n        } else if (level == 2) {\r\n            return 0.15 ether;\r\n        } else if (level == 3) {\r\n            return 0.35 ether;\r\n        } else if (level == 4) {\r\n            return 2 ether;\r\n        } else if (level == 5) {\r\n            return 5 ether;\r\n        } else if (level == 6) {\r\n            return 9 ether;\r\n        } else if (level == 7) {\r\n            return 35 ether;\r\n        } else if (level == 8) {\r\n            return 100 ether;\r\n        } else {\r\n            revert('16 wrong value');\r\n        }\r\n    }\r\n\r\n    function viewReferral(address user) public view returns (address[] memory) {\r\n        return users[user].referral;\r\n    }\r\n\r\n    function viewLevelExpired(address user, uint256 level) public view returns (uint256) {\r\n        return users[user].expiring[level];\r\n    }\r\n\r\n    function getBalance(address _user) public view returns (uint) {\r\n        return users[_user].balance;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"viewLevelExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"referrerID\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"isExist\",\"type\":\"bool\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"origRefID\",\"type\":\"uint256\"},{\"name\":\"referrerID\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"lastActivity\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userIDCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"findReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"viewReferral\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refId\",\"type\":\"uint256\"}],\"name\":\"registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"levelBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"receivedEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"lostEther\",\"type\":\"event\"}]","ContractName":"IOCrypto","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://dbf0150d3b15a1dafee93ef9d52dd9d9b61d98f03b3db4faeeb5e3898b1862a1"}]}