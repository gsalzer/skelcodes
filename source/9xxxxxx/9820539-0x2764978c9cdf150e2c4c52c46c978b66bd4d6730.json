{"status":"1","message":"OK","result":[{"SourceCode":"{\"auth.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity \\u003e=0.4.23;\\n\\ncontract DSAuthority {\\n    function canCall(\\n        address src, address dst, bytes4 sig\\n    ) public view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority (address indexed authority);\\n    event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority  public  authority;\\n    address      public  owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_)\\n        public\\n        auth\\n    {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_)\\n        public\\n        auth\\n    {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"ds-auth-unauthorized\\\");\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(0)) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\"},\"TokenAuthority.sol\":{\"content\":\"/*\\n  This file is part of The Colony Network.\\n\\n  The Colony Network is free software: you can redistribute it and/or modify\\n  it under the terms of the GNU General Public License as published by\\n  the Free Software Foundation, either version 3 of the License, or\\n  (at your option) any later version.\\n\\n  The Colony Network is distributed in the hope that it will be useful,\\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n  GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n  along with The Colony Network. If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n*/\\n\\npragma solidity 0.5.8;\\n\\nimport \\\"auth.sol\\\";\\n\\n\\ncontract TokenAuthority is DSAuthority {\\n  address public token;\\n  mapping(address =\\u003e mapping(bytes4 =\\u003e bool)) authorizations;\\n\\n  bytes4 constant BURN_FUNC_SIG = bytes4(keccak256(\\\"burn(uint256)\\\"));\\n  bytes4 constant BURN_OVERLOAD_FUNC_SIG = bytes4(keccak256(\\\"burn(address,uint256)\\\"));\\n\\n  constructor(address _token, address _colony, address[] memory allowedToTransfer) public {\\n    token = _token;\\n    bytes4 transferSig = bytes4(keccak256(\\\"transfer(address,uint256)\\\"));\\n    bytes4 transferFromSig = bytes4(keccak256(\\\"transferFrom(address,address,uint256)\\\"));\\n    bytes4 mintSig = bytes4(keccak256(\\\"mint(uint256)\\\"));\\n    bytes4 mintSigOverload = bytes4(keccak256(\\\"mint(address,uint256)\\\"));\\n\\n    authorizations[_colony][transferSig] = true;\\n    authorizations[_colony][mintSig] = true;\\n    authorizations[_colony][mintSigOverload] = true;\\n\\n    for (uint i = 0; i \\u003c allowedToTransfer.length; i++) {\\n      authorizations[allowedToTransfer[i]][transferSig] = true;\\n      authorizations[allowedToTransfer[i]][transferFromSig] = true;\\n    }\\n  }\\n\\n  function canCall(address src, address dst, bytes4 sig) public view returns (bool) {\\n    if (sig == BURN_FUNC_SIG || sig == BURN_OVERLOAD_FUNC_SIG) {\\n      // We allow anyone to burn their own tokens even when the token is still locked\\n      return true;\\n    }\\n\\n    if (dst != token) {\\n      return false;\\n    }\\n\\n    return authorizations[src][sig];\\n  }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"sig\",\"type\":\"bytes4\"}],\"name\":\"canCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_colony\",\"type\":\"address\"},{\"name\":\"allowedToTransfer\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"TokenAuthority","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a4a552638dda08e8b8647a7bc360a374c141b14000000000000000000000000049a364bce33b2b7ef3c1b0559f6269ddd4d8159b0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000064fa249e2385487157ce693adb36a108ee6e0660","Library":"","LicenseType":"None","SwarmSource":"bzzr://740a524cf74a600d9afff2be906a998399eb725cf27266677800ac3553dba666"}]}