{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\n\n\ncontract DSMath {\n    \n    \n\n    function add(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x * y) >= x);\n    }\n    \n    function div(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        require(y > 0);\n        z = x / y;\n    }\n    \n    function min(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n    function max(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    \n\n\n    function hadd(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert(y > 0);\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n    function hmax(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n\n    \n\n    function imin(int256 x, int256 y) pure internal returns (int256 z) {\n        return x <= y ? x : y;\n    }\n    function imax(int256 x, int256 y) pure internal returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    \n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function wmax(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    \n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) view internal returns (uint128 z) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function rmax(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    function cast(uint256 x) pure internal returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n\n}\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract WETH is ERC20 {\n    function deposit() public payable;\n    function withdraw(uint wad) public;\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n}\n\ninterface UniswapExchangeInterface {\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n}\n\ninterface OracleInterface {\n  function bill() external view returns (uint256);\n  function update(uint128 payment_, address token_) external;\n}\n\ncontract MedianizerInterface {\n    function oracles(uint256) public view returns (address);\n    function peek() public view returns (bytes32, bool);\n    function read() public returns (bytes32);\n    function poke() public;\n    function poke(bytes32) public;\n    function fund (uint256 amount, ERC20 token) public;\n}\n\ncontract FundOracles is DSMath {\n  ERC20 link;\n  WETH weth;\n  UniswapExchangeInterface uniswapExchange;\n\n  MedianizerInterface med;\n\n  constructor(MedianizerInterface med_, ERC20 link_, WETH weth_, UniswapExchangeInterface uniswapExchange_) public {\n    med = med_;\n    link = link_;\n    weth = weth_;\n    uniswapExchange = uniswapExchange_;\n  }\n  \n  function billWithEth(uint256 oracle_) public view returns (uint256) {\n      return OracleInterface(med.oracles(oracle_)).bill();\n  }\n  \n  function paymentWithEth(uint256 oracle_, uint128 payment_) public view returns(uint256) {\n      if (oracle_ < 5) {\n          return uniswapExchange.getEthToTokenOutputPrice(payment_);\n      } else {\n          return uint(payment_);\n      }\n  }\n\n  function updateWithEth(uint256 oracle_, uint128 payment_, address token_) public payable {\n    address oracleAddress = med.oracles(oracle_);\n    OracleInterface oracle = OracleInterface(oracleAddress);\n    if (oracle_ < 5) {\n      \n      uint256 ethAmt = msg.value;\n      link.approve(address(uniswapExchange), uint(payment_));\n      uint256 ethSold = uniswapExchange.ethToTokenSwapOutput.value(msg.value)(uint(payment_), now + 300);\n      link.approve(oracleAddress, uint(payment_));\n      oracle.update(payment_, token_);\n    } else {\n      \n      weth.deposit.value(msg.value)();\n      weth.approve(oracleAddress, uint(payment_));\n      oracle.update(payment_, token_);\n    }\n  }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"oracle_\",\"type\":\"uint256\"},{\"name\":\"payment_\",\"type\":\"uint128\"},{\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"updateWithEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracle_\",\"type\":\"uint256\"}],\"name\":\"billWithEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracle_\",\"type\":\"uint256\"},{\"name\":\"payment_\",\"type\":\"uint128\"}],\"name\":\"paymentWithEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"med_\",\"type\":\"address\"},{\"name\":\"link_\",\"type\":\"address\"},{\"name\":\"weth_\",\"type\":\"address\"},{\"name\":\"uniswapExchange_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"FundOracles","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000010d2f250a30dc78f3b418730e6aae4c1cf695889000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000f173214c720f58e03e194085b1db28b50acdeead","Library":"","LicenseType":"","SwarmSource":"bzzr://200c6b2b46fe248dbe74a2d645f8012f7b5eaa4e709da1c8b00234629a5cc799"}]}