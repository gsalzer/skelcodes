{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n/// @title ZUXBUX\r\n/// @author acityinohio\r\ncontract ZUXBUX {\r\n    address public owner;\r\n    uint public total;\r\n    mapping (address => uint) public invested;\r\n    mapping (address => uint) public balances;\r\n    address[] investors;\r\n\r\n    //log event of successful investment/withdraw and address\r\n    event LogInvestment(address investor, uint amount);\r\n    event LogWithdrawal(address investor, uint amount);\r\n\r\n    //modifiers for various things\r\n    modifier checkZeroBalance() { if (balances[msg.sender] == 0) { throw; } _;}\r\n    modifier accreditedInvestor() { if (msg.value < 1 finney) { throw; } _;}\r\n\r\n\t//constructor for initializing PonzIC.. ahem I mean ZUXBUX.\r\n    //the owner is the genius who made this revolutionary smart contract\r\n\tfunction ZUXBUX() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n    //the logic for a small fee for the creator of this contract\r\n    //miniscule in the grand scheme of things\r\n    function ownerFee(uint amount) private returns (uint fee) {\r\n        if (total < 200000 ether) {\r\n            fee = amount/2;\r\n            balances[owner] += fee;\r\n        }\r\n        return;\r\n    }\r\n\r\n    //This is where the magic is withdrawn.\r\n    //For users with balances. Can only be used to withdraw full balance.\r\n    function withdraw()\r\n    checkZeroBalance()\r\n    {\r\n        uint amount = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        if (!msg.sender.send(amount)) {\r\n            balances[msg.sender] = amount;\r\n        } else {\r\n            LogWithdrawal(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    //What's better than withdrawing? Re-investing profits!\r\n    function reinvest()\r\n    checkZeroBalance()\r\n    {\r\n        uint dividend = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        uint fee = ownerFee(dividend);\r\n        dividend -= fee;\r\n        for (uint i = 0; i < investors.length; i++) {\r\n            balances[investors[i]] += dividend * invested[investors[i]] / total;\r\n        }\r\n        invested[msg.sender] += (dividend + fee);\r\n        total += (dividend + fee);\r\n        LogInvestment(msg.sender, dividend+fee);\r\n    }\r\n\r\n\t//This is the where the magic is invested.\r\n    //Note the accreditedInvestor() modifier, to ensure only sophisticated\r\n    //investors with 0.1 ETH or more can invest. #SelfRegulation\r\n\tfunction invest() payable\r\n    accreditedInvestor()\r\n    {\r\n        //first send the owner's modest 50% fee but only if the total invested is less than 200000 ETH\r\n        uint dividend = msg.value;\r\n        uint fee = ownerFee(dividend);\r\n        dividend -= fee;\r\n        //then accrue balances from the generous remainder to everyone else previously invested\r\n        for (uint i = 0; i < investors.length; i++) {\r\n            balances[investors[i]] += dividend * invested[investors[i]] / total;\r\n        }\r\n\r\n        //finally, add this enterprising new investor to the public balances\r\n        if (invested[msg.sender] == 0) {\r\n            investors.push(msg.sender);\r\n            invested[msg.sender] = msg.value;\r\n        } else {\r\n            invested[msg.sender] += msg.value;\r\n        }\r\n        total += msg.value;\r\n        LogInvestment(msg.sender, msg.value);\r\n\t}\r\n\r\n    //finally, fallback function. no one should send money to this contract\r\n    //without first being added as an investment.\r\n    function () { throw; }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawal\",\"type\":\"event\"}]","ContractName":"ZUXBUX","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://e2c2d1a2fec17b8fe7ce8dac25001b37314a85740eb54d7b117d7a9b6bc81a56"}]}