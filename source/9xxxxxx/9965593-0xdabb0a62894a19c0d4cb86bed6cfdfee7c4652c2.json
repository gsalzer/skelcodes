{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\ncontract CToken {\r\n    address public underlying;\r\n    function transfer(address dst, uint256 amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, CToken cTokenCollateral) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external view returns (uint);\r\n    function totalSupply() external view returns(uint);\r\n    function balanceOfUnderlying(address account) external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n}\r\ncontract ITokensTypeStorage {\r\n  mapping(address => bool) public isRegistred;\r\n\r\n  mapping(address => bytes32) public getType;\r\n\r\n  mapping(address => bool) public isPermittedAddress;\r\n\r\n  address public owner;\r\n\r\n  function addNewTokenType(address _token, string _type) public;\r\n\r\n  function setTokenTypeAsOwner(address _token, string _type) public;\r\n}\r\n\r\n\r\ncontract PoolPortalInterface {\r\n  function buyPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  external\r\n  payable;\r\n\r\n  function sellPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  external\r\n  payable;\r\n\r\n  function getBacorConverterAddressByRelay(address relay)\r\n  public\r\n  view\r\n  returns(address converter);\r\n\r\n  function getBancorConnectorsAmountByRelayAmount\r\n  (\r\n    uint256 _amount,\r\n    ERC20 _relay\r\n  )\r\n  public view returns(uint256 bancorAmount, uint256 connectorAmount);\r\n\r\n  function getBancorConnectorsByRelay(address relay)\r\n  public\r\n  view\r\n  returns(\r\n    ERC20 BNTConnector,\r\n    ERC20 ERCConnector\r\n  );\r\n\r\n  function getBancorRatio(address _from, address _to, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256);\r\n\r\n  function getUniswapConnectorsAmountByPoolAmount(\r\n    uint256 _amount,\r\n    address _exchange\r\n  )\r\n  public\r\n  view\r\n  returns(uint256 ethAmount, uint256 ercAmount);\r\n\r\n  function getUniswapTokenAmountByETH(address _token, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256);\r\n\r\n  function getTokenByUniswapExchange(address _exchange)\r\n  public\r\n  view\r\n  returns(address);\r\n}\r\ncontract PermittedStablesInterface {\r\n  mapping (address => bool) public permittedAddresses;\r\n}\r\n\r\n\r\ncontract ExchangePortalInterface {\r\n\r\n  event Trade(address src, uint256 srcAmount, address dest, uint256 destReceived);\r\n\r\n  function trade(\r\n    ERC20 _source,\r\n    uint256 _sourceAmount,\r\n    ERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] _additionalArgs,\r\n    bytes _additionalData\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256);\r\n\r\n  function compoundRedeemByPercent(uint _percent, address _cToken) external returns(uint256);\r\n\r\n  function compoundMint(uint256 _amount, address _cToken) external payable returns(uint256);\r\n\r\n  function getPercentFromCTokenBalance(uint _percent, address _cToken, address _holder)\r\n   public\r\n   view\r\n   returns(uint256);\r\n\r\n  function getValue(address _from, address _to, uint256 _amount) public view returns (uint256);\r\n\r\n  function getTotalValue(address[] _fromAddresses, uint256[] _amounts, address _to)\r\n   public\r\n   view\r\n   returns (uint256);\r\n\r\n   function getCTokenUnderlying(address _cToken) public view returns(address);\r\n}\r\n\r\n\r\n\r\ncontract CEther{\r\n    function transfer(address dst, uint256 amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function mint() external payable;\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow() external payable;\r\n    function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable;\r\n    function exchangeRateCurrent() external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOfUnderlying(address account) external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract IOneSplitAudit {\r\n  function swap(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 amount,\r\n        uint256 minReturn,\r\n        uint256[] memory distribution,\r\n        uint256 disableFlags\r\n    ) public payable;\r\n\r\n  function getExpectedReturn(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 amount,\r\n        uint256 parts,\r\n        uint256 featureFlags // See contants in IOneSplit.sol\r\n    )\r\n      public\r\n      view\r\n      returns(\r\n          uint256 returnAmount,\r\n          uint256[] memory distribution\r\n      );\r\n}\r\n\r\n\r\ncontract PathFinderInterface {\r\n function generatePath(address _sourceToken, address _targetToken) public view returns (address[] memory);\r\n}\r\n\r\n\r\n\r\n/*\r\n    Bancor Network interface\r\n*/\r\ncontract BancorNetworkInterface {\r\n   function getReturnByPath(ERC20[] _path, uint256 _amount) public view returns (uint256, uint256);\r\n\r\n    function convert(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvert(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public returns (uint256);\r\n\r\n    function convertFor(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvertFor(\r\n        ERC20[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public returns (uint256);\r\n\r\n}\r\n\r\n\r\ncontract IGetBancorAddressFromRegistry{\r\n  function getBancorContractAddresByName(string _name) public view returns (address result);\r\n}\r\n\r\n\r\ncontract IParaswapParams{\r\n  function getParaswapParamsFromBytes32Array(bytes32[] memory _additionalArgs)\r\n  public pure returns\r\n  (\r\n    uint256 minDestinationAmount,\r\n    address[] memory callees,\r\n    uint256[] memory startIndexes,\r\n    uint256[] memory values,\r\n    uint256 mintPrice\r\n  );\r\n}\r\n\r\n\r\ncontract IPriceFeed{\r\n  function getBestPriceSimple(address _from, address _to, uint256 _amount) public view returns (uint256 result);\r\n}\r\n\r\n\r\ncontract ParaswapInterface{\r\n  function swap(\r\n     address sourceToken,\r\n     address destinationToken,\r\n     uint256 sourceAmount,\r\n     uint256 minDestinationAmount,\r\n     address[] memory callees,\r\n     bytes memory exchangeData,\r\n     uint256[] memory startIndexes,\r\n     uint256[] memory values,\r\n     string memory referrer,\r\n     uint256 mintPrice\r\n   )\r\n   public\r\n   payable;\r\n\r\n   function getTokenTransferProxy() external view returns (address);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/*\r\n* This contract do swap for ERC20 via Paraswap, 1inch, and (between synth assest),\r\n  Also Borrow and Reedem via Compound\r\n\r\n  Also this contract allow get ratio between crypto curency assets\r\n  Also get ratio for Bancor and Uniswap pools, Syntetix and Compound assets\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangePortal is ExchangePortalInterface, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  uint public version = 2;\r\n\r\n  // Contract for handle tokens types\r\n  ITokensTypeStorage public tokensTypes;\r\n\r\n  // COMPOUND\r\n  CEther public cEther;\r\n\r\n  // PARASWAP\r\n  address public paraswap;\r\n  ParaswapInterface public paraswapInterface;\r\n  IPriceFeed public priceFeedInterface;\r\n  IParaswapParams public paraswapParams;\r\n  address public paraswapSpender;\r\n\r\n  // 1INCH\r\n  IOneSplitAudit public oneInch;\r\n\r\n  // BANCOR\r\n  address public BancorEtherToken;\r\n  IGetBancorAddressFromRegistry public bancorRegistry;\r\n\r\n  // CoTrader additional\r\n  PoolPortalInterface public poolPortal;\r\n  PermittedStablesInterface public permitedStable;\r\n\r\n  // Enum\r\n  // NOTE: You can add a new type at the end, but do not change this order\r\n  enum ExchangeType { Paraswap, Bancor, OneInch }\r\n\r\n  // This contract recognizes ETH by this address\r\n  ERC20 constant private ETH_TOKEN_ADDRESS = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n  // Trade event\r\n  event Trade(\r\n     address trader,\r\n     address src,\r\n     uint256 srcAmount,\r\n     address dest,\r\n     uint256 destReceived,\r\n     uint8 exchangeType\r\n  );\r\n\r\n  // black list for non trade able tokens\r\n  mapping (address => bool) disabledTokens;\r\n\r\n  // Modifier to check that trading this token is not disabled\r\n  modifier tokenEnabled(ERC20 _token) {\r\n    require(!disabledTokens[address(_token)]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev contructor\r\n  *\r\n  * @param _paraswap               paraswap main address\r\n  * @param _paraswapPrice          paraswap price feed address\r\n  * @param _paraswapParams         helper contract for convert params from bytes32\r\n  * @param _bancorRegistryWrapper  address of Bancor Registry Wrapper\r\n  * @param _BancorEtherToken       address of Bancor ETH wrapper\r\n  * @param _permitedStable         address of permitedStable contract\r\n  * @param _poolPortal             address of pool portal\r\n  * @param _oneInch                address of 1inch OneSplitAudit contract\r\n  * @param _cEther                 address of the COMPOUND cEther\r\n  * @param _tokensTypes            address of the ITokensTypeStorage\r\n  */\r\n  constructor(\r\n    address _paraswap,\r\n    address _paraswapPrice,\r\n    address _paraswapParams,\r\n    address _bancorRegistryWrapper,\r\n    address _BancorEtherToken,\r\n    address _permitedStable,\r\n    address _poolPortal,\r\n    address _oneInch,\r\n    address _cEther,\r\n    address _tokensTypes\r\n    )\r\n    public\r\n  {\r\n    paraswap = _paraswap;\r\n    paraswapInterface = ParaswapInterface(_paraswap);\r\n    priceFeedInterface = IPriceFeed(_paraswapPrice);\r\n    paraswapParams = IParaswapParams(_paraswapParams);\r\n    paraswapSpender = paraswapInterface.getTokenTransferProxy();\r\n    bancorRegistry = IGetBancorAddressFromRegistry(_bancorRegistryWrapper);\r\n    BancorEtherToken = _BancorEtherToken;\r\n    permitedStable = PermittedStablesInterface(_permitedStable);\r\n    poolPortal = PoolPortalInterface(_poolPortal);\r\n    oneInch = IOneSplitAudit(_oneInch);\r\n    cEther = CEther(_cEther);\r\n    tokensTypes = ITokensTypeStorage(_tokensTypes);\r\n  }\r\n\r\n\r\n  // EXCHANGE Functions\r\n\r\n  /**\r\n  * @dev Facilitates a trade for a SmartFund\r\n  *\r\n  * @param _source            ERC20 token to convert from\r\n  * @param _sourceAmount      Amount to convert from (in _source token)\r\n  * @param _destination       ERC20 token to convert to\r\n  * @param _type              The type of exchange to trade with (For now 0 - because only paraswap)\r\n  * @param _additionalArgs    Array of bytes32 additional arguments (For fixed size items and for different types items in array )\r\n  * @param _additionalData    For any size data (if not used set just 0x0)\r\n  *\r\n  * @return The amount of _destination received from the trade\r\n  */\r\n  function trade(\r\n    ERC20 _source,\r\n    uint256 _sourceAmount,\r\n    ERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] _additionalArgs,\r\n    bytes _additionalData\r\n  )\r\n    external\r\n    payable\r\n    tokenEnabled(_destination)\r\n    returns (uint256)\r\n  {\r\n\r\n    require(_source != _destination);\r\n\r\n    uint256 receivedAmount;\r\n\r\n    if (_source == ETH_TOKEN_ADDRESS) {\r\n      require(msg.value == _sourceAmount);\r\n    } else {\r\n      require(msg.value == 0);\r\n    }\r\n\r\n    // SHOULD TRADE PARASWAP HERE\r\n    if (_type == uint(ExchangeType.Paraswap)) {\r\n      // call paraswap\r\n      receivedAmount = _tradeViaParaswap(\r\n          _source,\r\n          _destination,\r\n          _sourceAmount,\r\n          _additionalData,\r\n          _additionalArgs\r\n      );\r\n    }\r\n    // SHOULD TRADE BANCOR HERE\r\n    else if (_type == uint(ExchangeType.Bancor)){\r\n      receivedAmount = _tradeViaBancorNewtork(\r\n          _source,\r\n          _destination,\r\n          _sourceAmount\r\n      );\r\n    }\r\n    // SHOULD TRADE 1INCH HERE\r\n    else if (_type == uint(ExchangeType.OneInch)){\r\n      receivedAmount = _tradeViaOneInch(\r\n          _source,\r\n          _destination,\r\n          _sourceAmount\r\n      );\r\n    }\r\n\r\n    else {\r\n      // unknown exchange type\r\n      revert();\r\n    }\r\n\r\n    require(receivedAmount > 0, \"received amount can not be zerro\");\r\n\r\n    // Send assets\r\n    if (_destination == ETH_TOKEN_ADDRESS) {\r\n      (msg.sender).transfer(receivedAmount);\r\n    } else {\r\n      // transfer tokens received to sender\r\n      _destination.transfer(msg.sender, receivedAmount);\r\n    }\r\n\r\n    // After the trade, any _source that exchangePortal holds will be sent back to msg.sender\r\n    uint256 endAmount = (_source == ETH_TOKEN_ADDRESS) ? address(this).balance : _source.balanceOf(address(this));\r\n\r\n    // Check if we hold a positive amount of _source\r\n    if (endAmount > 0) {\r\n      if (_source == ETH_TOKEN_ADDRESS) {\r\n        (msg.sender).transfer(endAmount);\r\n      } else {\r\n        _source.transfer(msg.sender, endAmount);\r\n      }\r\n    }\r\n\r\n    emit Trade(msg.sender, _source, _sourceAmount, _destination, receivedAmount, uint8(_type));\r\n\r\n    return receivedAmount;\r\n  }\r\n\r\n\r\n  // Facilitates trade with Paraswap\r\n  function _tradeViaParaswap(\r\n    address sourceToken,\r\n    address destinationToken,\r\n    uint256 sourceAmount,\r\n    bytes   exchangeData,\r\n    bytes32[] _additionalArgs\r\n )\r\n   private\r\n   returns (uint256 destinationReceived)\r\n {\r\n   (uint256 minDestinationAmount,\r\n    address[] memory callees,\r\n    uint256[] memory startIndexes,\r\n    uint256[] memory values,\r\n    uint256 mintPrice) = paraswapParams.getParaswapParamsFromBytes32Array(_additionalArgs);\r\n\r\n   if (ERC20(sourceToken) == ETH_TOKEN_ADDRESS) {\r\n     paraswapInterface.swap.value(sourceAmount)(\r\n       sourceToken,\r\n       destinationToken,\r\n       sourceAmount,\r\n       minDestinationAmount,\r\n       callees,\r\n       exchangeData,\r\n       startIndexes,\r\n       values,\r\n       \"CoTrader\", // referrer\r\n       mintPrice\r\n     );\r\n   } else {\r\n     _transferFromSenderAndApproveTo(ERC20(sourceToken), sourceAmount, paraswapSpender);\r\n     paraswapInterface.swap(\r\n       sourceToken,\r\n       destinationToken,\r\n       sourceAmount,\r\n       minDestinationAmount,\r\n       callees,\r\n       exchangeData,\r\n       startIndexes,\r\n       values,\r\n       \"CoTrader\", // referrer\r\n       mintPrice\r\n     );\r\n   }\r\n\r\n   destinationReceived = tokenBalance(ERC20(destinationToken));\r\n   setTokenType(destinationToken, \"CRYPTOCURRENCY\");\r\n }\r\n\r\n // Facilitates trade with 1inch\r\n function _tradeViaOneInch(\r\n   address sourceToken,\r\n   address destinationToken,\r\n   uint256 sourceAmount\r\n   )\r\n   private\r\n   returns(uint256 destinationReceived)\r\n {\r\n    (, uint256[] memory distribution) = oneInch.getExpectedReturn(\r\n      IERC20(sourceToken),\r\n      IERC20(destinationToken),\r\n      sourceAmount,\r\n      10,\r\n      0);\r\n\r\n    if(ERC20(sourceToken) == ETH_TOKEN_ADDRESS) {\r\n      oneInch.swap.value(sourceAmount)(\r\n        IERC20(sourceToken),\r\n        IERC20(destinationToken),\r\n        sourceAmount,\r\n        1,\r\n        distribution,\r\n        0\r\n        );\r\n    } else {\r\n      _transferFromSenderAndApproveTo(ERC20(sourceToken), sourceAmount, address(oneInch));\r\n      oneInch.swap(\r\n        IERC20(sourceToken),\r\n        IERC20(destinationToken),\r\n        sourceAmount,\r\n        1,\r\n        distribution,\r\n        0\r\n        );\r\n    }\r\n\r\n    destinationReceived = tokenBalance(ERC20(destinationToken));\r\n    setTokenType(destinationToken, \"CRYPTOCURRENCY\");\r\n }\r\n\r\n\r\n // Facilitates trade with Bancor\r\n function _tradeViaBancorNewtork(\r\n   address sourceToken,\r\n   address destinationToken,\r\n   uint256 sourceAmount\r\n   )\r\n   private\r\n   returns(uint256 returnAmount)\r\n {\r\n    // get latest bancor contracts\r\n    BancorNetworkInterface bancorNetwork = BancorNetworkInterface(\r\n      bancorRegistry.getBancorContractAddresByName(\"BancorNetwork\")\r\n    );\r\n\r\n    PathFinderInterface pathFinder = PathFinderInterface(\r\n      bancorRegistry.getBancorContractAddresByName(\"BancorNetworkPathFinder\")\r\n    );\r\n\r\n    // Change source and destination to Bancor ETH wrapper\r\n    address source = ERC20(sourceToken) == ETH_TOKEN_ADDRESS ? BancorEtherToken : sourceToken;\r\n    address destination = ERC20(destinationToken) == ETH_TOKEN_ADDRESS ? BancorEtherToken : destinationToken;\r\n\r\n    // Get Bancor tokens path\r\n    address[] memory path = pathFinder.generatePath(source, destination);\r\n\r\n    // Convert addresses to ERC20\r\n    ERC20[] memory pathInERC20 = new ERC20[](path.length);\r\n    for(uint i=0; i<path.length; i++){\r\n        pathInERC20[i] = ERC20(path[i]);\r\n    }\r\n\r\n    // trade\r\n    if (ERC20(sourceToken) == ETH_TOKEN_ADDRESS) {\r\n      returnAmount = bancorNetwork.convert.value(sourceAmount)(pathInERC20, sourceAmount, 1);\r\n    }\r\n    else {\r\n      _transferFromSenderAndApproveTo(ERC20(sourceToken), sourceAmount, address(bancorNetwork));\r\n      returnAmount = bancorNetwork.claimAndConvert(pathInERC20, sourceAmount, 1);\r\n    }\r\n }\r\n\r\n\r\n  /**\r\n  * @dev Transfers tokens to this contract and approves them to another address\r\n  *\r\n  * @param _source          Token to transfer and approve\r\n  * @param _sourceAmount    The amount to transfer and approve (in _source token)\r\n  * @param _to              Address to approve to\r\n  */\r\n  function _transferFromSenderAndApproveTo(ERC20 _source, uint256 _sourceAmount, address _to) private {\r\n    require(_source.transferFrom(msg.sender, address(this), _sourceAmount));\r\n\r\n    _source.approve(_to, _sourceAmount);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev buy Compound cTokens\r\n  *\r\n  * @param _amount       amount of ERC20 or ETH\r\n  * @param _cToken       cToken address\r\n  */\r\n  function compoundMint(uint256 _amount, address _cToken)\r\n   external\r\n   payable\r\n   returns(uint256)\r\n  {\r\n    uint256 receivedAmount = 0;\r\n    if(_cToken == address(cEther)){\r\n      // mint cETH\r\n      cEther.mint.value(_amount)();\r\n      // transfer received cETH back to fund\r\n      receivedAmount = cEther.balanceOf(address(this));\r\n      cEther.transfer(msg.sender, receivedAmount);\r\n    }else{\r\n      // mint cERC20\r\n      CToken cToken = CToken(_cToken);\r\n      address underlyingAddress = cToken.underlying();\r\n      _transferFromSenderAndApproveTo(ERC20(underlyingAddress), _amount, address(_cToken));\r\n      cToken.mint(_amount);\r\n      // transfer received cERC back to fund\r\n      receivedAmount = cToken.balanceOf(address(this));\r\n      cToken.transfer(msg.sender, receivedAmount);\r\n    }\r\n\r\n    require(receivedAmount > 0, \"received amount can not be zerro\");\r\n\r\n    setTokenType(_cToken, \"COMPOUND\");\r\n    return receivedAmount;\r\n  }\r\n\r\n  /**\r\n  * @dev sell certain percent of Ctokens to Compound\r\n  *\r\n  * @param _percent      percent from 1 to 100\r\n  * @param _cToken       cToken address\r\n  */\r\n  function compoundRedeemByPercent(uint _percent, address _cToken)\r\n   external\r\n   returns(uint256)\r\n  {\r\n    uint256 receivedAmount = 0;\r\n\r\n    uint256 amount = getPercentFromCTokenBalance(_percent, _cToken, msg.sender);\r\n\r\n    // transfer amount from sender\r\n    ERC20(_cToken).transferFrom(msg.sender, address(this), amount);\r\n\r\n    // reedem\r\n    if(_cToken == address(cEther)){\r\n      // redeem compound ETH\r\n      cEther.redeem(amount);\r\n      // transfer received ETH back to fund\r\n      receivedAmount = address(this).balance;\r\n      (msg.sender).transfer(receivedAmount);\r\n\r\n    }else{\r\n      // redeem ERC20\r\n      CToken cToken = CToken(_cToken);\r\n      cToken.redeem(amount);\r\n      // transfer received ERC20 back to fund\r\n      address underlyingAddress = cToken.underlying();\r\n      ERC20 underlying = ERC20(underlyingAddress);\r\n      receivedAmount = underlying.balanceOf(address(this));\r\n      underlying.transfer(msg.sender, receivedAmount);\r\n    }\r\n\r\n    require(receivedAmount > 0, \"received amount can not be zerro\");\r\n\r\n    return receivedAmount;\r\n  }\r\n\r\n  // VIEW Functions\r\n\r\n  function tokenBalance(ERC20 _token) private view returns (uint256) {\r\n    if (_token == ETH_TOKEN_ADDRESS)\r\n      return address(this).balance;\r\n    return _token.balanceOf(address(this));\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the ratio by amount of token _from in token _to by totekn type\r\n  *\r\n  * @param _from      Address of token we're converting from\r\n  * @param _to        Address of token we're getting the value in\r\n  * @param _amount    The amount of _from\r\n  *\r\n  * @return best price from Paraswap or 1inch for ERC20, or ratio for Uniswap and Bancor pools\r\n  */\r\n  function getValue(address _from, address _to, uint256 _amount) public view returns (uint256){\r\n    if(_amount > 0){\r\n      if(tokensTypes.getType(_from) == bytes32(\"CRYPTOCURRENCY\")){\r\n        uint256 valueFromOneInch = getValueViaOneInch(_from, _to, _amount);\r\n        uint256 valueFromParaswap = getValueViaParaswap(_from, _to, _amount);\r\n        // return best price\r\n        return (valueFromOneInch > valueFromParaswap)\r\n        ? valueFromOneInch\r\n        : valueFromParaswap;\r\n      }\r\n      else if (tokensTypes.getType(_from) == bytes32(\"BANCOR POOL\")){\r\n        return getValueViaBancor(_from, _to, _amount);\r\n      }\r\n      else if (tokensTypes.getType(_from) == bytes32(\"UNISWAP POOL\")){\r\n        return getValueForUniswapPools(_from, _to, _amount);\r\n      }\r\n      else if (tokensTypes.getType(_from) == bytes32(\"COMPOUND\")){\r\n        return getValueViaCompound(_from, _to, _amount);\r\n      }\r\n      else{\r\n        // Unmarked type, try find value\r\n        return findValue(_from, _to, _amount);\r\n      }\r\n    }\r\n    else{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev find the ratio by amount of token _from in token _to trying all available methods\r\n  *\r\n  * @param _from      Address of token we're converting from\r\n  * @param _to        Address of token we're getting the value in\r\n  * @param _amount    The amount of _from\r\n  *\r\n  * @return best price from Paraswap or 1inch for ERC20, or ratio for Uniswap and Bancor pools\r\n  */\r\n  function findValue(address _from, address _to, uint256 _amount) public view returns (uint256) {\r\n     if(_amount > 0){\r\n       // If Paraswap return 0, check from 1inch for ensure\r\n       uint256 paraswapResult = getValueViaParaswap(_from, _to, _amount);\r\n       if(paraswapResult > 0)\r\n         return paraswapResult;\r\n\r\n       // If 1inch return 0, check from Bancor network for ensure this is not a Bancor pool\r\n       uint256 oneInchResult = getValueViaOneInch(_from, _to, _amount);\r\n       if(oneInchResult > 0)\r\n         return oneInchResult;\r\n\r\n       // If Bancor return 0, check from Syntetix network for ensure this is not Synth asset\r\n       uint256 bancorResult = getValueViaBancor(_from, _to, _amount);\r\n       if(bancorResult > 0)\r\n          return bancorResult;\r\n\r\n       // If Compound return 0, check from Uniswap pools for ensure this is not Uniswap\r\n       uint256 compoundResult = getValueViaCompound(_from, _to, _amount);\r\n       if(compoundResult > 0)\r\n          return compoundResult;\r\n\r\n       // Uniswap pools return 0 if these is not a Uniswap pool\r\n       return getValueForUniswapPools(_from, _to, _amount);\r\n     }\r\n     else{\r\n       return 0;\r\n     }\r\n  }\r\n\r\n  // helper for get ratio between assets in Paraswap aggregator\r\n  function getValueViaParaswap(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  ) public view returns (uint256 value) {\r\n    // Check call Paraswap (Because Paraswap can return error for some not supported  assets)\r\n    (bool success) = address(priceFeedInterface).call(\r\n    abi.encodeWithSelector(priceFeedInterface.getBestPriceSimple.selector, _from, _to, _amount));\r\n    // if Paraswap can get rate for this assets, use Paraswap\r\n    if(success){\r\n      value = priceFeedInterface.getBestPriceSimple(_from, _to, _amount);\r\n    }else{\r\n      value = 0;\r\n    }\r\n  }\r\n\r\n  // helper for get ratio between assets in 1inch aggregator\r\n  function getValueViaOneInch(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  ) public view returns (uint256 value) {\r\n    // Check call 1inch\r\n    (bool success) = address(oneInch).call(\r\n    abi.encodeWithSelector(oneInch.getExpectedReturn.selector, IERC20(_from), IERC20(_to), _amount));\r\n    // if 1inch can get rate for this assets, use 1inch\r\n    if(success){\r\n      (uint256 returnAmount, ) = oneInch.getExpectedReturn(\r\n        IERC20(_from),\r\n        IERC20(_to),\r\n        _amount,\r\n        10,\r\n        0);\r\n      value = returnAmount;\r\n    }else{\r\n      value = 0;\r\n    }\r\n  }\r\n\r\n  // helper for get ratio between assets in Bancor network\r\n  function getValueViaBancor(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n  public\r\n  view\r\n  returns (uint256 value)\r\n  {\r\n    // Check call Bancor (Because Bancor can return error for some not supported assets)\r\n    (bool success) = address(poolPortal).call(\r\n    abi.encodeWithSelector(poolPortal.getBancorRatio.selector, _from, _to, _amount));\r\n    // if Bancor can get rate for this assets use Bancor\r\n    if(success){\r\n      value = poolPortal.getBancorRatio(_from, _to, _amount);\r\n    }else{\r\n      value = 0;\r\n    }\r\n  }\r\n\r\n  // helper for get value between Compound assets and ETH/ERC20\r\n  // NOTE: _from should be COMPOUND cTokens,\r\n  // amount should be 1e8 because cTokens support 8 decimals\r\n  function getValueViaCompound(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  ) public view returns (uint256 value) {\r\n    // get underlying amount by cToken amount\r\n    uint256 underlyingAmount = getCompoundUnderlyingRatio(\r\n      _from,\r\n      _amount\r\n    );\r\n    // convert underlying in _to\r\n    if(underlyingAmount > 0){\r\n      // get underlying address\r\n      address underlyingAddress = (_from == address(cEther))\r\n      ? ETH_TOKEN_ADDRESS\r\n      : CToken(_from).underlying();\r\n      // get rate for underlying address via paraswap\r\n      return getValueViaParaswap(underlyingAddress, _to, underlyingAmount);\r\n    }\r\n    else{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // helper for get underlying amount by cToken amount\r\n  // NOTE: _from should be Compound token, amount = input * 1e8 (not 1e18)\r\n  function getCompoundUnderlyingRatio(\r\n    address _from,\r\n    uint256 _amount\r\n  )\r\n    public\r\n    view returns (uint256)\r\n  {\r\n    // Check call\r\n    (bool success) = address(_from).call(\r\n    abi.encodeWithSelector(CToken(_from).exchangeRateCurrent.selector));\r\n\r\n    if(success){\r\n      // get underlying amount by cToken amount\r\n      uint256 rate = CToken(_from).exchangeRateCurrent();\r\n      uint256 underlyingAmount = _amount.mul(rate).div(1e18);\r\n      return underlyingAmount;\r\n    }else{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // helper for get ratio between pools in Uniswap network\r\n  // _from - should be uniswap pool address\r\n  function getValueForUniswapPools(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n  public\r\n  view\r\n  returns (uint256)\r\n  {\r\n    // get connectors amount\r\n    (uint256 ethAmount,\r\n     uint256 ercAmount) = poolPortal.getUniswapConnectorsAmountByPoolAmount(\r\n      _amount,\r\n      _from\r\n    );\r\n    // get ERC amount in ETH\r\n    address token = poolPortal.getTokenByUniswapExchange(_from);\r\n    uint256 ercAmountInETH = getValueViaParaswap(token, ETH_TOKEN_ADDRESS, ercAmount);\r\n    // sum ETH with ERC amount in ETH\r\n    uint256 totalETH = ethAmount.add(ercAmountInETH);\r\n\r\n    // if _to == ETH no need additional convert, just return ETH amount\r\n    if(_to == address(ETH_TOKEN_ADDRESS)){\r\n      return totalETH;\r\n    }\r\n    // convert ETH into _to asset via Paraswap\r\n    else{\r\n      return getValueViaParaswap(ETH_TOKEN_ADDRESS, _to, totalETH);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev return percent of compound cToken balance\r\n  *\r\n  * @param _percent       amount of ERC20 or ETH\r\n  * @param _cToken        cToken address\r\n  * @param _holder        address of cToken holder\r\n  */\r\n  function getPercentFromCTokenBalance(uint _percent, address _cToken, address _holder)\r\n   public\r\n   view\r\n   returns(uint256)\r\n  {\r\n    if(_percent == 100){\r\n      return ERC20(_cToken).balanceOf(_holder);\r\n    }\r\n    else if(_percent > 0 && _percent < 100){\r\n      uint256 currectBalance = ERC20(_cToken).balanceOf(_holder);\r\n      return currectBalance.div(100).mul(_percent);\r\n    }\r\n    else{\r\n      // not correct percent\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function getCTokenUnderlying(address _cToken) public view returns(address){\r\n    return CToken(_cToken).underlying();\r\n  }\r\n\r\n  /**\r\n  * @dev get value for cToken in base asset (ERC20 or ETH) ratio for this smart fund address\r\n  *\r\n  * @param _cToken       cToken address\r\n  */\r\n  function compoundGetCTokenValue(\r\n    address _cToken\r\n  )\r\n    public\r\n    view\r\n    returns(uint256 result)\r\n  {\r\n    result = CToken(_cToken).balanceOfUnderlying(address(this));\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the total value of array of tokens and amounts\r\n  *\r\n  * @param _fromAddresses    Addresses of all the tokens we're converting from\r\n  * @param _amounts          The amounts of all the tokens\r\n  * @param _to               The token who's value we're converting to\r\n  *\r\n  * @return The total value of _fromAddresses and _amounts in terms of _to\r\n  */\r\n  function getTotalValue(address[] _fromAddresses, uint256[] _amounts, address _to) public view returns (uint256) {\r\n    uint256 sum = 0;\r\n    for (uint256 i = 0; i < _fromAddresses.length; i++) {\r\n      sum = sum.add(getValue(_fromAddresses[i], _to, _amounts[i]));\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  // SETTERS Functions\r\n\r\n  /**\r\n  * @dev Allows the owner to disable/enable the buying of a token\r\n  *\r\n  * @param _token      Token address whos trading permission is to be set\r\n  * @param _enabled    New token permission\r\n  */\r\n  function setToken(address _token, bool _enabled) external onlyOwner {\r\n    disabledTokens[_token] = _enabled;\r\n  }\r\n\r\n  // owner can change IFeed\r\n  function setNewIFeed(address _paraswapPrice) external onlyOwner {\r\n    priceFeedInterface = IPriceFeed(_paraswapPrice);\r\n  }\r\n\r\n  // owner can change paraswap spender address\r\n  function setNewParaswapSpender(address _paraswapSpender) external onlyOwner {\r\n    paraswapSpender = _paraswapSpender;\r\n  }\r\n\r\n  // owner can change paraswap Augustus\r\n  function setNewParaswapMain(address _paraswap) external onlyOwner {\r\n    paraswapInterface = ParaswapInterface(_paraswap);\r\n  }\r\n\r\n  // owner can change oneInch\r\n  function setNewOneInch(address _oneInch) external onlyOwner {\r\n    oneInch = IOneSplitAudit(_oneInch);\r\n  }\r\n\r\n  // Exchange portal can mark each token\r\n  function setTokenType(address _token, string _type) private {\r\n    // no need add type, if token alredy registred\r\n    if(tokensTypes.isRegistred(_token))\r\n      return;\r\n\r\n    tokensTypes.addNewTokenType(_token,  _type);\r\n  }\r\n\r\n  // fallback payable function to receive ether from other contract addresses\r\n  function() public payable {}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"oneInch\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paraswapPrice\",\"type\":\"address\"}],\"name\":\"setNewIFeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oneInch\",\"type\":\"address\"}],\"name\":\"setNewOneInch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"compoundGetCTokenValue\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cEther\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueForUniswapPools\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_percent\",\"type\":\"uint256\"},{\"name\":\"_cToken\",\"type\":\"address\"},{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getPercentFromCTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaParaswap\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolPortal\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceFeedInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaBancor\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"permitedStable\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paraswapInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_source\",\"type\":\"address\"},{\"name\":\"_sourceAmount\",\"type\":\"uint256\"},{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_additionalArgs\",\"type\":\"bytes32[]\"},{\"name\":\"_additionalData\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paraswap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getCompoundUnderlyingRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"findValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paraswap\",\"type\":\"address\"}],\"name\":\"setNewParaswapMain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paraswapSpender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaOneInch\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaCompound\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"compoundMint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"getCTokenUnderlying\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paraswapSpender\",\"type\":\"address\"}],\"name\":\"setNewParaswapSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BancorEtherToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paraswapParams\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percent\",\"type\":\"uint256\"},{\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"compoundRedeemByPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromAddresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"getTotalValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_paraswap\",\"type\":\"address\"},{\"name\":\"_paraswapPrice\",\"type\":\"address\"},{\"name\":\"_paraswapParams\",\"type\":\"address\"},{\"name\":\"_bancorRegistryWrapper\",\"type\":\"address\"},{\"name\":\"_BancorEtherToken\",\"type\":\"address\"},{\"name\":\"_permitedStable\",\"type\":\"address\"},{\"name\":\"_poolPortal\",\"type\":\"address\"},{\"name\":\"_oneInch\",\"type\":\"address\"},{\"name\":\"_cEther\",\"type\":\"address\"},{\"name\":\"_tokensTypes\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exchangeType\",\"type\":\"uint8\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destReceived\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"}]","ContractName":"ExchangePortal","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f92c1ad75005e6436b4ee84e88cb23ed8a29098800000000000000000000000012295f06da62693086f5da45b78e20b7780608530000000000000000000000000595aaa68ad0fbeacdeeaa7b7d78f22717ade957000000000000000000000000178c68aefdcae5c9818e43addf6a2b66df534ed5000000000000000000000000c0829421c1d260bd3cb3e0f06cfe2d52db2ce3150000000000000000000000003621c85a4f3a4dcff575550c5e1916b9ba4aeebd00000000000000000000000001fa1b31766c0e58a2c66b6fba3c36128aea60e4000000000000000000000000c586bef4a0992c495cf22e1aeee4e446cecdee0e0000000000000000000000004ddc2d193948926d02f9b1fe9e1daa0718270ed500000000000000000000000067d635a86d5bff3d3742a93761be0e272bb7541e","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://46c1a65d3940c45d41d080b941040cdeccdc526f110649008e091bc33d6e90ec"}]}