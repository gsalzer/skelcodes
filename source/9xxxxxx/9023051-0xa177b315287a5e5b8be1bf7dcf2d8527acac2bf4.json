{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.13;\n\n\ncontract Context {\n    \n    \n    constructor () internal { }\n    \n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface Comptroller {\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n    function markets(address cToken) external view returns (bool isListed, uint256 collateralFactorMantissa);\n}\n\ninterface PriceOracle {\n  function getUnderlyingPrice(address cToken) external view returns (uint);\n}\n\ninterface CERC20 {\n  function mint(uint mintAmount) external returns (uint);\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function repayBorrow(uint repayAmount) external returns (uint);\n  function borrowBalanceCurrent(address account) external returns (uint);\n  function exchangeRateCurrent() external returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n  function decimals() external view returns (uint);\n  function underlying() external view returns (address);\n}\n\ninterface CEther {\n  function mint() external payable;\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function repayBorrow() external payable;\n  function borrowBalanceCurrent(address account) external returns (uint);\n  function exchangeRateCurrent() external returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n  function decimals() external view returns (uint);\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    \n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        \n        \n        \n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        \n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    \n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        \n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        \n        \n        \n        \n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    \n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        \n        \n\n        \n        \n        \n        \n        \n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        \n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { \n            \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface KyberNetwork {\n  function getExpectedRate(ERC20Detailed src, ERC20Detailed dest, uint srcQty) external view\n      returns (uint expectedRate, uint slippageRate);\n\n  function tradeWithHint(\n    ERC20Detailed src, uint srcAmount, ERC20Detailed dest, address payable destAddress, uint maxDestAmount,\n    uint minConversionRate, address walletId, bytes calldata hint) external payable returns(uint);\n}\n\ncontract Utils {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Detailed;\n\n  \n  modifier isValidToken(address _token) {\n    require(_token != address(0));\n    if (_token != address(ETH_TOKEN_ADDRESS)) {\n      require(isContract(_token));\n    }\n    _;\n  }\n\n  address public DAI_ADDR;\n  address payable public KYBER_ADDR;\n  address payable public DEXAG_ADDR;\n\n  bytes public constant PERM_HINT = \"PERM\";\n\n  ERC20Detailed internal constant ETH_TOKEN_ADDRESS = ERC20Detailed(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n  ERC20Detailed internal dai;\n  KyberNetwork internal kyber;\n\n  uint constant internal PRECISION = (10**18);\n  uint constant internal MAX_QTY   = (10**28); \n  uint constant internal ETH_DECIMALS = 18;\n  uint constant internal MAX_DECIMALS = 18;\n\n  constructor(\n    address _daiAddr,\n    address payable _kyberAddr,\n    address payable _dexagAddr\n  ) public {\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    DEXAG_ADDR = _dexagAddr;\n\n    dai = ERC20Detailed(_daiAddr);\n    kyber = KyberNetwork(_kyberAddr);\n  }\n\n  \n  function getDecimals(ERC20Detailed _token) internal view returns(uint256) {\n    if (address(_token) == address(ETH_TOKEN_ADDRESS)) {\n      return uint256(ETH_DECIMALS);\n    }\n    return uint256(_token.decimals());\n  }\n\n  \n  function getBalance(ERC20Detailed _token, address _addr) internal view returns(uint256) {\n    if (address(_token) == address(ETH_TOKEN_ADDRESS)) {\n      return uint256(_addr.balance);\n    }\n    return uint256(_token.balanceOf(_addr));\n  }\n\n  \n  function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n        internal pure returns(uint)\n  {\n    require(srcAmount <= MAX_QTY);\n    require(destAmount <= MAX_QTY);\n\n    if (dstDecimals >= srcDecimals) {\n      require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n      return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n    } else {\n      require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n      return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n    }\n  }\n\n  \n  function __kyberTrade(ERC20Detailed _srcToken, uint256 _srcAmount, ERC20Detailed _destToken)\n    internal\n    returns(\n      uint256 _destPriceInSrc,\n      uint256 _srcPriceInDest,\n      uint256 _actualDestAmount,\n      uint256 _actualSrcAmount\n    )\n  {\n    require(_srcToken != _destToken);\n\n    uint256 beforeSrcBalance = getBalance(_srcToken, address(this));\n    uint256 msgValue;\n    if (_srcToken != ETH_TOKEN_ADDRESS) {\n      msgValue = 0;\n      _srcToken.safeApprove(KYBER_ADDR, 0);\n      _srcToken.safeApprove(KYBER_ADDR, _srcAmount);\n    } else {\n      msgValue = _srcAmount;\n    }\n    _actualDestAmount = kyber.tradeWithHint.value(msgValue)(\n      _srcToken,\n      _srcAmount,\n      _destToken,\n      toPayableAddr(address(this)),\n      MAX_QTY,\n      1,\n      0x332D87209f7c8296389C307eAe170c2440830A47,\n      PERM_HINT\n    );\n    _actualSrcAmount = beforeSrcBalance.sub(getBalance(_srcToken, address(this)));\n    require(_actualDestAmount > 0 && _actualSrcAmount > 0);\n    _destPriceInSrc = calcRateFromQty(_actualDestAmount, _actualSrcAmount, getDecimals(_destToken), getDecimals(_srcToken));\n    _srcPriceInDest = calcRateFromQty(_actualSrcAmount, _actualDestAmount, getDecimals(_srcToken), getDecimals(_destToken));\n  }\n\n  \n  function __dexagTrade(ERC20Detailed _srcToken, uint256 _srcAmount, ERC20Detailed _destToken, bytes memory _calldata)\n    internal\n    returns(\n      uint256 _destPriceInSrc,\n      uint256 _srcPriceInDest,\n      uint256 _actualDestAmount,\n      uint256 _actualSrcAmount\n    )\n  {\n    require(_srcToken != _destToken);\n\n    uint256 beforeSrcBalance = getBalance(_srcToken, address(this));\n    uint256 beforeDestBalance = getBalance(_destToken, address(this));\n    \n    if (_srcToken != ETH_TOKEN_ADDRESS) {\n      _actualSrcAmount = 0;\n      _srcToken.safeApprove(DEXAG_ADDR, 0);\n      _srcToken.safeApprove(DEXAG_ADDR, _srcAmount);\n    } else {\n      _actualSrcAmount = _srcAmount;\n    }\n\n    \n    (bool success,) = DEXAG_ADDR.call.value(_actualSrcAmount)(_calldata);\n    require(success);\n\n    \n    _actualDestAmount = beforeDestBalance.sub(getBalance(_destToken, address(this)));\n    _actualSrcAmount = beforeSrcBalance.sub(getBalance(_srcToken, address(this)));\n    require(_actualDestAmount > 0 && _actualSrcAmount > 0);\n    _destPriceInSrc = calcRateFromQty(_actualDestAmount, _actualSrcAmount, getDecimals(_destToken), getDecimals(_srcToken));\n    _srcPriceInDest = calcRateFromQty(_actualSrcAmount, _actualDestAmount, getDecimals(_srcToken), getDecimals(_destToken));\n\n    \n    (, uint256 kyberSrcPriceInDest) = kyber.getExpectedRate(_srcToken, _destToken, _srcAmount);\n    require(kyberSrcPriceInDest > 0 && _srcPriceInDest >= kyberSrcPriceInDest);\n  }\n\n  \n  function isContract(address _addr) internal view returns(bool) {\n    uint size;\n    if (_addr == address(0)) return false;\n    assembly {\n        size := extcodesize(_addr)\n    }\n    return size>0;\n  }\n\n  function toPayableAddr(address _addr) internal pure returns (address payable) {\n    return address(uint160(_addr));\n  }\n}\n\ncontract CompoundOrder is Utils(address(0), address(0), address(0)), Ownable {\n  \n  uint256 internal constant NEGLIGIBLE_DEBT = 10 ** 14; \n  uint256 internal constant MAX_REPAY_STEPS = 3; \n  uint256 internal constant DEFAULT_LIQUIDITY_SLIPPAGE = 10 ** 12; \n  uint256 internal constant FALLBACK_LIQUIDITY_SLIPPAGE = 10 ** 15; \n  uint256 internal constant MAX_LIQUIDITY_SLIPPAGE = 10 ** 17; \n\n  \n  Comptroller public COMPTROLLER; \n  PriceOracle public ORACLE; \n  CERC20 public CDAI; \n  address public CETH_ADDR;\n\n  \n  uint256 public stake;\n  uint256 public collateralAmountInDAI;\n  uint256 public loanAmountInDAI;\n  uint256 public cycleNumber;\n  uint256 public buyTime; \n  uint256 public outputAmount; \n  address public compoundTokenAddr;\n  bool public isSold;\n  bool public orderType; \n  bool internal initialized;\n\n\n  constructor() public {}\n\n  function init(\n    address _compoundTokenAddr,\n    uint256 _cycleNumber,\n    uint256 _stake,\n    uint256 _collateralAmountInDAI,\n    uint256 _loanAmountInDAI,\n    bool _orderType,\n    address _daiAddr,\n    address payable _kyberAddr,\n    address _comptrollerAddr,\n    address _priceOracleAddr,\n    address _cDAIAddr,\n    address _cETHAddr\n  ) public {\n    require(!initialized);\n    initialized = true;\n    \n    \n    require(_compoundTokenAddr != _cDAIAddr);\n    require(_stake > 0 && _collateralAmountInDAI > 0 && _loanAmountInDAI > 0); \n    stake = _stake;\n    collateralAmountInDAI = _collateralAmountInDAI;\n    loanAmountInDAI = _loanAmountInDAI;\n    cycleNumber = _cycleNumber;\n    compoundTokenAddr = _compoundTokenAddr;\n    orderType = _orderType;\n\n    COMPTROLLER = Comptroller(_comptrollerAddr);\n    ORACLE = PriceOracle(_priceOracleAddr);\n    CDAI = CERC20(_cDAIAddr);\n    CETH_ADDR = _cETHAddr;\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    dai = ERC20Detailed(_daiAddr);\n    kyber = KyberNetwork(_kyberAddr);\n\n    \n    _transferOwnership(msg.sender);\n  }\n\n  \n  function executeOrder(uint256 _minPrice, uint256 _maxPrice) public;\n\n  \n  function sellOrder(uint256 _minPrice, uint256 _maxPrice) public returns (uint256 _inputAmount, uint256 _outputAmount);\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public;\n\n  function getMarketCollateralFactor() public view returns (uint256);\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount);\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount);\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount);\n\n  \n  function getCurrentProfitInDAI() public returns (bool _isNegative, uint256 _amount) {\n    uint256 l;\n    uint256 r;\n    if (isSold) {\n      l = outputAmount;\n      r = collateralAmountInDAI;\n    } else {\n      uint256 cash = getCurrentCashInDAI();\n      uint256 supply = getCurrentCollateralInDAI();\n      uint256 borrow = getCurrentBorrowInDAI();\n      if (cash >= borrow) {\n        l = supply.add(cash);\n        r = borrow.add(collateralAmountInDAI);\n      } else {\n        l = supply;\n        r = borrow.sub(cash).mul(PRECISION).div(getMarketCollateralFactor()).add(collateralAmountInDAI);\n      }\n    }\n    \n    if (l >= r) {\n      return (false, l.sub(r));\n    } else {\n      return (true, r.sub(l));\n    }\n  }\n\n  \n  function getCurrentCollateralRatioInDAI() public returns (uint256 _amount) {\n    uint256 supply = getCurrentCollateralInDAI();\n    uint256 borrow = getCurrentBorrowInDAI();\n    if (borrow == 0) {\n      return uint256(-1);\n    }\n    return supply.mul(PRECISION).div(borrow);\n  }\n\n  \n  function getCurrentLiquidityInDAI() public returns (bool _isNegative, uint256 _amount) {\n    uint256 supply = getCurrentCollateralInDAI();\n    uint256 borrow = getCurrentBorrowInDAI().mul(PRECISION).div(getMarketCollateralFactor());\n    if (supply >= borrow) {\n      return (false, supply.sub(borrow));\n    } else {\n      return (true, borrow.sub(supply));\n    }\n  }\n\n  function __sellDAIForToken(uint256 _daiAmount) internal returns (uint256 _actualDAIAmount, uint256 _actualTokenAmount) {\n    ERC20Detailed t = __underlyingToken(compoundTokenAddr);\n    (,, _actualTokenAmount, _actualDAIAmount) = __kyberTrade(dai, _daiAmount, t); \n    require(_actualDAIAmount > 0 && _actualTokenAmount > 0); \n  }\n\n  function __sellTokenForDAI(uint256 _tokenAmount) internal returns (uint256 _actualDAIAmount, uint256 _actualTokenAmount) {\n    ERC20Detailed t = __underlyingToken(compoundTokenAddr);\n    (,, _actualDAIAmount, _actualTokenAmount) = __kyberTrade(t, _tokenAmount, dai); \n    require(_actualDAIAmount > 0 && _actualTokenAmount > 0); \n  }\n\n  \n  function __daiToToken(address _cToken, uint256 _daiAmount) internal view returns (uint256) {\n    if (_cToken == CETH_ADDR) {\n      \n      return _daiAmount.mul(ORACLE.getUnderlyingPrice(address(CDAI))).div(PRECISION);\n    }\n    ERC20Detailed t = __underlyingToken(_cToken);\n    return _daiAmount.mul(ORACLE.getUnderlyingPrice(address(CDAI))).mul(10 ** getDecimals(t)).div(ORACLE.getUnderlyingPrice(_cToken).mul(PRECISION));\n  }\n\n  \n  function __tokenToDAI(address _cToken, uint256 _tokenAmount) internal view returns (uint256) {\n    if (_cToken == CETH_ADDR) {\n      \n      return _tokenAmount.mul(PRECISION).div(ORACLE.getUnderlyingPrice(address(CDAI)));\n    }\n    ERC20Detailed t = __underlyingToken(_cToken);\n    return _tokenAmount.mul(ORACLE.getUnderlyingPrice(_cToken)).mul(PRECISION).div(ORACLE.getUnderlyingPrice(address(CDAI)).mul(10 ** uint256(t.decimals())));\n  }\n\n  function __underlyingToken(address _cToken) internal view returns (ERC20Detailed) {\n    if (_cToken == CETH_ADDR) {\n      \n      return ETH_TOKEN_ADDRESS;\n    }\n    CERC20 ct = CERC20(_cToken);\n    address underlyingToken = ct.underlying();\n    ERC20Detailed t = ERC20Detailed(underlyingToken);\n    return t;\n  }\n\n  function() external payable {}\n}\n\ncontract ShortCERC20Order is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = ORACLE.getUnderlyingPrice(compoundTokenAddr); \n    require(tokenPrice > 0); \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n    \n    \n    uint256 loanAmountInToken = __daiToToken(compoundTokenAddr, loanAmountInDAI);\n    dai.safeApprove(address(CDAI), 0); \n    dai.safeApprove(address(CDAI), collateralAmountInDAI); \n    require(CDAI.mint(collateralAmountInDAI) == 0); \n    dai.safeApprove(address(CDAI), 0);\n    require(market.borrow(loanAmountInToken) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    (uint256 actualDAIAmount,) = __sellTokenForDAI(loanAmountInToken);\n    loanAmountInDAI = actualDAIAmount; \n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    if (token.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = token.balanceOf(address(this));\n      token.safeApprove(compoundTokenAddr, 0);\n      token.safeApprove(compoundTokenAddr, repayAmount);\n      require(market.repayBorrow(repayAmount) == 0);\n      token.safeApprove(compoundTokenAddr, 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        uint256 errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(_repayAmountInDAI);\n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 currentDebt = market.borrowBalanceCurrent(address(this));\n    if (actualTokenAmount > currentDebt) {\n      actualTokenAmount = currentDebt;\n    }\n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    token.safeApprove(compoundTokenAddr, 0);\n    token.safeApprove(compoundTokenAddr, actualTokenAmount);\n    require(market.repayBorrow(actualTokenAmount) == 0);\n    token.safeApprove(compoundTokenAddr, 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(CDAI));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    uint256 supply = CDAI.balanceOf(address(this)).mul(CDAI.exchangeRateCurrent()).div(PRECISION);\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 borrow = __tokenToDAI(compoundTokenAddr, market.borrowBalanceCurrent(address(this)));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    uint256 cash = getBalance(dai, address(this));\n    return cash;\n  }\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"CDAI\",\"outputs\":[{\"internalType\":\"contract CERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CETH_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPTROLLER\",\"outputs\":[{\"internalType\":\"contract Comptroller\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEXAG_ADDR\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYBER_ADDR\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORACLE\",\"outputs\":[{\"internalType\":\"contract PriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERM_HINT\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralAmountInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compoundTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycleNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"executeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCurrentBorrowInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentCashInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCurrentCollateralInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCurrentCollateralRatioInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCurrentLiquidityInDAI\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isNegative\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCurrentProfitInDAI\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isNegative\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketCollateralFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_compoundTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmountInDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_loanAmountInDAI\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_orderType\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_daiAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_kyberAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_comptrollerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracleAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cDAIAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cETHAddr\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanAmountInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orderType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"outputAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_repayAmountInDAI\",\"type\":\"uint256\"}],\"name\":\"repayLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"sellOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_outputAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ShortCERC20Order","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://2373a0f4c27dd3832c4921fdae07ef8d2e8d1e23bb436bf72005f7544cc1e217"}]}