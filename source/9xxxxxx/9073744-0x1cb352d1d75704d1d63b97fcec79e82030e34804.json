{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev contract module that provides the OpenCerts DocumentStore contract to be used\r\n * to issue and remoke certificates on the blockchain\r\n */\r\ncontract DocumentStore is Ownable {\r\n    string public name;\r\n    string public version = \"2.3.0\";\r\n\r\n    /// A mapping of the document hash to the block number that was issued\r\n    mapping(bytes32 => uint256) documentIssued;\r\n    /// A mapping of the hash of the claim being revoked to the revocation block number\r\n    mapping(bytes32 => uint256) documentRevoked;\r\n\r\n    event DocumentIssued(bytes32 indexed document);\r\n    event DocumentRevoked(bytes32 indexed document);\r\n\r\n    constructor(string memory _name) public {\r\n        name = _name;\r\n    }\r\n\r\n    function issue(bytes32 document) public onlyOwner onlyNotIssued(document) {\r\n        documentIssued[document] = block.number;\r\n        emit DocumentIssued(document);\r\n    }\r\n\r\n    function bulkIssue(bytes32[] memory documents) public {\r\n        for (uint256 i = 0; i < documents.length; i++) {\r\n            issue(documents[i]);\r\n        }\r\n    }\r\n\r\n    function getIssuedBlock(bytes32 document)\r\n        public\r\n        view\r\n        onlyIssued(document)\r\n        returns (uint256)\r\n    {\r\n        return documentIssued[document];\r\n    }\r\n\r\n    function isIssued(bytes32 document) public view returns (bool) {\r\n        return (documentIssued[document] != 0);\r\n    }\r\n\r\n    function isIssuedBefore(bytes32 document, uint256 blockNumber)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            documentIssued[document] != 0 && documentIssued[document] <= blockNumber;\r\n    }\r\n\r\n    function revoke(bytes32 document)\r\n        public\r\n        onlyOwner\r\n        onlyNotRevoked(document)\r\n        returns (bool)\r\n    {\r\n        documentRevoked[document] = block.number;\r\n        emit DocumentRevoked(document);\r\n    }\r\n\r\n    function bulkRevoke(bytes32[] memory documents) public {\r\n        for (uint256 i = 0; i < documents.length; i++) {\r\n            revoke(documents[i]);\r\n        }\r\n    }\r\n\r\n    function isRevoked(bytes32 document) public view returns (bool) {\r\n        return documentRevoked[document] != 0;\r\n    }\r\n\r\n    function isRevokedBefore(bytes32 document, uint256 blockNumber)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            documentRevoked[document] <= blockNumber && documentRevoked[document] != 0;\r\n    }\r\n\r\n    modifier onlyIssued(bytes32 document) {\r\n        require(\r\n            isIssued(document),\r\n            \"Error: Only issued document hashes can be revoked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotIssued(bytes32 document) {\r\n        require(\r\n            !isIssued(document),\r\n            \"Error: Only hashes that have not been issued can be issued\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotRevoked(bytes32 claim) {\r\n        require(!isRevoked(claim), \"Error: Hash has been revoked previously\");\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * DocumentMultiSigWalletCertStore\r\n * ============\r\n *\r\n * Basic multi-signer wallet designed for use in a co-signing environment where \r\n * 2 signatures are required to issue and revoke certificates.\r\n * Typically used in a 2-of-3 signing configuration. Uses ecrecover to allow \r\n * for 2 signatures in a single transaction.\r\n *\r\n * The first signature is created on the operation hash (see Data Formats) and \r\n * passed to sendMultiSig/sendMultiSigToken\r\n * The signer is determined by verifyMultiSig().\r\n *\r\n * The second signature is created by the submitter of the transaction and determined \r\n * by msg.signer.\r\n * \r\n * This wallet only allows for three signers that have to be set upon deployment.\r\n * The signers cannot be changed/removed/added.\r\n * The wallet also deploys upon construction a DocumentStore contract, the name parameter \r\n * is used to label the DocumentStore Contract.\r\n * \r\n * This iteration of the wallet restricts the initiation of the different functions to \r\n * specific signers.\r\n * \r\n * Signer Authorisation\r\n * ====================\r\n * issueMultiSig & revokeMultiSig & bulkIssueMultiSig & bulkRevokeMultiSig \r\n * can only be initiated by the 3rd Signer AKA The Custodian \r\n * \r\n * changeStoreMultiSig & transferMultiSig can only be initiated by the 2nd Signer\r\n * AKA The Backup\r\n *\r\n * Data Formats\r\n * ============\r\n *\r\n * The signature is created with ethereumjs-util.ecsign(operationHash).\r\n * Like the eth_sign RPC call, it packs the values as a 65-byte array of [r, s, v].\r\n * Unlike eth_sign, the message is not prefixed.\r\n *\r\n * The operationHash the result of keccak256(prefix, hash, expireTime, sequenceId).\r\n * For Issue transactions, `prefix` is \"ISSUE\".\r\n * For Bulk Issue transactions, `prefix` is \"BULKISSUE\".\r\n * For Revoke transaction, `prefix` is \"REVOKE\".\r\n * For Bulk Revoke transaction, `prefix` is \"BULKREVOKE\".\r\n * For Transfer transaction, 'prefix' is \"TRANSFER\"\r\n * For Change transaction, 'prefix' is \"Change\"\r\n *\r\n */\r\ncontract DocumentMultiSigWalletCertStore {\r\n    // Events\r\n    event Issued(address msgSender, address otherSigner, bytes32 operation, bytes32 hash);\r\n    \r\n    event BulkIssue(address msgSender, address otherSigner, bytes32 operation, bytes32[] hashes);\r\n        \r\n    event Revoked(address msgSender, address otherSigner, bytes32 operation, bytes32 hash);\r\n    \r\n    event BulkRevoke(address msgSender, address otherSigner, bytes32 operation, bytes32[] hashes);\r\n        \r\n    event Transferred(address msgSender, address otherSigner, address newOwner);\r\n    \r\n    event Change(address msgSender, address otherSigner, address newStore);\r\n\r\n    // Public fields\r\n    address[] public signers; // The addresses that can co-sign transactions on the wallet\r\n    DocumentStore public documentStore; //DocumentStore Contract\r\n    \r\n    /**\r\n     * Constructor\r\n     * ============\r\n     * \r\n     * Deploys a new DocumentMultiSigWalletCertStore contract that also deplots a\r\n     * documentStore contract\r\n     * \r\n     * Takes in an array of 3 signers that will be used to approve transactions\r\n     * Takes in a string that will be used to label the DocumentStore Contract\r\n     * \r\n     */\r\n    constructor(address[] memory _signers, string memory _name) public {\r\n        if (_signers.length != 3) {\r\n            // Number of signers submitted is not 3\r\n            revert();\r\n        }\r\n        signers = _signers;\r\n        \r\n        documentStore = new DocumentStore(_name);\r\n    }\r\n\r\n    // Internal fields\r\n    uint constant SEQUENCE_ID_WINDOW_SIZE = 10;\r\n    uint[10] recentSequenceIds;\r\n\r\n    /**\r\n     * Determine if an address is a signer on this wallet\r\n     * @param signer address to check\r\n     * returns boolean indicating whether address is signer or not\r\n     */\r\n    function isSigner(address signer) public view returns (bool) {\r\n        // Iterate through all signers on the wallet and checks if the signer passed in is one of them\r\n        for (uint i = 0; i < signers.length; i++) {\r\n            if (signers[i] == signer) {\r\n                return true; //Signer passed in is a signer on the wallet\r\n            }\r\n        }\r\n        return false; //Signer passed in is NOT a signer on the wallet\r\n    }\r\n\r\n    /**\r\n     * Modifier that will execute internal code block only if the sender is an authorized signer on this wallet\r\n     */\r\n    modifier onlySigner {\r\n        if (!isSigner(msg.sender)) {\r\n            revert(); //Senders is not a signer\r\n        }\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Modifier that will execute internal code block only if the sender is the Custodian\r\n     */\r\n    modifier onlyCustodian {\r\n        if (!(msg.sender == signers[2])) {\r\n            revert(); //Senders is not a signer\r\n        }\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Modifier that will execute internal code block only if the sender is the Backup\r\n     */\r\n    modifier onlyBackup {\r\n        if (!(msg.sender == signers[1])) {\r\n            revert(); //Senders is not a signer\r\n        }\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Modifier that will execute internal code block only if the sender is an initiator\r\n     */\r\n    modifier onlyInitiators {\r\n        if ((msg.sender != signers[1]) && (msg.sender != signers[2])) {\r\n            revert(); //Senders is not a signer\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Fallback function. Is called when a transaction is received without calling a method\r\n     */\r\n    function() external {\r\n        revert(); // Reject any accidental Ether transfer\r\n    }\r\n    \r\n    /**\r\n     * Execute a multi-signature issue transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\r\n     *\r\n     * @param hash the certificate batch's hash that will be appended to the blockchain\r\n     * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n     * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n     * @param signature second signer's signature\r\n     */\r\n    function issueMultiSig(\r\n        bytes32 hash,\r\n        uint expireTime,\r\n        uint sequenceId,\r\n        bytes memory signature\r\n        ) public onlyCustodian {\r\n            bytes32 operationHash = keccak256(abi.encodePacked(\"ISSUE\", hash, expireTime, sequenceId));\r\n            \r\n            address otherSigner = verifyMultiSig(operationHash, signature, expireTime, sequenceId);\r\n            \r\n            documentStore.issue(hash);\r\n            \r\n            emit Issued(msg.sender, otherSigner, operationHash, hash);\r\n        }\r\n        \r\n    /**\r\n     * Execute a multi-signature bulk issue transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\r\n     *\r\n     * @param hashes an array of certificate batch hashes that will be appended to the blockchain\r\n     * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n     * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n     * @param signature second signer's signature\r\n     */\r\n    function bulkIssueMultiSig(\r\n        bytes32[] memory hashes,\r\n        uint expireTime,\r\n        uint sequenceId,\r\n        bytes memory signature\r\n        ) public onlyCustodian {\r\n            bytes32 operationHash = keccak256(abi.encodePacked(\"BULKISSUE\", hashes, expireTime, sequenceId));\r\n            \r\n            address otherSigner = verifyMultiSig(operationHash, signature, expireTime, sequenceId);\r\n            \r\n            documentStore.bulkIssue(hashes);\r\n            \r\n            emit BulkIssue(msg.sender, otherSigner, operationHash, hashes);\r\n        }\r\n        \r\n    /**\r\n     * Execute a multi-signature revoke transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\r\n     *\r\n     * @param hash the certificate's hash that will be revoked on the blockchain\r\n     * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n     * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n     * @param signature second signer's signature\r\n     */\r\n    function revokeMultiSig(\r\n        bytes32 hash,\r\n        uint expireTime,\r\n        uint sequenceId,\r\n        bytes memory signature\r\n        ) public onlyCustodian {\r\n            bytes32 operationHash = keccak256(abi.encodePacked(\"REVOKE\", hash, expireTime, sequenceId));\r\n            \r\n            address otherSigner = verifyMultiSig(operationHash, signature, expireTime, sequenceId);\r\n            \r\n            documentStore.revoke(hash);\r\n            \r\n            emit Revoked(msg.sender, otherSigner, operationHash, hash);\r\n        }\r\n        \r\n     /**\r\n     * Execute a multi-signature bulk revoke transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\r\n     *\r\n     * @param hashes an array of certificate hashes that will be revoked on the blockchain\r\n     * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n     * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n     * @param signature second signer's signature\r\n     */\r\n    function bulkRevokeMultiSig(\r\n        bytes32[] memory hashes,\r\n        uint expireTime,\r\n        uint sequenceId,\r\n        bytes memory signature\r\n        ) public onlyCustodian {\r\n            bytes32 operationHash = keccak256(abi.encodePacked(\"BULKREVOKE\", hashes, expireTime, sequenceId));\r\n            \r\n            address otherSigner = verifyMultiSig(operationHash, signature, expireTime, sequenceId);\r\n            \r\n            documentStore.bulkRevoke(hashes);\r\n            \r\n            emit BulkRevoke(msg.sender, otherSigner, operationHash, hashes);\r\n        }\r\n    \r\n    /**\r\n     * Execute a multi-signature transfer transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\r\n     * This transaction transfers the ownership of the certificate store to a new owner.\r\n     *\r\n     * @param newOwner the new owner's address\r\n     * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n     * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n     * @param signature second signer's signature\r\n     */    \r\n    function transferMultiSig(\r\n        address newOwner,\r\n        uint expireTime,\r\n        uint sequenceId,\r\n        bytes memory signature\r\n        ) public onlyBackup {\r\n            bytes32 operationHash = keccak256(abi.encodePacked(\"TRANSFER\", newOwner, expireTime, sequenceId));\r\n            \r\n            address otherSigner = verifyMultiSig(operationHash, signature, expireTime, sequenceId);\r\n            \r\n            documentStore.transferOwnership(newOwner);\r\n            \r\n            emit Transferred(msg.sender, otherSigner, newOwner);\r\n        }\r\n    \r\n    /**\r\n     * Execute a multi-signature change transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\r\n     * This transaction changes the address of the DocumentStore on this wallet contract.\r\n     *\r\n     * @param newStore the new owner's address\r\n     * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n     * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n     * @param signature second signer's signature\r\n     */  \r\n    function changeStoreMultiSig(\r\n        address newStore,\r\n        uint expireTime,\r\n        uint sequenceId,\r\n        bytes memory signature\r\n        ) public onlyBackup {\r\n            bytes32 operationHash = keccak256(abi.encodePacked(\"CHANGE\", newStore, expireTime, sequenceId));\r\n            \r\n            address otherSigner = verifyMultiSig(operationHash, signature, expireTime, sequenceId);\r\n            \r\n            documentStore = DocumentStore(newStore);\r\n            \r\n            emit Change(msg.sender, otherSigner, newStore);\r\n        }\r\n        \r\n    /**\r\n     * Do common multisig verification for both Issue and Revoke transactions\r\n     *\r\n     * @param operationHash keccak256(prefix, hash, expireTime, sequenceId)\r\n     * @param signature second signer's signature\r\n     * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n     * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n     * returns address that has created the signature\r\n     */\r\n    function verifyMultiSig(\r\n        bytes32 operationHash,\r\n        bytes memory signature,\r\n        uint expireTime,\r\n        uint sequenceId\r\n        ) private returns (address) {\r\n    \r\n            address otherSigner = recoverAddressFromSignature(operationHash, signature);\r\n            \r\n            // Verify that the transaction has not expired\r\n            if (expireTime < block.timestamp) {\r\n                // Transaction expired\r\n                revert();\r\n            }\r\n    \r\n            // Try to insert the sequence ID. Will revert if the sequence id was invalid\r\n            tryInsertSequenceId(sequenceId);\r\n        \r\n            if (!isSigner(otherSigner)) {\r\n                // Other signer not on this wallet or operation does not match arguments\r\n                revert();\r\n            }\r\n            if (otherSigner == msg.sender) {\r\n                // Cannot approve own transaction\r\n                revert();\r\n            }\r\n        \r\n            return otherSigner;\r\n        }\r\n    \r\n    /**\r\n     * Gets signer's address using ecrecover\r\n     * @param operationHash see Data Formats\r\n     * @param signature see Data Formats\r\n     * returns address recovered from the signature\r\n     */\r\n    function recoverAddressFromSignature(\r\n        bytes32 operationHash,\r\n        bytes memory signature\r\n        ) private pure returns (address) {\r\n            if (signature.length != 65) {\r\n            revert();\r\n            }\r\n        // We need to unpack the signature, which is given as an array of 65 bytes (like eth.sign)\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := and(mload(add(signature, 65)), 255)\r\n        }\r\n        if (v < 27) {\r\n            v += 27; // Ethereum versions are 27 or 28 as opposed to 0 or 1 which is submitted by some signing libs\r\n        }\r\n        return ecrecover(operationHash, v, r, s);\r\n    }\r\n        \r\n    /**\r\n     * Verify that the sequence id has not been used before and inserts it. Throws if the sequence ID was not accepted.\r\n     * We collect a window of up to 10 recent sequence ids, and allow any sequence id that is not in the window and\r\n     * greater than the minimum element in the window.\r\n     * @param sequenceId to insert into array of stored ids\r\n     */\r\n    function tryInsertSequenceId(uint sequenceId) private onlyInitiators {\r\n        // Keep a pointer to the lowest value element in the window\r\n        uint lowestValueIndex = 0;\r\n        for (uint i = 0; i < SEQUENCE_ID_WINDOW_SIZE; i++) {\r\n            if (recentSequenceIds[i] == sequenceId) {\r\n                // This sequence ID has been used before. Disallow!\r\n                revert();\r\n            }\r\n            if (recentSequenceIds[i] < recentSequenceIds[lowestValueIndex]) {\r\n                lowestValueIndex = i;\r\n            }\r\n        }\r\n        if (sequenceId < recentSequenceIds[lowestValueIndex]) {\r\n            // The sequence ID being used is lower than the lowest value in the window\r\n            // so we cannot accept it as it may have been used before\r\n            revert();\r\n        }\r\n        if (sequenceId > (recentSequenceIds[lowestValueIndex] + 10000)) {\r\n            // Block sequence IDs which are much higher than the lowest value\r\n            // This prevents people blocking the contract by using very large sequence IDs quickly\r\n            revert();\r\n        }\r\n        recentSequenceIds[lowestValueIndex] = sequenceId;\r\n    }\r\n    \r\n    /**\r\n     * Gets the next available sequence ID for signing when using executeAndConfirm\r\n     * returns the sequenceId one higher than the highest currently stored\r\n     */\r\n    function getNextSequenceId() public view returns (uint) {\r\n        uint highestSequenceId = 0;\r\n        for (uint i = 0; i < SEQUENCE_ID_WINDOW_SIZE; i++) {\r\n            if (recentSequenceIds[i] > highestSequenceId) {\r\n                highestSequenceId = recentSequenceIds[i];\r\n            }\r\n        }\r\n    return highestSequenceId + 1;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"issueMultiSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"documentStore\",\"outputs\":[{\"internalType\":\"contract DocumentStore\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"revokeMultiSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStore\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"changeStoreMultiSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"bulkIssueMultiSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferMultiSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextSequenceId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"bulkRevokeMultiSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"}],\"name\":\"BulkIssue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Revoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"}],\"name\":\"BulkRevoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"Transferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStore\",\"type\":\"address\"}],\"name\":\"Change\",\"type\":\"event\"}]","ContractName":"DocumentMultiSigWalletCertStore","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000ace66a41a60ce4190222be54806d6fc2096a9023000000000000000000000000738f291fe11518413d8f205adc9c0fe7879c06df00000000000000000000000001b2156c5bee35503923c9b712d7c08b88e828f9000000000000000000000000000000000000000000000000000000000000000b534d552041636164656d79000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://c706e26f642631b93768ca6a27f7bc230f5e329b85e6f3f562fad021e3873b09"}]}