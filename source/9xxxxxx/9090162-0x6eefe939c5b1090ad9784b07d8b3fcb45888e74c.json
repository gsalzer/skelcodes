{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\ninterface IFundRA {\n  function balanceOf(address _owner) external view returns (uint256);\n  function balanceOfAt(address _owner, uint256 _blockNumber) external view returns (uint256);\n  function totalSupplyAt(uint256 _blockNumber) external view returns (uint256);\n}\n\ninterface IACL {\n  function setRole(bytes32 _role, address _candidate, bool _allow) external;\n  function hasRole(address _candidate, bytes32 _role) external view returns (bool);\n}\n\ninterface IFundRegistry {\n  function setContract(bytes32 _key, address _value) external;\n\n  // GETTERS\n  function getContract(bytes32 _key) external view returns (address);\n  function getGGRAddress() external view returns (address);\n  function getPPGRAddress() external view returns (address);\n  function getACL() external view returns (IACL);\n  function getStorageAddress() external view returns (address);\n  function getMultiSigAddress() external view returns (address payable);\n  function getRAAddress() external view returns (address);\n  function getControllerAddress() external view returns (address);\n  function getProposalManagerAddress() external view returns (address);\n}\n\ncontract MultiSigWallet {\n\n    /*\n     *  Events\n     */\n    event Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint required);\n\n    /*\n     *  Constants\n     */\n    uint constant public MAX_OWNER_COUNT = 50;\n\n    /*\n     *  Storage\n     */\n    mapping (uint => Transaction) public transactions;\n    mapping (uint => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    address[] public owners;\n    uint public required;\n    uint public transactionCount;\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier onlyWallet() {\n        require(msg.sender == address(this));\n        _;\n    }\n\n    modifier ownerDoesNotExist(address owner) {\n        require(!isOwner[owner]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require(isOwner[owner]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require(transactions[transactionId].destination != address(0));\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require(confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require(!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require(!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier validRequirement(uint ownerCount, uint _required) {\n        require(ownerCount <= MAX_OWNER_COUNT\n            && _required <= ownerCount\n            && _required != 0\n            && ownerCount != 0);\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function()\n        external\n        payable\n    {\n        if (msg.value > 0)\n            emit Deposit(msg.sender, msg.value);\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\n    /// @param _owners List of initial owners.\n    /// @param _required Number of required confirmations.\n    constructor(address[] memory _owners, uint _required)\n        public\n        validRequirement(_owners.length, _required)\n    {\n        for (uint i=0; i<_owners.length; i++) {\n            require(!isOwner[_owners[i]] && _owners[i] != address(0));\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        public\n        onlyWallet\n        ownerDoesNotExist(owner)\n        notNull(owner)\n        validRequirement(owners.length + 1, required)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n        public\n        onlyWallet\n        ownerExists(owner)\n    {\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param newOwner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        public\n        onlyWallet\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        emit OwnerRemoval(owner);\n        emit OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint _required)\n        public\n        onlyWallet\n        validRequirement(owners.length, _required)\n    {\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return Returns transaction ID.\n    function submitTransaction(address destination, uint value, bytes memory data)\n        public\n        returns (uint transactionId)\n    {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        emit Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n                emit Execution(transactionId);\n            else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n\n    // call has been separated into its own function in order to take advantage\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\n    function external_call(address destination, uint value, uint dataLength, bytes memory data) private returns (bool) {\n        bool result;\n        assembly {\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n            result := call(\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n                destination,\n                value,\n                d,\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n                x,\n                0                  // Output is ignored, therefore the output size is zero\n            )\n        }\n        return result;\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint transactionId)\n        public\n        view\n        returns (bool)\n    {\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return Returns transaction ID.\n    function addTransaction(address destination, uint value, bytes memory data)\n        internal\n        notNull(destination)\n        returns (uint transactionId)\n    {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Number of confirmations.\n    function getConfirmationCount(uint transactionId)\n        public\n        view\n        returns (uint count)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        view\n        returns (uint count)\n    {\n        for (uint i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n                count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Returns array of owner addresses.\n    function getConfirmations(uint transactionId)\n        public\n        view\n        returns (address[] memory _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i=0; i<count; i++)\n            _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Returns array of transaction IDs.\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n        public\n        view\n        returns (uint[] memory _transactionIds)\n    {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n            {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint[](to - from);\n        for (i=from; i<to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}\n\ncontract FundMultiSig is MultiSigWallet {\n  event NewOwnerSet(uint256 required, uint256 total);\n\n  bytes32 public constant ROLE_OWNER_MANAGER = bytes32(\"owner_manager\");\n  address public constant ETH_CONTRACT_ADDRESS = address(1);\n\n  IFundRegistry public fundRegistry;\n\n  constructor(\n    address[] memory _initialOwners,\n    uint256 _required,\n    IFundRegistry _fundRegistry\n  )\n    public\n    MultiSigWallet(_initialOwners, _required)\n  {\n    fundRegistry = _fundRegistry;\n  }\n\n  modifier forbidden() {\n    assert(false);\n    _;\n  }\n\n  modifier onlyRole(bytes32 _role) {\n    require(fundRegistry.getACL().hasRole(msg.sender, _role), \"Invalid role\");\n\n    _;\n  }\n\n  function addOwner(address owner) public forbidden {}\n  function removeOwner(address owner) public forbidden {}\n  function replaceOwner(address owner, address newOwner) public forbidden {}\n  function changeRequirement(uint _required) public forbidden {}\n\n  function setOwners(address[] calldata _newOwners, uint256 _required) external onlyRole(ROLE_OWNER_MANAGER) {\n    require(_required <= _newOwners.length, \"Required too big\");\n    require(_required > 0, \"Required too low\");\n    require(_fundStorage().areMembersValid(_newOwners), \"Not all members are valid\");\n\n    owners = _newOwners;\n    required = _required;\n\n    emit NewOwnerSet(required, _newOwners.length);\n  }\n\n  // call has been separated into its own function in order to take advantage\n  // of the Solidity's code generator to produce a loop that copies tx.data into memory.\n  // solium-disable-next-line mixedcase\n  function external_call(address destination, uint value, uint dataLength, bytes memory data) private returns (bool) {\n    beforeTransactionHook(destination, value, dataLength, data);\n\n    bool result;\n    assembly {\n        let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n        let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n        result := call(\n            sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n                               // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n                               // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n            destination,\n            value,\n            d,\n            dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n            x,\n            0                  // Output is ignored, therefore the output size is zero\n        )\n    }\n    return result;\n  }\n\n  function beforeTransactionHook(address _destination, uint _value, uint _dataLength, bytes memory _data) private {\n    if (_value > 0) {\n      _fundStorage().handleMultiSigTransaction(ETH_CONTRACT_ADDRESS, _value);\n    }\n\n    (bool active,) = _fundStorage().periodLimits(_destination);\n\n    // If a withdrawal limit exists for this t_destination\n    if (active) {\n      uint256 erc20Value;\n\n      assembly {\n        let code := mload(add(_data, 0x20))\n        code := and(code, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n        switch code\n        // transfer(address,uint256)\n        case 0xa9059cbb00000000000000000000000000000000000000000000000000000000 {\n          erc20Value := mload(add(_data, 0x44))\n        }\n        default {\n          // Methods other than transfer are prohibited for ERC20 contracts\n          revert(0, 0)\n        }\n      }\n\n      if (erc20Value == 0) {\n        return;\n      }\n\n      _fundStorage().handleMultiSigTransaction(_destination, erc20Value);\n    }\n  }\n\n  function _fundStorage() internal view returns (IAbstractFundStorage) {\n    return IAbstractFundStorage(fundRegistry.getStorageAddress());\n  }\n}\n\ninterface IAbstractFundStorage {\n  function setConfigValue(bytes32 _key, bytes32 _value) external;\n\n  function setDefaultProposalConfig(\n    uint256 _support,\n    uint256 _quorum,\n    uint256 _timeout\n  )\n    external;\n\n  function setProposalConfig(\n    bytes32 _marker,\n    uint256 _support,\n    uint256 _quorum,\n    uint256 _timeout\n  )\n    external;\n\n  function addCommunityApp(\n    address _contract,\n    bytes32 _type,\n    bytes32 _abiIpfsHash,\n    string calldata _dataLink\n  )\n    external;\n  function removeCommunityApp(address _contract) external;\n\n  function addProposalMarker(\n    bytes4 _methodSignature,\n    address _destination,\n    address _proposalManager,\n    bytes32 _name,\n    string calldata _dataLink\n  )\n    external;\n  function removeProposalMarker(bytes32 _marker) external;\n  function replaceProposalMarker(bytes32 _oldMarker, bytes32 _newMethodSignature, address _newDestination) external;\n\n  function addFundRule(bytes32 _ipfsHash, string calldata _dataLink) external;\n\n  function addFeeContract(address _feeContract) external;\n\n  function removeFeeContract(address _feeContract) external;\n\n  function setMemberIdentification(address _member, bytes32 _identificationHash) external;\n\n  function disableFundRule(uint256 _id) external;\n\n  function setNameAndDataLink(\n    string calldata _name,\n    string calldata _dataLink\n  )\n    external;\n\n  function setMultiSigManager(\n    bool _active,\n    address _manager,\n    string calldata _name,\n    string calldata _dataLink\n  )\n    external;\n\n  function setPeriodLimit(bool _active, address _erc20Contract, uint256 _amount) external;\n\n  function handleMultiSigTransaction(\n    address _erc20Contract,\n    uint256 _amount\n  )\n    external;\n\n  // GETTERS\n  function membersIdentification(address _member) external view returns(bytes32);\n\n  function getProposalVotingConfig(bytes32 _key) external view returns (uint256 support, uint256 quorum, uint256 timeout);\n\n  function getThresholdMarker(address _destination, bytes calldata _data) external pure returns (bytes32 marker);\n\n  function config(bytes32 _key) external view returns (bytes32);\n\n  function getCommunityApps() external view returns (address[] memory);\n\n  function getActiveFundRules() external view returns (uint256[] memory);\n\n  function getActiveFundRulesCount() external view returns (uint256);\n\n  function communityAppsInfo(\n    address _contract\n  )\n    external\n    view\n    returns (\n      bytes32 appType,\n      bytes32 abiIpfsHash,\n      string memory dataLink\n    );\n\n  function proposalMarkers(\n    bytes32 _marker\n  )\n    external\n    view\n    returns (\n      address proposalManager,\n      address destination,\n      bytes32 name,\n      string memory dataLink\n    );\n\n  function areMembersValid(address[] calldata _members) external view returns (bool);\n\n  function getActiveMultisigManagers() external view returns (address[] memory);\n\n  function getActiveMultisigManagersCount() external view returns (uint256);\n\n  function getActivePeriodLimits() external view returns (address[] memory);\n\n  function getActivePeriodLimitsCount() external view returns (uint256);\n\n  function getFeeContracts() external view returns (address[] memory);\n\n  function getFeeContractCount() external view returns (uint256);\n\n  function multiSigManagers(address _manager)\n    external\n    view\n    returns (\n      bool active,\n      string memory managerName,\n      string memory dataLink\n    );\n\n  function periodLimits(address _erc20Contract) external view returns (bool active, uint256 amount);\n  function getCurrentPeriod() external view returns (uint256);\n}\n\ncontract Initializable {\n\n  /**\n   * @dev Indicates if the contract has been initialized.\n   */\n  bool public initialized;\n\n  /**\n   * @dev Modifier to use in the initialization function of a contract.\n   */\n  modifier isInitializer() {\n    require(!initialized, \"Contract instance has already been initialized\");\n    _;\n    initialized = true;\n  }\n}\n\nlibrary ArraySet {\n  struct AddressSet {\n    address[] array;\n    mapping(address => uint256) map;\n    mapping(address => bool) exists;\n  }\n\n  struct Bytes32Set {\n    bytes32[] array;\n    mapping(bytes32 => uint256) map;\n    mapping(bytes32 => bool) exists;\n  }\n\n  // AddressSet\n  function add(AddressSet storage _set, address _v) internal {\n    require(_set.exists[_v] == false, \"Element already exists\");\n\n    _set.map[_v] = _set.array.length;\n    _set.exists[_v] = true;\n    _set.array.push(_v);\n  }\n\n  function addSilent(AddressSet storage _set, address _v) internal returns (bool) {\n    if (_set.exists[_v] == true) {\n      return false;\n    }\n\n    _set.map[_v] = _set.array.length;\n    _set.exists[_v] = true;\n    _set.array.push(_v);\n\n    return true;\n  }\n\n  function remove(AddressSet storage _set, address _v) internal {\n    require(_set.array.length > 0, \"Array is empty\");\n    require(_set.exists[_v] == true, \"Element doesn't exist\");\n\n    _remove(_set, _v);\n  }\n\n  function removeSilent(AddressSet storage _set, address _v) internal returns (bool) {\n    if (_set.exists[_v] == false) {\n      return false;\n    }\n\n    _remove(_set, _v);\n    return true;\n  }\n\n  function _remove(AddressSet storage _set, address _v) internal {\n    uint256 lastElementIndex = _set.array.length - 1;\n    uint256 currentElementIndex = _set.map[_v];\n    address lastElement = _set.array[lastElementIndex];\n\n    _set.array[currentElementIndex] = lastElement;\n    delete _set.array[lastElementIndex];\n\n    _set.array.length = _set.array.length - 1;\n    delete _set.map[_v];\n    delete _set.exists[_v];\n    _set.map[lastElement] = currentElementIndex;\n  }\n\n  function clear(AddressSet storage _set) internal {\n    for (uint256 i = 0; i < _set.array.length; i++) {\n      address v = _set.array[i];\n      delete _set.map[v];\n      _set.exists[v] = false;\n    }\n\n    delete _set.array;\n  }\n\n  function has(AddressSet storage _set, address _v) internal view returns (bool) {\n    return _set.exists[_v];\n  }\n\n  function elements(AddressSet storage _set) internal view returns (address[] storage) {\n    return _set.array;\n  }\n\n  function size(AddressSet storage _set) internal view returns (uint256) {\n    return _set.array.length;\n  }\n\n  function isEmpty(AddressSet storage _set) internal view returns (bool) {\n    return _set.array.length == 0;\n  }\n\n  // Bytes32Set\n  function add(Bytes32Set storage _set, bytes32 _v) internal {\n    require(_set.exists[_v] == false, \"Element already exists\");\n\n    _add(_set, _v);\n  }\n\n  function addSilent(Bytes32Set storage _set, bytes32 _v) internal returns (bool) {\n    if (_set.exists[_v] == true) {\n      return false;\n    }\n\n    _add(_set, _v);\n\n    return true;\n  }\n\n  function _add(Bytes32Set storage _set, bytes32 _v) internal {\n    _set.map[_v] = _set.array.length;\n    _set.exists[_v] = true;\n    _set.array.push(_v);\n  }\n\n  function remove(Bytes32Set storage _set, bytes32 _v) internal {\n    require(_set.array.length > 0, \"Array is empty\");\n    require(_set.exists[_v] == true, \"Element doesn't exist\");\n\n    _remove(_set, _v);\n  }\n\n  function removeSilent(Bytes32Set storage _set, bytes32 _v) internal returns (bool) {\n    if (_set.exists[_v] == false) {\n      return false;\n    }\n\n    _remove(_set, _v);\n    return true;\n  }\n\n  function _remove(Bytes32Set storage _set, bytes32 _v) internal {\n    uint256 lastElementIndex = _set.array.length - 1;\n    uint256 currentElementIndex = _set.map[_v];\n    bytes32 lastElement = _set.array[lastElementIndex];\n\n    _set.array[currentElementIndex] = lastElement;\n    delete _set.array[lastElementIndex];\n\n    _set.array.length = _set.array.length - 1;\n    delete _set.map[_v];\n    delete _set.exists[_v];\n    _set.map[lastElement] = currentElementIndex;\n  }\n\n  function clear(Bytes32Set storage _set) internal {\n    for (uint256 i = 0; i < _set.array.length; i++) {\n      _set.exists[_set.array[i]] = false;\n    }\n\n    delete _set.array;\n  }\n\n  function has(Bytes32Set storage _set, bytes32 _v) internal view returns (bool) {\n    return _set.exists[_v];\n  }\n\n  function elements(Bytes32Set storage _set) internal view returns (bytes32[] storage) {\n    return _set.array;\n  }\n\n  function size(Bytes32Set storage _set) internal view returns (uint256) {\n    return _set.array.length;\n  }\n\n  function isEmpty(Bytes32Set storage _set) internal view returns (bool) {\n    return _set.array.length == 0;\n  }\n\n  ///////////////////////////// Uint256Set /////////////////////////////////////////\n  struct Uint256Set {\n    uint256[] array;\n    mapping(uint256 => uint256) map;\n    mapping(uint256 => bool) exists;\n  }\n\n  function add(Uint256Set storage _set, uint256 _v) internal {\n    require(_set.exists[_v] == false, \"Element already exists\");\n\n    _add(_set, _v);\n  }\n\n  function addSilent(Uint256Set storage _set, uint256 _v) internal returns (bool) {\n    if (_set.exists[_v] == true) {\n      return false;\n    }\n\n    _add(_set, _v);\n\n    return true;\n  }\n\n  function _add(Uint256Set storage _set, uint256 _v) internal {\n    _set.map[_v] = _set.array.length;\n    _set.exists[_v] = true;\n    _set.array.push(_v);\n  }\n\n  function remove(Uint256Set storage _set, uint256 _v) internal {\n    require(_set.array.length > 0, \"Array is empty\");\n    require(_set.exists[_v] == true, \"Element doesn't exist\");\n\n    _remove(_set, _v);\n  }\n\n  function removeSilent(Uint256Set storage _set, uint256 _v) internal returns (bool) {\n    if (_set.exists[_v] == false) {\n      return false;\n    }\n\n    _remove(_set, _v);\n    return true;\n  }\n\n  function _remove(Uint256Set storage _set, uint256 _v) internal {\n    uint256 lastElementIndex = _set.array.length - 1;\n    uint256 currentElementIndex = _set.map[_v];\n    uint256 lastElement = _set.array[lastElementIndex];\n\n    _set.array[currentElementIndex] = lastElement;\n    delete _set.array[lastElementIndex];\n\n    _set.array.length = _set.array.length - 1;\n    delete _set.map[_v];\n    delete _set.exists[_v];\n    _set.map[lastElement] = currentElementIndex;\n  }\n\n  function clear(Uint256Set storage _set) internal {\n    for (uint256 i = 0; i < _set.array.length; i++) {\n      _set.exists[_set.array[i]] = false;\n    }\n\n    delete _set.array;\n  }\n\n  function has(Uint256Set storage _set, uint256 _v) internal view returns (bool) {\n    return _set.exists[_v];\n  }\n\n  function elements(Uint256Set storage _set) internal view returns (uint256[] storage) {\n    return _set.array;\n  }\n\n  function size(Uint256Set storage _set) internal view returns (uint256) {\n    return _set.array.length;\n  }\n\n  function isEmpty(Uint256Set storage _set) internal view returns (bool) {\n    return _set.array.length == 0;\n  }\n}\n\ncontract FundProposalManager is Initializable {\n  using SafeMath for uint256;\n  using Counters for Counters.Counter;\n  using ArraySet for ArraySet.AddressSet;\n  using ArraySet for ArraySet.Uint256Set;\n\n  // 100% == 100 ether\n  uint256 public constant ONE_HUNDRED_PCT = 100 ether;\n\n  event NewProposal(uint256 indexed proposalId, address indexed proposer, bytes32 indexed marker);\n  event AyeProposal(uint256 indexed proposalId, address indexed voter);\n  event NayProposal(uint256 indexed proposalId, address indexed voter);\n\n  event Approved(uint256 ayeShare, uint256 support, uint256 indexed proposalId, bytes32 indexed marker);\n\n  struct ProposalVoting {\n    uint256 creationBlock;\n    uint256 creationTotalSupply;\n    uint256 createdAt;\n    uint256 timeoutAt;\n    uint256 requiredSupport;\n    uint256 minAcceptQuorum;\n    uint256 totalAyes;\n    uint256 totalNays;\n    mapping(address => Choice) participants;\n    ArraySet.AddressSet ayes;\n    ArraySet.AddressSet nays;\n  }\n\n  struct Proposal {\n    ProposalStatus status;\n    address creator;\n    address destination;\n    uint256 value;\n    bytes32 marker;\n    bytes data;\n    string dataLink;\n    bytes response;\n  }\n\n  IFundRegistry public fundRegistry;\n  Counters.Counter internal idCounter;\n\n  mapping(uint256 => Proposal) public proposals;\n  mapping(uint256 => address) private _proposalToSender;\n\n  mapping(bytes32 => ArraySet.Uint256Set) private _activeProposals;\n  mapping(address => mapping(bytes32 => ArraySet.Uint256Set)) private _activeProposalsBySender;\n\n  mapping(bytes32 => uint256[]) private _approvedProposals;\n  mapping(bytes32 => uint256[]) private _rejectedProposals;\n\n  mapping(uint256 => ProposalVoting) internal _proposalVotings;\n\n  enum ProposalStatus {\n    NULL,\n    ACTIVE,\n    APPROVED,\n    EXECUTED,\n    REJECTED\n  }\n\n  enum Choice {\n    PENDING,\n    AYE,\n    NAY\n  }\n\n  modifier onlyMember() {\n    require(_fundRA().balanceOf(msg.sender) > 0, \"Not valid member\");\n\n    _;\n  }\n\n  constructor() public {\n  }\n\n  function initialize(IFundRegistry _fundRegistry) external isInitializer {\n    fundRegistry = _fundRegistry;\n  }\n\n  function propose(\n    address _destination,\n    uint256 _value,\n    bytes calldata _data,\n    string calldata _dataLink\n  )\n    external\n    onlyMember\n  {\n    idCounter.increment();\n    uint256 id = idCounter.current();\n\n    Proposal storage p = proposals[id];\n    p.creator = msg.sender;\n    p.destination = _destination;\n    p.value = _value;\n    p.data = _data;\n    p.dataLink = _dataLink;\n    p.marker = _fundStorage().getThresholdMarker(_destination, _data);\n\n    p.status = ProposalStatus.ACTIVE;\n    _onNewProposal(id);\n\n    emit NewProposal(id, msg.sender, p.marker);\n  }\n\n  function aye(uint256 _proposalId) external {\n    require(proposals[_proposalId].status == ProposalStatus.ACTIVE, \"Proposal isn't active\");\n\n    _aye(_proposalId, msg.sender);\n  }\n\n  function nay(uint256 _proposalId) external {\n    require(proposals[_proposalId].status == ProposalStatus.ACTIVE, \"Proposal isn't active\");\n\n    _nay(_proposalId, msg.sender);\n  }\n\n  // permissionLESS\n  function triggerApprove(uint256 _proposalId) external {\n    Proposal storage p = proposals[_proposalId];\n    ProposalVoting storage pv = _proposalVotings[_proposalId];\n\n    // Voting is not executed yet\n    require(p.status == ProposalStatus.ACTIVE, \"Proposal isn't active\");\n\n    // Voting timeout has passed\n    require(pv.timeoutAt < block.timestamp, \"Timeout hasn't been passed\");\n\n    uint256 support = getCurrentSupport(_proposalId);\n\n    // Has enough support?\n    require(support >= pv.requiredSupport, \"Support hasn't been reached\");\n\n    uint256 ayeShare = getAyeShare(_proposalId);\n\n    // Has min quorum?\n    require(ayeShare >= pv.minAcceptQuorum, \"MIN aye quorum hasn't been reached\");\n\n    _activeProposals[p.marker].remove(_proposalId);\n    _activeProposalsBySender[_proposalToSender[_proposalId]][p.marker].remove(_proposalId);\n    _approvedProposals[p.marker].push(_proposalId);\n\n    p.status = ProposalStatus.APPROVED;\n    emit Approved(ayeShare, support, _proposalId, p.marker);\n\n    execute(_proposalId);\n  }\n\n  function execute(uint256 _proposalId) public {\n    Proposal storage p = proposals[_proposalId];\n\n    require(p.status == ProposalStatus.APPROVED, \"Proposal isn't APPROVED\");\n\n    p.status = ProposalStatus.EXECUTED;\n\n    (bool ok, bytes memory response) = address(p.destination)\n    .call\n    .value(p.value)\n    .gas(gasleft().sub(50000))(p.data);\n\n    if (ok == false) {\n      p.status = ProposalStatus.APPROVED;\n    }\n\n    p.response = response;\n  }\n\n  // INTERNAL\n\n  function _aye(uint256 _proposalId, address _voter) internal {\n    ProposalVoting storage pV = _proposalVotings[_proposalId];\n    uint256 reputation = reputationOf(_voter, pV.creationBlock);\n\n    if (pV.participants[_voter] == Choice.NAY) {\n      pV.nays.remove(_voter);\n      pV.totalNays = pV.totalNays.sub(reputation);\n    }\n\n    pV.participants[_voter] = Choice.AYE;\n    pV.ayes.add(_voter);\n    pV.totalAyes = pV.totalAyes.add(reputation);\n\n    emit AyeProposal(_proposalId, _voter);\n  }\n\n  function _nay(uint256 _proposalId, address _voter) internal {\n    ProposalVoting storage pV = _proposalVotings[_proposalId];\n    uint256 reputation = reputationOf(_voter, pV.creationBlock);\n\n    if (pV.participants[_voter] == Choice.AYE) {\n      pV.ayes.remove(_voter);\n      pV.totalAyes = pV.totalAyes.sub(reputation);\n    }\n\n    pV.participants[msg.sender] = Choice.NAY;\n    pV.nays.add(msg.sender);\n    pV.totalNays = pV.totalNays.add(reputation);\n\n    emit NayProposal(_proposalId, _voter);\n  }\n\n  function _onNewProposal(uint256 _proposalId) internal {\n    bytes32 marker = proposals[_proposalId].marker;\n\n    _activeProposals[marker].add(_proposalId);\n    _activeProposalsBySender[msg.sender][marker].add(_proposalId);\n    _proposalToSender[_proposalId] = msg.sender;\n\n    uint256 blockNumber = block.number.sub(1);\n    uint256 totalSupply = _fundRA().totalSupplyAt(blockNumber);\n    require(totalSupply > 0, \"Total reputation is 0\");\n\n    ProposalVoting storage pv = _proposalVotings[_proposalId];\n\n    pv.creationBlock = blockNumber;\n    pv.creationTotalSupply = totalSupply;\n\n    (uint256 support, uint256 quorum, uint256 timeout) = _fundStorage().getProposalVotingConfig(marker);\n    pv.createdAt = block.timestamp;\n    // pv.timeoutAt = block.timestamp + timeout;\n    pv.timeoutAt = block.timestamp.add(timeout);\n\n    pv.requiredSupport = support;\n    pv.minAcceptQuorum = quorum;\n  }\n\n  function _fundStorage() internal view returns (IAbstractFundStorage) {\n    return IAbstractFundStorage(fundRegistry.getStorageAddress());\n  }\n\n  function _fundRA() internal view returns (IFundRA) {\n    return IFundRA(fundRegistry.getRAAddress());\n  }\n\n  // GETTERS\n\n  function getProposalResponseAsErrorString(uint256 _proposalId) public view returns (string memory) {\n    return string(proposals[_proposalId].response);\n  }\n\n  function getActiveProposals(bytes32 _marker) public view returns (uint256[] memory) {\n    return _activeProposals[_marker].elements();\n  }\n\n  function getActiveProposalsCount(bytes32 _marker) public view returns (uint256) {\n    return _activeProposals[_marker].size();\n  }\n\n  function getActiveProposalsBySender(address _sender, bytes32 _marker) external view returns (uint256[] memory) {\n    return _activeProposalsBySender[_sender][_marker].elements();\n  }\n\n  function getActiveProposalsBySenderCount(address _sender, bytes32 _marker) external view returns (uint256) {\n    return _activeProposalsBySender[_sender][_marker].size();\n  }\n\n  function getApprovedProposals(bytes32 _marker) public view returns (uint256[] memory) {\n    return _approvedProposals[_marker];\n  }\n\n  function getApprovedProposalsCount(bytes32 _marker) public view returns (uint256) {\n    return _approvedProposals[_marker].length;\n  }\n\n  function getRejectedProposals(bytes32 _marker) public view returns (uint256[] memory) {\n    return _rejectedProposals[_marker];\n  }\n\n  function getRejectedProposalsCount(bytes32 _marker) public view returns (uint256) {\n    return _rejectedProposals[_marker].length;\n  }\n\n  function getProposalVoting(\n    uint256 _proposalId\n  )\n    external\n    view\n    returns (\n      uint256 creationBlock,\n      uint256 creationTotalSupply,\n      uint256 totalAyes,\n      uint256 totalNays,\n      address[] memory ayes,\n      address[] memory nays\n    )\n  {\n    ProposalVoting storage pV = _proposalVotings[_proposalId];\n\n    return (\n      pV.creationBlock,\n      pV.creationTotalSupply,\n      pV.totalAyes,\n      pV.totalNays,\n      pV.ayes.elements(),\n      pV.nays.elements()\n    );\n  }\n\n  function getProposalVotingProgress(\n    uint256 _proposalId\n  )\n    external\n    view\n    returns (\n      uint256 ayesShare,\n      uint256 naysShare,\n      uint256 totalAyes,\n      uint256 totalNays,\n      uint256 currentSupport,\n      uint256 requiredSupport,\n      uint256 minAcceptQuorum,\n      uint256 timeoutAt\n    )\n  {\n    ProposalVoting storage pV = _proposalVotings[_proposalId];\n\n    return (\n      getAyeShare(_proposalId),\n      getNayShare(_proposalId),\n      pV.totalAyes,\n      pV.totalNays,\n      getCurrentSupport(_proposalId),\n      pV.requiredSupport,\n      pV.minAcceptQuorum,\n      pV.timeoutAt\n    );\n  }\n\n  function getParticipantProposalChoice(uint256 _proposalId, address _participant) external view returns (Choice) {\n    return _proposalVotings[_proposalId].participants[_participant];\n  }\n\n  function reputationOf(address _address, uint256 _blockNumber) public view returns (uint256) {\n    return _fundRA().balanceOfAt(_address, _blockNumber);\n  }\n\n  function getCurrentSupport(uint256 _proposalId) public view returns (uint256) {\n    ProposalVoting storage pv = _proposalVotings[_proposalId];\n\n    uint256 totalVotes = pv.totalAyes.add(pv.totalNays);\n\n    if (totalVotes == 0) {\n      return 0;\n    }\n\n    return pv.totalAyes.mul(ONE_HUNDRED_PCT) / totalVotes;\n  }\n\n  function getAyeShare(uint256 _proposalId) public view returns (uint256) {\n    ProposalVoting storage p = _proposalVotings[_proposalId];\n\n    return p.totalAyes.mul(ONE_HUNDRED_PCT) / p.creationTotalSupply;\n  }\n\n  function getNayShare(uint256 _proposalId) public view returns (uint256) {\n    ProposalVoting storage p = _proposalVotings[_proposalId];\n\n    return p.totalNays.mul(ONE_HUNDRED_PCT) / p.creationTotalSupply;\n  }\n}\n\ncontract AbstractFundStorage is IAbstractFundStorage, Initializable {\n  using SafeMath for uint256;\n\n  using ArraySet for ArraySet.AddressSet;\n  using ArraySet for ArraySet.Uint256Set;\n  using ArraySet for ArraySet.Bytes32Set;\n  using Counters for Counters.Counter;\n\n  event AddProposalMarker(bytes32 indexed marker, address indexed proposalManager);\n  event RemoveProposalMarker(bytes32 indexed marker, address indexed proposalManager);\n  event ReplaceProposalMarker(bytes32 indexed oldMarker, bytes32 indexed newMarker, address indexed proposalManager);\n\n  event SetProposalVotingConfig(bytes32 indexed key, uint256 support, uint256 minAcceptQuorum, uint256 timeout);\n  event SetDefaultProposalVotingConfig(uint256 support, uint256 minAcceptQuorum, uint256 timeout);\n\n  event AddCommunityApp(address indexed contractAddress);\n  event RemoveCommunityApp(address indexed contractAddress);\n\n  event AddFundRule(uint256 indexed id);\n  event DisableFundRule(uint256 indexed id);\n\n  event AddFeeContract(address indexed contractAddress);\n  event RemoveFeeContract(address indexed contractAddress);\n\n  event SetMemberIdentification(address indexed member, bytes32 identificationHash);\n  event SetNameAndDataLink(string name, string dataLink);\n  event SetMultiSigManager(address indexed manager);\n  event SetPeriodLimit(address indexed erc20Contract, uint256 amount, bool active);\n  event HandleMultiSigTransaction(address indexed erc20Contract, uint256 amount);\n\n  event SetConfig(bytes32 indexed key, bytes32 value);\n\n  // 100% == 100 ether\n  uint256 public constant ONE_HUNDRED_PCT = 100 ether;\n\n  bytes32 public constant ROLE_CONFIG_MANAGER = bytes32(\"CONFIG_MANAGER\");\n  bytes32 public constant ROLE_COMMUNITY_APPS_MANAGER = bytes32(\"CA_MANAGER\");\n  bytes32 public constant ROLE_PROPOSAL_MARKERS_MANAGER = bytes32(\"MARKER_MANAGER\");\n  bytes32 public constant ROLE_NEW_MEMBER_MANAGER = bytes32(\"NEW_MEMBER_MANAGER\");\n  bytes32 public constant ROLE_EXPEL_MEMBER_MANAGER = bytes32(\"EXPEL_MEMBER_MANAGER\");\n  bytes32 public constant ROLE_FINE_MEMBER_INCREMENT_MANAGER = bytes32(\"FINE_MEMBER_INCREMENT_MANAGER\");\n  bytes32 public constant ROLE_FINE_MEMBER_DECREMENT_MANAGER = bytes32(\"FINE_MEMBER_DECREMENT_MANAGER\");\n  bytes32 public constant ROLE_CHANGE_NAME_AND_DESCRIPTION_MANAGER = bytes32(\"CHANGE_NAME_DATA_LINK_MANAGER\");\n  bytes32 public constant ROLE_ADD_FUND_RULE_MANAGER = bytes32(\"ADD_FUND_RULE_MANAGER\");\n  bytes32 public constant ROLE_DEACTIVATE_FUND_RULE_MANAGER = bytes32(\"DEACTIVATE_FUND_RULE_MANAGER\");\n  bytes32 public constant ROLE_FEE_MANAGER = bytes32(\"FEE_MANAGER\");\n  bytes32 public constant ROLE_MEMBER_DETAILS_MANAGER = bytes32(\"MEMBER_DETAILS_MANAGER\");\n  bytes32 public constant ROLE_MULTI_SIG_WITHDRAWAL_LIMITS_MANAGER = bytes32(\"MULTISIG_WITHDRAWAL_MANAGER\");\n  bytes32 public constant ROLE_MEMBER_IDENTIFICATION_MANAGER = bytes32(\"MEMBER_IDENTIFICATION_MANAGER\");\n  bytes32 public constant ROLE_PROPOSAL_THRESHOLD_MANAGER = bytes32(\"THRESHOLD_MANAGER\");\n  bytes32 public constant ROLE_DEFAULT_PROPOSAL_THRESHOLD_MANAGER = bytes32(\"DEFAULT_THRESHOLD_MANAGER\");\n  bytes32 public constant ROLE_DECREMENT_TOKEN_REPUTATION = bytes32(\"DECREMENT_TOKEN_REPUTATION_ROLE\");\n  bytes32 public constant ROLE_MULTISIG = bytes32(\"MULTISIG\");\n\n  bytes32 public constant IS_PRIVATE = bytes32(\"is_private\");\n\n  struct FundRule {\n    bool active;\n    uint256 id;\n    address manager;\n    bytes32 ipfsHash;\n    string dataLink;\n    uint256 createdAt;\n  }\n\n  struct CommunityApp {\n    bytes32 abiIpfsHash;\n    bytes32 appType;\n    string dataLink;\n  }\n\n  struct ProposalMarker {\n    bool active;\n    bytes32 name;\n    string dataLink;\n    address destination;\n    address proposalManager;\n  }\n\n  struct MultiSigManager {\n    bool active;\n    address manager;\n    string name;\n    string dataLink;\n  }\n\n  struct MemberFines {\n    uint256 total;\n    // Assume ETH is address(0x1)\n    mapping(address => MemberFineItem) tokenFines;\n  }\n\n  struct MemberFineItem {\n    uint256 amount;\n  }\n\n  struct PeriodLimit {\n    bool active;\n    uint256 amount;\n  }\n\n  struct VotingConfig {\n    uint256 support;\n    uint256 minAcceptQuorum;\n    uint256 timeout;\n  }\n\n  IFundRegistry public fundRegistry;\n  VotingConfig public defaultVotingConfig;\n\n  string public name;\n  string public dataLink;\n  uint256 public initialTimestamp;\n  uint256 public periodLength;\n\n  ArraySet.AddressSet internal _communityApps;\n  ArraySet.Uint256Set internal _activeFundRules;\n  ArraySet.AddressSet internal _feeContracts;\n\n  Counters.Counter internal fundRuleCounter;\n\n  ArraySet.AddressSet internal _activeMultisigManagers;\n  ArraySet.AddressSet internal _activePeriodLimitsContracts;\n\n  mapping(bytes32 => bytes32) public config;\n  // contractAddress => details\n  mapping(address => CommunityApp) public communityAppsInfo;\n  // marker => details\n  mapping(bytes32 => ProposalMarker) public proposalMarkers;\n  // role => address\n  mapping(bytes32 => address) public coreContracts;\n  // manager => details\n  mapping(address => MultiSigManager) public multiSigManagers;\n  // erc20Contract => details\n  mapping(address => PeriodLimit) public periodLimits;\n  // periodId => (erc20Contract => runningTotal)\n  mapping(uint256 => mapping(address => uint256)) internal _periodRunningTotals;\n  // member => identification hash\n  mapping(address => bytes32) public membersIdentification;\n\n  // FRP => fundRuleDetails\n  mapping(uint256 => FundRule) public fundRules;\n\n  // marker => customVotingConfigs\n  mapping(bytes32 => VotingConfig) public customVotingConfigs;\n\n  modifier onlyFeeContract() {\n    require(_feeContracts.has(msg.sender), \"Not a fee contract\");\n\n    _;\n  }\n\n  modifier onlyMultiSig() {\n    require(fundRegistry.getACL().hasRole(msg.sender, ROLE_MULTISIG), \"Invalid role\");\n\n    _;\n  }\n\n  modifier onlyRole(bytes32 _role) {\n    require(fundRegistry.getACL().hasRole(msg.sender, _role), \"Invalid role\");\n\n    _;\n  }\n\n  constructor() public {\n  }\n\n  function initialize(\n    IFundRegistry _fundRegistry,\n    bool _isPrivate,\n    uint256 _defaultProposalSupport,\n    uint256 _defaultProposalMinAcceptQuorum,\n    uint256 _defaultProposalTimeout,\n    uint256 _periodLength\n  )\n    external\n    isInitializer\n  {\n    config[IS_PRIVATE] = _isPrivate ? bytes32(uint256(1)) : bytes32(uint256(0));\n\n    periodLength = _periodLength;\n    initialTimestamp = block.timestamp;\n\n    _validateVotingConfig(_defaultProposalSupport, _defaultProposalMinAcceptQuorum, _defaultProposalTimeout);\n\n    defaultVotingConfig.support = _defaultProposalSupport;\n    defaultVotingConfig.minAcceptQuorum = _defaultProposalMinAcceptQuorum;\n    defaultVotingConfig.timeout = _defaultProposalTimeout;\n\n    fundRegistry = _fundRegistry;\n  }\n\n  function setDefaultProposalConfig(\n    uint256 _support,\n    uint256 _minAcceptQuorum,\n    uint256 _timeout\n  )\n    external\n    onlyRole(ROLE_DEFAULT_PROPOSAL_THRESHOLD_MANAGER)\n  {\n    _validateVotingConfig(_support, _minAcceptQuorum, _timeout);\n\n    defaultVotingConfig.support = _support;\n    defaultVotingConfig.minAcceptQuorum = _minAcceptQuorum;\n    defaultVotingConfig.timeout = _timeout;\n\n    emit SetDefaultProposalVotingConfig(_support, _minAcceptQuorum, _timeout);\n  }\n\n  function setProposalConfig(\n    bytes32 _marker,\n    uint256 _support,\n    uint256 _minAcceptQuorum,\n    uint256 _timeout\n  )\n    external\n    onlyRole(ROLE_PROPOSAL_THRESHOLD_MANAGER)\n  {\n    _validateVotingConfig(_support, _minAcceptQuorum, _timeout);\n\n    customVotingConfigs[_marker] = VotingConfig({\n      support: _support,\n      minAcceptQuorum: _minAcceptQuorum,\n      timeout: _timeout\n    });\n\n    emit SetProposalVotingConfig(_marker, _support, _minAcceptQuorum, _timeout);\n  }\n\n  function setConfigValue(bytes32 _key, bytes32 _value) external onlyRole(ROLE_CONFIG_MANAGER) {\n    config[_key] = _value;\n\n    emit SetConfig(_key, _value);\n  }\n\n  function addCommunityApp(\n    address _contract,\n    bytes32 _type,\n    bytes32 _abiIpfsHash,\n    string calldata _dataLink\n  )\n    external\n    onlyRole(ROLE_COMMUNITY_APPS_MANAGER)\n  {\n    CommunityApp storage c = communityAppsInfo[_contract];\n\n    _communityApps.addSilent(_contract);\n\n    c.appType = _type;\n    c.abiIpfsHash = _abiIpfsHash;\n    c.dataLink = _dataLink;\n\n    emit AddCommunityApp(_contract);\n  }\n\n  function removeCommunityApp(address _contract) external onlyRole(ROLE_COMMUNITY_APPS_MANAGER) {\n    _communityApps.remove(_contract);\n\n    emit RemoveCommunityApp(_contract);\n  }\n\n  function addProposalMarker(\n    bytes4 _methodSignature,\n    address _destination,\n    address _proposalManager,\n    bytes32 _name,\n    string calldata _dataLink\n  )\n    external\n    onlyRole(ROLE_PROPOSAL_MARKERS_MANAGER)\n  {\n    bytes32 _marker = keccak256(abi.encode(_destination, _methodSignature));\n\n    ProposalMarker storage m = proposalMarkers[_marker];\n\n    m.active = true;\n    m.proposalManager = _proposalManager;\n    m.destination = _destination;\n    m.name = _name;\n    m.dataLink = _dataLink;\n\n    emit AddProposalMarker(_marker, _proposalManager);\n  }\n\n  function removeProposalMarker(bytes32 _marker) external onlyRole(ROLE_PROPOSAL_MARKERS_MANAGER) {\n    proposalMarkers[_marker].active = false;\n\n    emit RemoveProposalMarker(_marker, proposalMarkers[_marker].proposalManager);\n  }\n\n  function replaceProposalMarker(\n    bytes32 _oldMarker,\n    bytes32 _newMethodSignature,\n    address _newDestination\n  )\n    external\n    onlyRole(ROLE_PROPOSAL_MARKERS_MANAGER)\n  {\n    bytes32 _newMarker = keccak256(abi.encode(_newDestination, _newMethodSignature));\n\n    proposalMarkers[_newMarker] = proposalMarkers[_oldMarker];\n    proposalMarkers[_newMarker].destination = _newDestination;\n    proposalMarkers[_oldMarker].active = false;\n\n    emit ReplaceProposalMarker(_oldMarker, _newMarker, proposalMarkers[_newMarker].proposalManager);\n  }\n\n  function addFundRule(\n    bytes32 _ipfsHash,\n    string calldata _dataLink\n  )\n    external\n    onlyRole(ROLE_ADD_FUND_RULE_MANAGER)\n  {\n    fundRuleCounter.increment();\n    uint256 _id = fundRuleCounter.current();\n\n    FundRule storage fundRule = fundRules[_id];\n\n    fundRule.active = true;\n    fundRule.id = _id;\n    fundRule.ipfsHash = _ipfsHash;\n    fundRule.dataLink = _dataLink;\n    fundRule.manager = msg.sender;\n    fundRule.createdAt = block.timestamp;\n\n    _activeFundRules.add(_id);\n\n    emit AddFundRule(_id);\n  }\n\n  function disableFundRule(uint256 _id) external onlyRole(ROLE_DEACTIVATE_FUND_RULE_MANAGER) {\n    fundRules[_id].active = false;\n\n    _activeFundRules.remove(_id);\n\n    emit DisableFundRule(_id);\n  }\n\n  function addFeeContract(address _feeContract) external onlyRole(ROLE_FEE_MANAGER) {\n    _feeContracts.add(_feeContract);\n\n    emit AddFeeContract(_feeContract);\n  }\n\n  function removeFeeContract(address _feeContract) external onlyRole(ROLE_FEE_MANAGER) {\n    _feeContracts.remove(_feeContract);\n\n    emit RemoveFeeContract(_feeContract);\n  }\n\n  function setMemberIdentification(address _member, bytes32 _identificationHash) external onlyRole(ROLE_MEMBER_IDENTIFICATION_MANAGER) {\n    membersIdentification[_member] = _identificationHash;\n\n    emit SetMemberIdentification(_member, _identificationHash);\n  }\n\n  function setNameAndDataLink(\n    string calldata _name,\n    string calldata _dataLink\n  )\n    external\n    onlyRole(ROLE_CHANGE_NAME_AND_DESCRIPTION_MANAGER)\n  {\n    name = _name;\n    dataLink = _dataLink;\n\n    emit SetNameAndDataLink(_name, _dataLink);\n  }\n\n  function setMultiSigManager(\n    bool _active,\n    address _manager,\n    string calldata _name,\n    string calldata _dataLink\n  )\n    external\n    onlyRole(ROLE_MEMBER_DETAILS_MANAGER)\n  {\n    MultiSigManager storage m = multiSigManagers[_manager];\n\n    m.active = _active;\n    m.name = _name;\n    m.dataLink = _dataLink;\n\n    if (_active) {\n      _activeMultisigManagers.addSilent(_manager);\n    } else {\n      _activeMultisigManagers.removeSilent(_manager);\n    }\n\n    emit SetMultiSigManager(_manager);\n  }\n\n  function setPeriodLimit(\n    bool _active,\n    address _erc20Contract,\n    uint256 _amount\n  )\n    external\n    onlyRole(ROLE_MULTI_SIG_WITHDRAWAL_LIMITS_MANAGER)\n  {\n    periodLimits[_erc20Contract].active = _active;\n    periodLimits[_erc20Contract].amount = _amount;\n\n    if (_active) {\n      _activePeriodLimitsContracts.addSilent(_erc20Contract);\n    } else {\n      _activePeriodLimitsContracts.removeSilent(_erc20Contract);\n    }\n\n    emit SetPeriodLimit(_erc20Contract, _amount, _active);\n  }\n\n  function handleMultiSigTransaction(\n    address _erc20Contract,\n    uint256 _amount\n  )\n    external\n    onlyMultiSig\n  {\n    PeriodLimit storage limit = periodLimits[_erc20Contract];\n    if (limit.active == false) {\n      return;\n    }\n\n    uint256 currentPeriod = getCurrentPeriod();\n    // uint256 runningTotalAfter = _periodRunningTotals[currentPeriod][_erc20Contract] + _amount;\n    uint256 runningTotalAfter = _periodRunningTotals[currentPeriod][_erc20Contract].add(_amount);\n\n    require(runningTotalAfter <= periodLimits[_erc20Contract].amount, \"Running total for the current period exceeds the limit\");\n    _periodRunningTotals[currentPeriod][_erc20Contract] = runningTotalAfter;\n\n    emit HandleMultiSigTransaction(_erc20Contract, _amount);\n  }\n\n  // INTERNAL\n\n  function _validateVotingConfig(\n    uint256 _support,\n    uint256 _minAcceptQuorum,\n    uint256 _timeout\n  )\n    internal\n    pure\n  {\n    require(_minAcceptQuorum > 0 && _minAcceptQuorum <= _support, \"Invalid min accept quorum value\");\n    require(_support > 0 && _support <= ONE_HUNDRED_PCT, \"Invalid support value\");\n    require(_timeout > 0, \"Invalid duration value\");\n  }\n\n  // GETTERS\n\n  function getThresholdMarker(address _destination, bytes memory _data) public pure returns(bytes32 marker) {\n    bytes32 methodName;\n\n    assembly {\n      methodName := and(mload(add(_data, 0x20)), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n    }\n\n    return keccak256(abi.encode(_destination, methodName));\n  }\n\n  function getProposalVotingConfig(\n    bytes32 _key\n  )\n    external\n    view\n    returns (uint256 support, uint256 minAcceptQuorum, uint256 timeout)\n  {\n    uint256 to = customVotingConfigs[_key].timeout;\n\n    if (to > 0) {\n      return (\n        customVotingConfigs[_key].support,\n        customVotingConfigs[_key].minAcceptQuorum,\n        customVotingConfigs[_key].timeout\n      );\n    } else {\n      return (\n        defaultVotingConfig.support,\n        defaultVotingConfig.minAcceptQuorum,\n        defaultVotingConfig.timeout\n      );\n    }\n  }\n\n  function getCommunityApps() external view returns (address[] memory) {\n    return _communityApps.elements();\n  }\n\n  function getActiveFundRules() external view returns (uint256[] memory) {\n    return _activeFundRules.elements();\n  }\n\n  function getActiveFundRulesCount() external view returns (uint256) {\n    return _activeFundRules.size();\n  }\n\n  function areMembersValid(address[] calldata _members) external view returns (bool) {\n    uint256 len = _members.length;\n\n    for (uint256 i = 0; i < len; i++) {\n      if (multiSigManagers[_members[i]].active == false) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getActiveMultisigManagers() external view returns (address[] memory) {\n    return _activeMultisigManagers.elements();\n  }\n\n  function getActiveMultisigManagersCount() external view returns (uint256) {\n    return _activeMultisigManagers.size();\n  }\n\n  function getActivePeriodLimits() external view returns (address[] memory) {\n    return _activePeriodLimitsContracts.elements();\n  }\n\n  function getActivePeriodLimitsCount() external view returns (uint256) {\n    return _activePeriodLimitsContracts.size();\n  }\n\n  function getFeeContracts() external view returns (address[] memory) {\n    return _feeContracts.elements();\n  }\n\n  function getFeeContractCount() external view returns (uint256) {\n    return _feeContracts.size();\n  }\n\n  function getCurrentPeriod() public view returns (uint256) {\n    // return (block.timestamp - initialTimestamp) / periodLength;\n    return (block.timestamp.sub(initialTimestamp)) / periodLength;\n  }\n}\n\ninterface IPPToken {\n  event SetMinter(address indexed minter);\n  event SetBaseURI(string baseURI);\n  event SetDataLink(string indexed dataLink);\n  event SetLegalAgreementIpfsHash(bytes32 legalAgreementIpfsHash);\n  event SetController(address indexed controller);\n  event SetDetails(\n    address indexed geoDataManager,\n    uint256 indexed privatePropertyId\n  );\n  event SetContour(\n    address indexed geoDataManager,\n    uint256 indexed privatePropertyId\n  );\n  event SetExtraData(bytes32 indexed key, bytes32 value);\n  event SetPropertyExtraData(uint256 indexed propertyId, bytes32 indexed key, bytes32 value);\n  event Mint(address indexed to, uint256 indexed privatePropertyId);\n  event Burn(address indexed from, uint256 indexed privatePropertyId);\n\n  enum PropertyInitialSetupStage {\n    PENDING,\n    DETAILS,\n    DONE\n  }\n\n  enum AreaSource {\n    USER_INPUT,\n    CONTRACT\n  }\n\n  enum TokenType {\n    NULL,\n    LAND_PLOT,\n    BUILDING,\n    ROOM,\n    PACKAGE\n  }\n\n  // ERC20 METHOD\n  function transferFrom(address from, address to, uint256 tokenId) external;\n  function approve(address to, uint256 tokenId) external;\n\n  // PERMISSIONED METHODS\n\n  function setMinter(address _minter) external;\n  function setDataLink(string calldata _dataLink) external;\n  function setLegalAgreementIpfsHash(bytes32 _legalAgreementIpfsHash) external;\n  function setController(address payable _controller) external;\n  function setDetails(\n    uint256 _privatePropertyId,\n    TokenType _tokenType,\n    AreaSource _areaSource,\n    uint256 _area,\n    bytes32 _ledgerIdentifier,\n    string calldata _humanAddress,\n    string calldata _dataLink\n  )\n    external;\n\n  function setContour(\n    uint256 _privatePropertyId,\n    uint256[] calldata _contour,\n    int256 _highestPoint\n  )\n    external;\n\n  function mint(address _to) external;\n  function burn(uint256 _tokenId) external;\n\n  // GETTERS\n  function controller() external view returns (address payable);\n  function minter() external view returns (address);\n\n  function tokensOfOwner(address _owner) external view returns (uint256[] memory);\n  function ownerOf(uint256 _tokenId) external view returns (address);\n  function exists(uint256 _tokenId) external view returns (bool);\n  function getType(uint256 _tokenId) external view returns (TokenType);\n  function getContour(uint256 _tokenId) external view returns (uint256[] memory);\n  function getContourLength(uint256 _tokenId) external view returns (uint256);\n  function getHighestPoint(uint256 _tokenId) external view returns (int256);\n  function getHumanAddress(uint256 _tokenId) external view returns (string memory);\n  function getArea(uint256 _tokenId) external view returns (uint256);\n  function getAreaSource(uint256 _tokenId) external view returns (AreaSource);\n  function getLedgerIdentifier(uint256 _tokenId) external view returns (bytes32);\n  function getDataLink(uint256 _tokenId) external view returns (string memory);\n  function getDetails(uint256 _privatePropertyId)\n    external\n    view\n    returns (\n      TokenType tokenType,\n      uint256[] memory contour,\n      int256 highestPoint,\n      AreaSource areaSource,\n      uint256 area,\n      bytes32 ledgerIdentifier,\n      string memory humanAddress,\n      string memory dataLink,\n      PropertyInitialSetupStage setupStage\n    );\n}\n\ninterface IRA {\n  // ERC20 compatible\n  function balanceOf(address owner) external view returns (uint256);\n\n  // ERC20 compatible\n  function totalSupply() external view returns (uint256);\n\n  // Ping-Pong Handshake\n  function ping() external pure returns (bytes32);\n}\n\ninterface IPPLocker {\n  function deposit(IPPToken _tokenContract, uint256 _tokenId) external payable;\n  function withdraw() external;\n  function approveMint(IRA _tra) external;\n  function burn(IRA _tra) external;\n  function isMinted(address _tra) external view returns (bool);\n  function getTras() external view returns (address[] memory);\n  function getTrasCount() external view returns (uint256);\n  function isOwner() external view returns (bool);\n  function owner() external view returns(address);\n  function tokenId() external view returns(uint256);\n  function reputation() external view returns(uint256);\n  function tokenContract() external view returns(IPPToken);\n}\n\ninterface IPPTokenRegistry {\n  event AddToken(address indexed token, address indexed owener, address indexed factory);\n  event SetFactory(address factory);\n  event SetLockerRegistry(address lockerRegistry);\n\n  function tokenList(uint256 _index) external view returns (address);\n  function isValid(address _tokenContract) external view returns (bool);\n  function requireValidToken(address _token) external view;\n  function addToken(address _privatePropertyToken) external;\n  function getAllTokens() external view returns (address[] memory);\n}\n\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\ninterface IPPGlobalRegistry {\n  function setContract(bytes32 _key, address _value) external;\n\n  // GETTERS\n  function getContract(bytes32 _key) external view returns (address);\n  function getACL() external view returns (IACL);\n  function getGaltTokenAddress() external view returns (address);\n  function getPPTokenRegistryAddress() external view returns (address);\n  function getPPLockerRegistryAddress() external view returns (address);\n  function getPPMarketAddress() external view returns (address);\n}\n\ncontract PrivateFundStorage is AbstractFundStorage {\n\n  event ApproveMint(address indexed registry, uint256 indexed tokenId);\n\n  event Expel(address indexed registry, uint256 indexed tokenId);\n  event DecrementExpel(address indexed registry, uint256 indexed tokenId);\n\n  event ChangeFine(bool indexed isIncrement, address indexed registry, uint256 indexed tokenId, address contractAddress);\n\n  event LockChange(bool indexed isLock, address indexed registry, uint256 indexed tokenId);\n\n  // registry => (tokenId => details)\n  mapping(address => mapping(uint256 => MemberFines)) private _fines;\n  // registry => (tokenId => isMintApproved)\n  mapping(address => mapping(uint256 => bool)) private _mintApprovals;\n  // registry => (tokenId => isExpelled)\n  mapping(address => mapping(uint256 => bool)) private _expelledTokens;\n  // registry => (tokenId => availableAmountToBurn)\n  mapping(address => mapping(uint256 => uint256)) private _expelledTokenReputation;\n  // registry => (tokenId => isLocked)\n  mapping(address => mapping(uint256 => bool)) private _lockedTokens;\n\n  constructor() public {\n  }\n\n  function _onlyValidToken(address _token) internal view {\n    IPPGlobalRegistry ppgr = IPPGlobalRegistry(fundRegistry.getPPGRAddress());\n\n    IPPTokenRegistry(ppgr.getPPTokenRegistryAddress())\n      .requireValidToken(_token);\n  }\n\n  function approveMint(address _registry, uint256 _tokenId)\n    external\n    onlyRole(ROLE_NEW_MEMBER_MANAGER)\n  {\n    _onlyValidToken(_registry);\n    _mintApprovals[_registry][_tokenId] = true;\n\n    emit ApproveMint(_registry, _tokenId);\n  }\n\n  function expel(address _registry, uint256 _tokenId)\n    external\n    onlyRole(ROLE_EXPEL_MEMBER_MANAGER)\n  {\n    _onlyValidToken(_registry);\n    require(_expelledTokens[_registry][_tokenId] == false, \"Already Expelled\");\n\n    address owner = IERC721(_registry).ownerOf(_tokenId);\n    uint256 amount = IPPLocker(owner).reputation();\n\n    assert(amount > 0);\n\n    _expelledTokens[_registry][_tokenId] = true;\n    _expelledTokenReputation[_registry][_tokenId] = amount;\n\n    emit Expel(_registry, _tokenId);\n  }\n\n  function decrementExpelledTokenReputation(\n    address _registry,\n    uint256 _tokenId,\n    uint256 _amount\n  )\n    external\n    onlyRole(ROLE_DECREMENT_TOKEN_REPUTATION)\n    returns (bool completelyBurned)\n  {\n    _onlyValidToken(_registry);\n    require(_amount > 0 && _amount <= _expelledTokenReputation[_registry][_tokenId], \"Invalid reputation amount\");\n\n    _expelledTokenReputation[_registry][_tokenId] = _expelledTokenReputation[_registry][_tokenId] - _amount;\n\n    completelyBurned = (_expelledTokenReputation[_registry][_tokenId] == 0);\n\n    emit DecrementExpel(_registry, _tokenId);\n  }\n\n  function incrementFine(\n    address _registry,\n    uint256 _tokenId,\n    address _contract,\n    uint256 _amount\n  )\n    external\n    onlyRole(ROLE_FINE_MEMBER_INCREMENT_MANAGER)\n  {\n    _onlyValidToken(_registry);\n\n    // _fines[_registry][_tokenId].tokenFines[_contract].amount += _amount;\n    _fines[_registry][_tokenId].tokenFines[_contract].amount = _fines[_registry][_tokenId].tokenFines[_contract].amount.add(_amount);\n    // _fines[_registry][_tokenId].total += _amount;\n    _fines[_registry][_tokenId].total = _fines[_registry][_tokenId].total.add(_amount);\n\n    emit ChangeFine(true, _registry, _tokenId, _contract);\n  }\n\n  function decrementFine(\n    address _registry,\n    uint256 _tokenId,\n    address _contract,\n    uint256 _amount\n  )\n    external\n    onlyRole(ROLE_FINE_MEMBER_DECREMENT_MANAGER)\n  {\n    _onlyValidToken(_registry);\n\n    // _fines[_registry][_tokenId].tokenFines[_contract].amount -= _amount;\n    _fines[_registry][_tokenId].tokenFines[_contract].amount = _fines[_registry][_tokenId].tokenFines[_contract].amount.sub(_amount);\n    // _fines[_registry][_tokenId].total -= _amount;\n    _fines[_registry][_tokenId].total -= _fines[_registry][_tokenId].total.sub(_amount);\n\n    emit ChangeFine(false, _registry, _tokenId, _contract);\n  }\n\n  function lockSpaceToken(\n    address _registry,\n    uint256 _tokenId\n  )\n    external\n    onlyFeeContract\n  {\n    _onlyValidToken(_registry);\n    _lockedTokens[_registry][_tokenId] = true;\n\n    emit LockChange(true, _registry, _tokenId);\n  }\n\n  function unlockSpaceToken(\n    address _registry,\n    uint256 _tokenId\n  )\n    external\n    onlyFeeContract\n  {\n    _onlyValidToken(_registry);\n    _lockedTokens[_registry][_tokenId] = false;\n\n    emit LockChange(false, _registry, _tokenId);\n  }\n\n  // GETTERS\n  function getFineAmount(\n    address _registry,\n    uint256 _tokenId,\n    address _erc20Contract\n  )\n    external\n    view\n    returns (uint256)\n  {\n    return _fines[_registry][_tokenId].tokenFines[_erc20Contract].amount;\n  }\n\n  function getTotalFineAmount(\n    address _registry,\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (uint256)\n  {\n    return _fines[_registry][_tokenId].total;\n  }\n\n  function getExpelledToken(\n    address _registry,\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (bool isExpelled, uint256 amount)\n  {\n    return (\n      _expelledTokens[_registry][_tokenId],\n      _expelledTokenReputation[_registry][_tokenId]\n    );\n  }\n\n  function isMintApproved(\n    address _registry,\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (bool)\n  {\n    if (_expelledTokens[_registry][_tokenId] == true) {\n      return false;\n    }\n\n    if (uint256(config[IS_PRIVATE]) == uint256(1)) {\n      return _mintApprovals[_registry][_tokenId];\n    } else {\n      return true;\n    }\n  }\n\n  function isTokenLocked(\n    address _registry,\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (bool)\n  {\n    return _lockedTokens[_registry][_tokenId];\n  }\n}\n\ncontract DetailableFee {\n\n  // \"regular_erc20\" or \"regular_eth\"\n  bytes32 public feeType;\n  string public title;\n  string public description;\n  string public dataLink;\n\n  bool public detailsSet;\n\n  constructor() public {\n\n  }\n\n  function setDetails(\n    bytes32 _feeType,\n    string memory _title,\n    string memory _description,\n    string memory _dataLink\n  )\n    public\n  {\n    require(!detailsSet, \"Details already set\");\n\n\n    feeType = _feeType;\n    title = _title;\n    description = _description;\n    dataLink = _dataLink;\n\n    detailsSet = true;\n  }\n\n  function getDetails() public view returns (\n    bytes32 _feeType,\n    string memory _title,\n    string memory _description,\n    string memory _dataLink\n  )\n  {\n\n    return (\n      feeType,\n      title,\n      description,\n      dataLink\n    );\n  }\n}\n\ninterface IRegularFee {\n}\n\ncontract AbstractRegularFee is DetailableFee, IRegularFee {\n  using SafeMath for uint256;\n\n  uint256 public initialTimestamp;\n  // Period in seconds\n  uint256 public periodLength;\n  // Period in seconds after the current period end  for pre-payments using the current `rate`\n  uint256 public prePaidPeriodGap;\n  // Amount of funds to pay in a single period\n  uint256 public rate;\n\n  constructor (\n    uint256 _initialTimestamp,\n    uint256 _period,\n    uint256 _rate\n  ) public {\n    require(_initialTimestamp > 0, \"Initial timestamp length is 0\");\n    require(_period > 0, \"Period length is 0\");\n    require(_rate > 0, \"Rate is 0\");\n\n    initialTimestamp = _initialTimestamp;\n    periodLength = _period;\n    rate = _rate;\n    // 1 month (30 days)\n    prePaidPeriodGap = 2592000;\n  }\n\n  // GETTERS\n\n  function getCurrentPeriod() public view returns (uint256) {\n    require(block.timestamp > initialTimestamp, \"Contract not initiated yet\");\n\n    // return (block.timestamp - initialTimestamp) / periodLength;\n    return (block.timestamp.sub(initialTimestamp)) / periodLength;\n  }\n\n  function getNextPeriodTimestamp() public view returns (uint256) {\n    if (block.timestamp <= initialTimestamp) {\n      return initialTimestamp;\n    }\n\n    // return ((getCurrentPeriod() + 1) * periodLength) + initialTimestamp;\n    return ((getCurrentPeriod() + 1).mul(periodLength)).add(initialTimestamp);\n  }\n\n  function getCurrentPeriodTimestamp() public view returns (uint256) {\n    if (block.timestamp <= initialTimestamp) {\n      return initialTimestamp;\n    }\n\n    // return (getCurrentPeriod() * periodLength) + initialTimestamp;\n    return (getCurrentPeriod().mul(periodLength)).add(initialTimestamp);\n  }\n}\n\ncontract AbstractPrivateRegularFee is AbstractRegularFee {\n  using SafeMath for uint256;\n\n  IFundRegistry public fundRegistry;\n\n  // registry => (tokenId => timestamp)\n  mapping(address => mapping(uint256 => uint256)) public paidUntil;\n  // registry => (tokenId => amount)\n  mapping(address => mapping(uint256 => uint256)) public totalPaid;\n\n  constructor(IFundRegistry _fundRegistry) public {\n    fundRegistry = _fundRegistry;\n  }\n\n  function _onlyValidToken(address _token) internal view {\n    IPPGlobalRegistry ppgr = IPPGlobalRegistry(fundRegistry.getPPGRAddress());\n    IPPTokenRegistry(ppgr.getPPTokenRegistryAddress()).requireValidToken(_token);\n  }\n\n  function lockToken(address _registry, uint256 _tokenId) public {\n    require(paidUntil[_registry][_tokenId] < getNextPeriodTimestamp(), \"paidUntil too small\");\n    _fundStorage().lockSpaceToken(_registry, _tokenId);\n  }\n\n  function lockTokenArray(address _registry, uint256[] calldata _tokenIds) external {\n    for (uint i = 0; i < _tokenIds.length; i++) {\n      lockToken(_registry, _tokenIds[i]);\n    }\n  }\n\n  function unlockToken(address _registry, uint256 _tokenId) public {\n    require(paidUntil[_registry][_tokenId] >= getNextPeriodTimestamp(), \"paidUntil too big\");\n    _fundStorage().unlockSpaceToken(_registry, _tokenId);\n  }\n\n  function unlockTokenArray(address _registry, uint256[] calldata _tokenIds) external {\n    for (uint i = 0; i < _tokenIds.length; i++) {\n      unlockToken(_registry, _tokenIds[i]);\n    }\n  }\n\n  function _fundStorage() internal view returns (PrivateFundStorage) {\n    return PrivateFundStorage(fundRegistry.getStorageAddress());\n  }\n\n  function _pay(address _registry, uint256 _tokenIds, uint256 _amount) internal {\n    _onlyValidToken(_registry);\n\n    uint256 currentPaidUntil = paidUntil[_registry][_tokenIds];\n    if (currentPaidUntil == 0) {\n      currentPaidUntil = getCurrentPeriodTimestamp();\n    }\n\n    // uint256 newPaidUntil = currentPaidUntil + (_amount * periodLength / rate);\n    uint256 newPaidUntil = currentPaidUntil.add(_amount.mul(periodLength) / rate);\n    // uint256 permittedPaidUntil = getNextPeriodTimestamp() + prePaidPeriodGap;\n    uint256 permittedPaidUntil = getNextPeriodTimestamp().add(prePaidPeriodGap);\n\n    require(newPaidUntil <= permittedPaidUntil, \"Payment exceeds permitted pre-payment timestamp\");\n\n    paidUntil[_registry][_tokenIds] = newPaidUntil;\n    // totalPaid[_registry][_tokenIds] += _amount;\n    totalPaid[_registry][_tokenIds] = totalPaid[_registry][_tokenIds].add(_amount);\n  }\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract PrivateRegularErc20Fee is AbstractPrivateRegularFee {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  IERC20 public erc20Token;\n\n  constructor (\n    IERC20 _token,\n    IFundRegistry _fundRegistry,\n    uint256 _initialTimestamp,\n    uint256 _periodLength,\n    uint256 _rate\n  )\n    public\n    AbstractPrivateRegularFee(_fundRegistry)\n    AbstractRegularFee(_initialTimestamp, _periodLength, _rate)\n  {\n    erc20Token = _token;\n  }\n\n  // Each paidUntil point shifts by the current `rate`\n  function pay(address _registry, uint256 _tokenId, uint256 _amount) external {\n    require(_amount > 0, \"Expect ETH payment\");\n    require(erc20Token.allowance(msg.sender, address(this)) >= _amount, \"Insufficient allowance\");\n\n    _pay(_registry, _tokenId, _amount);\n\n    erc20Token.transferFrom(msg.sender, address(fundRegistry.getMultiSigAddress()), _amount);\n  }\n\n  function payArray(\n    address[] calldata _registries,\n    uint256[] calldata _spaceTokensIds,\n    uint256[] calldata _amounts\n  )\n    external\n  {\n    uint256 totalAmount = 0;\n\n    for (uint i = 0; i < _spaceTokensIds.length; i++) {\n      // totalAmount += _amounts[_i];\n      totalAmount = totalAmount.add(_amounts[i]);\n      _pay(_registries[i], _spaceTokensIds[i], _amounts[i]);\n    }\n\n    erc20Token.transferFrom(msg.sender, address(fundRegistry.getMultiSigAddress()), totalAmount);\n  }\n}\n\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract PrivateRegularErc20FeeFactory is Ownable {\n  event NewContract(address addr, address erc20Token);\n\n  function build(\n    IERC20 _erc20Token,\n    IFundRegistry _fundRegistry,\n    uint256 _initialTimestamp,\n    uint256 _period,\n    uint256 _amount\n  )\n    external\n    returns (IRegularFee regularFee)\n  {\n    regularFee = new PrivateRegularErc20Fee(\n      _erc20Token,\n      _fundRegistry,\n      _initialTimestamp,\n      _period,\n      _amount\n    );\n\n    emit NewContract(address(regularFee), address(_erc20Token));\n  }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"}],\"name\":\"NewContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_erc20Token\",\"type\":\"address\"},{\"internalType\":\"contract IFundRegistry\",\"name\":\"_fundRegistry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"build\",\"outputs\":[{\"internalType\":\"contract IRegularFee\",\"name\":\"regularFee\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PrivateRegularErc20FeeFactory","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://945b79aaf6bfd56efdb5085d166a93b3606f8ad7385b00bbf60be8db2f686003"}]}