{"status":"1","message":"OK","result":[{"SourceCode":"{\"EncropyTokenOptimized.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.7.0;\\n\\n//\\nimport \\\"./TokenERC20.sol\\\";\\nimport \\\"./YearsDataSetOptimized.sol\\\";\\n// import \\\"./Functions.sol\\\";\\n\\ncontract EncropyTokenOptimized is TokenERC20 {\\n\\n    uint8 public constant decimals = 8;  // 8 is the most common number of decimal places\\n\\n    uint256 constant initialDate = 1584460800; // 2020-03-18 发行日期 timezone is PRC\\n    uint256 constant firstYearSupply = 500000000*10**uint256(decimals); // 首年发行量5亿个\\n\\n    string constant PROFIT_LEDGER = \\u0027PROFIT_LEDGER\\u0027; // 盈利总账\\n    string constant HOLDING_LEDGER = \\u0027HOLDING_LEDGER\\u0027; // 持有总账\\n    string constant PROGRAM_LEDGER = \\u0027PROGRAM_LEDGER\\u0027; // 编程总账\\n    string constant PROPOSAL_LEDGER = \\u0027PROPOSAL_LEDGER\\u0027; // 参议总账\\n    string constant NODE_LEDGER = \\u0027NODE_LEDGER\\u0027; // 服务器节点总账\\n    string constant FUND_LEDGER = \\u0027FUND_LEDGER\\u0027; // 基金总账\\n    string constant DESTROY_LEDGER = \\u0027DESTROY_LEDGER\\u0027; // 销毁总账\\n\\n    string public constant name = \\u0027Encropy\\u0027;\\n    string public constant symbol = \\u0027ECP\\u0027;\\n\\n    mapping(string =\\u003e address) ledgers; // 账本\\n    mapping(string =\\u003e uint8) allocationRatio; // 分配比例\\n    mapping(uint256 =\\u003e uint256) allocatedDates; // 已经分配ECP的日期\\n\\n    YearsDataSetOptimized yearsData;//  = new YearsDataSetOptimized(initialDate,firstYearSupply); // 分配数据\\n\\n\\n    event DailyMined(uint256 indexed date, uint256 volume);\\n    event LedgerChanged(string indexed ledger_name, address new_address);\\n\\n    modifier checkMined(uint256 _time) {\\n        require(isAllocated(_time) == false, \\u0027today have been mined!\\u0027);\\n        _;\\n    }\\n    modifier checkNowMined() {\\n        uint256 _time = now;\\n        require(_time \\u003c= 3383222400, \\u0027time is exceed the limit\\u0027);\\n        require(isAllocated(_time) == false, \\u0027today have been mined!\\u0027);\\n        _;\\n    }\\n\\n    // event FallbackIsCalled(address caller_address, uint256 _value, bytes data);\\n    // event ReceiveIsCalled(address caller_address, uint256 _value);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        yearsData = new YearsDataSetOptimized(initialDate,firstYearSupply); // 分配数据\\n        setLedgers();\\n    }\\n\\n    // receive() external payable {\\n    //     emit ReceiveIsCalled(msg.sender, msg.value);\\n    // }\\n\\n    // fallback() external payable {\\n    //     emit FallbackIsCalled(msg.sender, msg.value, msg.data);\\n    // }\\n\\n    // 设定账本地址和比例\\n    function setLedgers() private {\\n        // ledgers[\\u0027GENERAL_LEDGER\\u0027] = 0xc5A2D4ffBb95570602616A7ACAA4904C88A3BE33; // 总账\\n        ledgers[PROFIT_LEDGER] = 0x775a40c61f2Af5Ae9E7DC6A1f5E022ED9E58455D;\\n        ledgers[HOLDING_LEDGER] = 0x677d514Fb8D6FCDC2f741575aa8FE506210B5781;\\n        ledgers[PROGRAM_LEDGER] = 0x948E284E0222b35ca6E5404b0766f933e077b118;\\n        ledgers[PROPOSAL_LEDGER] = 0x6F7b95C8CEd86D091002A3546f5154256d6c0AA1;\\n        ledgers[NODE_LEDGER] = 0xC46E4B28703C1dDfA77507B8c6Bc7dC495a3b1de;\\n        ledgers[FUND_LEDGER] = 0x18731261A0cA711e67877389FBa962021CdfE1BD;\\n        ledgers[DESTROY_LEDGER] = 0xCEA7B41F90069Cf88F004ee806f88d4840EFc530;\\n\\n        allocationRatio[PROFIT_LEDGER] = 50;\\n        allocationRatio[HOLDING_LEDGER] = 20;\\n        allocationRatio[PROGRAM_LEDGER] = 10;\\n        allocationRatio[PROPOSAL_LEDGER] = 10;\\n        allocationRatio[NODE_LEDGER] = 5;\\n        allocationRatio[FUND_LEDGER] = 5;\\n\\n        // prevMine();\\n    }\\n\\n    // 获取账本地址\\n    function getLedgerAddress(string memory _name) public view returns (address) {\\n        return ledgers[_name];\\n    }\\n\\n    // 获取账本分成比例\\n    function getLedgerRadio(string memory _name) public view returns (uint8) {\\n        return allocationRatio[_name];\\n    }\\n\\n    // 获取该年度的数据\\n    function getYearData(uint16 _year) public view returns(uint16 year, uint256 start_time, uint256 end_time, uint16 daysInYear, uint256 issueVolume) {\\n        return yearsData.getYearDataFromYear(_year);\\n    }\\n\\n    // 从时间戳里面获取日期的时间戳\\n    function getYearDataFromTimestamp(uint256 _time) public view returns(uint16 year, uint256 start_time, uint256 end_time, uint16 daysInYear, uint256 issueVolume) {\\n        return yearsData.getYearDataFromTimestamp(_time);\\n    }\\n\\n    // 从时间戳里面获取日期的时间戳\\n    function getDayTimestampFromTimestamp(uint256 _time) public view returns(uint256) {\\n        return yearsData.getDayTimestamp(_time);\\n    }\\n\\n    // 获取从现在到发行日的所有历史的日期时间戳\\n    function getHistoryDaysTimestamp() public view returns(uint256[] memory){\\n        uint256 time = now - 3600*24;\\n        return yearsData.getHistoryDaysTimestamp(time);\\n    }\\n\\n    // 该日期是否已经挖过了\\n    function isAllocated(uint256 _dayTimestamp) public view returns(bool) {\\n        if (allocatedDates[_dayTimestamp] \\u003e 0)\\n        {\\n            return true;\\n        }\\n\\n        _dayTimestamp = getDayTimestampFromTimestamp(_dayTimestamp);\\n\\n        if (allocatedDates[_dayTimestamp] \\u003e 0)\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n    // 指定日期的挖矿挖矿\\n    function mine(uint256 _dayTimestamp) checkMined(_dayTimestamp) private onlyOwner{\\n        uint256 __dayTimestamp = getDayTimestampFromTimestamp(_dayTimestamp);\\n\\n        (, , , uint16 daysInYear, uint256 issueVolume) = getYearDataFromTimestamp(__dayTimestamp);\\n\\n        uint256 dayVolume = issueVolume / daysInYear; // 每日的出矿量\\n\\n        totalSupply += dayVolume; // 总量增加\\n\\n        balanceOf[msg.sender] += dayVolume; // 创建人人余额增加\\n\\n        emit DailyMined(__dayTimestamp, dayVolume);\\n\\n        allocatedDates[__dayTimestamp] = dayVolume; // 记录已挖的日期\\n\\n        allocatingMine(dayVolume); // 按规则分配矿池\\n\\n    }\\n\\n    // 挖今天的矿\\n    function mine() checkNowMined public onlyOwner {\\n        uint256 _now = now;\\n\\n        mine(_now);\\n    }\\n\\n    // 按规则分配矿池\\n    function allocatingMine(uint256 _dayVolume) internal onlyOwner{\\n        uint256 value = 0;\\n\\n        value = (_dayVolume * 50) / 100;\\n        transfer(ledgers[PROFIT_LEDGER], value);\\n\\n        value = (_dayVolume * 20) / 100;\\n        transfer(ledgers[HOLDING_LEDGER], value);\\n\\n        value = (_dayVolume * 10) / 100;\\n        transfer(ledgers[PROGRAM_LEDGER], value);\\n\\n        value = (_dayVolume * 10) / 100;\\n        transfer(ledgers[PROPOSAL_LEDGER], value);\\n\\n        value = (_dayVolume * 5) / 100;\\n        transfer(ledgers[NODE_LEDGER], value);\\n\\n\\n        // value = (_dayVolume * allocationRatio[FUND_LEDGER]) / 100;\\n        value = balanceOf[msg.sender]; // 剩下的全给基金会，防止有余数\\n        transfer(ledgers[FUND_LEDGER], value);\\n    }\\n    // 将之前的先挖出来\\n    function prevMine() public onlyOwner{\\n        uint256[] memory historyDaysTimestamp = getHistoryDaysTimestamp();\\n\\n        uint256 max = 5;\\n        for (uint256 i=0; i\\u003chistoryDaysTimestamp.length; i++)\\n        {\\n            // if (max \\u003c 0)\\n            // {\\n            //     break;\\n            // }\\n\\n            if (!isAllocated(historyDaysTimestamp[i]))\\n            {\\n                mine(historyDaysTimestamp[i]);\\n                max = max-1;\\n            }\\n        }\\n    }\\n\\n    // 一天的发行量\\n    function dateOfSupply(uint256 _date) public view returns (uint256) {\\n        (,,,uint256 daysOfYear, uint256 supplyOfYear) = getYearDataFromTimestamp(_date);\\n\\n        return supplyOfYear / daysOfYear;\\n    }\\n\\n    // 今天的发行量\\n    function todayOfSupply() public view returns(uint256) {\\n        return dateOfSupply(now);\\n    }\\n\\n    function changeLedgerAddress(string memory _ledger_name, address _new_address) onlyOwner public {\\n        require(ledgers[_ledger_name] != address(0), \\u0027ledger is not exists.\\u0027);\\n\\n        ledgers[_ledger_name] = _new_address;\\n\\n        emit LedgerChanged(_ledger_name, _new_address);\\n    }\\n\\n}\\n\"},\"owned.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.7.0;\\n\\ncontract owned {\\n    address public owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner) onlyOwner public {\\n        owner = newOwner;\\n    }\\n}\"},\"TokenERC20.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.7.0;\\n\\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }\\n\\nimport \\\"./owned.sol\\\";\\n\\ncontract TokenERC20 is owned{\\n    // string public name;\\n    // string public symbol;\\n    // uint8 public decimals;\\n    uint256 public totalSupply;\\n\\n    // 用mapping保存每个地址对应的余额\\n    mapping (address =\\u003e uint256) public balanceOf;\\n    // 存储对账号的控制\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowance;\\n\\n    mapping (address =\\u003e bool) public frozenAccount;\\n\\n    /* This generates a public event on the blockchain that will notify clients */\\n    event FrozenFunds(address indexed target, bool frozen);\\n\\n    // 事件，用来通知客户端交易发生\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    // 事件，用来通知客户端代币被消费\\n    event Burn(address indexed from, uint256 value);\\n\\n    /**\\n     * 初始化构造\\n     */\\n    // constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\\n    //     totalSupply = initialSupply * 10 ** uint256(decimals);  // 供应的份额，份额跟最小的代币单位有关，份额 = 币数 * 10 ** decimals。\\n    //     balanceOf[msg.sender] = totalSupply;                // 创建者拥有所有的代币\\n    //     name = tokenName;                                   // 代币名称\\n    //     symbol = tokenSymbol;                               // 代币符号\\n    // }\\n\\n    /**\\n     * 代币交易转移的内部实现\\n     */\\n    // function _transfer(address _from, address _to, uint _value) internal {\\n    //     // 确保目标地址不为0x0，因为0x0地址代表销毁\\n    //     require(_to != address(0x0));\\n    //     // 检查发送者余额\\n    //     require(balanceOf[_from] \\u003e= _value);\\n    //     // 确保转移为正数个\\n    //     require(balanceOf[_to] + _value \\u003e balanceOf[_to]);\\n\\n    //     // 以下用来检查交易，\\n    //     uint previousBalances = balanceOf[_from] + balanceOf[_to];\\n    //     // Subtract from the sender\\n    //     balanceOf[_from] -= _value;\\n    //     // Add the same to the recipient\\n    //     balanceOf[_to] += _value;\\n    //     emit Transfer(_from, _to, _value);\\n\\n    //     // 用assert来检查代码逻辑。\\n    //     assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\\n    // }\\n\\n    /**\\n     *  代币交易转移\\n     * 从创建交易者账号发送`_value`个代币到 `_to`账号\\n     *\\n     * @param _to 接收者地址\\n     * @param _value 转移数额\\n     */\\n    function transfer(address _to, uint256 _value) public {\\n        _transfer(msg.sender, _to, _value);\\n    }\\n\\n    /**\\n     * 账号之间代币交易转移\\n     * @param _from 发送者地址\\n     * @param _to 接收者地址\\n     * @param _value 转移数额\\n     */\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\n        require(_value \\u003c= allowance[_from][msg.sender], \\u0027You have not been allowed to transfer.\\u0027);     // Check allowance\\n        allowance[_from][msg.sender] -= _value;\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * 设置某个地址（合约）可以交易者名义花费的代币数。\\n     *\\n     * 允许发送者`_spender` 花费不多于 `_value` 个代币\\n     *\\n     * @param _spender The address authorized to spend\\n     * @param _value the max amount they can spend\\n     */\\n    function approve(address _spender, uint256 _value) public\\n        returns (bool success) {\\n        allowance[msg.sender][_spender] = _value;\\n        return true;\\n    }\\n\\n    /**\\n     * 设置允许一个地址（合约）以交易者名义可最多花费的代币数。\\n     *\\n     * @param _spender 被授权的地址（合约）\\n     * @param _value 最大可花费代币数\\n     * @param _extraData 发送给合约的附加数据\\n     */\\n    // function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\\n    //     public\\n    //     returns (bool success) {\\n    //     tokenRecipient spender = tokenRecipient(_spender);\\n    //     if (approve(_spender, _value)) {\\n    //         spender.receiveApproval(msg.sender, _value, address(this), _extraData);\\n    //         return true;\\n    //     }\\n    // }\\n\\n    /**\\n     * 销毁创建者账户中指定个代币\\n     */\\n    function burn(uint256 _value) public returns (bool success) {\\n        require(balanceOf[msg.sender] \\u003e= _value, \\u0027This msg.sender have not enough value to burn.\\u0027);   // Check if the sender has enough\\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\\n        totalSupply -= _value;                      // Updates totalSupply\\n        emit Burn(msg.sender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * 销毁用户账户中指定个代币\\n     *\\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\\n     *\\n     * @param _from the address of the sender\\n     * @param _value the amount of money to burn\\n     */\\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\\n        require(balanceOf[_from] \\u003e= _value, \\u0027This address have not enough value to burn.\\u0027);                // Check if the targeted balance is enough\\n        require(_value \\u003c= allowance[_from][msg.sender], \\u0027This address have not been allowed to burn.\\u0027);    // Check allowance\\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender\\u0027s allowance\\n        totalSupply -= _value;                              // Update totalSupply\\n        emit Burn(_from, _value);\\n        return true;\\n    }\\n    \\n    /* Internal transfer, only can be called by this contract */\\n    function _transfer(address _from, address _to, uint _value) internal {\\n        require (_to != address(0x0), \\u0027Can not transfer to a empty address.\\u0027);                               // Prevent transfer to 0x0 address. Use burn() instead\\n        require (balanceOf[_from] \\u003e= _value, \\u0027This address have not enough value to transfer.\\u0027);               // Check if the sender has enough\\n        require (balanceOf[_to] + _value \\u003e balanceOf[_to], \\u0027The receiving address have too many token to transfer.\\u0027); // Check for overflows\\n        require(!frozenAccount[_from], \\u0027This address have been frozen.\\u0027);                     // Check if sender is frozen\\n        require(!frozenAccount[_to], \\u0027The receiving address have been frozen.\\u0027);                       // Check if recipient is frozen\\n        balanceOf[_from] -= _value;                         // Subtract from the sender\\n        balanceOf[_to] += _value;                           // Add the same to the recipient\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /// @notice Create `mintedAmount` tokens and send it to `target`\\n    /// @param target Address to receive the tokens\\n    /// @param mintedAmount the amount of tokens it will receive\\n    // function mintToken(address target, uint256 mintedAmount) onlyOwner public {\\n    //     balanceOf[target] += mintedAmount;\\n    //     totalSupply += mintedAmount;\\n    //     emit Transfer(address(0), address(this), mintedAmount);\\n    //     emit Transfer(address(this), target, mintedAmount);\\n    // }\\n\\n    /// @notice `freeze? Prevent | Allow` `target` from sending \\u0026 receiving tokens\\n    /// @param target Address to be frozen\\n    /// @param freeze either to freeze it or not\\n    function freezeAccount(address target, bool freeze) onlyOwner public {\\n        frozenAccount[target] = freeze;\\n        emit FrozenFunds(target, freeze);\\n    }\\n}\\n\"},\"YearsDataSetOptimized.sol\":{\"content\":\"pragma solidity \\u003e=0.4.0 \\u003c0.7.0;\\n\\n// time_zone is PRC\\ncontract YearsDataSetOptimized {\\n\\n    // gap of UTC and PRC time\\n    uint16 constant time_zone_seconds = 3600*8; // PRC的时区秒数\\n    uint16 constant start_year = 2020; // 开始年份\\n    uint16 constant end_year = 2076; // 结束年份\\n    // uint16[14] LeapYears = [2023,2027,2031,2035,2039,2043,2047,2051,2055,2059,2063,2067,2071,2075];\\n    uint16[14] LeapYears = [2024,2028,2032,2036,2040,2044,2048,2052,2056,2060,2064,2068,2072,2076]; // 闰年年份\\n\\n    uint256 constant secondsInDay = 86400; // 一天的秒数\\n    uint256 constant maxTimestamp = 3383222400; // 最大的时间戳，用来限制输入数据\\n    uint256 initialDateTimestamp; // 开始发行的时间戳，PRC time zone\\n    uint256 firstYearSupply;\\n\\n    // 限制年份\\n    modifier checkYear(uint256 _year)  {\\n        require(_year \\u003e= 2020 \\u0026\\u0026 _year \\u003c= 2076, \\u0027Year number must be between 2020 and 2076\\u0027);\\n        _;\\n    }\\n\\n    // 限制时间戳\\n    modifier checkTimestamp(uint256 _time) {\\n        require(_time \\u003e 0 \\u0026\\u0026 _time \\u003c= maxTimestamp, \\u0027Timestamp must not be be between 0 and 3383222400\\u0027);\\n        _;\\n    }\\n\\n    constructor(uint256 _initialDateTimestamp, uint256 _firstYearSupply) public {\\n        initialDateTimestamp = _initialDateTimestamp;\\n        firstYearSupply = _firstYearSupply;\\n\\n        // for test\\n/*        if (initialDateTimestamp == 0)\\n        {\\n            initialDateTimestamp = 1584460800;\\n        }\\n\\n        if (firstYearSupply == 0)\\n        {\\n            firstYearSupply = 50000000000000000;\\n        }\\n*/\\n        require(initialDateTimestamp \\u003e 0, \\u0027initial DateTime can not be 0.\\u0027);\\n        require(firstYearSupply \\u003e 0, \\u0027First Year Supply can not be 0.\\u0027);\\n\\n        // 设定年度的开始和结束时间戳、一年里面的天数，总发行量，作为数据验证\\n        //yearsData[2020] = dayInYear(2020,1584460800,1615996800,365,50000000000000000);\\n        //yearsData[2021] = dayInYear(2021,1615996800,1647532800,365,25000000000000000);\\n        //yearsData[2022] = dayInYear(2022,1647532800,1679068800,365,12500000000000000);\\n        //yearsData[2023] = dayInYear(2023,1679068800,1710691200,366,6250000000000000);\\n        //yearsData[2024] = dayInYear(2024,1710691200,1742227200,365,3125000000000000);\\n        //yearsData[2025] = dayInYear(2025,1742227200,1773763200,365,1562500000000000);\\n        //yearsData[2026] = dayInYear(2026,1773763200,1805299200,365,781250000000000);\\n        //yearsData[2027] = dayInYear(2027,1805299200,1836921600,366,390625000000000);\\n        //yearsData[2028] = dayInYear(2028,1836921600,1868457600,365,195312500000000);\\n        //yearsData[2029] = dayInYear(2029,1868457600,1899993600,365,97656250000000);\\n        //yearsData[2030] = dayInYear(2030,1899993600,1931529600,365,48828125000000);\\n        //yearsData[2031] = dayInYear(2031,1931529600,1963152000,366,24414062500000);\\n        //yearsData[2032] = dayInYear(2032,1963152000,1994688000,365,12207031250000);\\n        //yearsData[2033] = dayInYear(2033,1994688000,2026224000,365,6103515625000);\\n        //yearsData[2034] = dayInYear(2034,2026224000,2057760000,365,3051757812500);\\n        //yearsData[2035] = dayInYear(2035,2057760000,2089382400,366,1525878906250);\\n        //yearsData[2036] = dayInYear(2036,2089382400,2120918400,365,762939453125);\\n        //yearsData[2037] = dayInYear(2037,2120918400,2152454400,365,381469726562);\\n        //yearsData[2038] = dayInYear(2038,2152454400,2183990400,365,190734863281);\\n        //yearsData[2039] = dayInYear(2039,2183990400,2215612800,366,95367431640);\\n        //yearsData[2040] = dayInYear(2040,2215612800,2247148800,365,47683715820);\\n        //yearsData[2041] = dayInYear(2041,2247148800,2278684800,365,23841857910);\\n        //yearsData[2042] = dayInYear(2042,2278684800,2310220800,365,11920928955);\\n        //yearsData[2043] = dayInYear(2043,2310220800,2341843200,366,5960464477);\\n        //yearsData[2044] = dayInYear(2044,2341843200,2373379200,365,2980232238);\\n        //yearsData[2045] = dayInYear(2045,2373379200,2404915200,365,1490116119);\\n        //yearsData[2046] = dayInYear(2046,2404915200,2436451200,365,745058059);\\n        //yearsData[2047] = dayInYear(2047,2436451200,2468073600,366,372529029);\\n        //yearsData[2048] = dayInYear(2048,2468073600,2499609600,365,186264514);\\n        //yearsData[2049] = dayInYear(2049,2499609600,2531145600,365,93132257);\\n        //yearsData[2050] = dayInYear(2050,2531145600,2562681600,365,46566128);\\n        //yearsData[2051] = dayInYear(2051,2562681600,2594304000,366,23283064);\\n        //yearsData[2052] = dayInYear(2052,2594304000,2625840000,365,11641532);\\n        //yearsData[2053] = dayInYear(2053,2625840000,2657376000,365,5820766);\\n        //yearsData[2054] = dayInYear(2054,2657376000,2688912000,365,2910383);\\n        //yearsData[2055] = dayInYear(2055,2688912000,2720534400,366,1455191);\\n        //yearsData[2056] = dayInYear(2056,2720534400,2752070400,365,727595);\\n        //yearsData[2057] = dayInYear(2057,2752070400,2783606400,365,363797);\\n        //yearsData[2058] = dayInYear(2058,2783606400,2815142400,365,181898);\\n        //yearsData[2059] = dayInYear(2059,2815142400,2846764800,366,90949);\\n        //yearsData[2060] = dayInYear(2060,2846764800,2878300800,365,45474);\\n        //yearsData[2061] = dayInYear(2061,2878300800,2909836800,365,22737);\\n        //yearsData[2062] = dayInYear(2062,2909836800,2941372800,365,11368);\\n        //yearsData[2063] = dayInYear(2063,2941372800,2972995200,366,5684);\\n        //yearsData[2064] = dayInYear(2064,2972995200,3004531200,365,2842);\\n        //yearsData[2065] = dayInYear(2065,3004531200,3036067200,365,1421);\\n        //yearsData[2066] = dayInYear(2066,3036067200,3067603200,365,710);\\n        //yearsData[2067] = dayInYear(2067,3067603200,3099225600,366,355);\\n        //yearsData[2068] = dayInYear(2068,3099225600,3130761600,365,177);\\n        //yearsData[2069] = dayInYear(2069,3130761600,3162297600,365,88);\\n        //yearsData[2070] = dayInYear(2070,3162297600,3193833600,365,44);\\n        //yearsData[2071] = dayInYear(2071,3193833600,3225456000,366,22);\\n        //yearsData[2072] = dayInYear(2072,3225456000,3256992000,365,11);\\n        //yearsData[2073] = dayInYear(2073,3256992000,3288528000,365,5);\\n        //yearsData[2074] = dayInYear(2074,3288528000,3320064000,365,2);\\n        //yearsData[2075] = dayInYear(2075,3320064000,3351686400,366,1);\\n        //yearsData[2076] = dayInYear(2076,3351686400,3383222400,365,0);\\n\\n    }\\n\\n\\n    // 获取该年度的数据\\n    // return (年度, 开始时间戳，结束时间戳，该年度的天数，该年度的总发行量)\\n    function getYearDataFromYear(uint16 _year) checkYear(_year) public view  returns(uint16 , uint256 , uint256 , uint16, uint256) {\\n\\n        uint256 issueVolumeOfYear = firstYearSupply; // 首年发行量\\n        uint256 start_gep_days = 0;\\n        uint256 last_year;\\n\\n        uint16[14] memory _leap_years = LeapYears;\\n\\n        // 算出开始时间距离发行日的天数\\n        for (uint16 i=start_year; i\\u003c=_year; i++)\\n        {\\n            last_year = i;\\n            if (i \\u003e start_year)\\n            {\\n                issueVolumeOfYear = issueVolumeOfYear / 2;\\n                start_gep_days += 365;\\n            }\\n\\n            for (uint256 ii=0; ii\\u003c_leap_years.length; ii++)\\n            {\\n                if (last_year == _leap_years[ii])\\n                {\\n                    // 闰年加一天\\n                    start_gep_days++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        uint16 _daysInYear = 365;\\n\\n        last_year++;\\n\\n        for (uint256 ii=0; ii\\u003c_leap_years.length; ii++)\\n        {\\n            if (last_year == _leap_years[ii])\\n            {\\n                // 闰年加一天\\n                _daysInYear++;\\n                break;\\n            }\\n        }\\n\\n        uint256 start_time = initialDateTimestamp + start_gep_days*1 days; // 开始时间\\n        uint256 end_time = initialDateTimestamp + (start_gep_days + _daysInYear)*1 days; // 结束时间\\n\\n        return (_year, start_time, end_time ,_daysInYear, issueVolumeOfYear);\\n    }\\n\\n    // 根据时间戳来获取当年度的数据\\n    // return (年度, 开始时间戳，结束时间戳，该年度的天数，该年度的总发行量)\\n    function getYearDataFromTimestamp(uint256 _time) checkTimestamp(_time) public view returns(uint16, uint256 , uint256 , uint16 , uint256 ) {\\n        uint16 year;\\n        uint256 start_time;\\n        uint256 end_time;\\n        uint16 daysInYear;\\n        uint256 issueVolumeOfYear;\\n\\n        // 计算_time时间戳落在那个年份内\\n        for (uint16 i=start_year; i\\u003c=end_year; i++)\\n        {\\n            (year, start_time, end_time ,daysInYear,issueVolumeOfYear) = getYearDataFromYear(i);\\n\\n            if (_time \\u003e= start_time \\u0026\\u0026 _time \\u003c end_time)\\n            {\\n                break;\\n            }\\n\\n        }\\n        return (year, start_time, end_time ,daysInYear, issueVolumeOfYear);\\n    }\\n\\n    // 从时间戳获取日期的时间戳\\n    function getDayTimestamp(uint256 _time) checkTimestamp(_time) public pure returns (uint256) {\\n        uint256 mod = (_time + time_zone_seconds) % secondsInDay;\\n\\n        uint256 dayTimestamp = _time - mod;\\n        return dayTimestamp;\\n    }\\n\\n    // 获取时间区间内的所有日期时间戳\\n    function getHistoryDaysTimestamp(uint256 _dayTimestamp) checkTimestamp(_dayTimestamp) public view returns(uint256[] memory) {\\n        uint256 dayTimestamp = getDayTimestamp(_dayTimestamp);\\n        uint256 dayTimestamp2 = dayTimestamp;\\n        uint256 _initialDateTimestamp = initialDateTimestamp;\\n        uint16 count = 0;\\n\\n        // 因为不支持动态数组，只能先计算数组的大小，然后再赋值过去，我日~~~~\\n        for (uint16 i=0; i\\u003c365; i++)\\n        {\\n            if (dayTimestamp \\u003c= _initialDateTimestamp)\\n            {\\n                break;\\n            }\\n\\n            count++;\\n\\n            dayTimestamp -= secondsInDay;\\n        }\\n\\n        uint256[] memory daysTimestamp = new uint256[](count);\\n\\n        dayTimestamp = dayTimestamp2;\\n\\n        // 赋值给数组\\n        daysTimestamp[0] = dayTimestamp;\\n        for (uint16 i=1; i\\u003ccount; i++)\\n        {\\n            dayTimestamp -= secondsInDay;\\n            daysTimestamp[i] = dayTimestamp;\\n        }\\n\\n        return daysTimestamp;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"volume\",\"type\":\"uint256\"}],\"name\":\"DailyMined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"ledger_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"new_address\",\"type\":\"address\"}],\"name\":\"LedgerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_ledger_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_new_address\",\"type\":\"address\"}],\"name\":\"changeLedgerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"dateOfSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getDayTimestampFromTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHistoryDaysTimestamp\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getLedgerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getLedgerRadio\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_year\",\"type\":\"uint16\"}],\"name\":\"getYearData\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"start_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_time\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"daysInYear\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"issueVolume\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getYearDataFromTimestamp\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"start_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_time\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"daysInYear\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"issueVolume\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dayTimestamp\",\"type\":\"uint256\"}],\"name\":\"isAllocated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prevMine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"todayOfSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EncropyTokenOptimized","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://5f0202ff20cb777fbe02a0ef3f75517cb30bd9466ad312da4d4a8c0a7f468df4"}]}