{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public pendingOwner;\r\n    mapping(address => bool) public managers;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event SetManager(address indexed owner, address indexed newManager);\r\n    event RemoveManager(address indexed owner, address indexed previousManager);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"onlyOwner: non-owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than a manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(managers[msg.sender], \"onlyManager: non-manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the user(`account`) is the a manager.\r\n     */\r\n    function isManager(address _account) public view returns (bool) {\r\n        return managers[_account];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner_`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != owner, \"transferOwnership: the same owner.\");\r\n        require(pendingOwner != _newOwner, \"transferOwnership : the same pendingOwner.\");\r\n        pendingOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Accepts ownership of the contract.\r\n     * Can only be called by the settting new owner(`pendingOwner`).\r\n     */\r\n    function acceptOwnership() external {\r\n        require(msg.sender == pendingOwner, \"acceptOwnership: only new owner do this.\");\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Set a new user(`account`) as a manager.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function setManager(address _account) external onlyOwner {\r\n        require(_account != address(0), \"setManager: account cannot be a zero address.\");\r\n        require(!isManager(_account), \"setManager: Already a manager address.\");\r\n        managers[_account] = true;\r\n        emit SetManager(owner, _account);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a previous manager account.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function removeManager(address _account) external onlyOwner {\r\n        require(_account != address(0), \"removeManager: _account cannot be a zero address.\");\r\n        require(isManager(_account), \"removeManager: Not an admin address.\");\r\n        managers[_account] = false;\r\n        emit RemoveManager(owner, _account);\r\n    }\r\n}\r\n\r\ncontract ErrorReporter {\r\n\r\n    enum Error {\r\n        NO_ERROR,\r\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\r\n        UNAUTHORIZED,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW,\r\n        DIVISION_BY_ZERO,\r\n        BAD_INPUT,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_TRANSFER_FAILED,\r\n        MARKET_NOT_SUPPORTED,\r\n        SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_RATE_CALCULATION_FAILED,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_OUT_FAILED,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INSUFFICIENT_BALANCE,\r\n        INVALID_COLLATERAL_RATIO,\r\n        MISSING_ASSET_PRICE,\r\n        EQUITY_INSUFFICIENT_BALANCE,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        ASSET_NOT_PRICED,\r\n        INVALID_LIQUIDATION_DISCOUNT,\r\n        INVALID_COMBINED_RISK_PARAMETERS,\r\n        ZERO_ORACLE_ADDRESS,\r\n        CONTRACT_PAUSED\r\n    }\r\n}\r\n\r\ncontract CarefulMath is ErrorReporter {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mul(uint a, uint b) internal pure returns (Error, uint) {\r\n        if (a == 0) {\r\n            return (Error.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint a, uint b) internal pure returns (Error, uint) {\r\n        if (b == 0) {\r\n            return (Error.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint a, uint b) internal pure returns (Error, uint) {\r\n        if (b <= a) {\r\n            return (Error.NO_ERROR, a - b);\r\n        } else {\r\n            return (Error.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function add(uint a, uint b) internal pure returns (Error, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (Error.NO_ERROR, c);\r\n        } else {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\r\n        (Error err0, uint sum) = add(a, b);\r\n\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return sub(sum, c);\r\n    }\r\n}\r\n\r\ncontract Exponential is CarefulMath {\r\n\r\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\r\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\r\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\r\n    uint constant expScale = 10**18;\r\n\r\n    // See TODO on expScale\r\n    uint constant halfExpScale = expScale/2;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    uint constant mantissaOne = 10**18;\r\n    uint constant mantissaOneTenth = 10**17;\r\n\r\n    /**\r\n    * @dev Creates an exponential from numerator and denominator values.\r\n    *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n    *            or if `denom` is zero.\r\n    */\r\n    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\r\n        (Error err0, uint scaledNumerator) = mul(num, expScale);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err1, uint rational) = div(scaledNumerator, denom);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two exponentials, returning a new exponential.\r\n    */\r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n        (Error error, uint result) = add(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two exponentials, returning a new exponential.\r\n    */\r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n        (Error error, uint result) = sub(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n    * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n    */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\r\n        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n    * @dev Divide an Exp by a scalar, returning a new Exp.\r\n    */\r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\r\n        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n    * @dev Divide a scalar by an Exp, returning a new Exp.\r\n    */\r\n    function divScalarByExp(uint scalar, Exp divisor) pure internal returns (Error, Exp memory) {\r\n        /*\r\n            We are doing this as:\r\n            getExp(mul(expScale, scalar), divisor.mantissa)\r\n\r\n            How it works:\r\n            Exp = a / b;\r\n            Scalar = s;\r\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (Error err0, uint numerator) = mul(expScale, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two exponentials, returning a new exponential.\r\n    */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n\r\n        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == Error.NO_ERROR);\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n      * @dev Divides two exponentials, returning a new exponential.\r\n      *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n      *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n      */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n      * @dev Truncates the given exp to a whole number value.\r\n      *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\r\n      */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / 10**18;\r\n    }\r\n\r\n    /**\r\n      * @dev Checks if first Exp is less than second Exp.\r\n      */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\r\n    }\r\n\r\n    /**\r\n      * @dev Checks if left Exp <= right Exp.\r\n      */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n      * @dev returns true if Exp is exactly zero\r\n      */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n}\r\n\r\ninterface ILendFMe {\r\n\t\r\n\tfunction collateralRatio() external view returns (uint);\r\n\t\r\n\tfunction getCollateralMarketsLength() external view returns (uint);\r\n\tfunction collateralMarkets(uint marketIndex) external view returns (address);\r\n\tfunction markets(address asset) external view returns (bool, uint, address, uint, uint, uint, uint, uint, uint);\r\n\tfunction assetPrices(address asset) external view returns (uint);\r\n\t\r\n\tfunction supplyBalances(address account, address asset) external view returns (uint, uint);\r\n\tfunction borrowBalances(address account, address asset) external view returns (uint, uint);\r\n}\r\n\r\ncontract LendfMeData is Ownable, Exponential {\r\n    \r\n    address public owner;\r\n    \r\n    ILendFMe public lendfMe;\r\n    address public assetScalar;\r\n    uint public blockPaused = 9900772;\r\n    \r\n    struct Market {\r\n        bool isSupported;\r\n        uint blockNumber;\r\n        address interestRateModel;\r\n\r\n        uint totalSupply;\r\n        uint supplyRateMantissa;\r\n        uint supplyIndex;\r\n\r\n        uint totalBorrows;\r\n        uint borrowRateMantissa;\r\n        uint borrowIndex;\r\n    }\r\n    \r\n    struct Balance {\r\n        uint principal;\r\n        uint interestIndex;\r\n    }\r\n\r\n    constructor(address _lendfMe, address asset) public {\r\n        lendfMe = ILendFMe(_lendfMe);\r\n        assetScalar = asset;\r\n        owner = msg.sender;\r\n        managers[msg.sender] = true;\r\n    }\r\n    \r\n    function setLendfMe(address _lendfMe) public onlyManager {\r\n        lendfMe = ILendFMe(_lendfMe);\r\n    }\r\n    \r\n    function setAssetScalar(address _asset) public onlyManager {\r\n        assetScalar = _asset;\r\n    }\r\n    \r\n    function setBlockPaused(uint _blockPaused) public onlyManager {\r\n        blockPaused = _blockPaused;\r\n    }\r\n\r\n    function calculateInterestIndex(uint startingInterestIndex, uint interestRateMantissa, uint blockStart, uint blockEnd) pure public returns (Error, uint) {\r\n\r\n        // Get the block delta\r\n        (Error err0, uint blockDelta) = sub(blockEnd, blockStart);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        // Scale the interest rate times number of blocks\r\n        // Note: Doing Exp construction inline to avoid `CompilerError: Stack too deep, try removing local variables.`\r\n        (Error err1, Exp memory blocksTimesRate) = mulScalar(Exp({mantissa: interestRateMantissa}), blockDelta);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, 0);\r\n        }\r\n\r\n        // Add one to that result (which is really Exp({mantissa: expScale}) which equals 1.0)\r\n        (Error err2, Exp memory onePlusBlocksTimesRate) = addExp(blocksTimesRate, Exp({mantissa: mantissaOne}));\r\n        if (err2 != Error.NO_ERROR) {\r\n            return (err2, 0);\r\n        }\r\n\r\n        // Then scale that accumulated interest by the old interest index to get the new interest index\r\n        (Error err3, Exp memory newInterestIndexExp) = mulScalar(onePlusBlocksTimesRate, startingInterestIndex);\r\n        if (err3 != Error.NO_ERROR) {\r\n            return (err3, 0);\r\n        }\r\n\r\n        // Finally, truncate the interest index. This works only if interest index starts large enough\r\n        // that is can be accurately represented with a whole number.\r\n        return (Error.NO_ERROR, truncate(newInterestIndexExp));\r\n    }\r\n\r\n    function calculateBalance(uint startingBalance, uint interestIndexStart, uint interestIndexEnd) pure public returns (Error, uint) {\r\n        if (startingBalance == 0) {\r\n            // We are accumulating interest on any previous balance; if there's no previous balance, then there is\r\n            // nothing to accumulate.\r\n            return (Error.NO_ERROR, 0);\r\n        }\r\n        (Error err0, uint balanceTimesIndex) = mul(startingBalance, interestIndexEnd);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return div(balanceTimesIndex, interestIndexStart);\r\n    }\r\n\r\n    function getSupplyBalance(address account, address asset, uint blockEnd) view public returns (uint) {\r\n        Error err;\r\n        uint newSupplyIndex;\r\n        uint userSupplyCurrent;\r\n\r\n        Market memory market;\r\n        (, market.blockNumber, , , , , , market.borrowRateMantissa, market.borrowIndex) = lendfMe.markets(asset);\r\n        Balance memory supplyBalance;\r\n        (supplyBalance.principal, supplyBalance.interestIndex) = lendfMe.borrowBalances(account, asset);\r\n\r\n        // Calculate the newSupplyIndex, needed to calculate user's supplyCurrent\r\n        (err, newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, blockEnd);\r\n        require(err == Error.NO_ERROR);\r\n\r\n        // Use newSupplyIndex and stored principal to calculate the accumulated balance\r\n        (err, userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, newSupplyIndex);\r\n        require(err == Error.NO_ERROR);\r\n\r\n        return userSupplyCurrent;\r\n    }\r\n    \r\n    function getSupplyBalance(address account, address asset) view public returns (uint) {\r\n        return getSupplyBalance(account, asset, blockPaused);\r\n    }\r\n    \r\n    function getBorrowBalance(address account, address asset, uint blockEnd) view public returns (uint) {\r\n        Error err;\r\n        uint newBorrowIndex;\r\n        uint userBorrowCurrent;\r\n\r\n        Market memory market;\r\n        (, market.blockNumber, , , , , , market.borrowRateMantissa, market.borrowIndex) = lendfMe.markets(asset);\r\n        Balance memory borrowBalance;\r\n        (borrowBalance.principal, borrowBalance.interestIndex) = lendfMe.borrowBalances(account, asset);\r\n\r\n        // Calculate the newBorrowIndex, needed to calculate user's borrowCurrent\r\n        (err, newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, blockEnd);\r\n        require(err == Error.NO_ERROR);\r\n\r\n        // Use newBorrowIndex and stored principal to calculate the accumulated balance\r\n        (err, userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, newBorrowIndex);\r\n        require(err == Error.NO_ERROR);\r\n\r\n        return userBorrowCurrent;\r\n    }\r\n    \r\n    function getBorrowBalance(address account, address asset) view public returns (uint) {\r\n        return getBorrowBalance(account, asset, blockPaused);\r\n    }\r\n\r\n    \r\n    struct AccountValueLocalVars {\r\n        address assetAddress;\r\n        uint collateralMarketsLength;\r\n\r\n        uint newSupplyIndex;\r\n        uint userSupplyCurrent;\r\n        Exp supplyTotalValue;\r\n        Exp sumSupplies;\r\n\r\n        uint newBorrowIndex;\r\n        uint userBorrowCurrent;\r\n        Exp borrowTotalValue;\r\n        Exp sumBorrows;\r\n    }\r\n    \r\n    function calculateAccountValuesInternal(address userAddress) public view returns (Error, uint, uint) {\r\n        \r\n        AccountValueLocalVars memory localResults; // Re-used for all intermediate results\r\n        localResults.sumSupplies = Exp({mantissa: 0});\r\n        localResults.sumBorrows = Exp({mantissa: 0});\r\n        Error err; // Re-used for all intermediate errors\r\n        localResults.collateralMarketsLength = lendfMe.getCollateralMarketsLength();\r\n        Market memory currentMarket;\r\n        Balance memory supplyBalance;\r\n        Balance memory borrowBalance;\r\n\r\n        for (uint i = 0; i < localResults.collateralMarketsLength; i++) {\r\n            localResults.assetAddress = lendfMe.collateralMarkets(i);\r\n            (\r\n                , \r\n                currentMarket.blockNumber, \r\n                , \r\n                , currentMarket.supplyRateMantissa, \r\n                currentMarket.supplyIndex, \r\n                , currentMarket.borrowRateMantissa, \r\n                currentMarket.borrowIndex\r\n            ) = lendfMe.markets(localResults.assetAddress);\r\n            (supplyBalance.principal, supplyBalance.interestIndex) = lendfMe.supplyBalances(userAddress, localResults.assetAddress);\r\n            (borrowBalance.principal, borrowBalance.interestIndex) = lendfMe.borrowBalances(userAddress, localResults.assetAddress);\r\n\r\n            if (supplyBalance.principal > 0) {\r\n                // We calculate the newSupplyIndex and user’s supplyCurrent (includes interest)\r\n                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, blockPaused);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                // We have the user's supply balance with interest so let's multiply by the asset price to get the total value\r\n                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent); // supplyCurrent * oraclePrice = supplyValueInEth\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                // Add this to our running sum of supplies\r\n                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n            }\r\n\r\n            if (borrowBalance.principal > 0) {\r\n                // We perform a similar actions to get the user's borrow balance\r\n                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, blockPaused);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                // In the case of borrow, we multiply the borrow value by the collateral ratio\r\n                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent); // ( borrowCurrent* oraclePrice * collateralRatio) = borrowTotalValueInEth\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                // Add this to our running sum of borrows\r\n                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);\r\n    }\r\n\r\n    function calculateAccountValues(address userAddress) public view returns (uint, uint) {\r\n        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);\r\n        if (err != Error.NO_ERROR) {\r\n\r\n            return (0, 0);\r\n        }\r\n\r\n        return (supplyValue, borrowValue);\r\n    }\r\n    \r\n    \r\n    function getAccountLiquidity(address account) public view returns (int) {\r\n        (Error err, Exp memory accountLiquidity, Exp memory accountShortfall) = calculateAccountLiquidity(account);\r\n        require(err == Error.NO_ERROR);\r\n\r\n        if (isZeroExp(accountLiquidity)) {\r\n            return -1 * int(truncate(accountShortfall));\r\n        } else {\r\n            return int(truncate(accountLiquidity));\r\n        }\r\n    }\r\n    \r\n    function calculateAccountLiquidity(address userAddress) internal view returns (Error, Exp memory, Exp memory) {\r\n        Error err;\r\n        uint sumSupplyValuesMantissa;\r\n        uint sumBorrowValuesMantissa;\r\n        (err, sumSupplyValuesMantissa, sumBorrowValuesMantissa) = calculateAccountValuesInternal(userAddress);\r\n        if (err != Error.NO_ERROR) {\r\n            return(err, Exp({mantissa: 0}), Exp({mantissa: 0}));\r\n        }\r\n\r\n        Exp memory result;\r\n        \r\n        Exp memory sumSupplyValuesFinal = Exp({mantissa: sumSupplyValuesMantissa});\r\n        Exp memory sumBorrowValuesFinal; // need to apply collateral ratio\r\n\r\n        (err, sumBorrowValuesFinal) = mulExp(Exp({mantissa: lendfMe.collateralRatio()}), Exp({mantissa: sumBorrowValuesMantissa}));\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, Exp({mantissa: 0}), Exp({mantissa: 0}));\r\n        }\r\n\r\n        // if sumSupplies < sumBorrows, then the user is under collateralized and has account shortfall.\r\n        // else the user meets the collateral ratio and has account liquidity.\r\n        if (lessThanExp(sumSupplyValuesFinal, sumBorrowValuesFinal)) {\r\n            // accountShortfall = borrows - supplies\r\n            (err, result) = subExp(sumBorrowValuesFinal, sumSupplyValuesFinal);\r\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumBorrows is greater than sumSupplies directly above, therefore `subExp` cannot fail.\r\n\r\n            return (Error.NO_ERROR, Exp({mantissa: 0}), result);\r\n        } else {\r\n            // accountLiquidity = supplies - borrows\r\n            (err, result) = subExp(sumSupplyValuesFinal, sumBorrowValuesFinal);\r\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumSupplies is greater than sumBorrows directly above, therefore `subExp` cannot fail.\r\n\r\n            return (Error.NO_ERROR, result, Exp({mantissa: 0}));\r\n        }\r\n    }\r\n    \r\n    \r\n    function getPriceForAssetAmount(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\r\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, Exp({mantissa: 0}));\r\n        }\r\n\r\n        if (isZeroExp(assetPrice)) {\r\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return mulScalar(assetPrice, assetAmount); // assetAmountWei * oraclePrice = assetValueInEth\r\n    }\r\n\r\n    function fetchAssetPrice(address asset) internal view returns (Error, Exp memory) {\r\n        return (Error.NO_ERROR, Exp({mantissa: lendfMe.assetPrices(asset)}));\r\n    }\r\n\r\n    function assetPrices(address asset) public view returns (uint) {\r\n        (Error err, Exp memory result) = fetchAssetPrice(asset);\r\n        if (err != Error.NO_ERROR) {\r\n            return 0;\r\n        }\r\n        return result.mantissa;\r\n    }\r\n    \r\n    function getUSDForEth(uint ethValue) view public returns (uint) {\r\n        (, uint USDValue) = div(ethValue, lendfMe.assetPrices(assetScalar));\r\n        return USDValue;\r\n    }\r\n    \r\n    function getAssetUSDForValue(address asset, uint amount) view public returns (uint) {\r\n        uint balanceUSD;\r\n        (, balanceUSD) = mul(amount, lendfMe.assetPrices(asset));\r\n        return getUSDForEth(balanceUSD);\r\n    }\r\n    \r\n    function getUSD(address asset, uint amount) view public returns (uint) {\r\n        return getAssetUSDForValue(asset, amount);\r\n    }\r\n    \r\n    function getSupplyBalanceUSD(address account, address asset) view public returns (uint) {\r\n        uint amount = getSupplyBalance(account, asset);\r\n        return getUSD(asset, amount);\r\n    }\r\n    \r\n    function getBorrowBalanceUSD(address account, address asset) view public returns (uint) {\r\n        uint amount = getBorrowBalance(account, asset);\r\n        return getUSD(asset, amount);\r\n    }\r\n    \r\n    function calculateAccountUSD(address account) view public returns (uint, uint) {\r\n        (uint supplyValue, uint borrowValue) = calculateAccountValues(account);\r\n        return (getUSDForEth(supplyValue), getUSDForEth(borrowValue));\r\n    }\r\n    \r\n    function getLiquidity(address account) public view returns (int) {\r\n        (uint supplyValue, uint borrowValue) = calculateAccountValues(account);\r\n        return int(getUSDForEth(supplyValue) - getUSDForEth(borrowValue));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getBorrowBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"getUSDForEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"blockEnd\",\"type\":\"uint256\"}],\"name\":\"getBorrowBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"blockEnd\",\"type\":\"uint256\"}],\"name\":\"getSupplyBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getBorrowBalanceUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lendfMe\",\"type\":\"address\"}],\"name\":\"setLendfMe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"assetPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockPaused\",\"type\":\"uint256\"}],\"name\":\"setBlockPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getSupplyBalanceUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"calculateAccountValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lendfMe\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getSupplyBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getAssetUSDForValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"setAssetScalar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startingInterestIndex\",\"type\":\"uint256\"},{\"name\":\"interestRateMantissa\",\"type\":\"uint256\"},{\"name\":\"blockStart\",\"type\":\"uint256\"},{\"name\":\"blockEnd\",\"type\":\"uint256\"}],\"name\":\"calculateInterestIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startingBalance\",\"type\":\"uint256\"},{\"name\":\"interestIndexStart\",\"type\":\"uint256\"},{\"name\":\"interestIndexEnd\",\"type\":\"uint256\"}],\"name\":\"calculateBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"calculateAccountUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"calculateAccountValuesInternal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assetScalar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_lendfMe\",\"type\":\"address\"},{\"name\":\"asset\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"SetManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"previousManager\",\"type\":\"address\"}],\"name\":\"RemoveManager\",\"type\":\"event\"}]","ContractName":"LendfMeData","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000eee3e3828a45f7601d5f54bf49bb01d1a9df5ea000000000000000000000000eb269732ab75a6fd61ea60b06fe994cd32a83549","Library":"","LicenseType":"None","SwarmSource":"bzzr://afec68e2c591cd2cd2985abee6999e5689145f78b1241c8bb7a6931153eb0d4e"}]}