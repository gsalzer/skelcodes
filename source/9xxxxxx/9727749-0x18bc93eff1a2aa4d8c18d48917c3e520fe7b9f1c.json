{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract TransferableToken{\r\n    function balanceOf(address _owner) public returns (uint256 balance) ;\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) ;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) ;\r\n}\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        TransferableToken token = TransferableToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, balance));\r\n        require(status, \"call failed\");\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20TokenBankInterface{\r\n  function balance() public view returns(uint);\r\n  function token() public view returns(address, string memory);\r\n  function issue(address _to, uint _amount) public returns (bool success);\r\n}\r\n\r\ncontract ERC20Payment{\r\n  using SafeMath for uint;\r\n\r\n  string public payment_info;\r\n  ERC20TokenBankInterface public bank;\r\n  address public account;\r\n  uint public total_amount;\r\n  uint public remain;\r\n\r\n  event ClaimedPayment(address account, address to, uint amount);\r\n  event ChangedBank(address old_bank, address new_bank);\r\n\r\n  modifier only_owner{\r\n    require(account == msg.sender, \"only owner can call this\");\r\n    _;\r\n  }\r\n  constructor(string memory _info, address _bank, address _account, uint _amount) public {\r\n    require(_bank != address(0x0), \"invalid address\");\r\n    require(_account != address(0x0), \"invalid address\");\r\n    payment_info = _info;\r\n    bank = ERC20TokenBankInterface(_bank);\r\n    account = _account;\r\n    total_amount = _amount;\r\n    remain = _amount;\r\n  }\r\n\r\n  function change_token_bank(address _addr) public only_owner returns(bool){\r\n    require(_addr != address(0x0), \"invalid address\");\r\n    require(_addr != address(bank), \"same as old bank\");\r\n\r\n    address old =address(bank);\r\n    bank = ERC20TokenBankInterface(_addr);\r\n    emit ChangedBank(old, address(bank));\r\n    return true;\r\n  }\r\n\r\n  function bank_balance() public view returns(uint){\r\n    return bank.balance();\r\n  }\r\n  function bank_token() public view returns(address, string memory){\r\n    return bank.token();\r\n  }\r\n\r\n  function claim_payment(address to, uint amount) public only_owner returns(bool){\r\n    require(to != address(0x0), \"invalid address\");\r\n    require(amount <= remain, \"not enough remain\");\r\n    require(amount <= bank_balance(), \"bank doesn't have enough token\");\r\n    remain = remain.safeSub(amount);\r\n    bank.issue(to, amount);\r\n    emit ClaimedPayment(msg.sender, to, amount);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20PaymentFactory{\r\n  event CreateERC20Payment(address addr);\r\n\r\n  function newPayment(string memory info, address bank, address account, uint amount)\r\n  public returns (ERC20Payment){\r\n    ERC20Payment addr = new ERC20Payment(info, bank, account, amount);\r\n    emit CreateERC20Payment(address(addr));\r\n    return addr;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"info\",\"type\":\"string\"},{\"name\":\"bank\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"newPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"CreateERC20Payment\",\"type\":\"event\"}]","ContractName":"ERC20PaymentFactory","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"SafeMath:a37426cdca2be3d52c950d5ca1ffac842b89b06a","LicenseType":"MIT","SwarmSource":"bzzr://da63ad6d45eca03decf41c4737c76b8613234226e5c3587c6513dbd3e149763a"}]}