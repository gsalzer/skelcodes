{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/* Interface for the DMEX base contract */\r\ncontract DMEX_Base {\r\n    function getReserve(address token, address user) returns (uint256);\r\n    function setReserve(address token, address user, uint256 amount) returns (bool);\r\n\r\n    function availableBalanceOf(address token, address user) returns (uint256);\r\n    function balanceOf(address token, address user) returns (uint256);\r\n\r\n    function setBalance(address token, address user, uint256 amount) returns (bool);\r\n    function getInactivityReleasePeriod() returns (uint256);\r\n    function getMakerTakerBalances(address token, address maker, address taker) returns (uint256[4]);\r\n\r\n    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) returns (bool);\r\n    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) returns (bool);\r\n    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) returns (bool);\r\n    \r\n}\r\n\r\n// The DMEX Trading Contract\r\ncontract DMEX_Trading {\r\n    function assert(bool assertion) pure {\r\n        \r\n        if (!assertion) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    // Safe Multiply Function - prevents integer overflow \r\n    function safeMul(uint a, uint b) pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    // Safe Subtraction Function - prevents integer overflow \r\n    function safeSub(uint a, uint b) pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    // Safe Addition Function - prevents integer overflow \r\n    function safeAdd(uint a, uint b) pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    address public owner; // holds the address of the contract owner\r\n\r\n    // Event fired when the owner of the contract is changed\r\n    event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Allows only the owner of the contract to execute the function\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // Allows only the owner of the contract to execute the function\r\n    modifier onlyOracle {\r\n        assert(msg.sender == DmexOracleContract);\r\n        _;\r\n    }\r\n\r\n    // Changes the owner of the contract\r\n    function setOwner(address newOwner) onlyOwner {\r\n        emit SetOwner(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    mapping (address => bool) public admins;                    // mapping of admin addresses\r\n    mapping (address => bool) public pools;                     // mapping of liquidity pool addresses\r\n    mapping (bytes32 => uint256) public orderFills;             // mapping of orders to filled qunatity\r\n    mapping (bytes32 => mapping(uint256 => uint256)) public assetPrices; // mapping of assetHashes to block numbers to prices\r\n\r\n\r\n    address public feeAccount;          // the account that receives the trading fees\r\n    address public exchangeContract;    // the address of the DMEX_Base contract\r\n    address public DmexOracleContract;  // the address of the DMEX oracle contract\r\n\r\n    uint256 public makerFee;            // maker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\r\n    uint256 public takerFee;            // taker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\r\n    \r\n    uint256 public fundingInterval = 2057;     // the interval in blocks when funding fee is charged\r\n\r\n    bool public feeAccountChangeDisabled = false; // if true, fee account can't be changed\r\n\r\n    struct FuturesAsset {\r\n        address baseToken;              // the token for collateral\r\n        string priceUrl;                // the url where the price of the asset will be taken for settlement\r\n        string pricePath;               // price path in the returned JSON from the priceUrl (ex. path \"last\" will return tha value last from the json: {\"high\": \"156.49\", \"last\": \"154.31\", \"timestamp\": \"1556522201\", \"bid\": \"154.22\", \"vwap\": \"154.65\", \"volume\": \"25578.79138868\", \"low\": \"152.33\", \"ask\": \"154.26\", \"open\": \"152.99\"})\r\n        bool disabled;                  // if true, the asset cannot be used in contract creation (when price url no longer valid)\r\n        uint256 decimals;               // number of decimals in the price            \r\n    }\r\n\r\n    function createFuturesAsset(address baseToken, string priceUrl, string pricePath, uint256 decimals) onlyAdmin returns (bytes32)\r\n    {    \r\n        bytes32 futuresAsset = keccak256(this, baseToken, priceUrl, pricePath, decimals);\r\n        if (futuresAssets[futuresAsset].disabled) throw; // asset already exists and is disabled\r\n        \r\n        futuresAssets[futuresAsset] = FuturesAsset({\r\n            baseToken           : baseToken,\r\n            priceUrl            : priceUrl,\r\n            pricePath           : pricePath,\r\n            disabled            : false,\r\n            decimals            : decimals            \r\n        });\r\n\r\n        //emit FuturesAssetCreated(futuresAsset, baseToken, priceUrl, pricePath, decimals);\r\n        return futuresAsset;\r\n    }\r\n    \r\n    struct FuturesContract {\r\n        bytes32 asset;                  // the hash of the underlying asset object\r\n        uint256 expirationBlock;        // futures contract expiration block\r\n        uint256 closingPrice;           // the closing price for the futures contract\r\n        bool closed;                    // is the futures contract closed (0 - false, 1 - true)\r\n        bool broken;                    // if someone has forced release of funds the contract is marked as broken and can no longer close positions (0-false, 1-true)\r\n        uint256 multiplier;             // the multiplier price, normally the ETHUSD price * 1e8\r\n        uint256 fundingRate;            // funding rate expressed as proportion per block * 1e18\r\n        uint256 closingBlock;           // the block in which the contract was closed\r\n        bool perpetual;                 // true if contract is perpetual\r\n        uint256 maintenanceMargin;      // the maintenance margin coef 1e8\r\n    }\r\n\r\n    function createFuturesContract(bytes32 asset, uint256 expirationBlock, uint256 multiplier, uint256 fundingRate, bool perpetual, uint256 maintenanceMargin) onlyAdmin returns (bytes32)\r\n    {    \r\n        bytes32 futuresContract = keccak256(this, asset, expirationBlock, multiplier, fundingRate, perpetual, maintenanceMargin);\r\n        \r\n        futuresContracts[futuresContract] = FuturesContract({\r\n            asset               : asset,\r\n            expirationBlock     : expirationBlock,\r\n            closingPrice        : 0,\r\n            closed              : false,\r\n            broken              : false,\r\n            multiplier          : multiplier,\r\n            fundingRate         : fundingRate,\r\n            closingBlock        : 0,\r\n            perpetual           : perpetual,\r\n            maintenanceMargin   : maintenanceMargin\r\n        });\r\n\r\n        //emit FuturesContractCreated(futuresContract, asset, expirationBlock, multiplier, fundingRate, perpetual);\r\n        return futuresContract;\r\n    }\r\n\r\n    function getContractExpiration (bytes32 futuresContractHash) public view returns (uint256)\r\n    {\r\n        return futuresContracts[futuresContractHash].expirationBlock;\r\n    }\r\n\r\n    function getContractClosed (bytes32 futuresContractHash) public view returns (bool)\r\n    {\r\n        return futuresContracts[futuresContractHash].closed;\r\n    }\r\n\r\n    function getAssetDecimals (bytes32 futuresContractHash) public view returns (uint256)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].decimals;\r\n    }\r\n\r\n    function getContractBaseToken (bytes32 futuresContractHash) public view returns (address)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].baseToken;\r\n    }\r\n\r\n    function assetPricePath (bytes32 assetHash) public view returns (string)\r\n    {\r\n        return futuresAssets[assetHash].pricePath;\r\n    }\r\n\r\n    function getContractPriceUrl (bytes32 futuresContractHash) returns (string)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].priceUrl;\r\n    }\r\n\r\n    function getContractPricePath (bytes32 futuresContractHash) returns (string)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].pricePath;\r\n    }\r\n\r\n    function getMaintenanceMargin (bytes32 futuresContractHash) returns (uint256)\r\n    {\r\n        return futuresContracts[futuresContractHash].maintenanceMargin;\r\n    }\r\n\r\n    function setClosingPrice (bytes32 futuresContractHash, uint256 price) onlyOracle returns (bool) {\r\n        if (futuresContracts[futuresContractHash].closingPrice != 0) revert();\r\n        futuresContracts[futuresContractHash].closingPrice = price;\r\n        futuresContracts[futuresContractHash].closed = true;\r\n        futuresContracts[futuresContractHash].closingBlock = min(block.number,futuresContracts[futuresContractHash].expirationBlock);\r\n\r\n        return true;\r\n    }\r\n\r\n    function recordLatestAssetPrice (bytes32 futuresContractHash, uint256 price) onlyOracle returns (bool) {\r\n        assetPrices[futuresContracts[futuresContractHash].asset][block.number] = price;\r\n    }\r\n\r\n    mapping (bytes32 => FuturesAsset)       public futuresAssets;      // mapping of futuresAsset hash to FuturesAsset structs\r\n    mapping (bytes32 => FuturesContract)    public futuresContracts;   // mapping of futuresContract hash to FuturesContract structs\r\n    mapping (bytes32 => uint256)            public positions;          // mapping of user addresses to position hashes to position\r\n\r\n\r\n    enum Errors {\r\n        /*  0 */INVALID_PRICE,                 \r\n        /*  1 */INVALID_SIGNATURE,                \r\n        /*  2 */FUTURES_CONTRACT_EXPIRED,       \r\n        /*  3 */UINT48_VALIDATION,\r\n        /*  4 */LIQUIDATION_PRICE_NOT_TOUCHED,\r\n        /*  5 */POOL_MISUSE\r\n    }\r\n\r\n    event FuturesTrade(bool side, uint256 size, uint256 price, bytes32 indexed futuresContract, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\r\n    event FuturesPositionClosed(bytes32 indexed positionHash, uint256 closingPrice);\r\n    //event FuturesForcedRelease(bytes32 indexed futuresContract, bool side, address user);\r\n    event FuturesAssetCreated(bytes32 indexed futuresAsset, address baseToken, string priceUrl, string pricePath, uint256 maintenanceMargin);\r\n    event FuturesContractCreated(bytes32 indexed futuresContract, bytes32 asset, uint256 expirationBlock, uint256 multiplier, uint256 fundingRate, bool perpetual);\r\n    event PositionLiquidated(bytes32 indexed positionHash, uint256 price);\r\n    event FuturesMarginUpdated(address indexed user, bytes32 indexed futuresContract, bool side, uint64 marginToAdd);\r\n \r\n    // Fee change event\r\n    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee);\r\n\r\n    // Fee account changed event\r\n    event FeeAccountChanged(address indexed newFeeAccount);\r\n\r\n    // Log event, logs errors in contract execution (for internal use)\r\n    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\r\n    //event LogErrorLight(uint8 errorId);\r\n    // event LogUint(uint8 id, uint256 value);\r\n    // event LogBytes(uint8 id, bytes32 value);\r\n\r\n    // Constructor function, initializes the contract and sets the core variables\r\n    function DMEX_Trading(address feeAccount_, uint256 makerFee_, uint256 takerFee_, address exchangeContract_, address DmexOracleContract_, address poolAddress) {\r\n        owner               = msg.sender;\r\n        feeAccount          = feeAccount_;\r\n        makerFee            = makerFee_;\r\n        takerFee            = takerFee_;\r\n\r\n        exchangeContract    = exchangeContract_;\r\n        DmexOracleContract    = DmexOracleContract_;\r\n\r\n        pools[poolAddress] = true;\r\n    }\r\n\r\n    // Changes the fees\r\n    function setFees(uint256 makerFee_, uint256 takerFee_) onlyOwner {\r\n        require(makerFee_       < 10 finney && takerFee_ < 10 finney); // The fees cannot be set higher then 1%\r\n        makerFee                = makerFee_;\r\n        takerFee                = takerFee_;\r\n\r\n        emit FeeChange(makerFee, takerFee);\r\n    }\r\n\r\n    // Change fee account\r\n    function changeFeeAccount (address feeAccount_) onlyOwner {\r\n        if (feeAccountChangeDisabled) revert();\r\n        feeAccount = feeAccount_;\r\n        emit FeeAccountChanged(feeAccount_);\r\n    }\r\n\r\n    // Change thew funding interval\r\n    function changeFundingInterval(uint256 _newInterval) onlyOwner returns (bool _success)\r\n    {\r\n        fundingInterval = _newInterval;\r\n    }\r\n\r\n    // Disable future fee account change\r\n    function disableFeeAccountChange() onlyOwner {\r\n        feeAccountChangeDisabled = true;\r\n    }\r\n\r\n    // Adds or disables an admin account\r\n    function setAdmin(address admin, bool isAdmin) onlyOwner {\r\n        admins[admin] = isAdmin;\r\n    }\r\n\r\n    // Adds or disables a liquidity pool address\r\n    function setPool(address user, bool enabled) onlyOwner public {\r\n        pools[user] = enabled;\r\n    }\r\n\r\n    // Allows for admins only to call the function\r\n    modifier onlyAdmin {\r\n        if (msg.sender != owner && !admins[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n    function() external {\r\n        throw;\r\n    }   \r\n\r\n\r\n    function validateUint48(uint256 val) returns (bool)\r\n    {\r\n        if (val != uint48(val)) return false;\r\n        return true;\r\n    }\r\n\r\n    function validateUint64(uint256 val) returns (bool)\r\n    {\r\n        if (val != uint64(val)) return false;\r\n        return true;\r\n    }\r\n\r\n    function validateUint128(uint256 val) returns (bool)\r\n    {\r\n        if (val != uint128(val)) return false;\r\n        return true;\r\n    }\r\n\r\n\r\n    // Structure that holds order values, used inside the trade() function\r\n    struct FuturesOrderPair {\r\n        uint256 makerNonce;                 // maker order nonce, makes the order unique\r\n        uint256 takerNonce;                 // taker order nonce\r\n\r\n        uint256 takerIsBuying;              // true/false taker is the buyer\r\n\r\n        address maker;                      // address of the maker\r\n        address taker;                      // address of the taker\r\n\r\n        bytes32 makerOrderHash;             // hash of the maker order\r\n        bytes32 takerOrderHash;             // has of the taker order\r\n\r\n        uint256 makerAmount;                // trade amount for maker\r\n        uint256 takerAmount;                // trade amount for taker\r\n\r\n        uint256 makerPrice;                 // maker order price in wei (18 decimal precision)\r\n        uint256 takerPrice;                 // taker order price in wei (18 decimal precision)\r\n\r\n        uint256 makerLeverage;              // maker leverage\r\n        uint256 takerLeverage;              // taker leverage\r\n\r\n        bytes32 futuresContract;            // the futures contract being traded\r\n\r\n        address baseToken;                  // the address of the base token for futures contract\r\n\r\n        bytes32 makerPositionHash;          // hash for maker position\r\n        bytes32 makerInversePositionHash;   // hash for inverse maker position \r\n\r\n        bytes32 takerPositionHash;          // hash for taker position\r\n        bytes32 takerInversePositionHash;   // hash for inverse taker position\r\n    }\r\n\r\n    // Structure that holds trade values, used inside the trade() function\r\n    struct FuturesTradeValues {\r\n        uint256 qty;                    // amount to be trade\r\n        uint256 makerProfit;            // holds profit value\r\n        uint256 makerLoss;              // holds loss value\r\n        uint256 takerProfit;            // holds loss value\r\n        uint256 takerLoss;              // holds loss value\r\n        uint256 makerBalance;           // holds maker balance value\r\n        uint256 takerBalance;           // holds taker balance value\r\n        uint256 makerReserve;           // holds taker reserved value\r\n        uint256 takerReserve;           // holds taker reserved value\r\n        uint256 makerTradeCollateral;   // holds maker collateral value for trade\r\n        uint256 takerTradeCollateral;   // holds taker collateral value for trade\r\n        uint256 makerFee;\r\n        uint256 takerFee;\r\n        address pool;\r\n        bool[3] makerBoolValues;\r\n        bool[3] takerBoolValues;\r\n    }\r\n\r\n\r\n    function generateOrderHash (bool maker, bool takerIsBuying, address user, bytes32 futuresContractHash, uint256[11] tradeValues) public view returns (bytes32)\r\n    {\r\n        if (maker)\r\n        {\r\n            //                     futuresContract      user  amount          price           side            nonce           leverage\r\n            return keccak256(this, futuresContractHash, user, tradeValues[4], tradeValues[6], !takerIsBuying, tradeValues[0], tradeValues[2]);\r\n        }\r\n        else\r\n        {\r\n            //                     futuresContract      user  amount          price           side            nonce           leverage\r\n            return keccak256(this, futuresContractHash, user, tradeValues[5], tradeValues[7],  takerIsBuying, tradeValues[1], tradeValues[8]);  \r\n        }\r\n    }\r\n\r\n    // Executes multiple trades in one transaction, saves gas fees\r\n    function batchFuturesTrade(\r\n        uint8[2][] v,\r\n        bytes32[4][] rs,\r\n        uint256[11][] tradeValues,\r\n        address[3][] tradeAddresses,\r\n        bool[2][] boolValues,\r\n        uint256[5][] contractValues,\r\n        string priceUrl,\r\n        string pricePath\r\n    ) onlyAdmin\r\n    {\r\n        // function createFuturesAsset(address baseToken, string priceUrl, string pricePath, uint256 maintenanceMargin, uint256 decimals) onlyAdmin returns (bytes32)\r\n\r\n        /*\r\n            contractValues\r\n            [0] expirationBlock\r\n            [1] multiplier\r\n            [2] fundingRate\r\n            [3] maintenanceMargin\r\n            [4] asset decimals\r\n\r\n            assetStrings\r\n            [0] asset name\r\n            [1] asset priceUrl\r\n            [2] asset pricePath\r\n\r\n            tradeAddresses\r\n            [0] maker\r\n            [1] taker\r\n            [2] asset baseToken\r\n\r\n        */\r\n\r\n        // perform trades\r\n        for (uint i = 0; i < tradeAddresses.length; i++) {\r\n            futuresTrade(\r\n                v[i],\r\n                rs[i],\r\n                tradeValues[i],\r\n                [tradeAddresses[i][0], tradeAddresses[i][1]],\r\n                boolValues[i][0],\r\n                createFuturesContract(\r\n                    createFuturesAsset(tradeAddresses[i][2], priceUrl, pricePath, contractValues[i][4]),\r\n                    contractValues[i][0], \r\n                    contractValues[i][1], \r\n                    contractValues[i][2], \r\n                    boolValues[i][1],\r\n                    contractValues[i][3]\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // Opens/closes futures positions\r\n    function futuresTrade(\r\n        uint8[2] v,\r\n        bytes32[4] rs,\r\n        uint256[11] tradeValues,\r\n        address[2] tradeAddresses,\r\n        bool takerIsBuying,\r\n        bytes32 futuresContractHash\r\n    ) onlyAdmin returns (uint filledTakerTokenAmount)\r\n    {\r\n        /* tradeValues\r\n          [0] makerNonce\r\n          [1] takerNonce\r\n          [2] makerLeverage\r\n          [3] takerIsBuying\r\n          [4] makerAmount\r\n          [5] takerAmount\r\n          [6] makerPrice\r\n          [7] takerPrice\r\n          [8] takerLeverage\r\n          [9] makerFee\r\n          [10] takerFee\r\n\r\n          tradeAddresses\r\n          [0] maker\r\n          [1] taker\r\n        */\r\n\r\n        FuturesOrderPair memory t  = FuturesOrderPair({\r\n            makerNonce      : tradeValues[0],\r\n            takerNonce      : tradeValues[1],\r\n            //takerGasFee     : tradeValues[2],\r\n            takerIsBuying   : tradeValues[3],\r\n            makerAmount     : tradeValues[4],      \r\n            takerAmount     : tradeValues[5],   \r\n            makerPrice      : tradeValues[6],         \r\n            takerPrice      : tradeValues[7],\r\n            makerLeverage   : tradeValues[2],\r\n            takerLeverage   : tradeValues[8],\r\n\r\n            maker           : tradeAddresses[0],\r\n            taker           : tradeAddresses[1],\r\n\r\n            makerOrderHash  : generateOrderHash(true,  takerIsBuying, tradeAddresses[0], futuresContractHash, tradeValues), // keccak256(this, futuresContractHash, tradeAddresses[0], tradeValues[4], tradeValues[6], !takerIsBuying, tradeValues[0], tradeValues[2]),\r\n            takerOrderHash  : generateOrderHash(false, takerIsBuying, tradeAddresses[1], futuresContractHash, tradeValues), // keccak256(this, futuresContractHash, tradeAddresses[1], tradeValues[5], tradeValues[7],  takerIsBuying, tradeValues[1], tradeValues[8]),            \r\n\r\n            futuresContract : futuresContractHash,\r\n\r\n            baseToken       : getContractBaseToken(futuresContractHash),\r\n\r\n            //                                            user               futuresContractHash   side           \r\n            makerPositionHash           : keccak256(this, tradeAddresses[0], futuresContractHash, !takerIsBuying),\r\n            makerInversePositionHash    : keccak256(this, tradeAddresses[0], futuresContractHash,  takerIsBuying),\r\n\r\n            takerPositionHash           : keccak256(this, tradeAddresses[1], futuresContractHash,  takerIsBuying),\r\n            takerInversePositionHash    : keccak256(this, tradeAddresses[1], futuresContractHash, !takerIsBuying)\r\n\r\n        });\r\n    \r\n        // Valifate size and price values\r\n        if (!validateUint128(t.makerAmount) || !validateUint128(t.takerAmount) || !validateUint64(t.makerPrice) || !validateUint64(t.takerPrice))\r\n        {            \r\n            emit LogError(uint8(Errors.UINT48_VALIDATION), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; \r\n        }\r\n\r\n        // Check if futures contract has expired already\r\n        if ((!futuresContracts[t.futuresContract].perpetual && block.number > futuresContracts[t.futuresContract].expirationBlock) || futuresContracts[t.futuresContract].closed == true || futuresContracts[t.futuresContract].broken == true)\r\n        {\r\n            emit LogError(uint8(Errors.FUTURES_CONTRACT_EXPIRED), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // futures contract is expired\r\n        }\r\n\r\n        // Checks the signature for the maker order\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\r\n        {\r\n            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n        // Checks the signature for the taker order\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\r\n        {\r\n            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n        // check prices\r\n        if ((!takerIsBuying && t.makerPrice < t.takerPrice) || (takerIsBuying && t.takerPrice < t.makerPrice))\r\n        {\r\n            emit LogError(uint8(Errors.INVALID_PRICE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // prices don't match\r\n        }\r\n\r\n        // trades between pools and trades without a pool are not allowed\r\n        if ((pools[t.maker] && pools[t.taker]) || (!pools[t.maker] && !pools[t.taker]))\r\n        {\r\n            emit LogError(uint8(Errors.POOL_MISUSE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // trade between pools\r\n        }           \r\n        \r\n\r\n        uint256[4] memory balances = DMEX_Base(exchangeContract).getMakerTakerBalances(t.baseToken, t.maker, t.taker);\r\n\r\n        // Initializing trade values structure \r\n        FuturesTradeValues memory tv = FuturesTradeValues({\r\n            qty                 : 0,\r\n            makerBalance        : balances[0], \r\n            takerBalance        : balances[1],  \r\n            makerReserve        : balances[2],  \r\n            takerReserve        : balances[3],\r\n            makerTradeCollateral: 0,\r\n            takerTradeCollateral: 0,\r\n            makerFee            : min(makerFee, tradeValues[9]),\r\n            takerFee            : min(takerFee, tradeValues[10]),\r\n            makerProfit         : 0,\r\n            makerLoss           : 0,\r\n            takerProfit         : 0,\r\n            takerLoss           : 0,\r\n            pool                : pools[t.maker] ? t.maker : t.taker,\r\n            makerBoolValues     : [false, false, false],\r\n            takerBoolValues     : [false, false, false]\r\n        });\r\n\r\n        // traded quantity is the smallest quantity between the maker and the taker, takes into account amounts already filled on the orders\r\n        // and open inverse positions\r\n        tv.qty = min(safeSub(t.makerAmount, orderFills[t.makerOrderHash]), safeSub(t.takerAmount, orderFills[t.takerOrderHash]));\r\n        \r\n        if (positionExists(t.makerInversePositionHash) && positionExists(t.takerInversePositionHash))\r\n        {\r\n            tv.qty = min(tv.qty, min(retrievePosition(t.makerInversePositionHash)[0], retrievePosition(t.takerInversePositionHash)[0]));\r\n        }\r\n        else if (positionExists(t.makerInversePositionHash))\r\n        {\r\n            tv.qty = min(tv.qty, retrievePosition(t.makerInversePositionHash)[0]);\r\n        }\r\n        else if (positionExists(t.takerInversePositionHash))\r\n        {\r\n            tv.qty = min(tv.qty, retrievePosition(t.takerInversePositionHash)[0]);\r\n        }\r\n\r\n        tv.makerTradeCollateral = calculateCollateral(tv.qty, t.makerPrice, t.makerLeverage, t.futuresContract, tv.makerFee);\r\n        tv.takerTradeCollateral = calculateCollateral(tv.qty, t.makerPrice, t.takerLeverage, t.futuresContract, tv.takerFee);\r\n\r\n        if (((!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash)) || positionExists(t.makerPositionHash)) && !pools[t.maker])\r\n        {\r\n            // check if maker has enough balance   \r\n            if (safeSub(tv.makerBalance,tv.makerReserve) < safeMul(tv.makerTradeCollateral, 1e10))\r\n            {\r\n                tv.qty =    safeMul(\r\n                                tv.qty,                                \r\n                                safeSub(\r\n                                    tv.makerBalance,\r\n                                    tv.makerReserve\r\n                                )\r\n                            ) \r\n                            / \r\n                            safeMul(tv.makerTradeCollateral, 1e10);\r\n            }\r\n        }\r\n\r\n        if (((!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash)) || positionExists(t.takerPositionHash)) && !pools[t.taker])\r\n        {            \r\n            // check if taker has enough balance\r\n            if (safeSub(tv.takerBalance,tv.takerReserve) < safeMul(tv.takerTradeCollateral, 1e10))\r\n            {                \r\n                tv.qty =    safeMul(\r\n                                tv.qty,\r\n                                safeSub(\r\n                                    tv.takerBalance,\r\n                                    tv.takerReserve\r\n                                )  \r\n                            ) \r\n                            / \r\n                            safeMul(tv.takerTradeCollateral, 1e10);\r\n            }\r\n        }\r\n        \r\n       \r\n        if (!takerIsBuying) /*------------- Maker long, Taker short -------------*/\r\n        {       \r\n            // position actions for maker\r\n            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\r\n            {\r\n                tv.makerBoolValues = [true, true, false]; // [newPosition, side, increasePositon]\r\n            } else {               \r\n                \r\n                if (positionExists(t.makerPositionHash))\r\n                {\r\n                    // increase position size\r\n                    tv.makerBoolValues = [false, true, true]; // [newPosition, side, increasePositon]\r\n                }\r\n                else\r\n                {\r\n                    // close/partially close existing position\r\n                    if (t.makerPrice < retrievePosition(t.makerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                        \r\n                    }\r\n\r\n                    tv.makerBoolValues = [false, true, false]; // [newPosition, side, increasePositon]\r\n                }                \r\n            }            \r\n\r\n            // position actions for taker\r\n            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\r\n            {        \r\n                // create new position\r\n                tv.takerBoolValues = [true, false, false]; // [newPosition, side, increasePositon]\r\n            } else {\r\n                if (positionExists(t.takerPositionHash))\r\n                {\r\n                    // increase position size\r\n                    tv.takerBoolValues = [false, false, true]; // [newPosition, side, increasePositon]\r\n                }\r\n                else\r\n                {    \r\n                    // close/partially close existing position\r\n                    if (t.makerPrice > retrievePosition(t.takerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false); \r\n                    }\r\n\r\n                    tv.takerBoolValues = [false, false, false]; // [newPosition, side, increasePositon]\r\n                }\r\n            }\r\n        }        \r\n        else /*------------- Maker short, Taker long -------------*/\r\n        {      \r\n            \r\n            // position actions for maker\r\n            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\r\n            {\r\n                // create new position\r\n                tv.makerBoolValues = [true, false, false]; // [newPosition, side, increasePositon]\r\n                \r\n\r\n            } else {\r\n                if (positionExists(t.makerPositionHash))\r\n                {\r\n                    // increase position size\r\n                    tv.makerBoolValues = [false, false, true]; // [newPosition, side, increasePositon]\r\n                }\r\n                else\r\n                {\r\n                    // close/partially close existing position\r\n                    if (t.makerPrice > retrievePosition(t.makerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);                               \r\n                    }\r\n\r\n                    tv.makerBoolValues = [false, false, false]; // [newPosition, side, increasePositon]\r\n                }\r\n            }    \r\n\r\n            // position actions for taker\r\n            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\r\n            {\r\n                tv.takerBoolValues = [true, true, false]; // [newPosition, side, increasePositon]\r\n            } else {\r\n                if (positionExists(t.takerPositionHash))\r\n                {\r\n                    // increase position size\r\n                    tv.takerBoolValues = [false, true, true]; // [newPosition, side, increasePositon]\r\n                }\r\n                else\r\n                {\r\n\r\n                    // close/partially close existing position\r\n                    if (t.makerPrice < retrievePosition(t.takerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                  \r\n                    }   \r\n\r\n                    tv.takerBoolValues = [false, true, false]; // [newPosition, side, increasePositon]                \r\n                }\r\n            }                      \r\n        }\r\n\r\n\r\n        if (tv.makerLoss > 0)\r\n        {\r\n            if (!updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken, // base token\r\n                        t.maker,  // user address\r\n                        tv.pool\r\n                    ], \r\n                    !tv.makerBoolValues[0] && !tv.makerBoolValues[2] ? t.makerInversePositionHash : t.makerPositionHash, // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice, // price\r\n                        tv.makerFee, // fee\r\n                        tv.makerProfit,  // profit\r\n                        tv.makerLoss, // loss\r\n                        tv.makerBalance, // balance\r\n                        0, // gasFee\r\n                        tv.makerReserve, // reserve\r\n                        t.makerLeverage // leverage\r\n                    ], \r\n                    tv.makerBoolValues\r\n                )\r\n            )\r\n            {\r\n                futuresContracts[t.futuresContract].broken = true;\r\n                forceReleaseReserveOperation(t.futuresContract, tv.pool == t.maker ? !tv.takerBoolValues[1] : !tv.makerBoolValues[1], tv.pool == t.maker ? t.taker : t.maker);\r\n                return;\r\n            }\r\n\r\n            updateBalances(\r\n                t.futuresContract, \r\n                [\r\n                    t.baseToken,   // base toke\r\n                    t.taker, // user address\r\n                    tv.pool\r\n                ], \r\n                !tv.takerBoolValues[0] && !tv.takerBoolValues[2] ? t.takerInversePositionHash : t.takerPositionHash,  // position hash\r\n                [\r\n                    tv.qty, // qty\r\n                    t.makerPrice, // price\r\n                    tv.takerFee, // fee\r\n                    tv.takerProfit, // profit\r\n                    tv.takerLoss, // loss\r\n                    tv.takerBalance, // balance\r\n                    0, // gasFee\r\n                    tv.takerReserve, // reserve\r\n                    t.takerLeverage // leverage\r\n                ], \r\n                tv.takerBoolValues\r\n            ); \r\n        }\r\n        else\r\n        {\r\n            if (!updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken,   // base toke\r\n                        t.taker, // user address\r\n                        tv.pool\r\n                    ], \r\n                    !tv.takerBoolValues[0] && !tv.takerBoolValues[2] ? t.takerInversePositionHash : t.takerPositionHash,  // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice, // price\r\n                        tv.takerFee, // fee\r\n                        tv.takerProfit, // profit\r\n                        tv.takerLoss, // loss\r\n                        tv.takerBalance, // balance\r\n                        0, // gasFee\r\n                        tv.takerReserve, // reserve\r\n                        t.takerLeverage // leverage\r\n                    ], \r\n                    tv.takerBoolValues\r\n                )\r\n            )\r\n            {\r\n                futuresContracts[t.futuresContract].broken = true;               \r\n                forceReleaseReserveOperation(t.futuresContract, tv.pool == t.maker ? !tv.takerBoolValues[1] : !tv.makerBoolValues[1], tv.pool == t.maker ? t.taker : t.maker);       \r\n                return;\r\n            }\r\n\r\n            updateBalances(\r\n                t.futuresContract, \r\n                [\r\n                    t.baseToken, // base token\r\n                    t.maker,  // user address\r\n                    tv.pool\r\n                ], \r\n                !tv.makerBoolValues[0] && !tv.makerBoolValues[2] ? t.makerInversePositionHash : t.makerPositionHash, // position hash\r\n                [\r\n                    tv.qty, // qty\r\n                    t.makerPrice, // price\r\n                    tv.makerFee, // fee\r\n                    tv.makerProfit,  // profit\r\n                    tv.makerLoss, // loss\r\n                    tv.makerBalance, // balance\r\n                    0, // gasFee\r\n                    tv.makerReserve, // reserve\r\n                    t.makerLeverage // leverage\r\n                ], \r\n                tv.makerBoolValues\r\n            ); \r\n        }\r\n\r\n        \r\n\r\n//--> 220 000\r\n        orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.qty); // increase the maker order filled amount\r\n        orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty); // increase the taker order filled amount\r\n\r\n//--> 264 000\r\n        emit FuturesTrade(takerIsBuying, tv.qty, t.makerPrice, t.futuresContract, t.makerOrderHash, t.takerOrderHash);\r\n\r\n        return tv.qty;\r\n    }\r\n\r\n\r\n    function calculateProfit(uint256 closingPrice, uint256 entryPrice, uint256 qty, bytes32 futuresContractHash, bool side) public view returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        return safeMul(safeMul(safeSub(side ? entryPrice : closingPrice, side ? closingPrice : entryPrice), qty), multiplier )  / 1e16;            \r\n    }\r\n\r\n    function calculateTradeValue(uint256 qty, uint256 price, bytes32 futuresContractHash)  public view returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        return safeMul(safeMul(safeMul(qty, price), 1e2), multiplier) / 1e8 ;\r\n    }\r\n\r\n    function calculateLoss(uint256 closingPrice, uint256 entryPrice, uint256 qty,  bytes32 futuresContractHash, bool side) public view returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n\r\n        return safeMul(safeMul(safeSub(side ? closingPrice : entryPrice, side ? entryPrice : closingPrice), qty), multiplier) / 1e16 ;        \r\n    }\r\n\r\n    function calculateCollateral (uint256 qty, uint256 price, uint256 leverage, bytes32 futuresContractHash, uint256 fee) view returns (uint256) // 1e8\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        uint256 collateral;\r\n            \r\n        collateral = safeMul(safeMul(price, qty), multiplier) / 1e8 / leverage;\r\n\r\n        return safeAdd(collateral, calculateFee(qty, price, fee, futuresContractHash));               \r\n    }\r\n\r\n    function calculateProportionalMargin(uint256 currQty, uint256 newQty, uint256 margin) view returns (uint256) // 1e8\r\n    {\r\n        uint256 proportionalMargin = safeMul(margin, newQty)/currQty;\r\n        return proportionalMargin;          \r\n    }\r\n\r\n    function calculateFundingCost (uint256 price, uint256 qty, uint256 fundingBlocks, bytes32 futuresContractHash)  public view returns (uint256) // 1e8\r\n    {\r\n        uint256 fundingRate = futuresContracts[futuresContractHash].fundingRate;\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n\r\n        uint256 fundingCost = safeMul(safeMul(safeMul(safeMul(fundingBlocks/fundingInterval, fundingInterval), fundingRate), safeMul(qty, price)/1e8)/1e18, multiplier)/1e8;\r\n\r\n        return fundingCost;  \r\n    }\r\n\r\n    function calculateFee (uint256 qty, uint256 tradePrice, uint256 fee, bytes32 futuresContractHash)  public view returns (uint256)\r\n    {\r\n        return safeMul(calculateTradeValue(qty, tradePrice, futuresContractHash), fee / 1e10) / 1e18;\r\n    }  \r\n\r\n\r\n    // Update user balance\r\n    function updateBalances (bytes32 futuresContract, address[3] addressValues, bytes32 positionHash, uint256[9] uintValues, bool[3] boolValues) private returns (bool)\r\n    {\r\n        /*\r\n            addressValues\r\n            [0] baseToken\r\n            [1] user\r\n            [2] pool address\r\n\r\n            uintValues\r\n            [0] qty\r\n            [1] price\r\n            [2] fee\r\n            [3] profit\r\n            [4] loss\r\n            [5] balance\r\n            [6] gasFee\r\n            [7] reserve\r\n            [8] leverage\r\n\r\n            boolValues\r\n            [0] newPostion\r\n            [1] side\r\n            [2] increase position\r\n\r\n        */\r\n\r\n\r\n        // pam = [fee value, collateral, fundignCost, payableFundingCost]               \r\n        uint256[3] memory pam = [\r\n            safeMul(calculateFee(uintValues[0], uintValues[1], uintValues[2], futuresContract), 1e10), \r\n            calculateCollateral(uintValues[0], uintValues[1], uintValues[8], futuresContract, 0),\r\n            0\r\n        ];\r\n\r\n\r\n               \r\n        if (boolValues[0] || boolValues[2])  \r\n        {\r\n            // Position is new or position is increased\r\n            if (boolValues[0])\r\n            {\r\n                // new position\r\n                recordNewPosition(positionHash, uintValues[0], uintValues[1], boolValues[1] ? 1 : 0, block.number, pam[1]);\r\n            }\r\n            else\r\n            {\r\n                // increase position\r\n                updatePositionSize(positionHash, safeAdd(retrievePosition(positionHash)[0], uintValues[0]), uintValues[1], safeAdd(retrievePosition(positionHash)[4], pam[1]));\r\n            }\r\n\r\n            \r\n            if (!pools[addressValues[1]])\r\n            {\r\n                subBalanceAddReserve(addressValues[0], addressValues[1], pam[0], pam[1]);                    \r\n            }\r\n            else\r\n            {\r\n                pam[0] = 0;\r\n            }\r\n        } \r\n        else \r\n        {\r\n            // Position exists, decreasing\r\n            pam[1] = calculateProportionalMargin(retrievePosition(positionHash)[0], uintValues[0], retrievePosition(positionHash)[4]);\r\n            \r\n            updatePositionSize(positionHash, safeSub(retrievePosition(positionHash)[0], uintValues[0]),  uintValues[1], safeSub(retrievePosition(positionHash)[4], pam[1]));\r\n\r\n            pam[2] = calculateFundingCost(retrievePosition(positionHash)[1], uintValues[0], safeSub(block.number, retrievePosition(positionHash)[3]), futuresContract);   \r\n            \r\n\r\n            if (pools[addressValues[1]]) {\r\n                pam[0] = 0;\r\n                pam[1] = 0;\r\n                pam[2] = 0;\r\n            }\r\n\r\n            if (uintValues[3] > 0) \r\n            {\r\n                // profit > 0\r\n                if (safeAdd(pam[0], safeMul(pam[2], 1e10)) <= safeMul(uintValues[3],1e10))\r\n                {\r\n                    addBalanceSubReserve(addressValues[0], addressValues[1], safeSub(safeMul(uintValues[3],1e10), safeAdd(pam[0], safeMul(pam[2], 1e10))), pam[1]);\r\n                }\r\n                else\r\n                {\r\n\r\n                    if (!subBalanceSubReserve(addressValues[0], addressValues[1], safeSub(safeAdd(pam[0], safeMul(pam[2], 1e10)), safeMul(uintValues[3],1e10)), pam[1]))\r\n                    {\r\n                        return false;\r\n                    }\r\n                }                \r\n            } \r\n            else \r\n            {   \r\n                // loss >= 0\r\n                // deduct loss from user balance\r\n                if (!subBalanceSubReserve(addressValues[0], addressValues[1], safeAdd(safeMul(uintValues[4],1e10), safeAdd(pam[0], safeMul(pam[2], 1e10))), pam[1])) \r\n                {\r\n                    return false;\r\n                }\r\n            }     \r\n\r\n        }          \r\n        \r\n        //if (safeAdd(pam[0], safeMul(pam[2], 1e10)) > 0)\r\n        if (pam[0] > 0)\r\n        {\r\n            addBalance(addressValues[0], feeAccount, DMEX_Base(exchangeContract).balanceOf(addressValues[0], feeAccount), pam[0]); // send fee to feeAccount\r\n        }\r\n\r\n        if (pam[2] > 0)\r\n        {\r\n            addBalance(addressValues[0], addressValues[2], DMEX_Base(exchangeContract).balanceOf(addressValues[0], addressValues[2]), safeMul(pam[2], 1e10));\r\n        }\r\n\r\n        return true;\r\n        \r\n    }\r\n\r\n    function recordNewPosition (bytes32 positionHash, uint256 size, uint256 price, uint256 side, uint256 block, uint256 collateral) private\r\n    {\r\n        if (!validateUint64(size) || !validateUint64(price) || !validateUint64(collateral)) \r\n        {\r\n            throw;\r\n        }\r\n\r\n        uint256 character = uint64(size);\r\n        character |= price<<64;\r\n        character |= collateral<<128;\r\n        character |= side<<192;\r\n        character |= block<<208;\r\n\r\n        positions[positionHash] = character;\r\n    }\r\n\r\n    function retrievePosition (bytes32 positionHash) public view returns (uint256[5])\r\n    {\r\n        uint256 character = positions[positionHash];\r\n        uint256 size = uint256(uint64(character));\r\n        uint256 price = uint256(uint64(character>>64));\r\n        uint256 collateral = uint256(uint64(character>>128));\r\n        uint256 side = uint256(uint16(character>>192));\r\n        uint256 entryBlock = uint256(uint48(character>>208));\r\n\r\n        return [size, price, side, entryBlock, collateral];\r\n    }\r\n\r\n    function updatePositionSize(bytes32 positionHash, uint256 size, uint256 price, uint256 collateral) private\r\n    {\r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n\r\n        if (size > pos[0])\r\n        {\r\n            uint256 totalValue = safeAdd(safeMul(pos[0], pos[1]), safeMul(price, safeSub(size, pos[0])));\r\n            uint256 newSize = safeSub(size, pos[0]);\r\n            // position is increasing in size\r\n            recordNewPosition(\r\n                positionHash, \r\n                size, \r\n                totalValue / size, \r\n                pos[2], \r\n                safeAdd(safeMul(safeMul(pos[0], pos[1]), pos[3]), safeMul(safeMul(price, newSize), block.number)) / totalValue, // pos[3]\r\n                collateral\r\n            );\r\n        }\r\n        else\r\n        {\r\n            // position is decreasing in size\r\n            recordNewPosition(\r\n                positionHash, \r\n                size, \r\n                pos[1], \r\n                pos[2], \r\n                pos[3],\r\n                collateral\r\n            );\r\n        }        \r\n    }\r\n\r\n    function positionExists (bytes32 positionHash) internal view returns (bool)\r\n    {\r\n        return retrievePosition(positionHash)[0] != 0;\r\n    }\r\n\r\n\r\n    // This function allows the user to manually release collateral in case the oracle service does not provide the price during the inactivityReleasePeriod\r\n    function forceReleaseReserve (bytes32 futuresContract, bool side, address user) public\r\n    {   \r\n        if (futuresContracts[futuresContract].expirationBlock == 0) revert();       \r\n        if (futuresContracts[futuresContract].expirationBlock > block.number) revert();\r\n        if (safeAdd(futuresContracts[futuresContract].expirationBlock, DMEX_Base(exchangeContract).getInactivityReleasePeriod()) > block.number) revert();    \r\n\r\n        futuresContracts[futuresContract].broken = true;\r\n        forceReleaseReserveOperation(futuresContract, side, user);\r\n    }\r\n\r\n    function forceReleaseReserveOperation(bytes32 futuresContract, bool side, address user) private\r\n    {\r\n        if (!futuresContracts[futuresContract].broken) revert();\r\n        bytes32 positionHash = keccak256(this, user, futuresContract, side);\r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n        if (pos[0] == 0) revert();\r\n        \r\n        FuturesContract cont = futuresContracts[futuresContract];\r\n        address baseToken = futuresAssets[cont.asset].baseToken;\r\n\r\n        subReserve(\r\n            baseToken, \r\n            user, \r\n            DMEX_Base(exchangeContract).getReserve(baseToken, user), \r\n            pos[4]\r\n        );        \r\n\r\n        updatePositionSize(positionHash, 0, 0, 0);\r\n\r\n        //emit FuturesForcedRelease(futuresContract, side, user);\r\n    }\r\n\r\n    function addBalance(address token, address user, uint256 balance, uint256 amount) private\r\n    {\r\n        DMEX_Base(exchangeContract).setBalance(token, user, safeAdd(balance, amount));\r\n    }\r\n\r\n    function subBalance(address token, address user, uint256 balance, uint256 amount) private returns (bool)\r\n    {\r\n        if (balance < amount) return false;\r\n        DMEX_Base(exchangeContract).setBalance(token, user, safeSub(balance, amount));\r\n        return true;\r\n    }\r\n\r\n    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) private returns (bool)\r\n    {\r\n        if (!DMEX_Base(exchangeContract).subBalanceAddReserve(token, user, subBalance, safeMul(addReserve, 1e10)))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) private returns (bool)\r\n    {\r\n        if (!DMEX_Base(exchangeContract).addBalanceSubReserve(token, user, addBalance, safeMul(subReserve, 1e10)))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) private returns (bool)\r\n    {\r\n        if (!DMEX_Base(exchangeContract).subBalanceSubReserve(token, user, subBalance, safeMul(subReserve, 1e10)))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function subReserve(address token, address user, uint256 reserve, uint256 amount) private \r\n    {\r\n        DMEX_Base(exchangeContract).setReserve(token, user, safeSub(reserve, safeMul(amount, 1e10)));\r\n    }\r\n\r\n    function getMakerTakerPositions(bytes32 makerPositionHash, bytes32 makerInversePositionHash, bytes32 takerPosition, bytes32 takerInversePosition) public view returns (uint256[5][4])\r\n    {\r\n        return [\r\n            retrievePosition(makerPositionHash),\r\n            retrievePosition(makerInversePositionHash),\r\n            retrievePosition(takerPosition),\r\n            retrievePosition(takerInversePosition)\r\n        ];\r\n    }\r\n\r\n\r\n    struct FuturesClosePositionValues {\r\n        address baseToken;\r\n        uint256 reserve;                \r\n        uint256 balance;                \r\n        uint256 closingPrice;           \r\n        bytes32 futuresContract;        \r\n        uint256 expirationBlock;        \r\n        uint256 entryBlock;             \r\n        uint256 collateral;            \r\n        uint256 totalPayable;\r\n        uint256 closingBlock;\r\n        uint256 liquidationPrice;\r\n        uint256 closingFee;\r\n        bool perpetual;\r\n        uint256 profit;\r\n        uint256 loss;\r\n        uint256 fundingCost;\r\n    }\r\n\r\n\r\n    function closeFuturesPosition(bytes32 futuresContract, bool side, address poolAddress)\r\n    {\r\n        closeFuturesPositionInternal(futuresContract, side, msg.sender, poolAddress, takerFee);\r\n    }\r\n\r\n    function closeFuturesPositionInternal (bytes32 futuresContract, bool side, address user, address poolAddress, uint256 expirationFee) private returns (bool)\r\n    {\r\n        bytes32 positionHash = keccak256(this, user, futuresContract, side);        \r\n        uint256[5] memory pos = retrievePosition(positionHash);        \r\n\r\n        if (futuresContracts[futuresContract].broken) revert(); // contract broken\r\n        if (futuresContracts[futuresContract].closed == false && futuresContracts[futuresContract].expirationBlock != 0) revert(); // contract not yet settled\r\n        if (pos[1] == 0) revert(); // position not found\r\n        if (pos[0] == 0) revert(); // position already closed\r\n        if (pools[user]) return;\r\n        if (!pools[poolAddress]) return;\r\n\r\n        uint256 fundingBlocks = safeSub(futuresContracts[futuresContract].closingBlock, pos[3]+1);\r\n        \r\n        FuturesClosePositionValues memory v = FuturesClosePositionValues({\r\n            baseToken       : getContractBaseToken(futuresContract),\r\n            reserve         : 0,\r\n            balance         : 0,\r\n            closingPrice    : futuresContracts[futuresContract].closingPrice,\r\n            futuresContract : futuresContract,\r\n            expirationBlock : futuresContracts[futuresContract].expirationBlock,\r\n            entryBlock      : pos[3],\r\n            collateral      : 0,\r\n            totalPayable    : 0,\r\n            closingBlock    : futuresContracts[futuresContract].closingBlock,\r\n            liquidationPrice: calculateLiquidationPriceFromPositionHash(futuresContract, side, user),\r\n            closingFee      : calculateFee(pos[0], pos[1], min(expirationFee, takerFee), futuresContract),\r\n            perpetual       : futuresContracts[futuresContract].perpetual,\r\n            profit          : 0,\r\n            loss            : 0,\r\n            fundingCost     : calculateFundingCost(pos[1], pos[0], fundingBlocks, futuresContract)\r\n        });\r\n\r\n        v.reserve = DMEX_Base(exchangeContract).getReserve(v.baseToken, user);\r\n        v.balance = DMEX_Base(exchangeContract).balanceOf(v.baseToken, user);\r\n    \r\n\r\n\r\n        if (( side && v.closingPrice <= v.liquidationPrice) ||\r\n            (!side && v.closingPrice >= v.liquidationPrice) )\r\n        {\r\n            liquidatePositionWithClosingPrice(futuresContract, user, side, poolAddress);\r\n            return;\r\n        }\r\n\r\n        v.collateral = pos[4];         \r\n        v.totalPayable = safeAdd(v.closingFee, v.fundingCost);\r\n\r\n        if (( side && v.closingPrice > pos[1]) ||\r\n            (!side && v.closingPrice < pos[1]))\r\n        {   \r\n            // user made a profit\r\n            v.profit = calculateProfit(v.closingPrice, pos[1], pos[0], futuresContract, !side);\r\n      \r\n            if (v.profit > safeAdd(v.fundingCost, v.closingFee/2))\r\n            {\r\n                if (!subBalance(v.baseToken, poolAddress, DMEX_Base(exchangeContract).balanceOf(v.baseToken, poolAddress), safeMul(safeSub(v.profit, safeAdd(v.fundingCost, v.closingFee/2)), 1e10)))\r\n                {\r\n                    // brake contract\r\n                    futuresContracts[futuresContract].broken = true;\r\n                    forceReleaseReserveOperation(futuresContract, side, user);\r\n                    return false;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                addBalance(v.baseToken, poolAddress, DMEX_Base(exchangeContract).balanceOf(v.baseToken, poolAddress), safeMul(safeSub(safeAdd(v.fundingCost, v.closingFee/2), v.profit), 1e10)); \r\n            }\r\n\r\n\r\n            if (v.profit > v.totalPayable)\r\n            {\r\n                addBalance(v.baseToken, user, v.balance, safeSub(safeMul(v.profit, 1e10), safeMul(v.totalPayable, 1e10))); \r\n            }\r\n            else\r\n            {\r\n                subBalance(v.baseToken, user, v.balance, safeMul(min(v.collateral, safeSub(v.totalPayable, v.profit)), 1e10)); \r\n            }            \r\n        }\r\n        else\r\n        {\r\n            // user made a loss\r\n            v.loss = calculateLoss(v.closingPrice, pos[1], pos[0], futuresContract, !side);  \r\n   \r\n            subBalance(v.baseToken, user, v.balance, safeMul(min(v.collateral, safeAdd(v.loss, v.totalPayable)), 1e10)); \r\n            addBalance(v.baseToken, poolAddress, DMEX_Base(exchangeContract).balanceOf(v.baseToken, poolAddress), safeMul(safeSub(min(v.collateral, safeAdd(v.loss, v.totalPayable)), v.closingFee/2), 1e10)); \r\n        } \r\n\r\n\r\n        subReserve(\r\n            v.baseToken, \r\n            user, \r\n            v.reserve, \r\n            v.collateral\r\n        ); \r\n\r\n        addBalance(v.baseToken, feeAccount, DMEX_Base(exchangeContract).balanceOf(v.baseToken, feeAccount), safeMul(v.closingFee/2, 1e10)); // send fee to feeAccount\r\n\r\n        updatePositionSize(positionHash, 0, 0, 0); \r\n\r\n        // update pool position\r\n        updatePositionSize(keccak256(this, poolAddress, futuresContract, !side), 0, 0, 0); \r\n\r\n        emit FuturesPositionClosed(positionHash, v.closingPrice);\r\n\r\n        return true;\r\n    }\r\n\r\n    function generatePositionHash (address user, bytes32 futuresContractHash, bool side) public view returns (bytes32)\r\n    {\r\n        return keccak256(this, user, futuresContractHash, side);\r\n    }\r\n\r\n    // closes position for user\r\n    function closeFuturesPositionForUser (bytes32 futuresContract, bool side, address user, address poolAddress, uint256 expirationFee) onlyAdmin\r\n    {\r\n        closeFuturesPositionInternal(futuresContract, side, user, poolAddress, expirationFee);\r\n    }\r\n\r\n    struct UpdateMarginValues {\r\n        bytes32 newMarginHash;\r\n        address baseToken;\r\n    }\r\n\r\n    function updateMargin(bytes32 futuresContractHash, address user, bool side, uint8 vs, bytes32 r, bytes32 s, uint64 newMargin /* 1e8 */, uint256 operationFee /* 1e18 */)\r\n    {\r\n        if (pools[user]) revert();\r\n        bytes32 positionHash = generatePositionHash(user, futuresContractHash, side);        \r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n        if (pos[0] == 0) revert();\r\n        if (newMargin == pos[4]) revert();\r\n\r\n        uint256 fee = calculateFee(pos[0], pos[1], min(operationFee, takerFee), futuresContractHash); // min(operationFee, takerFee)\r\n\r\n        UpdateMarginValues memory v = UpdateMarginValues({\r\n            newMarginHash: keccak256(this, user, futuresContractHash, side, newMargin),\r\n            baseToken: getContractBaseToken(futuresContractHash)\r\n        });\r\n\r\n        // check the signature is correct\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", v.newMarginHash), vs, r, s) != user) revert();\r\n\r\n        // check user has enough available balance\r\n        if (newMargin > pos[4])\r\n        {\r\n            if (DMEX_Base(exchangeContract).availableBalanceOf(v.baseToken, user) < safeMul(safeAdd(safeSub(newMargin, pos[4]), fee), 1e10)) revert();\r\n        }        \r\n\r\n        if (newMargin > pos[4])\r\n        {\r\n            // reserve additional margin and subtract fee from user\r\n            subBalanceAddReserve(v.baseToken, user, safeMul(fee, 1e10), safeSub(newMargin, pos[4]));            \r\n        }\r\n        else\r\n        {\r\n            // release margin form positon\r\n            subBalanceSubReserve(v.baseToken, user, safeMul(fee, 1e10), safeSub(pos[4], newMargin));   \r\n        }\r\n        \r\n        // update margin position position\r\n        updatePositionSize(positionHash, pos[0], pos[1], newMargin);  \r\n        \r\n        // add fee to feeAccount\r\n        addBalance(v.baseToken, feeAccount, DMEX_Base(exchangeContract).balanceOf(v.baseToken, feeAccount), safeMul(fee, 1e10));\r\n    \r\n        emit FuturesMarginUpdated(user, futuresContractHash, side, newMargin);\r\n    }\r\n\r\n    // Settle positions for closed contracts\r\n    function batchSettlePositions (\r\n        bytes32[] futuresContracts,\r\n        bool[] sides,\r\n        address[] users,\r\n        address[] pools,\r\n        uint256[] expirationFee\r\n    ) onlyAdmin {\r\n        \r\n        for (uint i = 0; i < futuresContracts.length; i++) \r\n        {\r\n            closeFuturesPositionForUser(futuresContracts[i], sides[i], users[i], pools[i], expirationFee[i]);\r\n        }\r\n    }\r\n\r\n    function liquidatePositionWithClosingPrice(bytes32 futuresContractHash, address user, bool side, address poolAddress) private\r\n    {\r\n        bytes32 positionHash = generatePositionHash(user, futuresContractHash, side);\r\n        liquidatePosition(positionHash, futuresContractHash, user, side, futuresContracts[futuresContractHash].closingPrice, poolAddress, futuresContracts[futuresContractHash].closingBlock);\r\n    }\r\n\r\n    function liquidatePositionWithAssetPrice(bytes32 futuresContractHash, address user, bool side, uint256 priceBlockNumber, address poolAddress) onlyAdmin\r\n    {\r\n        bytes32 assetHash = futuresContracts[futuresContractHash].asset;\r\n        if (assetPrices[assetHash][priceBlockNumber] == 0) return;\r\n\r\n        bytes32 positionHash = generatePositionHash(user, futuresContractHash, side);\r\n\r\n        // check that the price is older than postion\r\n        if (priceBlockNumber < retrievePosition(positionHash)[3]) return;  \r\n\r\n        liquidatePosition(positionHash, futuresContractHash, user, side, assetPrices[assetHash][priceBlockNumber], poolAddress, priceBlockNumber);\r\n    }\r\n\r\n    struct LiquidatePositionValues {\r\n        uint256 maintenanceMargin;\r\n        uint256 fundingRate;\r\n        uint256 multiplier;\r\n    }\r\n\r\n    function liquidatePosition (bytes32 positionHash, bytes32 futuresContractHash, address user, bool side, uint256 price, address poolAddress, uint256 block) private\r\n    {\r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n        if (pos[0] == 0) return;\r\n        if (!pools[poolAddress]) return;  \r\n        if (futuresContracts[futuresContractHash].broken) revert(); // contract broken    \r\n\r\n        bytes32 assetHash = futuresContracts[futuresContractHash].asset;  \r\n\r\n\r\n        uint256 collateral = pos[4];\r\n        uint256 fundingBlocks = safeSub(block, pos[3]);\r\n\r\n        LiquidatePositionValues memory v = LiquidatePositionValues({\r\n            maintenanceMargin: getMaintenanceMargin(futuresContractHash),\r\n            fundingRate: futuresContracts[futuresContractHash].fundingRate,\r\n            multiplier: futuresContracts[futuresContractHash].multiplier\r\n        });\r\n        \r\n        uint256 liquidationPrice = calculateLiquidationPrice(pos, [fundingBlocks, v.fundingRate, v.maintenanceMargin, v.multiplier]);\r\n\r\n        // get block price\r\n        if (( side && price >= liquidationPrice)\r\n        ||  (!side && price <= liquidationPrice))\r\n        {\r\n            emit LogError(uint8(Errors.LIQUIDATION_PRICE_NOT_TOUCHED), futuresContractHash, positionHash);\r\n            return; \r\n        }\r\n\r\n        // deduct collateral from user account\r\n        subBalanceSubReserve(futuresAssets[assetHash].baseToken, user, safeMul(collateral, 1e10), collateral);\r\n\r\n        // send collateral to pool address\r\n        addBalance(futuresAssets[assetHash].baseToken, poolAddress, DMEX_Base(exchangeContract).balanceOf(futuresAssets[assetHash].baseToken, poolAddress), safeMul(collateral, 1e10));\r\n    \r\n        updatePositionSize(positionHash, 0, 0, 0); \r\n        updatePositionSize(generatePositionHash(poolAddress, futuresContractHash, !side), 0, 0, 0); \r\n\r\n        emit PositionLiquidated(positionHash, price);\r\n    }\r\n\r\n    struct LiquidationPriceValues {\r\n        uint256 size;\r\n        uint256 price;\r\n        uint256 baseCollateral;\r\n    }\r\n\r\n    function calculateLiquidationPriceFromPositionHash (bytes32 futuresContractHash, bool side, address user) returns (uint256)\r\n    {\r\n        bytes32 positionHash = keccak256(this, user, futuresContractHash, side);      \r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n\r\n        if (pos[0] == 0) return;\r\n\r\n        uint256 fundingRate = futuresContracts[futuresContractHash].fundingRate;\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        uint256 maintenanceMargin = getMaintenanceMargin(futuresContractHash);\r\n\r\n        return calculateLiquidationPrice (pos, [safeSub(block.number, pos[3]), fundingRate, maintenanceMargin, multiplier]);\r\n    }\r\n\r\n    function calculateLiquidationPrice(uint256[5] pos, uint256[4] values) public view returns (uint256)\r\n    {\r\n    \r\n        /*\r\n            values\r\n            [0] fundingBlocks \r\n            [1] fundingRate\r\n            [2] maintenanceMargin \r\n            [3] multiplier\r\n        */\r\n        LiquidationPriceValues memory v = LiquidationPriceValues({\r\n            size: pos[0],\r\n            price: pos[1],\r\n            baseCollateral: pos[4]\r\n        });\r\n\r\n        // adjust funding blocks to funding interval\r\n        values[0] = safeMul(values[0]/fundingInterval, fundingInterval);\r\n        \r\n        uint256 collateral = safeMul(v.baseCollateral, 1e8) / values[3];\r\n        \r\n        \r\n        uint256 leverage = safeMul(v.price,v.size)/collateral/1e6;\r\n        uint256 coef = safeMul(safeMul(values[2], 1e10)/leverage, 1e2);\r\n        \r\n        uint256 fundingCost = safeMul(safeMul(safeMul(v.size, v.price)/1e8, values[0]), values[1])/1e18;\r\n        \r\n        uint256 netLiqPrice;\r\n        uint256 liquidationPrice;\r\n        \r\n        uint256 movement = safeMul(safeSub(collateral, min(collateral, fundingCost)), 1e8)/v.size;\r\n        \r\n        \r\n        if (pos[2] == 0)\r\n        {\r\n        \r\n            netLiqPrice = safeAdd(v.price, movement);\r\n            liquidationPrice = safeSub(netLiqPrice, min(netLiqPrice, safeMul(v.price, coef)/1e18)); \r\n        }\r\n        else\r\n        {\r\n            netLiqPrice = safeSub(v.price, movement);\r\n            liquidationPrice = safeAdd(netLiqPrice, safeMul(v.price, coef)/1e18); \r\n        }        \r\n        \r\n        return liquidationPrice;\r\n    }\r\n\r\n\r\n    // Returns the smaller of two values\r\n    function min(uint a, uint b) private pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // Returns the largest of the two values\r\n    function max(uint a, uint b) private pure returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"assertion\",\"type\":\"bool\"}],\"name\":\"assert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractPriceUrl\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DmexOracleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"poolAddress\",\"type\":\"address\"},{\"name\":\"expirationFee\",\"type\":\"uint256\"}],\"name\":\"closeFuturesPositionForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableFeeAccountChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateLiquidationPriceFromPositionHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"recordLatestAssetPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractPricePath\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"leverage\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"calculateCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2][]\"},{\"name\":\"rs\",\"type\":\"bytes32[4][]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[11][]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[3][]\"},{\"name\":\"boolValues\",\"type\":\"bool[2][]\"},{\"name\":\"contractValues\",\"type\":\"uint256[5][]\"},{\"name\":\"priceUrl\",\"type\":\"string\"},{\"name\":\"pricePath\",\"type\":\"string\"}],\"name\":\"batchFuturesTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetHash\",\"type\":\"bytes32\"}],\"name\":\"assetPricePath\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getAssetDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"validateUint48\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccountChangeDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"futuresContracts\",\"outputs\":[{\"name\":\"asset\",\"type\":\"bytes32\"},{\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"name\":\"closingPrice\",\"type\":\"uint256\"},{\"name\":\"closed\",\"type\":\"bool\"},{\"name\":\"broken\",\"type\":\"bool\"},{\"name\":\"multiplier\",\"type\":\"uint256\"},{\"name\":\"fundingRate\",\"type\":\"uint256\"},{\"name\":\"closingBlock\",\"type\":\"uint256\"},{\"name\":\"perpetual\",\"type\":\"bool\"},{\"name\":\"maintenanceMargin\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"positions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContracts\",\"type\":\"bytes32[]\"},{\"name\":\"sides\",\"type\":\"bool[]\"},{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"pools\",\"type\":\"address[]\"},{\"name\":\"expirationFee\",\"type\":\"uint256[]\"}],\"name\":\"batchSettlePositions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"validateUint128\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newInterval\",\"type\":\"uint256\"}],\"name\":\"changeFundingInterval\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"priceBlockNumber\",\"type\":\"uint256\"},{\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"liquidatePositionWithAssetPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"}],\"name\":\"changeFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"fundingBlocks\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateFundingCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"vs\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"newMargin\",\"type\":\"uint64\"},{\"name\":\"operationFee\",\"type\":\"uint256\"}],\"name\":\"updateMargin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"priceUrl\",\"type\":\"string\"},{\"name\":\"pricePath\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"createFuturesAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"bytes32\"},{\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"name\":\"multiplier\",\"type\":\"uint256\"},{\"name\":\"fundingRate\",\"type\":\"uint256\"},{\"name\":\"perpetual\",\"type\":\"bool\"},{\"name\":\"maintenanceMargin\",\"type\":\"uint256\"}],\"name\":\"createFuturesContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setClosingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[11]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[2]\"},{\"name\":\"takerIsBuying\",\"type\":\"bool\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"futuresTrade\",\"outputs\":[{\"name\":\"filledTakerTokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getMaintenanceMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pools\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"makerPositionHash\",\"type\":\"bytes32\"},{\"name\":\"makerInversePositionHash\",\"type\":\"bytes32\"},{\"name\":\"takerPosition\",\"type\":\"bytes32\"},{\"name\":\"takerInversePosition\",\"type\":\"bytes32\"}],\"name\":\"getMakerTakerPositions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[5][4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"forceReleaseReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"closingPrice\",\"type\":\"uint256\"},{\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"calculateLoss\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"generatePositionHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"closeFuturesPosition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"closingPrice\",\"type\":\"uint256\"},{\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"calculateProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateTradeValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractBaseToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"validateUint64\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currQty\",\"type\":\"uint256\"},{\"name\":\"newQty\",\"type\":\"uint256\"},{\"name\":\"margin\",\"type\":\"uint256\"}],\"name\":\"calculateProportionalMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"futuresAssets\",\"outputs\":[{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"priceUrl\",\"type\":\"string\"},{\"name\":\"pricePath\",\"type\":\"string\"},{\"name\":\"disabled\",\"type\":\"bool\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"tradePrice\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"positionHash\",\"type\":\"bytes32\"}],\"name\":\"retrievePosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maker\",\"type\":\"bool\"},{\"name\":\"takerIsBuying\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"tradeValues\",\"type\":\"uint256[11]\"}],\"name\":\"generateOrderHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pos\",\"type\":\"uint256[5]\"},{\"name\":\"values\",\"type\":\"uint256[4]\"}],\"name\":\"calculateLiquidationPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"},{\"name\":\"exchangeContract_\",\"type\":\"address\"},{\"name\":\"DmexOracleContract_\",\"type\":\"address\"},{\"name\":\"poolAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"side\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"FuturesTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"positionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"closingPrice\",\"type\":\"uint256\"}],\"name\":\"FuturesPositionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"futuresAsset\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceUrl\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"pricePath\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"maintenanceMargin\",\"type\":\"uint256\"}],\"name\":\"FuturesAssetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"asset\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"multiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundingRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"perpetual\",\"type\":\"bool\"}],\"name\":\"FuturesContractCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"positionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PositionLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"side\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"marginToAdd\",\"type\":\"uint64\"}],\"name\":\"FuturesMarginUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"takerFee\",\"type\":\"uint256\"}],\"name\":\"FeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newFeeAccount\",\"type\":\"address\"}],\"name\":\"FeeAccountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"errorId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"LogError\",\"type\":\"event\"}]","ContractName":"DMEX_Trading","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000095445852148540acb6fcb9e39856d15f1c416381000000000000000000000000000000000000000000000000002386f26fc0fff6000000000000000000000000000000000000000000000000002386f26fc0fff60000000000000000000000002101e480e22c953b37b9d0fe6551c1354fe705e6000000000000000000000000beb5546df7b08bea6210a48b4c7adfe684b36cbd0000000000000000000000000a24bde9d7618f9b745036fe0a7b57c7451ed724","Library":"","LicenseType":"GNU GPLv2","SwarmSource":"bzzr://1188be19c95bcb5d4ec115b2884bcf9ef4ecd0e3c1d86096964063530ee90fc7"}]}