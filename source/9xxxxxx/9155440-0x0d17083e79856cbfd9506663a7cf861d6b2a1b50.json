{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\ncontract LotteryTicket {\r\n    address owner;\r\n    string public constant name = \"LotteryTicket\";\r\n    string public constant symbol = \"✓\";\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    function emitEvent(address addr) public {\r\n        require(msg.sender == owner);\r\n        emit Transfer(msg.sender, addr, 1);\r\n    }\r\n}\r\n\r\ncontract WinnerTicket {\r\n    address owner;\r\n    string public constant name = \"WinnerTicket\";\r\n    string public constant symbol = \"✓\";\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    function emitEvent(address addr) public {\r\n        require(msg.sender == owner);\r\n        emit Transfer(msg.sender, addr, 1);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Storage {\r\n    address owner;\r\n\r\n    mapping (address => uint256) public amount;\r\n    mapping (uint256 => address[]) public level;\r\n    uint256 public count;\r\n    uint256 public maximum;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function purchase(address addr) public {\r\n        require(msg.sender == owner);\r\n\r\n        amount[addr]++;\r\n        if (amount[addr] > 1) {\r\n            level[amount[addr]].push(addr);\r\n            if (amount[addr] > 2) {\r\n                for (uint256 i = 0; i < level[amount[addr] - 1].length; i++) {\r\n                    if (level[amount[addr] - 1][i] == addr) {\r\n                        delete level[amount[addr] - 1][i];\r\n                        break;\r\n                    }\r\n                }\r\n            } else if (amount[addr] == 2) {\r\n                count++;\r\n            }\r\n            if (amount[addr] > maximum) {\r\n                maximum = amount[addr];\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function draw(uint256 goldenWinners) public view returns(address[] memory addresses) {\r\n\r\n        addresses = new address[](goldenWinners);\r\n        uint256 winnersCount;\r\n\r\n        for (uint256 i = maximum; i >= 2; i--) {\r\n            for (uint256 j = 0; j < level[i].length; j++) {\r\n                if (level[i][j] != address(0)) {\r\n                    addresses[winnersCount] = level[i][j];\r\n                    winnersCount++;\r\n                    if (winnersCount == goldenWinners) {\r\n                        return addresses;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\ncontract RefStorage is Ownable {\r\n\r\n    IERC20 public token;\r\n\r\n    mapping (address => bool) public contracts;\r\n\r\n    uint256 public prize = 0.00005 ether;\r\n    uint256 public interval = 100;\r\n\r\n    mapping (address => Player) public players;\r\n    struct Player {\r\n        uint256 tickets;\r\n        uint256 checkpoint;\r\n        address referrer;\r\n    }\r\n\r\n    event ReferrerAdded(address player, address referrer);\r\n    event BonusSent(address recipient, uint256 amount);\r\n\r\n    modifier restricted() {\r\n        require(contracts[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        token = IERC20(address(0x9f9EFDd09e915C1950C5CA7252fa5c4F65AB049B));\r\n    }\r\n\r\n    function changeContracts(address contractAddr) public onlyOwner {\r\n        contracts[contractAddr] = true;\r\n    }\r\n\r\n    function changePrize(uint256 newPrize) public onlyOwner {\r\n        prize = newPrize;\r\n    }\r\n\r\n    function changeInterval(uint256 newInterval) public onlyOwner {\r\n        interval = newInterval;\r\n    }\r\n\r\n    function newTicket() external restricted {\r\n        players[tx.origin].tickets++;\r\n        if (players[tx.origin].referrer != address(0) && (players[tx.origin].tickets - players[tx.origin].checkpoint) % interval == 0) {\r\n            if (token.balanceOf(address(this)) >= prize * 2) {\r\n                token.transfer(tx.origin, prize);\r\n                emit BonusSent(tx.origin, prize);\r\n                token.transfer(players[tx.origin].referrer, prize);\r\n                emit BonusSent(players[tx.origin].referrer, prize);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addReferrer(address referrer) external restricted {\r\n        if (players[tx.origin].referrer == address(0) && players[referrer].tickets >= interval && referrer != tx.origin) {\r\n            players[tx.origin].referrer = referrer;\r\n            players[tx.origin].checkpoint = players[tx.origin].tickets;\r\n\r\n            emit ReferrerAdded(tx.origin, referrer);\r\n        }\r\n    }\r\n\r\n    function sendBonus(address winner) external restricted {\r\n        if (token.balanceOf(address(this)) >= prize) {\r\n            token.transfer(winner, prize);\r\n\r\n            emit BonusSent(winner, prize);\r\n        }\r\n    }\r\n\r\n    function withdrawERC20(address ERC20Token, address recipient) external onlyOwner {\r\n        uint256 amount = IERC20(ERC20Token).balanceOf(address(this));\r\n        IERC20(ERC20Token).transfer(recipient, amount);\r\n    }\r\n\r\n    function ticketsOf(address player) public view returns(uint256) {\r\n        return players[player].tickets;\r\n    }\r\n\r\n    function referrerOf(address player) public view returns(address) {\r\n        return players[player].referrer;\r\n    }\r\n}\r\n\r\ninterface Drawer {\r\n    function delegatecall(uint256 blocks) external returns(bool);\r\n}\r\n\r\ncontract Lottery100ETH is Ownable {\r\n\r\n    Storage public x;\r\n    RefStorage public RS;\r\n    LotteryTicket public LT;\r\n    WinnerTicket public WT;\r\n\r\n    uint256 constant public PRICE = 0.01 ether;\r\n\r\n    address[] public players;\r\n\r\n    uint256 public limit = 10000;\r\n\r\n    uint256 public futureblock;\r\n\r\n    uint256 public gameCount;\r\n\r\n    bool public paused;\r\n\r\n    address public drawer;\r\n\r\n    bool public onDrawing;\r\n\r\n    uint256[] silver    = [40,  0.5 ether];\r\n    uint256[] gold      = [10,  1   ether];\r\n    uint256[] brilliant = [1,   50  ether];\r\n\r\n    event NewPlayer(address indexed addr, uint256 indexed gameCount);\r\n    event SilverWinner(address indexed addr, uint256 prize, uint256 indexed gameCount);\r\n    event GoldenWinner(address indexed addr, uint256 prize, uint256 indexed gameCount);\r\n    event BrilliantWinner(address indexed addr, uint256 prize, uint256 indexed gameCount);\r\n    event txCostRefunded(address indexed addr, uint256 amount);\r\n    event FeePayed(address indexed owner, uint256 amount);\r\n    event OnDrawing(uint256 time);\r\n\r\n    modifier notOnPause() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier notFromContract() {\r\n        require(!isContract(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    constructor(address RS_Addr) public {\r\n        x = new Storage();\r\n        LT = new LotteryTicket();\r\n        WT = new WinnerTicket();\r\n        RS = RefStorage(RS_Addr);\r\n        gameCount++;\r\n    }\r\n\r\n    function() external payable {\r\n\r\n        if (onDrawing) {\r\n\r\n            if (block.number < futureblock + 210) {\r\n                drawing();\r\n            } else {\r\n                setFutureBlock();\r\n                if (msg.value != 0) {\r\n                    msg.sender.send(msg.value);\r\n                }\r\n                return;\r\n            }\r\n\r\n        }\r\n\r\n        if (msg.data.length != 0) {\r\n            RS.addReferrer(bytesToAddress(bytes(msg.data)));\r\n        }\r\n\r\n        if (msg.value >= PRICE && !paused && !onDrawing) {\r\n            buyTicket();\r\n        } else if (msg.value != 0) {\r\n            msg.sender.send(msg.value);\r\n        }\r\n\r\n        if (players.length >= limit) {\r\n            setFutureBlock();\r\n        }\r\n\r\n    }\r\n\r\n    function buyTicket() internal notOnPause notFromContract {\r\n\r\n        if (msg.value > PRICE) {\r\n            msg.sender.send(msg.value - PRICE);\r\n        }\r\n\r\n        players.push(msg.sender);\r\n        x.purchase(msg.sender);\r\n        RS.newTicket();\r\n        LT.emitEvent(msg.sender);\r\n        emit NewPlayer(msg.sender, gameCount);\r\n\r\n    }\r\n\r\n    function setFutureBlock() internal {\r\n\r\n        if (block.number >= futureblock + 210) {\r\n            futureblock = block.number + 40;\r\n        }\r\n\r\n        if (!onDrawing) {\r\n            onDrawing = true;\r\n        }\r\n\r\n        if (drawer != address(0)) {\r\n            Drawer(drawer).delegatecall(41);\r\n        }\r\n\r\n        emit OnDrawing(block.timestamp);\r\n\r\n    }\r\n\r\n    function drawing() internal {\r\n\r\n        require(block.number > futureblock, \"Awaiting for a future block\");\r\n\r\n        if (drawer != address(0)) {\r\n            require(msg.sender == drawer);\r\n        } else {\r\n            require(!isContract(msg.sender));\r\n        }\r\n\r\n        for (uint256 i = 0; i < silver[0]; i++) {\r\n            address winner = players[uint((blockhash(futureblock - 1 - i))) % players.length];\r\n            address(uint160(winner)).send(silver[1]);\r\n            WT.emitEvent(winner);\r\n            emit SilverWinner(winner, silver[1], gameCount);\r\n        }\r\n\r\n        uint256 goldenWinners = gold[0];\r\n        uint256 goldenPrize = gold[1];\r\n        if (x.count() < gold[0]) {\r\n            goldenWinners = x.count();\r\n            goldenPrize = gold[0] * gold[1] / x.count();\r\n        }\r\n        if (goldenWinners != 0) {\r\n            address[] memory addresses = x.draw(goldenWinners);\r\n            for (uint256 k = 0; k < addresses.length; k++) {\r\n                address(uint160(addresses[k])).send(goldenPrize);\r\n                RS.sendBonus(addresses[k]);\r\n                WT.emitEvent(addresses[k]);\r\n                emit GoldenWinner(addresses[k], goldenPrize, gameCount);\r\n            }\r\n        }\r\n\r\n        uint256 laps = 14;\r\n        uint256 winnerIdx;\r\n        uint256 indexes = players.length * 1e18;\r\n        for (uint256 j = 0; j < laps; j++) {\r\n            uint256 change = (indexes) / (2 ** (j+1));\r\n            if (uint256(keccak256(abi.encodePacked(blockhash(futureblock - j)))) % 2 == 0) {\r\n                winnerIdx += change;\r\n            }\r\n        }\r\n        winnerIdx = winnerIdx / 1e18;\r\n        address(uint160(players[winnerIdx])).send(brilliant[1]);\r\n        WT.emitEvent(players[winnerIdx]);\r\n        emit BrilliantWinner(players[winnerIdx], brilliant[1], gameCount);\r\n\r\n        delete players;\r\n        players.length = 0;\r\n        futureblock = 0;\r\n        x = new Storage();\r\n        gameCount++;\r\n\r\n        uint256 txCost = tx.gasprice * (1000000);\r\n        msg.sender.send(txCost);\r\n        emit txCostRefunded(msg.sender, txCost);\r\n\r\n        uint256 fee = address(this).balance - msg.value;\r\n        address(uint160(owner)).send(fee);\r\n        emit FeePayed(owner, fee);\r\n\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        paused = false;\r\n    }\r\n\r\n    function withdrawERC20(address ERC20Token, address recipient) external onlyOwner {\r\n        uint256 amount = IERC20(ERC20Token).balanceOf(address(this));\r\n        IERC20(ERC20Token).transfer(recipient, amount);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory source) internal pure returns(address parsedReferrer) {\r\n        assembly {\r\n            parsedReferrer := mload(add(source,0x14))\r\n        }\r\n        return parsedReferrer;\r\n    }\r\n\r\n    function amountOfPlayers() public view returns(uint) {\r\n        return players.length;\r\n    }\r\n\r\n    function referrerOf(address player) external view returns(address) {\r\n        return RS.referrerOf(player);\r\n    }\r\n\r\n    function ticketsOf(address player) external view returns(uint256) {\r\n        return RS.ticketsOf(player);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"x\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drawer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"ticketsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"futureblock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ERC20Token\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"referrerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onDrawing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"RS_Addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"gameCount\",\"type\":\"uint256\"}],\"name\":\"NewPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"gameCount\",\"type\":\"uint256\"}],\"name\":\"SilverWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"gameCount\",\"type\":\"uint256\"}],\"name\":\"GoldenWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"gameCount\",\"type\":\"uint256\"}],\"name\":\"BrilliantWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"txCostRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"OnDrawing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Lottery100ETH","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000978275d7652a35dc8df9ce6b62822aea6a97589d","Library":"","LicenseType":"None","SwarmSource":"bzzr://d42eaef670cd8d8707220c35d80a9325d1a124bf60b3ffbea6ff0beef73e2cba"}]}