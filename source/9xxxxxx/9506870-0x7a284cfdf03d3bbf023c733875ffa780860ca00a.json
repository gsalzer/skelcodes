{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.16 <0.7.0;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n/**\r\n * @title  ChainValidator interface\r\n * @author Miko Vainio\r\n * @notice External chain validator contract, can be used for more sophisticated validation of new validators and transactors, e.g. custom min. required conditions,\r\n *         concrete users whitelisting, etc...\r\n **/\r\ninterface ChainValidator {\r\n    /**\r\n     * @notice Validation functon for new validators\r\n     * \r\n     * @param vesting               How many tokens new validator wants to vest\r\n     * @param acc                   Account address of the validator\r\n     * @param mining                Flag if validator is going to mine. \r\n     *                               mining == false in case validateNewValidator is called during vestInChain method\r\n     *                               mining == true in case validateNewValidator is called during startMining method\r\n     * @param actNumOfValidators    How many active validators is currently in chain\r\n     **/\r\n    function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool);\r\n    \r\n    /**\r\n     * @notice Validation function for new transactors\r\n     * \r\n     * @param deposit               How many tokens new transactor wants to deposit\r\n     * @param acc                   Account address of the transactor\r\n     * @param actNumOfTransactors   How many whitelisted transactors (their deposit balance >= min. required balance) is currently in chain\r\n     **/\r\n    function validateNewTransactor(uint256 deposit, address acc, uint256 actNumOfTransactors) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title   Nordic Energy Registry Contract\r\n * @author  Miko Vainio\r\n * @notice  This smart contract is used for anchoring statistics (users gas consumption, validators stats - blocks mined, etc...) from Nordic Energy blockchain network into the ethereum, \r\n *          base on which users consumption and validators rewards in Nordic Energy (ERC20) tokens are calculated and distributed\r\n **/\r\ncontract NordicEnergyRegistry {\r\n    using SafeMath for uint256;\r\n    \r\n    /**************************************************************************************************************************/\r\n    /************************************************** Constants *************************************************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    // Token precision. 1 NET token = 1*10^18\r\n    uint256 constant NET_PRECISION               = 10**18;\r\n    \r\n    // Largest tx fee fixed at 0.1 NET\r\n    uint256 constant LARGEST_TX_FEE              = NET_PRECISION/10;\r\n    \r\n    // Min notary period = 1440 blocks (2 hours)\r\n    uint256 constant MIN_NOTARY_PERIOD           = 1440;    // mainnet: 1440, testnet: 60 \r\n    \r\n    // Max notary period = 34560 blocks (48 hours)\r\n    uint256 constant MAX_NOTARY_PERIOD           = 34560;\r\n    \r\n    // Time after which chain becomes inactive in case there was no successfull notary processed\r\n    // Users can then increase/descrease their vesting/deposit instantly and bypass 2-step process with confirmations.\r\n    uint256 constant CHAIN_INACTIVITY_TIMEOUT    = 7 days;  // mainnet: 7, testnet 1 days \r\n    \r\n    // Time after which validators can withdraw their vesting\r\n    uint256 constant VESTING_LOCKUP_TIMEOUT      = 7 days;  // mainnet: 7, testnet 1 days\r\n    \r\n    // Max num of characters in chain url\r\n    uint256 constant MAX_URL_LENGTH              = 100;\r\n    \r\n    // Max num of characters in chain description\r\n    uint256 constant MAX_DESCRIPTION_LENGTH      = 200;\r\n    \r\n    // Min. required deposit for all chains\r\n    uint256 constant NordicEnergy_MIN_REQUIRED_DEPOSIT = 1000*NET_PRECISION;\r\n    \r\n    // Min. required vesting for all chains\r\n    uint256 constant NordicEnergy_MIN_REQUIRED_VESTING = 1000*NET_PRECISION;\r\n    \r\n    \r\n    /**************************************************************************************************************************/\r\n    /**************************************************** Events **************************************************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    // New chain was registered\r\n    event NewChain(uint256 chainId, string description, string endpoint);\r\n    \r\n    // Deposit request created\r\n    // in case confirmed == true, tokens were transferred and account's deposit balance was updated\r\n    // in case confirmed == false, listener needs to wait for another DepositInChain event with confirmed flag == true.\r\n    // It can paired up with the first event if first 4 parameters are the same\r\n    event DepositInChain(uint256 indexed chainId, address indexed account, uint256 deposit, uint256 lastNotaryBlock, bool confirmed);\r\n    \r\n    // Vesting request created\r\n    // in case confirmed == true, tokens were transferred and account's vesting balance was updated\r\n    // in case confirmed == false, listener needs to wait for another VestInChain event with confirmed flag == true.\r\n    // It can paired up with the first event if first 4 parameters are the same\r\n    event VestInChain(uint256 indexed chainId, address indexed account, uint256 vesting, uint256 lastNotaryBlock, bool confirmed);\r\n    \r\n    // if whitelisted == true  - allow user to transact\r\n    // if whitelisted == false - do not allow user to transact\r\n    event AccountWhitelisted(uint256 indexed chainId, address indexed account, bool whitelisted);\r\n    \r\n    // Validator start/stop mining\r\n    event AccountMining(uint256 indexed chainId, address indexed account, bool mining);\r\n\r\n    // Validator's new mining reward \r\n    event MiningReward(uint256 indexed chainId, address indexed account, uint256 reward);\r\n    \r\n    // New notary was processed\r\n    event Notary(uint256 indexed chainId, uint256 lastBlock, uint256 blocksProcessed);\r\n    \r\n    // Manual notary reset was processed\r\n    event NotaryReset(uint256 indexed chainId, uint256 lastValidBlock, uint256 resetBlock);\r\n    \r\n\r\n    /**************************************************************************************************************************/\r\n    /***************************************** Structure related to the list of users *******************************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    // Iterable map that is used only together with the Users mapping as data holder\r\n    struct IterableMap {\r\n        // map of indexes to the list array\r\n        // indexes are shifted +1 compared to the real indexes of this list, because 0 means non-existing element\r\n        mapping(address => uint256) listIndex;\r\n        // list of addresses \r\n        address[]                   list;        \r\n    }\r\n    \r\n    struct VestingRequest {\r\n        // Flag if there is ongoing request for user\r\n        bool                    exist;\r\n        // Last notary block number when the request was accepted \r\n        uint256                 notaryBlock;\r\n        // New value of vesting to be set\r\n        uint256                 newVesting;\r\n    }\r\n    \r\n    struct Validator {\r\n        // Flag if validator mined at least 1 block in current notary window\r\n        bool                    currentNotaryMined;\r\n        // Flag if validator mined at least 1 block in the previous notary window\r\n        bool                    prevNotaryMined;\r\n        // Vesting request\r\n        VestingRequest          vestingRequest;\r\n        // Actual user's vesting\r\n        uint256                  vesting;\r\n        // Last time when the user increased his vesting balance. It is used to calculate the time when he can withdraw his vesting \r\n        uint256                 lastVestingIncreaseTime;\r\n    }\r\n    \r\n    // Only full deposit withdrawals are saved as deposit requests - other types of deposits do not need to be confirmed\r\n    struct DepositWithdrawalRequest {\r\n        // Last notary block number when the request was accepted \r\n        uint256                  notaryBlock;\r\n        // Flag if there is ongoing request for user\r\n        bool                     exist;\r\n    }\r\n    \r\n    struct Transactor {\r\n        // Actual user's deposit\r\n        uint256                  deposit;\r\n        // DepositWithdrawalRequest request\r\n        DepositWithdrawalRequest depositWithdrawalRequest;\r\n        // Flag if user is whitelisted (allowed to transact) -> actual deposit must be greater than min. required deposit condition \r\n        bool                     whitelisted;\r\n    }\r\n    \r\n    struct User {\r\n        // Transactor's data\r\n        Transactor   transactor;\r\n        \r\n        // Validator's data\r\n        Validator    validator;\r\n    }\r\n\r\n    \r\n    /**************************************************************************************************************************/\r\n    /***************************************************** Other structure ******************************************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    ERC20 token;\r\n    \r\n    struct LastNotary {\r\n        // Timestamp(eth block time), when last notary was accepted\r\n        uint256 timestamp;\r\n        // Actual Nordic Energy block number, when the last notary was accepted\r\n        uint256 block;\r\n    }\r\n    \r\n    struct ChainInfo {\r\n        // Internal chain ID\r\n        uint256                         id;\r\n        \r\n        // Min. required deposit for transactors (more sophisticated conditions might be set in external validator contract)\r\n        // Must be >= MIN_REQUIRED_DEPOSIT (1000 NET)\r\n        uint256                         minRequiredDeposit;\r\n        \r\n        // Min. required vesting for validators (more sophisticated conditions might be set in external validator contract)\r\n        // Must be >= MIN_REQUIRED_VESTING (1000 NET)\r\n        uint256                         minRequiredVesting;\r\n        \r\n        // Actual number of whitelisted transactors (their current depost > min.required deposit)\r\n        uint256                         actNumOfTransactors;\r\n        \r\n        // Max number of active validators for chain. There is no limit to how many users can vest.\r\n        // Tthis is limit for active validators (startMining function) \r\n        // 0  means unlimited\r\n        // It must be some reasonable value together with min. required vesting condition as \r\n        // too small num of validators limit with too low min. required vesting condition might lead to chain being stuck\r\n        uint256                         maxNumOfValidators;\r\n        \r\n        // Max number of users(transactors) for chain.\r\n        // Tthis is limit for whitelisted transactors (their current depost > min.required deposit)\r\n        // 0  means unlimited\r\n        // It must be some reasonable value together with min. required deposit condition as \r\n        // too small num of validators limit with too low min. required deposit condition might lead to chain being stuck\r\n        uint256                         maxNumOfTransactors;\r\n        \r\n        // Required vesting balance for reward bonus to be applied  \r\n        // 0 means no bonus is ever appliedm must be >= MIN_REQUIRED_VESTING (1000 NET)\r\n        uint256                         rewardBonusRequiredVesting;\r\n        \r\n        // Reward bonus percentage, must be > 0%\r\n        uint256                         rewardBonusPercentage;\r\n        \r\n        // How much vesting in total is vested in the chain by the active validators\r\n        uint256                         totalVesting;\r\n        \r\n        // Number of blocks after which notary is called, 1 block is generated every 5 seconds, e.g notaryPeriod = 1440 blocks = 2 hours\r\n        uint256                         notaryPeriod;\r\n        \r\n        // When was the last notary function called (block and time)\r\n        LastNotary                      lastNotary;\r\n        \r\n        // Flag for condition to be checked during notary:\r\n        // InvolvedVesting of validators who signed notary statistics must be greater than 50% of chain total vesting(sum of all active validator's vesting)\r\n        // to notary statistics to be accepted is accepted\r\n        bool                            involvedVestingNotaryCond;\r\n        \r\n        // Flag for condition to be checked during notary:\r\n        // Number of validators who signed notary statistics must be greater or equal than 2/3+1 of all active validators\r\n        // to notary statistics to be accepted is accepted\r\n        bool                            participationNotaryCond;\r\n        \r\n        // Flag that says if the chain was already(& sucessfully) registered\r\n        bool                            registered;\r\n        \r\n        // Flag that says if chain is active - num of active validators > 0 && first block was already mined \r\n        bool                            active;\r\n        \r\n        // Address of the chain creator\r\n        address                         creator;\r\n        \r\n        // Validator with the smallest vesting balance among all existing validators\r\n        // In case someone vests more tokens, he will replace the one with smallest vesting balance\r\n        address                         lastValidator;\r\n        \r\n        // Smart-contract for validating min.required deposit and vesting\r\n        ChainValidator                  chainValidator;\r\n        \r\n        // Chain description\r\n        string                          description;\r\n        \r\n        // Chain endpoint\r\n        string                          endpoint;\r\n        \r\n        // List of existing users - all users, who have deposited or vested\r\n        IterableMap                     users;\r\n        \r\n        // List of existing validators - only those who vested enough and are actively mining are here\r\n        // Active validator are in separate array because of heavy processing furing notary (no need to filter them out of users thanks tot this)\r\n        IterableMap                     validators;\r\n        \r\n        // Mapping data holder for users (validators & transactors) data\r\n        mapping(address => User)        usersData;\r\n    }\r\n    \r\n    // Registered chains\r\n    mapping(uint256 => ChainInfo)   private chains;\r\n    \r\n    // Next chain id\r\n    uint256                         public  nextId = 0;\r\n\r\n    \r\n    /**************************************************************************************************************************/\r\n    /************************************ Contract interface - external/public functions **************************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    /**\r\n     * @notice Requests vest in chain\r\n     *\r\n     * @param chainId  ChainId that sender wants to interact with\r\n     * \r\n     * @param vesting  New requested vesting balance. Possible scenarios:\r\n     *                 1. vesting == 0 \r\n     *                      - stopMining must be called first\r\n     *                      - can be called after VESTING_LOCKUP_TIMEOUT (7 days) since the last vesting increase\r\n     *                      - vestingRequest is created\r\n     *                      - if chain.active == true\r\n     *                           * confirmVestInChain can be called in the next notary window to finalize full vesting withdrawal\r\n     *                      - if chain.active == false\r\n     *                           * confirmVestInChain can be called immediately to finalize full vesting withdrawal\r\n     *                 \r\n     *                 2. vesting == actual validators vesting balance\r\n     *                      - not allowed\r\n     * \r\n     *                 3. vesting > actual validators vesting balance\r\n     *                      - in case all active validators slots are taken, vesting must be > than the lastValidator vesting (last == smallest vesting among all active validators) \r\n     *                      - vestingRequest is created\r\n     *                      - NET token transfer is processed\r\n     *                      - if chain.active == true\r\n     *                           * confirmVestInChain can be called in the next notary window to finalize vesting increase\r\n     *                      - if chain.active == false\r\n     *                           * confirmVestInChain can be called immediately to finalize full vesting increase\r\n     *\r\n     *                 4. vesting < actual validators vesting balance\r\n     *                      - can be called after VESTING_LOCKUP_TIMEOUT (7 days) since the last vesting increase\r\n     *                      - processed immediately, no confirmation needed\r\n     *                      - NET token transfer is processed\r\n     **/\r\n    function requestVestInChain(uint256 chainId, uint256 vesting) external {\r\n        ChainInfo storage chain = chains[chainId];\r\n        Validator storage validator = chain.usersData[msg.sender].validator;\r\n        \r\n        // Enable users to vest into registered (but non-active) chain and start minig so it becomes active\r\n        require(chain.registered == true,                                 \"Non-registered chain\");\r\n        require(transactorExist(chain, msg.sender) == false,              \"Validator cannot be transactor at the same time. Withdraw your depoist or use different account\");\r\n        require(vestingRequestExist(chain, msg.sender) == false,          \"There is already one vesting request being processed for this acc\");\r\n        \r\n        // Checks if chain is active, if not set it active flag to false \r\n        checkAndSetChainActivity(chain);\r\n        \r\n        // Full vesting withdrawal\r\n        if (vesting == 0) {\r\n            require(validatorExist(chain, msg.sender) == true,            \"Non-existing validator account (0 vesting balance)\");\r\n            require(activeValidatorExist(chain, msg.sender) == false,     \"StopMinig must be called first\");\r\n            \r\n            // In case user wants to withdraw full vesting and chain is active, check vesting lockup timeout\r\n            if (chain.active == true) {\r\n                require(validator.lastVestingIncreaseTime + VESTING_LOCKUP_TIMEOUT < now,  \"Unable to decrease vesting balance, validators need to wait VESTING_LOCKUP_TIMEOUT(7 days) since the last increase\");\r\n            }\r\n        }\r\n        // Vest in chain or withdraw just part of vesting\r\n        else {\r\n            require(validator.vesting != vesting,                         \"Cannot vest the same amount of Nordic Energy tokens as you already has vested\");\r\n            require(vesting >= chain.minRequiredVesting,                  \"User does not meet min.required vesting condition\");\r\n            \r\n            if (chain.chainValidator != ChainValidator(0)) {\r\n                require(chain.chainValidator.validateNewValidator(vesting, msg.sender, false /* not mining yet */, chain.validators.list.length), \"Validator not allowed by external chainvalidator smart contract\");\r\n            }\r\n            \r\n            // In case user wants to decrease vesting and chain is active, check vesting lockup timeout\r\n            if (vesting < validator.vesting) {\r\n                if (chain.active == true) {\r\n                    require(validator.lastVestingIncreaseTime + VESTING_LOCKUP_TIMEOUT < now,  \"Unable to decrease vesting balance, validators need to wait VESTING_LOCKUP_TIMEOUT(7 days) since the last increase\");\r\n                }\r\n            }\r\n            // In case user wants to increase vesting, do not allow him if there is no more places for active validators and user does not vest more than the the one with smallest vesting balance \r\n            else if (chain.maxNumOfValidators != 0 && chain.validators.list.length >= chain.maxNumOfValidators) {\r\n           \r\n                require(vesting > chain.usersData[chain.lastValidator].validator.vesting, \"Upper limit of validators reached. Must vest more than the last validator to be able to start mining and replace him\");\r\n            }\r\n        }\r\n        \r\n        requestVest(chain, vesting, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @notice Confirms existing vesting request\r\n     *\r\n     * @param chainId ChainId that sender wants to interact with\r\n     *                \r\n     *                Possible values for existing vestig request:\r\n     *                1. vesting == 0 \r\n     *                      - vestingRequest is deleted\r\n     *                      - NET token transfer is processed \r\n     *                      - validator's vesting balance is updated\r\n     *                2. vesting > actual validators vesting balance\r\n     *                      - vestingRequest is deleted\r\n     *                      - validator's vesting balance is updated\r\n     * \r\n     *                - if chain.active == true\r\n     *                      * confirmVestInChain can be called in the next notary window after the one, in which change was requeted\r\n     *                - if chain.active == false\r\n     *                      * confirmVestInChain can be called immediately\r\n     **/\r\n    function confirmVestInChain(uint256 chainId) external {\r\n        ChainInfo storage chain = chains[chainId];\r\n        \r\n        // Enable users to confirm vesting request into registered (but non-active) chain and start minig so it becomes active\r\n        require(chain.registered == true, \"Non-registered chain\");\r\n        require(vestingRequestExist(chain, msg.sender) == true, \"Non-existing vesting request\");\r\n        \r\n        // Checks if chain is active, if not set it active flag to false \r\n        checkAndSetChainActivity(chain);\r\n        \r\n        // Chain is active\r\n        if (chain.active == true) {\r\n            require(chain.lastNotary.block > chain.usersData[msg.sender].validator.vestingRequest.notaryBlock, \"Confirm can be called in the next notary window after request was accepted\");    \r\n        }\r\n        \r\n        confirmVest(chain, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @notice Requests deposit in chain\r\n     *\r\n     * @param chainId  ChainId that sender wants to interact with\r\n     * \r\n     * @param deposit  New requested deposit balance. Possible scenarios:\r\n     *                 1. deposit == 0 \r\n     *                      - depositWithdrawalRequest is created\r\n     *                      - validators whitelisted flag is set to false and AccountWhitelisted event is emmited\r\n     *                      - if chain.active == true\r\n     *                           * confirmDepositWithdrawalFromChain can be called in the next notary window to finalize full deposit withdrawal\r\n     *                      - if chain.active == false\r\n     *                           * confirmDepositWithdrawalFromChain can be called immediately to finalize full deposit withdrawal\r\n     *                 \r\n     *                 2. deposit == actual transactors deposit balance\r\n     *                      - not allowed\r\n     * \r\n     *                 3. deposit > actual validators deposit balance\r\n     *                      - processed immediately, no confirmation needed\r\n     * \r\n     *                 4. deposit < actual validators deposit balance\r\n     *                      - processed immediately, no confirmation needed\r\n     **/\r\n    function requestDepositInChain(uint256 chainId, uint256 deposit) external {\r\n        ChainInfo storage chain = chains[chainId];\r\n        \r\n        require(chain.registered == true,                                             \"Non-registered chain\");\r\n        require(validatorExist(chain, msg.sender) == false,                           \"Transactor cannot be validator at the same time. Withdraw your vesting or use different account\");\r\n        require(depositWithdrawalRequestExist(chain, msg.sender) == false,            \"There is already existing withdrawal request being processed for this acc\");\r\n        \r\n        // Checks if chain is active, if not set it active flag to false \r\n        checkAndSetChainActivity(chain);\r\n        \r\n        // Withdraw whole deposit\r\n        if (deposit == 0) {\r\n            require(transactorExist(chain, msg.sender) == true,                       \"Non-existing transactor account (0 deposit balance)\");\r\n        }\r\n        // Deposit in chain or withdraw just part of deposit\r\n        else {\r\n            require(chain.usersData[msg.sender].transactor.deposit != deposit,        \"Cannot deposit the same amount of tokens as you already has deposited\");\r\n            require(deposit >= chain.minRequiredDeposit,                              \"User does not meet min.required deposit condition\");\r\n            \r\n            if (chain.chainValidator != ChainValidator(0)) {\r\n                require(chain.chainValidator.validateNewTransactor(deposit, msg.sender, chain.actNumOfTransactors), \"Transactor not allowed by external chainvalidator SC\");\r\n            }\r\n            \r\n            // Upper limit of transactors reached\r\n            if (chain.maxNumOfTransactors != 0 && chain.usersData[msg.sender].transactor.whitelisted == false) {\r\n                require(chain.actNumOfTransactors <= chain.maxNumOfTransactors, \"Upper limit of transactors reached\");\r\n            }\r\n        }\r\n                \r\n        requestDeposit(chain, deposit, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @notice Confirms existing full deposit withdrawal request\r\n     *\r\n     * @param chainId ChainId that sender wants to interact with\r\n     *                Possible values for existing full deposit withdrawal request:\r\n     *                1. deposit == 0 \r\n     *                      - depositWithdrawalRequest is deleted\r\n     *                      - NET token transfer is processed \r\n     *                      - validator's vesting balance is updated\r\n     * \r\n     *                - if chain.active == true\r\n     *                      * confirmDepositWithdrawalFromChain can be called in the next notary window after the one, in which change was requeted\r\n     *                - if chain.active == false\r\n     *                      * confirmDepositWithdrawalFromChain can be called immediately\r\n     **/\r\n    function confirmDepositWithdrawalFromChain(uint256 chainId) external {\r\n        ChainInfo storage chain = chains[chainId];\r\n\r\n        require(chain.registered == true, \"Non-registered chain\");\r\n        require(depositWithdrawalRequestExist(chain, msg.sender) == true, \"Non-existing deposit withdrawal request\");\r\n        \r\n        // Checks if chain is active, if not set it active flag to false \r\n        checkAndSetChainActivity(chain);\r\n        \r\n        // Chain is active\r\n        if (chain.active == true) {\r\n            require(chain.lastNotary.block > chain.usersData[msg.sender].transactor.depositWithdrawalRequest.notaryBlock, \"Confirm can be called in the next notary window after request was accepted\");\r\n        }\r\n        \r\n        confirmDepositWithdrawal(chain, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @notice Internally creates/registers new chain.\r\n     * \r\n     * @param description                     Description of the chain (e.g name, short purpose description, etc...). Max 200 characters\r\n     *                                         Cannot be empty. Max num of characters is 200\r\n     * @param initEndpoint                    Chain endpoint, might be a website with chain description, condition to join and nodes ip:port addresses that can be used fo joining\r\n     *                                         Cannot be empty. Max num of characters is 100\r\n     * @param chainValidator                  External validator contract, might imolement more sophisticated rules for joing the chain as validator or as user (e.g. accounts whitelisting, etc...)\r\n     *                                         0 means no external validator contract\r\n     * @param minRequiredDeposit              Min.required deposit to become transactor (user). It must be some reasonable number as user should never be able to run out of Nordic Energy tokens during notaryPeriod considering \r\n     *                                         max. tx fee is fixed to 0.1 NET tokens E.g. there is private chain with whitelisted users and user creator know they will send max. 100 000 txs / notaryPeriod. \r\n     *                                         Min. required deposit should be then 10 000 NET tokens. \r\n     *                                         It is something like prebought credit for transactions that is required to have on your account before each notary. In fact, users will have to deposit more than minRequiredDeposit as \r\n     *                                         they will be automatically blacklisted during the notary even if they sent only 1 tx, because their deposit balance would be < minRequiredDeposit before the next notary. \r\n     *                                         On top of this condition, chain creator might implement more sophisticated condition in external validator contract\r\n     *                                         0 means default (1000 NET), otherwise must be >= 1000 NET tokens\r\n     * @param minRequiredVesting              Min.required deposit to become validator.\r\n     *                                         On top of this condition, chain creator might implement more sophisticated condition in external validator contract\r\n     *                                         0 means default (1000 NET), otherwise must be >= 1000 NET tokens\r\n     * @param rewardBonusRequiredVesting      Min. required vesting balance for bonus reward to be applied.\r\n     *                                         0 means that chain will not support rewards bonus \r\n     * @param rewardBonusPercentage           Reward bonus (percentage) to be applied if validator's vesting balance >= rewardBonusRequiredVesting.\r\n     *                                         In case rewardBonusRequiredVesting > 0, rewardBonusPercentage must be > 0%, otherwise it is ignored\r\n     * @param notaryPeriod                    Notary period in blocks (1 block every 5s), it is basically time interval notary periodic calls where users consumptions are processed and rewards distributed. \r\n     *                                         Must be in range <1440 (2 hours), 34560 (48 hours)>\r\n     * @param maxNumOfValidators              Max. number of active validators (those who vested and started mining). As Nordic Energy is using Byzantium fault tolerance (BFT) consensus alg., it is recommended to use max no more than 51 validators(21 recommended).\r\n     *                                         On top of this condition, chain creator might implement more sophisticated condition in external validator contract\r\n     *                                         0 means unlimited\r\n     * @param maxNumOfTransactors             Max. number of transactors/users (those who deposited. It is recommended to restrict this number as notary will not be able to process theoretically unlimited number of users\r\n     *                                         On top of this condition, chain creator might implement more sophisticated condition in external validator smart contract\r\n     *                                         0 means unlimited\r\n     * @param involvedVestingNotaryCond       Flag, if 50% invloved vesting condition should be checked during notary. It means that vesting balances sum of those validators, who signed statistics \r\n     *                                         sent to the notary must be > 50% of the sum of all active validators vesting balances on chain \r\n     *                                         At least one of the involvedVestingNotaryCond or participationNotaryCond must be specified\r\n     * @param participationNotaryCond         Flag, 2/3 + 1 participation condition should be checked during notary. It means that more or equal to 2/3+1 of all active validators on chain \r\n     *                                         must sign statistics sent to the notary for notary to be accepted \r\n     *                                         At least one of the involvedVestingNotaryCond or participationNotaryCond must be specified\r\n     * \r\n     * @return chainId of the created chain\r\n     **/ \r\n    function registerChain(string memory description, string memory initEndpoint, ChainValidator chainValidator, uint256 minRequiredDeposit, uint256 minRequiredVesting, uint256 rewardBonusRequiredVesting, uint256 rewardBonusPercentage, \r\n                           uint256 notaryPeriod, uint256 maxNumOfValidators, uint256 maxNumOfTransactors, bool involvedVestingNotaryCond, bool participationNotaryCond) public returns (uint256 chainId) {\r\n        require(bytes(description).length > 0 && bytes(description).length <= MAX_DESCRIPTION_LENGTH,   \"Chain description length must be: > 0 && <= MAX_DESCRIPTION_LENGTH(200)\");\r\n        require(bytes(initEndpoint).length > 0 && bytes(initEndpoint).length <= MAX_URL_LENGTH,         \"Chain endpoint length must be: > 0 && <= MAX_URL_LENGTH(100)\");\r\n        require(notaryPeriod >= MIN_NOTARY_PERIOD && notaryPeriod <= MAX_NOTARY_PERIOD,                 \"Notary period must be in range <MIN_NOTARY_PERIOD(1440), MAX_NOTARY_PERIOD(34560)>\");\r\n        require(involvedVestingNotaryCond == true || participationNotaryCond == true,                   \"At least one notary condition must be specified\");\r\n        \r\n        if (minRequiredDeposit > 0) {\r\n            require(minRequiredDeposit >= NordicEnergy_MIN_REQUIRED_DEPOSIT,                                  \"Min. required deposit for all chains must be >= NordicEnergy_MIN_REQUIRED_DEPOSIT (1000 NET)\");\r\n        }\r\n        \r\n        if (minRequiredVesting > 0) {\r\n            require(minRequiredVesting >= NordicEnergy_MIN_REQUIRED_VESTING,                                  \"Min. required vesting for all chains must be >= NordicEnergy_MIN_REQUIRED_VESTING (1000 NET)\");\r\n        }\r\n        \r\n        if (rewardBonusRequiredVesting > 0) {\r\n            require(rewardBonusPercentage > 0,                                                          \"Reward bonus percentage must be > 0%\");    \r\n        }\r\n    \r\n        chainId                         = nextId;\r\n        ChainInfo storage chain         = chains[chainId];\r\n        \r\n        chain.id                        = chainId;\r\n        chain.description               = description;\r\n        chain.endpoint                  = initEndpoint;\r\n        chain.minRequiredDeposit        = minRequiredDeposit;\r\n        chain.minRequiredVesting        = minRequiredVesting;\r\n        chain.notaryPeriod              = notaryPeriod;\r\n        chain.registered                = true;\r\n        chain.creator                   = msg.sender;\r\n        \r\n        if (chainValidator != ChainValidator(0)) {\r\n            chain.chainValidator = chainValidator;\r\n        }\r\n        \r\n        // Sets min required deposit\r\n        if (minRequiredDeposit == 0) {\r\n            chain.minRequiredDeposit = NordicEnergy_MIN_REQUIRED_DEPOSIT;\r\n        } \r\n        else {\r\n            chain.minRequiredDeposit = minRequiredDeposit;\r\n        }\r\n        \r\n        // Sets min required vesting\r\n        if (minRequiredVesting == 0) {\r\n            chain.minRequiredVesting = NordicEnergy_MIN_REQUIRED_VESTING;\r\n        } \r\n        else {\r\n            chain.minRequiredVesting = minRequiredVesting;\r\n        }\r\n\r\n        \r\n        if (involvedVestingNotaryCond == true) {\r\n            chain.involvedVestingNotaryCond  = true;    \r\n        }\r\n        \r\n        if (participationNotaryCond == true) {\r\n            chain.participationNotaryCond    = true;\r\n        }\r\n        \r\n        if (maxNumOfValidators > 0) {\r\n            chain.maxNumOfValidators         = maxNumOfValidators;\r\n        }\r\n        \r\n        if (maxNumOfTransactors > 0) {\r\n            chain.maxNumOfTransactors        = maxNumOfTransactors;\r\n        }\r\n        \r\n        if (rewardBonusRequiredVesting > 0) {\r\n            chain.rewardBonusRequiredVesting = rewardBonusRequiredVesting;\r\n            chain.rewardBonusPercentage      = rewardBonusPercentage;\r\n        }\r\n        \r\n        emit NewChain(chainId, description, initEndpoint);\r\n        \r\n        nextId++;\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets some of the static blockchain details. Only chain creator can call this method\r\n     *\r\n     * @param chainId       ChainId that sender wants to interact with\r\n     * @param description   New chain description (e.g name, short purpose description, etc...)\r\n     * @param endpoint      New chain endpoint, might be a website with chain description, condition to join and nodes ip:port addresses that can be used fo joining\r\n     **/\r\n    function setChainStaticDetails(uint256 chainId, string calldata description, string calldata endpoint) external {\r\n        ChainInfo storage chain = chains[chainId];\r\n        require(msg.sender == chain.creator, \"Only chain creator can call this method\");\r\n    \r\n        require(bytes(description).length <= MAX_DESCRIPTION_LENGTH,   \"Chain description length must be: > 0 && <= MAX_DESCRIPTION_LENGTH(200)\");\r\n        require(bytes(endpoint).length <= MAX_URL_LENGTH,              \"Chain endpoint length must be: > 0 && <= MAX_URL_LENGTH(100)\");\r\n        \r\n        if (bytes(description).length > 0) {\r\n            chain.description = description;\r\n        }\r\n        if (bytes(endpoint).length > 0) {\r\n            chain.endpoint = endpoint;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns chain static details (those that do not change).\r\n     *\r\n     * @param chainId                         ChainId that sender wants to interact with\r\n     * \r\n     * @return description                   Description of the blockchain (e.g name, short purpose description, etc...)\r\n     * @return endpoint                      Chain endpoint, might be a website with chain description, condition to join and nodes ip:port addresses that can be used fo joining\r\n     * @return registered                    Flag if chain with specified chainId is registered\r\n     * @return minRequiredDeposit            Min.required deposit to become transactor (user). \r\n     *                                        On top of this condition, chain creator might implement more sophisticated condition in external validator contract\r\n     * @return minRequiredVesting            Min.required deposit to become validator.\r\n     *                                        On top of this condition, chain creator might implement more sophisticated condition in external validator contract\r\n     * @return rewardBonusRequiredVesting    Min. required vesting balance for bonus reward to be applied.\r\n     *                                        In case rewardBonusRequiredVesting == 0, there is no reward bonus fot this chain\r\n     * @return rewardBonusPercentage         Reward bonus (percentage) to be applied if validator's vesting balance >= rewardBonusRequiredVesting.\r\n     * @return notaryPeriod                  Notary period in blocks (1 block every 5s), it is basically time interval notary periodic calls where users consumptions are processed and rewards distributed. \r\n     * @return maxNumOfValidators            Max. number of active validators (those who vested and started mining).\r\n     *                                        On top of this condition, chain creator might implement more sophisticated condition in external validator contract\r\n     *                                        0 means unlimited\r\n     * @return maxNumOfTransactors           Max. number of transactors/users (those who deposited.\r\n     *                                        On top of this condition, chain creator might implement more sophisticated condition in external validator contract\r\n     *                                        0 means unlimited\r\n     * @return involvedVestingNotaryCond     Flag, if 50% invloved vesting condition is checked during notary. It means that vesting balances sum of those validators, who signed statistics \r\n     *                                        sent to the notary must be > 50% of the sum of all active validators vesting balances on blockchain \r\n     * @return participationNotaryCond       Flag, 2/3 + 1 participation condition is checked during notary. It means that more or equal to 2/3+1 of all active validators on chain \r\n     *                                        must sign statistics sent to the notary for notary to be accepted \r\n     **/\r\n    function getChainStaticDetails(uint256 chainId) external view returns (string memory description, string memory endpoint, bool registered, uint256 minRequiredDeposit, uint256 minRequiredVesting, \r\n                                                                           uint256 rewardBonusRequiredVesting, uint256 rewardBonusPercentage, uint256 notaryPeriod, uint256 maxNumOfValidators, \r\n                                                                           uint256 maxNumOfTransactors, bool involvedVestingNotaryCond, bool participationNotaryCond) {\r\n        ChainInfo storage chain = chains[chainId];\r\n        \r\n        description                 = chain.description;\r\n        endpoint                    = chain.endpoint;\r\n        registered                  = chain.registered;\r\n        minRequiredDeposit          = chain.minRequiredDeposit;\r\n        minRequiredVesting          = chain.minRequiredVesting;\r\n        rewardBonusRequiredVesting  = chain.rewardBonusRequiredVesting;\r\n        rewardBonusPercentage       = chain.rewardBonusPercentage;\r\n        notaryPeriod                = chain.notaryPeriod;\r\n        maxNumOfValidators          = chain.maxNumOfValidators;\r\n        maxNumOfTransactors         = chain.maxNumOfTransactors;\r\n        involvedVestingNotaryCond   = chain.involvedVestingNotaryCond;\r\n        participationNotaryCond     = chain.participationNotaryCond;\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns dynamic chain details\r\n     *\r\n     * @param chainId                    ChainId that sender wants to interact with\r\n     * \r\n     * @return active                    Flag if chain is active. \r\n     *                                   True if there is > 0 active validatoes and there was successfull notary processed during last CHAIN_INACTIVITY_TIMEOUT (7 days), otherwise false\r\n     * @return totalVesting              Actual chain total vesting - sum of all active validators vesting balance \r\n     * @return validatorsCount           Number of chain active validators\r\n     * @return transactorsCount          Number of chain whitelisted transactors (their deposit balance >= min. required deposit)\r\n     * @return lastValidatorVesting      Vesting of the last active validator (with the smallest vesting balance among all active validators). He is to be\r\n     *                                    by anyone who vests more and want to become validator\r\n     * @return lastNotaryBlock           Last processed block from NordicEnergy blockchain network during the last notary\r\n     * @return lastNotaryTimestamp       Time of the last notary\r\n     **/\r\n    function getChainDynamicDetails(uint256 chainId) public view returns (bool active, uint256 totalVesting, uint256 validatorsCount, uint256 transactorsCount,\r\n                                                                          uint256 lastValidatorVesting, uint256 lastNotaryBlock, uint256 lastNotaryTimestamp) {\r\n        ChainInfo storage chain = chains[chainId];\r\n        \r\n        active               = chain.active;\r\n        totalVesting         = chain.totalVesting;\r\n        validatorsCount      = chain.validators.list.length;\r\n        transactorsCount     = chain.actNumOfTransactors;\r\n        lastValidatorVesting = chain.usersData[chain.lastValidator].validator.vesting;   \r\n        lastNotaryBlock      = chain.lastNotary.block;\r\n        lastNotaryTimestamp  = chain.lastNotary.timestamp;\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns user details\r\n     *\r\n     * @param chainId                           ChainId that sender wants to interact with\r\n     * @param acc                               Account to get details about\r\n     * \r\n     * @return deposit                         Actual deposit balance\r\n     * @return whitelisted                     Flag if user is allowed to transact (his deposit balance >= min. requred deposit)\r\n     * @return vesting                         Actual veseting balance\r\n     * @return lastVestingIncreaseTime         Last time, when validator increased his vesting. Validators then have to wait VESTING_LOCKUP_TIMEOUT (14 days)\r\n     *                                          since lastVestingIncreaseTime before they can withraw full or just part of the vesting\r\n     * @return mining                          Flag if user validator is actively mining (called startMining method)\r\n     * @return prevNotaryMined                 Flag if validator mined at least one block during the previous notary window\r\n     * @return vestingReqExist                 Flag if there is onoging request for vesting increse or full withdrawal\r\n     * @return vestingReqNotary                Last known block accepted by notary in time when vesting request was created\r\n     * @return vestingReqValue                 New value of vesting specified in request\r\n     * @return depositFullWithdrawalReqExist   Flag if there is onoging request for deposit full withdrawal\r\n     * @return depositReqNotary                Last known block accepted by notary in time when deposit withdrawal request was created\r\n     **/\r\n    function getUserDetails(uint256 chainId, address acc) external view returns (uint256 deposit, bool whitelisted, \r\n                                                                                 uint256 vesting, uint256 lastVestingIncreaseTime, bool mining, bool prevNotaryMined,\r\n                                                                                 bool vestingReqExist, uint256 vestingReqNotary, uint256 vestingReqValue,\r\n                                                                                 bool depositFullWithdrawalReqExist, uint256 depositReqNotary) {\r\n        ChainInfo storage chain = chains[chainId];\r\n        User storage user       = chain.usersData[acc];\r\n         \r\n        deposit                 = user.transactor.deposit;\r\n        whitelisted             = user.transactor.whitelisted;\r\n        vesting                 = user.validator.vesting;\r\n        lastVestingIncreaseTime = user.validator.lastVestingIncreaseTime;\r\n        mining                  = activeValidatorExist(chain, acc);\r\n        prevNotaryMined         = user.validator.currentNotaryMined;  \r\n        \r\n        if (vestingRequestExist(chain, acc)) {\r\n            vestingReqExist            = true;\r\n            vestingReqNotary           = user.validator.vestingRequest.notaryBlock;\r\n            vestingReqValue            = user.validator.vestingRequest.newVesting;\r\n        }\r\n        \r\n        if (depositWithdrawalRequestExist(chain, acc)) {\r\n            depositFullWithdrawalReqExist  = true;\r\n            depositReqNotary               = user.transactor.depositWithdrawalRequest.notaryBlock;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Notarization function - calculates user consumption as well as validators rewards. First, calculate hash from statistics sent to the notary, then, \r\n     *        do ec_recover of the signatures to determine signers, checks if there is enough signers (total vesting of signers > 50% of all vestings) or total num of signes >= 2/3+1 out of all validators\r\n     *        and calculates users consuptions and validators rewards. Consuptions are deducted from the transactors deposit balances and rewards are added to the validators vesting balances.\r\n     *        In case chain.active flag is false, it sets it to true.\r\n     *        All active validators, who did not mine at least 1 block during last 2 notary windows are automatically removed from list of active validators\r\n     * \r\n     * @param chainId          ChainId that sender wants to interact with\r\n     * @param notaryStartBlock Start block of statistics from Nordic Energy blockchain network     \r\n     * @param notaryEndBlock   End block of statistics from Nordic Energy blockchain network    \r\n     * @param validators       List of validators from Nordic Energy blockchain network\r\n     * @param blocksMined      List of mined blocks counts by validators \r\n     * @param users            List of users (transactors) from Nordic Energy blockchain network\r\n     * @param userGas          List of users sums of gas consumption for all transactions they sent \r\n     * @param largestTx        Gas consumption of the largest (most expensive) transaction in statistics \r\n     * @param v, r, s          Parts of ecc signatures\r\n     * \r\n     * @dev MiningReward(uint256 indexed chainId, address indexed account, uint256 reward) for each calculated reward\r\n     * @dev Notary(uint256 indexed chainId, uint256 lastBlock, uint256 blocksProcessed) at the end of notary\r\n     **/\r\n    function notary(uint256 chainId, uint256 notaryStartBlock, uint256 notaryEndBlock, address[] memory validators, uint32[] memory blocksMined,\r\n                    address[] memory users, uint64[] memory userGas, uint64 largestTx,\r\n                    uint8[] memory v, bytes32[] memory r, bytes32[] memory s) public {\r\n                  \r\n        ChainInfo storage chain = chains[chainId];\r\n        require(chain.registered    == true,                            \"Invalid chain data: Non-registered chain\");\r\n        require(validatorExist(chain, msg.sender) == true,              \"Sender must have vesting balance > 0\");\r\n        require(chain.totalVesting  > 0,                                \"Current chain total_vesting == 0, there are no active validators\");\r\n        \r\n        require(validators.length       > 0,                            \"Invalid statistics data: validators.length == 0\");\r\n        require(validators.length       == blocksMined.length,          \"Invalid statistics data: validators.length != num of block mined\");\r\n        if (chain.maxNumOfValidators != 0) {\r\n            require(validators.length   <= chain.maxNumOfValidators,    \"Invalid statistics data: validators.length > maxNumOfValidators\");\r\n            require(v.length            <= chain.maxNumOfValidators,    \"Invalid statistics data: signatures.length > maxNumOfValidators\");\r\n        }\r\n        \r\n        if (chain.maxNumOfTransactors != 0) {\r\n            require(users.length    <= chain.maxNumOfTransactors,   \"Invalid statistics data: users.length > maxNumOfTransactors\");\r\n        }\r\n        require(users.length        > 0,                            \"Invalid statistics data: users.length == 0\");\r\n        require(users.length        == userGas.length,              \"Invalid statistics data: users.length != usersGas.length\");\r\n        \r\n        require(v.length            == r.length,                    \"Invalid statistics data: v.length != r.length\");\r\n        require(v.length            == s.length,                    \"Invalid statistics data: v.length != s.length\");\r\n        require(notaryStartBlock    >  chain.lastNotary.block,      \"Invalid statistics data: notaryBlock_start <= last known notary block\");\r\n        require(notaryEndBlock      >  notaryStartBlock,            \"Invalid statistics data: notaryEndBlock <= notaryStartBlock\");\r\n        require(largestTx           >  0,                           \"Invalid statistics data: Largest tx <= 0\");\r\n        \r\n        bytes32 signatureHash = keccak256(abi.encodePacked(notaryEndBlock, validators, blocksMined, users, userGas, largestTx));\r\n        \r\n        // Validates notary conditions(involvedVesting && participation) to statistics to be accepted\r\n        validateNotaryConditions(chain, signatureHash, v, r, s);\r\n        \r\n        // Calculates total cost based on user's usage durint current notary window\r\n        uint256 totalCost = processUsersConsumptions(chain, users, userGas, largestTx);\r\n        \r\n        // In case totalCost == 0, something is wrong and there is no need for notary to continue as there is no tokens to be distributed to the validators.\r\n        // There is probably ongoing coordinated attack based on invalid statistics sent to the notary\r\n        require(totalCost > 0, \"Invalid statistics data: users totalUsageCost == 0\");\r\n        \r\n        // How many block could validator mined since the last notary in case he did sign every possible block \r\n        uint256 maxBlocksMined = (notaryEndBlock - notaryStartBlock) + 1;\r\n        \r\n        // Calculates total involved vesting from provided list of validators and removes all validators that did not mine during last 2 notyary windows\r\n        uint256 totalInvolvedVesting = processNotaryValidators(chain, validators, blocksMined, maxBlocksMined);\r\n        \r\n        // In case totalInvolvedVesting == 0, something is wrong and there is no need for notary to continue as rewards cannot be calculated. It might happen\r\n        // as edge case when the last validator stopped mining durint current notary window or there is ongoing coordinated attack based on invalid statistics sent to the notary\r\n        require(totalInvolvedVesting > 0, \"totalInvolvedVesting == 0. Invalid statistics or 0 active validators left in the chain\");\r\n        \r\n        // Calculates and process validator's rewards based on their participation rate and vesting balance\r\n        processValidatorsRewards(chain, totalInvolvedVesting, validators, blocksMined, maxBlocksMined, totalCost);\r\n        \r\n        // Updates info when the last notary was processed \r\n        chain.lastNotary.block = notaryEndBlock;\r\n        chain.lastNotary.timestamp = now;\r\n        \r\n        if (chain.active == false) {\r\n            chain.active = true;\r\n        }\r\n        \r\n        emit Notary(chainId, notaryEndBlock, maxBlocksMined);\r\n    }\r\n    \r\n    /**\r\n     * @notice Manually resets last accepted notary block & timestamp. Only chain creator can call this method\r\n     *\r\n     * @param chainId           ChainId that sender wants to interact with\r\n     * @param resetBlock        New last accepted notary block number\r\n     * @param processRequests   Flag if notary block set in vesting/deposit requests should be set\r\n     * @param unvoteValidators  Flag if stopMining should be called for all active validators\r\n     **/\r\n    function resetNotary(uint256 chainId, uint256 resetBlock, bool processRequests, bool unvoteValidators) external {\r\n        ChainInfo storage chain = chains[chainId];\r\n        require(msg.sender == chain.creator, \"Only chain creator can call this method\");\r\n        \r\n        // Manually updates info when the last notary was processed \r\n        uint256 lastValidBlock = chain.lastNotary.block;\r\n        chain.lastNotary.block = resetBlock;\r\n        \r\n        if (processRequests == true) {\r\n          bool end = false;\r\n          for (uint256 batch = 0; end == false; batch++) {\r\n              end = resetRequests(chainId, resetBlock, batch);\r\n          }\r\n        }\r\n        \r\n        if (unvoteValidators == true) {\r\n            removeValidators(chainId, chain.validators.list);\r\n        }\r\n    \r\n        emit NotaryReset(chainId, lastValidBlock, resetBlock);               \r\n    }\r\n    \r\n    /**\r\n     * @notice Manually removes validators from list of active validators(stop Mining is called)\r\n     *\r\n     * @param chainId       ChainId that sender wants to interact with\r\n     * @param validators    List of validators (their addresses) to beremoved from list of active validators\r\n     **/\r\n    function removeValidators(uint256 chainId, address[] memory validators) public {\r\n        ChainInfo storage chain = chains[chainId];\r\n        require(msg.sender == chain.creator, \"Only chain creator can call this method\");\r\n        \r\n        for (uint256 i = 0; i < validators.length; i++) {\r\n            if (activeValidatorExist(chain, validators[i]) == true) {\r\n                activeValidatorRemove(chain, validators[i]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Manually resets notary block in vesting/deposit requests of users. Only chain creator can call this method\r\n     *\r\n     * @param chainId       ChainId that sender wants to interact with\r\n     * @param resetBlock    New notary to be set in requests\r\n     * @param batch         Batch number to be fetched. If the list is too big it cannot return all validators in one call. Instead, users are fetching batches of 100 account at a time \r\n     *\r\n     * @return end          Flag if there are no more users(their requests) to be processed left. To get all users, caller should fetch all batches until he sees end == true\r\n     **/\r\n    function resetRequests(uint256 chainId, uint256 resetBlock, uint256 batch) public returns (bool end) {\r\n        ChainInfo storage chain = chains[chainId];\r\n        require(msg.sender == chain.creator, \"Only chain creator can call this method\");\r\n        \r\n        uint256 usersTotalCount = chain.users.list.length;\r\n        uint256 i;\r\n        for(i = batch * 100; i < (batch + 1)*100 && i < usersTotalCount; i++) {\r\n            User storage user = chain.usersData[chain.users.list[i]];\r\n            \r\n            if (user.transactor.depositWithdrawalRequest.exist == true) {\r\n              user.transactor.depositWithdrawalRequest.notaryBlock = resetBlock;\r\n            }\r\n            \r\n            if (user.validator.vestingRequest.exist == true) {\r\n              user.validator.vestingRequest.notaryBlock = resetBlock;\r\n            }\r\n        }\r\n        \r\n        if (i >= usersTotalCount) {\r\n            end = true;\r\n        }\r\n        else {\r\n            end = false;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns list of transactors (users) that are allowed to transact - their deposit >= min. required deposit (their accounts)\r\n     *\r\n     * @param chainId      ChainId that sender wants to interact with\r\n     * @param batch        Batch number to be fetched. If the list is too big it cannot return all validators in one call. Instead, users are fetching batches of 100 account at a time \r\n     * \r\n     * @return validators  List(batch of 100) of account\r\n     * @return count       How many accounts are returned in specified batch\r\n     * @return end         Flag if there are no more accounts left. To get all accounts, caller should fetch all batches until he sees end == true\r\n     **/\r\n    function getTransactors(uint256 chainId, uint256 batch) external view returns (address[100] memory transactors, uint256 count, bool end) {\r\n        return getUsers(chains[chainId], true, batch);\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns list of active and non-active validators (their accounts)\r\n     *\r\n     * @param chainId      ChainId that sender wants to interact with\r\n     * @param batch        Batch number to be fetched. If the list is too big it cannot return all validators in one call. Instead, users are fetching batches of 100 account at a time \r\n     * \r\n     * @return validators  List(batch of 100) of account\r\n     * @return count       How many accounts are returned in specified batch\r\n     * @return end         Flag if there are no more accounts left. To get all accounts, caller should fetch all batches until he sees end == true\r\n     **/\r\n    function getAllowedToValidate(uint256 chainId, uint256 batch) view external returns (address[100] memory validators, uint256 count, bool end) {\r\n        return getUsers(chains[chainId], false, batch);\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns list of active validators (their accounts)\r\n     *\r\n     * @param chainId       ChainId that sender wants to interact with\r\n     * @param batch         Batch number to be fetched. If the list is too big it cannot return all validators in one call. Instead, users are fetching batches of 100 account at a time \r\n     * \r\n     * @return validators  List(batch of 100) of account\r\n     * @return count       How many accounts are returned in specified batch\r\n     * @return end         Flag if there are no more accounts left. To get all accounts, caller should fetch all batches until he sees end == true\r\n     **/\r\n    function getValidators(uint256 chainId, uint256 batch) view external returns (address[100] memory validators, uint256 count, bool end) {\r\n        ChainInfo storage chain = chains[chainId];\r\n        \r\n        count = 0;\r\n        uint256 validatorsTotalCount = chain.validators.list.length;\r\n        \r\n        address acc;\r\n        uint256 i;\r\n        for(i = batch * 100; i < (batch + 1)*100 && i < validatorsTotalCount; i++) {\r\n            acc = chain.validators.list[i];\r\n            \r\n            validators[count] = acc;\r\n            count++;\r\n        }\r\n        \r\n        if (i >= validatorsTotalCount) {\r\n            end = true;\r\n        }\r\n        else {\r\n            end = false;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets mining validator's mining flag to true and emit event so other nodes vote him\r\n     *\r\n     * @param chainId ChainId that sender wants to interact with\r\n     * \r\n     * @dev AccountMining(uint256 indexed chainId, address indexed account, bool mining) event with mining == true\r\n     **/\r\n    function startMining(uint256 chainId) external {\r\n        ChainInfo storage chain = chains[chainId];\r\n        address acc = msg.sender;\r\n        uint256 validatorVesting = chain.usersData[acc].validator.vesting;\r\n        \r\n        require(chain.registered == true,                         \"Non-registered chain\");\r\n        require(validatorExist(chain, acc) == true,               \"Non-existing validator (0 vesting balance)\");\r\n        require(vestingRequestExist(chain, acc) == false,         \"Cannot start mining - there is ongoing vesting request\");\r\n        \r\n        if (chain.chainValidator != ChainValidator(0)) {\r\n            require(chain.chainValidator.validateNewValidator(validatorVesting, acc, true /* mining */, chain.validators.list.length) == true, \"Validator not allowed by external chainvalidator SC\");\r\n        }\r\n        \r\n        if (activeValidatorExist(chain, acc) == true) {\r\n            // Emit event even if validator is already active - user might want to explicitely emit this event in case something went wrong on the nodes and\r\n            // others did not vote him\r\n            emit AccountMining(chainId, acc, true);\r\n            \r\n            return;\r\n        }\r\n            \r\n        // Upper limit of validators reached\r\n        if (chain.maxNumOfValidators != 0 && chain.validators.list.length >= chain.maxNumOfValidators) {\r\n            require(validatorVesting > chain.usersData[chain.lastValidator].validator.vesting, \"Upper limit of validators reached. Must vest more than the last validator to replace him\");\r\n            activeValidatorReplace(chain, acc);\r\n        }\r\n        // There is still empty place for new validator\r\n        else {\r\n            activeValidatorInsert(chain, acc);\r\n        }\r\n    }\r\n  \r\n    /**\r\n     * @notice Sets mining validator's mining flag to false and emit event so other nodes unvote. In case stopMining is called \r\n     *        by the last active validator, so there is 0 active validators left, it sets chain.active flag to false \r\n     *\r\n     * @param chainId ChainId that sender wants to interact with\r\n     * \r\n     * @dev AccountMining(uint256 indexed chainId, address indexed account, bool mining) event with mining == false\r\n     **/\r\n    function stopMining(uint256 chainId) external {\r\n        ChainInfo storage chain = chains[chainId];\r\n        address acc = msg.sender;\r\n        \r\n        require(chain.registered == true, \"Non-registered chain\");\r\n        require(validatorExist(chain, acc) == true, \"Non-existing validator (0 vesting balance)\");\r\n    \r\n        if (activeValidatorExist(chain, acc) == false) {\r\n            // Emit event even if validator is already inactive - user might want to explicitely emit this event in case something went wrong on the nodes and\r\n            // others did not unvote him\r\n            emit AccountMining(chainId, acc, false);\r\n            \r\n            return;\r\n        }\r\n        \r\n        activeValidatorRemove(chain, acc);\r\n    }\r\n    \r\n\r\n    /**************************************************************************************************************************/\r\n    /**************************************** Functions related to the list of users ******************************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    // Adds acc from the map\r\n    function insertAcc(IterableMap storage map, address acc) internal {\r\n        map.list.push(acc);\r\n        // indexes are stored + 1   \r\n        map.listIndex[acc] = map.list.length;\r\n    }\r\n    \r\n    // Removes acc from the map\r\n    function removeAcc(IterableMap storage map, address acc) internal {\r\n        uint256 index = map.listIndex[acc];\r\n        require(index > 0 && index <= map.list.length, \"RemoveAcc invalid index\");\r\n        \r\n        // Move an last element of array into the vacated key slot.\r\n        uint256 foundIndex = index - 1;\r\n        uint256 lastIndex  = map.list.length - 1;\r\n    \r\n        map.listIndex[map.list[lastIndex]] = foundIndex + 1;\r\n        map.list[foundIndex] = map.list[lastIndex];\r\n        map.list.length--;\r\n    \r\n        // Deletes element\r\n        map.listIndex[acc] = 0;\r\n    }\r\n    \r\n    // Returns true, if acc exists in the iterable map, otherwise false\r\n    function existAcc(IterableMap storage map, address acc) internal view returns (bool) {\r\n        return map.listIndex[acc] != 0;\r\n    }\r\n    \r\n    // Inits validator data holder in the users mapping and inserts it into the list of users\r\n    function validatorCreate(ChainInfo storage chain, address acc, uint256 vesting) internal {\r\n        Validator storage validator     = chain.usersData[acc].validator;\r\n        \r\n        validator.vesting                   = vesting;\r\n        validator.lastVestingIncreaseTime   = now;\r\n        // Inits previously notary windows as mined so validator does not get removed from the list of actively mining validators right after the creation\r\n        validator.currentNotaryMined        = true;\r\n        validator.prevNotaryMined           = true;\r\n        \r\n        \r\n        // No need to check if validatorExist for the same acc as it is not possible to have vesting > 0 & deosit > 0 at the same time\r\n        insertAcc(chain.users, acc);\r\n    }\r\n    \r\n    // Deinits validator data holder in the users mapping and removes it from the list of users\r\n    function validatorDelete(ChainInfo storage chain, address acc) internal {\r\n        Validator storage validator = chain.usersData[acc].validator;\r\n        \r\n        if (activeValidatorExist(chain, acc) == true) {\r\n            activeValidatorRemove(chain, acc);\r\n        }\r\n        \r\n        validator.vesting                   = 0;\r\n        validator.lastVestingIncreaseTime   = 0;\r\n        validator.currentNotaryMined        = false;\r\n        validator.prevNotaryMined           = false;\r\n        \r\n        // No need to check if transactorExist for the same acc as it is not possible to have vesting > 0 & deosit > 0 at the same time\r\n        removeAcc(chain.users, acc);\r\n    }\r\n    \r\n    // Inserts validator into the list of actively mining validators\r\n    function activeValidatorInsert(ChainInfo storage chain, address acc) internal {\r\n        Validator storage validator = chain.usersData[acc].validator;\r\n        \r\n        // Updates lastValidator in case this is first validator or new validator's vesting balance is less\r\n        if (chain.validators.list.length == 0 || validator.vesting <= chain.usersData[chain.lastValidator].validator.vesting) {\r\n            chain.lastValidator = acc;\r\n        }\r\n        \r\n        insertAcc(chain.validators, acc);   \r\n        \r\n        // Updates chain total vesting\r\n        chain.totalVesting = chain.totalVesting.add(validator.vesting);\r\n        \r\n        emit AccountMining(chain.id, acc, true);\r\n    }\r\n    \r\n    // Removes validator from the list of actively mining validators\r\n    function activeValidatorRemove(ChainInfo storage chain, address acc) internal {\r\n        Validator storage validator = chain.usersData[acc].validator;\r\n        \r\n        removeAcc(chain.validators, acc);   \r\n        \r\n        // Updates chain total vesting\r\n        chain.totalVesting = chain.totalVesting.sub(validator.vesting);\r\n        \r\n        // If there is no active validator left, set chain.active flag to false so others might vest in chain without\r\n        // waiting for the next notary window to be processed\r\n        if (chain.validators.list.length == 0) {\r\n            chain.active = false;\r\n            chain.lastValidator = address(0x0);\r\n        }\r\n        // There are still some active validators left\r\n        else {\r\n            // If lastValidator is being removed, find a new validator with the smallest vesting balance\r\n            if (chain.lastValidator == acc) {\r\n                resetLastActiveValidator(chain);\r\n            }\r\n        }\r\n        \r\n        emit AccountMining(chain.id, acc, false);\r\n    }\r\n    \r\n    // Replaces lastValidator for the new one in the list of actively mining validators\r\n    function activeValidatorReplace(ChainInfo storage chain, address acc) internal {\r\n        address accToBeReplaced                 = chain.lastValidator;\r\n        Validator memory validatorToBeReplaced  = chain.usersData[accToBeReplaced].validator;\r\n        Validator memory newValidator           = chain.usersData[acc].validator;\r\n        \r\n        // Updates chain total vesting\r\n        chain.totalVesting = chain.totalVesting.sub(validatorToBeReplaced.vesting);\r\n        chain.totalVesting = chain.totalVesting.add(newValidator.vesting);\r\n        \r\n        // Updates active validarors list\r\n        removeAcc(chain.validators, accToBeReplaced);\r\n        insertAcc(chain.validators, acc);\r\n        \r\n        // Finds a new validator with the smallest vesting balance\r\n        resetLastActiveValidator(chain);\r\n        \r\n        emit AccountMining(chain.id, accToBeReplaced, false);\r\n        emit AccountMining(chain.id, acc, true);\r\n    }\r\n    \r\n    // Resets last validator - the one with the smallest vesting balance\r\n    function resetLastActiveValidator(ChainInfo storage chain) internal {\r\n        address foundLastValidatorAcc     = chain.validators.list[0];\r\n        uint256 foundLastValidatorVesting = chain.usersData[foundLastValidatorAcc].validator.vesting;\r\n        \r\n        address actValidatorAcc;\r\n        uint256 actValidatorVesting;\r\n        for (uint256 i = 1; i < chain.validators.list.length; i++) {\r\n            actValidatorAcc     = chain.validators.list[i];\r\n            actValidatorVesting = chain.usersData[actValidatorAcc].validator.vesting;\r\n            \r\n            if (actValidatorVesting <= foundLastValidatorVesting) {\r\n                foundLastValidatorAcc     = actValidatorAcc;\r\n                foundLastValidatorVesting = actValidatorVesting;\r\n            }\r\n        }\r\n        \r\n        chain.lastValidator = foundLastValidatorAcc;\r\n    }\r\n    \r\n    // Returns true, if acc is in the list of actively mining validators, otherwise false\r\n    function activeValidatorExist(ChainInfo storage chain, address acc) internal view returns (bool) {\r\n        return existAcc(chain.validators, acc);\r\n    }\r\n    \r\n    // Returns true, if acc hase vesting > 0, otherwise false\r\n    function validatorExist(ChainInfo storage chain, address acc) internal view returns (bool) {\r\n        return chain.usersData[acc].validator.vesting > 0;\r\n    }\r\n    \r\n    // Inits transactor data holder in the users mapping and inserts it into the list of users\r\n    function transactorCreate(ChainInfo storage chain, address acc, uint256 deposit) internal {\r\n        Transactor storage transactor = chain.usersData[acc].transactor;\r\n        \r\n        transactor.deposit = deposit;\r\n        transactorWhitelist(chain, acc);\r\n        \r\n        // No need to check if validatorExist for the same acc as it is not possible to have vesting > 0 & deosit > 0 at the same time\r\n        insertAcc(chain.users, acc);\r\n    }\r\n    \r\n    // Deinits transactor data holder in the users mapping and removes it from the list of users\r\n    function transactorDelete(ChainInfo storage chain, address acc) internal {\r\n        Transactor storage transactor = chain.usersData[acc].transactor;\r\n        \r\n        transactor.deposit = 0;\r\n        transactorBlacklist(chain, acc);\r\n        \r\n        // No need to check if validatorExist for the same acc as it is not possible to have vesting > 0 & deosit > 0 at the same time\r\n        removeAcc(chain.users, acc);\r\n    }\r\n    \r\n    // Returns true, if acc hase deposit > 0, otherwise false\r\n    function transactorExist(ChainInfo storage chain, address acc) internal view returns (bool) {\r\n        return chain.usersData[acc].transactor.deposit > 0;\r\n    }\r\n    \r\n    // Blacklists transactor\r\n    function transactorBlacklist(ChainInfo storage chain, address acc) internal {\r\n        Transactor storage transactor   = chain.usersData[acc].transactor;\r\n        \r\n        if (transactor.whitelisted == true) {\r\n            chain.actNumOfTransactors--;\r\n            \r\n            transactor.whitelisted = false;\r\n            emit AccountWhitelisted(chain.id, acc, false);\r\n        }\r\n    }\r\n    \r\n    // Whitelists transactor\r\n    function transactorWhitelist(ChainInfo storage chain, address acc) internal {\r\n        Transactor storage transactor   = chain.usersData[acc].transactor;\r\n        \r\n        if (transactor.whitelisted == false) {\r\n            chain.actNumOfTransactors++;\r\n            \r\n            transactor.whitelisted = true;\r\n            emit AccountWhitelisted(chain.id, acc, true);\r\n        }\r\n    }\r\n    \r\n    // Returns list of users\r\n    function getUsers(ChainInfo storage chain, bool transactorsFlag, uint256 batch) internal view returns (address[100] memory users, uint256 count, bool end) {\r\n        count = 0;\r\n        uint256 usersTotalCount = chain.users.list.length;\r\n        \r\n        address acc;\r\n        uint256 i;\r\n        for(i = batch * 100; i < (batch + 1)*100 && i < usersTotalCount; i++) {\r\n            acc = chain.users.list[i];\r\n            \r\n            // Get transactors (only those who are whitelisted - their depist passed min.required conditions)\r\n            if (transactorsFlag == true) {\r\n                if (chain.usersData[acc].transactor.whitelisted == false) {\r\n                    continue;\r\n                } \r\n            }\r\n            // Get validators (active and non-active)\r\n            else {\r\n                if (chain.usersData[acc].validator.vesting == 0) {\r\n                    continue;\r\n                }\r\n            }\r\n            \r\n            users[count] = acc;\r\n            count++;\r\n        }\r\n        \r\n        if (i >= usersTotalCount) {\r\n            end = true;\r\n        }\r\n        else {\r\n            end = false;\r\n        }\r\n    }\r\n    \r\n    /**************************************************************************************************************************/\r\n    /*********************************** Functions related to the vesting/deposit requests ************************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    // Creates new vesting request\r\n    function vestingRequestCreate(ChainInfo storage chain, address acc, uint256 vesting) internal {\r\n        VestingRequest storage request = chain.usersData[acc].validator.vestingRequest;\r\n        \r\n        request.exist       = true;\r\n        request.newVesting  = vesting;\r\n        request.notaryBlock = chain.lastNotary.block; \r\n    }\r\n\r\n    // Creates new deposit withdrawal request\r\n    function depositWithdrawalRequestCreate(ChainInfo storage chain, address acc) internal {\r\n        DepositWithdrawalRequest storage request = chain.usersData[acc].transactor.depositWithdrawalRequest;\r\n        \r\n        request.exist       = true;\r\n        request.notaryBlock = chain.lastNotary.block; \r\n    }\r\n    \r\n    function vestingRequestDelete(ChainInfo storage chain, address acc) internal {\r\n        // There is ongoing deposit request for this account - only reset vesting request\r\n        VestingRequest storage request = chain.usersData[acc].validator.vestingRequest;\r\n        request.exist          = false;\r\n        request.notaryBlock    = 0;\r\n        request.newVesting     = 0;\r\n    }\r\n    \r\n    function depositWithdrawalRequestDelete(ChainInfo storage chain, address acc) internal {\r\n        // There is ongoing vesting request for this account - only reset vesting request\r\n        DepositWithdrawalRequest storage request = chain.usersData[acc].transactor.depositWithdrawalRequest;\r\n        request.exist          = false;\r\n        request.notaryBlock    = 0;\r\n    }\r\n    \r\n    // Checks if acc has any ongoing vesting request\r\n    function vestingRequestExist(ChainInfo storage chain, address acc) internal view returns (bool) {\r\n        return chain.usersData[acc].validator.vestingRequest.exist;\r\n    }\r\n    \r\n    // Checks if acc has any ongoing DEPOSIT WITHDRAWAL request\r\n    function depositWithdrawalRequestExist(ChainInfo storage chain, address acc) internal view returns (bool) {\r\n        return chain.usersData[acc].transactor.depositWithdrawalRequest.exist;\r\n    }\r\n    \r\n    // Full vesting withdrawal  and vesting increase are procesed in 2 steps with confirmaition\r\n    // Immediate full withdrawal is not allowed as validators might already mine some blocks so they can get rewards \r\n    // based on theirs vesting balance for that\r\n    function requestVest(ChainInfo storage chain, uint256 vesting, address acc) internal {\r\n        Validator storage validator = chain.usersData[acc].validator;\r\n        \r\n        uint256 validatorVesting = validator.vesting;\r\n        \r\n        // Vesting increase - process in 2 steps\r\n        if (vesting > validatorVesting) {\r\n            uint256 toVest = vesting - validatorVesting;\r\n            token.transferFrom(acc, address(this), toVest);\r\n        }\r\n        // Vesting decrease - process immediately\r\n        else if (vesting != 0) {\r\n            uint256 toWithdraw = validatorVesting - vesting;\r\n            \r\n            validator.vesting = vesting;    \r\n            \r\n            // If validator is actively mining, decrease chain's total vesting\r\n            if (activeValidatorExist(chain, acc) == true) {\r\n                chain.totalVesting = chain.totalVesting.sub(toWithdraw);\r\n                \r\n                // Updates lastValidator in case it is needed - if user is decreasing vesting and there ist last validator \r\n                // with the same amount of tokens, keep him as last one because he had lower vesting for more time\r\n                if (acc != chain.lastValidator && validator.vesting < chain.usersData[chain.lastValidator].validator.vesting) {\r\n                    chain.lastValidator = acc;\r\n                }\r\n            }\r\n            \r\n            // Transfers tokens\r\n            token.transfer(acc, toWithdraw);\r\n            \r\n            emit VestInChain(chain.id, acc, vesting, chain.lastNotary.block, true);\r\n            return;\r\n        }\r\n        // else full vesting withdrawal - process in 2 steps\r\n        \r\n        vestingRequestCreate(chain, acc, vesting);\r\n        emit VestInChain(chain.id, acc, vesting, chain.usersData[acc].validator.vestingRequest.notaryBlock, false);\r\n        \r\n        return;\r\n    }\r\n    \r\n    function confirmVest(ChainInfo storage chain, address acc) internal {\r\n        Validator storage validator             = chain.usersData[acc].validator;\r\n        VestingRequest memory request           = chain.usersData[acc].validator.vestingRequest;\r\n        \r\n        vestingRequestDelete(chain, acc);\r\n        uint256 origVesting = validator.vesting;\r\n        \r\n        // Vesting increase\r\n        if (request.newVesting > origVesting) {\r\n            // Non-existing validator - internally creates new one\r\n            if (validatorExist(chain, acc) == false) {\r\n                validatorCreate(chain, acc, request.newVesting);\r\n            }\r\n            // Existing validator\r\n            else {\r\n                validator.vesting = request.newVesting;\r\n                validator.lastVestingIncreaseTime = now;\r\n                \r\n                if (activeValidatorExist(chain, acc) == true) {\r\n                    chain.totalVesting = chain.totalVesting.add(request.newVesting - origVesting);\r\n                    \r\n                    // Updates last validator in case it is him who is increasing vesting balance\r\n                    if (acc == chain.lastValidator) {\r\n                        resetLastActiveValidator(chain);\r\n                    }\r\n                }    \r\n            }\r\n        }\r\n        // Full vesting withdrawal - stopMining must be called before\r\n        else {\r\n            uint256 toWithdraw = origVesting;\r\n            validatorDelete(chain, acc);\r\n            \r\n            // Transfers tokens\r\n            token.transfer(acc, toWithdraw);\r\n        }\r\n        \r\n        emit VestInChain(chain.id, acc, request.newVesting, request.notaryBlock, true);\r\n    }\r\n    \r\n    function requestDeposit(ChainInfo storage chain, uint256 deposit, address acc) internal {\r\n        Transactor storage transactor = chain.usersData[acc].transactor;\r\n        \r\n        // If user wants to withdraw whole deposit\r\n        if (deposit == 0) {\r\n            depositWithdrawalRequestCreate(chain, acc);\r\n            transactorBlacklist(chain, acc);\r\n            emit DepositInChain(chain.id, acc, deposit, chain.usersData[acc].transactor.depositWithdrawalRequest.notaryBlock, false);  \r\n          \r\n            return;\r\n        }\r\n      \r\n        // If user wants to deposit in chain, process it immediately\r\n        uint256 actTransactorDeposit = transactor.deposit;\r\n        \r\n        if(actTransactorDeposit > deposit) {\r\n            transactor.deposit = deposit;\r\n         \r\n            uint256 toWithdraw = actTransactorDeposit - deposit;\r\n            token.transfer(acc, toWithdraw);\r\n        } else {\r\n            uint256 toDeposit = deposit - actTransactorDeposit;\r\n            token.transferFrom(acc, address(this), toDeposit);\r\n         \r\n            // First deposit - create internally new user\r\n            if (transactorExist(chain, acc) == false) {\r\n                transactorCreate(chain, acc, deposit);\r\n            }\r\n            else {\r\n                transactor.deposit = deposit;\r\n                transactorWhitelist(chain, acc);\r\n            }\r\n        }\r\n        \r\n        emit DepositInChain(chain.id, acc, deposit, chain.lastNotary.block, true);\r\n    }\r\n    \r\n    function confirmDepositWithdrawal(ChainInfo storage chain, address acc) internal {\r\n        Transactor storage transactor   = chain.usersData[acc].transactor;\r\n        \r\n        uint256 toWithdraw              = transactor.deposit;\r\n        uint256 requestNotaryBlock      = transactor.depositWithdrawalRequest.notaryBlock;\r\n        \r\n        transactorDelete(chain, acc);\r\n        depositWithdrawalRequestDelete(chain, acc);\r\n        \r\n        // Withdraw whole deposit\r\n        token.transfer(acc, toWithdraw);\r\n        \r\n        emit DepositInChain(chain.id, acc, 0, requestNotaryBlock, true);\r\n    }\r\n    \r\n    /**************************************************************************************************************************/\r\n    /*************************************************** Other functions ******************************************************/\r\n    /**************************************************************************************************************************/\r\n\r\n    constructor(ERC20 _token) public {\r\n        token = _token;\r\n    }\r\n  \r\n    // Process users consumption based on their usage\r\n    function processUsersConsumptions(ChainInfo storage chain, address[] memory users, uint64[] memory userGas, uint64 largestTxGas) internal returns (uint256 totalCost) {\r\n        // Total usage cost in NET tokens\r\n        totalCost = 0;\r\n        \r\n        // Individual user's usage cost in Nordic Energy tokens\r\n        uint256 userCost;\r\n        \r\n        uint256 transactorDeposit;\r\n        address acc;\r\n        for(uint256 i = 0; i < users.length; i++) {\r\n            acc = users[i];\r\n            Transactor storage transactor = chain.usersData[acc].transactor;\r\n            transactorDeposit = transactor.deposit;\r\n            \r\n            // This can happen only if there is non-registered transactor(user) in statistics, which means that there is probaly\r\n            // ongoing coordinated attack based on invalid statistics sent to the notary\r\n            // Ignores non-registred user\r\n            if (transactorExist(chain, acc) == false || userGas[i] == 0) {\r\n                // Let nodes know that this user is not allowed to transact only if chain is active - in case it is not and becomes active again \r\n                // there might be some users that already withdrawed their deposit  \r\n                if (chain.active == true) {\r\n                    emit AccountWhitelisted(chain.id, users[i], false);\r\n                }\r\n                continue;\r\n            }\r\n            \r\n            userCost = (userGas[i] * LARGEST_TX_FEE) / largestTxGas;\r\n            \r\n            // This can happen only if user runs out of tokens(which should not happen due to min.required deposit)\r\n            if(userCost > transactorDeposit ) {\r\n                userCost = transactorDeposit;\r\n            \r\n                transactorDelete(chain, acc);\r\n            }\r\n            else {\r\n                transactorDeposit = transactorDeposit.sub(userCost);\r\n                \r\n                // Updates user's stored deposit balance based on his usage\r\n                transactor.deposit = transactorDeposit;\r\n                \r\n                // Check if user's deposit balance is >= min. required deposit conditions\r\n                if (transactorDeposit < chain.minRequiredDeposit) {\r\n                    transactorBlacklist(chain, acc);\r\n                }\r\n            }\r\n            \r\n            // Adds user's cost to the total cost\r\n            totalCost = totalCost.add(userCost);\r\n        }\r\n    }\r\n    \r\n    // Calculates validators invloved total vesting and removes validators that did not mine at all during the last 2 notary windows\r\n    function processNotaryValidators(ChainInfo storage chain, address[] memory validators, uint32[] memory blocksMined, uint256 maxBlocksMined) internal returns (uint256 totalInvolvedVesting) {\r\n        // Array of flags if active validators mined this notary window \r\n        bool[] memory miningValidators = new bool[](chain.validators.list.length); \r\n        \r\n        // Selected validator's account address, index and vesting balance\r\n        address actValidatorAcc;\r\n        uint256 actValidatorIdx;\r\n        uint256 actValidatorVesting;\r\n        \r\n        for(uint256 i = 0; i < validators.length; i++) {\r\n            actValidatorAcc = validators[i];\r\n        \r\n            // Validators, who are not actively mining anymore (their node probably crashed) do not receive no rewaeds\r\n            if (activeValidatorExist(chain, actValidatorAcc) == false || blocksMined[i] == 0) {\r\n                continue;\r\n            }\r\n            \r\n            actValidatorIdx = chain.validators.listIndex[actValidatorAcc] - 1;\r\n            \r\n            // In case there miningValidators[actValidatorIdx] is already true, it means the same validator address is twice in the statistics,\r\n            // This should never happen, ignore such validators \r\n            if (miningValidators[actValidatorIdx] == true) {\r\n                continue;\r\n            }\r\n            else {\r\n                miningValidators[actValidatorIdx] = true;\r\n            }\r\n            \r\n            actValidatorVesting = chain.usersData[actValidatorAcc].validator.vesting;\r\n            \r\n            // In case rewardBonusRequiredVesting is specified && actValidatorVesting is bigger, apply bonus\r\n            if (chain.rewardBonusRequiredVesting > 0 && actValidatorVesting >= chain.rewardBonusRequiredVesting) {\r\n                actValidatorVesting = actValidatorVesting.mul(chain.rewardBonusPercentage + 100) / 100;\r\n            }\r\n            \r\n            totalInvolvedVesting = totalInvolvedVesting.add(actValidatorVesting.mul(blocksMined[i])); \r\n        }\r\n        totalInvolvedVesting /= maxBlocksMined;\r\n\r\n        // Process miningValidators from statistics and set current validators(registered in sc as active validators) mining flags accordingly\r\n        for(uint256 i = 0; i < chain.validators.list.length; i++) {\r\n            actValidatorAcc = chain.validators.list[i];\r\n            \r\n            Validator storage validator = chain.usersData[actValidatorAcc].validator;\r\n            validator.prevNotaryMined   = validator.currentNotaryMined;\r\n            \r\n            if (miningValidators[i] == true) {\r\n                validator.currentNotaryMined = true;\r\n            }\r\n            else {\r\n                validator.currentNotaryMined = false;\r\n            }\r\n        }\r\n        \r\n        // Deletes validators who did not mine in the last 2 notary windows \r\n        uint256 activeValidatorsCount = chain.validators.list.length; \r\n        for (uint256 i = 0; i < activeValidatorsCount; ) {\r\n            actValidatorAcc = chain.validators.list[i];\r\n            Validator memory validator = chain.usersData[actValidatorAcc].validator;\r\n           \r\n            if (validator.currentNotaryMined == true || validator.prevNotaryMined == true) {\r\n                i++;\r\n                continue;\r\n            }\r\n           \r\n            activeValidatorRemove(chain, actValidatorAcc);\r\n            activeValidatorsCount--;\r\n        } \r\n     \r\n        delete miningValidators;   \r\n    }\r\n\r\n    // Process validators rewards based on their participation rate(how many blocks they signed) and their vesting balance\r\n    function processValidatorsRewards(ChainInfo storage chain, uint256 totalInvolvedVesting, address[] memory validators, uint32[] memory blocksMined, uint256 maxBlocksMined, uint256 NETToDistribute) internal {\r\n        // Array of flags if active validators mined this notary window \r\n        bool[] memory miningValidators = new bool[](chain.validators.list.length); \r\n        \r\n        // Selected validator's account address and vesting balance\r\n        address actValidatorAcc;\r\n        uint256 actValidatorIdx;\r\n        uint256 actValidatorVesting;\r\n        uint256 actValidatorReward;\r\n        \r\n        // Whats left after all rewards are distributed (math rounding)\r\n        uint256 NETToDistributeRest = NETToDistribute;\r\n        \r\n        // Runs through all validators and calculates their reward based on:\r\n        //     1. How many blocks out of max_blocks_mined each validator signed\r\n        //     2. How many token each validator vested\r\n        for(uint256 i = 0; i < validators.length; i++) {\r\n            actValidatorAcc = validators[i];\r\n            \r\n            // Validators, who are not actively mining anymore (their node probably crashed) do not receive no rewaeds\r\n            if (activeValidatorExist(chain, actValidatorAcc) == false || blocksMined[i] == 0) {\r\n                continue;\r\n            } \r\n            \r\n            actValidatorIdx = chain.validators.listIndex[actValidatorAcc] - 1;\r\n            \r\n            // In case there miningValidators[actValidatorIdx] is already true, it means the same validator address is twice in the statistics,\r\n            // This should never happen, ignore such validators \r\n            if (miningValidators[actValidatorIdx] == true) {\r\n                continue;\r\n            }\r\n            else {\r\n                miningValidators[actValidatorIdx] = true;\r\n            }\r\n            \r\n            Validator storage actValidator = chain.usersData[actValidatorAcc].validator;\r\n            actValidatorVesting = actValidator.vesting;\r\n            \r\n            // In case rewardBonusRequiredVesting is specified && actValidatorVesting is bigger, apply bonus\r\n            if (chain.rewardBonusRequiredVesting > 0 && actValidatorVesting >= chain.rewardBonusRequiredVesting) {\r\n                actValidatorVesting = actValidatorVesting.mul(chain.rewardBonusPercentage + 100) / 100;\r\n            }\r\n        \r\n            actValidatorReward = actValidatorVesting.mul(blocksMined[i]).mul(NETToDistribute) / maxBlocksMined / totalInvolvedVesting;\r\n            \r\n            NETToDistributeRest = NETToDistributeRest.sub(actValidatorReward);\r\n            \r\n            // Add rewards to the validator's vesting balance\r\n            actValidator.vesting = actValidator.vesting.add(actValidatorReward);\r\n            \r\n            emit MiningReward(chain.id, actValidatorAcc, actValidatorReward);\r\n        }\r\n        \r\n        if(NETToDistributeRest > 0) {\r\n            // Add the rest(math rounding) to the validator, who called notary function\r\n            Validator storage sender = chain.usersData[msg.sender].validator;\r\n            \r\n            sender.vesting = sender.vesting.add(NETToDistributeRest);\r\n            \r\n            if (activeValidatorExist(chain, msg.sender) == false) {\r\n                chain.totalVesting = chain.totalVesting.sub(NETToDistributeRest);\r\n            }\r\n            \r\n            emit MiningReward(chain.id, msg.sender, NETToDistributeRest);\r\n        }\r\n        \r\n        // Updates chain total vesting\r\n        chain.totalVesting = chain.totalVesting.add(NETToDistribute); \r\n        \r\n        // As validators vestings were updated, last validator might change so find a new one\r\n        resetLastActiveValidator(chain);\r\n\r\n        delete miningValidators;\r\n    }\r\n   \r\n   // Validates notary conditions(involvedVesting && participation) to statistics to be accepted\r\n    function validateNotaryConditions(ChainInfo storage chain, bytes32 signatureHash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) internal view {\r\n        uint256 involvedVestingSum = 0;\r\n        uint256 involvedSignaturesCount = 0;\r\n        \r\n        bool[] memory signedValidators = new bool[](chain.validators.list.length); \r\n        \r\n        address signerAcc;\r\n        for(uint256 i = 0; i < v.length; i++) {\r\n            signerAcc = ecrecover(signatureHash, v[i], r[i], s[i]);\r\n            \r\n            // In case statistics is signed by validator, who is not registered in SC, ignore him   \r\n            if (activeValidatorExist(chain, signerAcc) == false) {\r\n                continue;\r\n            }\r\n            \r\n            uint256 validatorIdx = chain.validators.listIndex[signerAcc] - 1;\r\n            \r\n            // In case there is duplicit signature from the same validator, ignore it\r\n            if (signedValidators[validatorIdx] == true) {\r\n                continue;\r\n            }\r\n            else {\r\n                signedValidators[validatorIdx] = true;\r\n            }\r\n            \r\n            \r\n            involvedVestingSum = involvedVestingSum.add(chain.usersData[signerAcc].validator.vesting);\r\n            involvedSignaturesCount++;\r\n        }\r\n        \r\n        delete signedValidators;\r\n        \r\n        // There must be more than 50% out of total possible vesting involved in signatures\r\n        if (chain.involvedVestingNotaryCond == true) {\r\n            // There must be more than 50% out of total possible vesting involved\r\n            involvedVestingSum = involvedVestingSum.mul(2);\r\n            require(involvedVestingSum > chain.totalVesting, \"Invalid statistics data: involvedVesting <= 50% of chain.totalVesting\");\r\n        }\r\n        \r\n        \r\n        // There must be more than 2/3 + 1 out of all active validators unique signatures\r\n        if (chain.participationNotaryCond == true) {\r\n            uint256 actNumOfValidators = chain.validators.list.length;\r\n            \r\n            // min. number of active validators for BFT to work properly is 4\r\n            if (actNumOfValidators >= 4) {\r\n                uint256 minRequiredSignaturesCount = ((2 * actNumOfValidators) / 3) + 1;\r\n                \r\n                require(involvedSignaturesCount >= minRequiredSignaturesCount, \"Invalid statistics data: Not enough signatures provided (2/3 + 1 cond)\");\r\n            }\r\n            // if there is less than 4 active validators, everyone has to sign statistics\r\n            else {\r\n                require(involvedSignaturesCount == actNumOfValidators, \"Invalid statistics data: Not enough signatures provided (involvedSignatures == activeValidatorsCount)\");\r\n            }\r\n        }\r\n    }\r\n   \r\n    // Checks if chain is active(successfull notary processed during last CHAIN_INACTIVITY_TIMEOUT), if not set it active flag to false\r\n    // If last notary is older than CHAIN_INACTIVITY_TIMEOUT, it means that validators cannot reach consensus or there is no active validator and chain is basically stuck.\r\n    function checkAndSetChainActivity(ChainInfo storage chain) internal {\r\n        if (chain.active == true && chain.lastNotary.timestamp + CHAIN_INACTIVITY_TIMEOUT < now) {\r\n            chain.active = false;   \r\n        }\r\n    }\r\n}\r\n\r\n// SafeMath library. Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"mining\",\"type\":\"bool\"}],\"name\":\"AccountMining\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"AccountWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastNotaryBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"}],\"name\":\"DepositInChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"MiningReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"endpoint\",\"type\":\"string\"}],\"name\":\"NewChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocksProcessed\",\"type\":\"uint256\"}],\"name\":\"Notary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastValidBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resetBlock\",\"type\":\"uint256\"}],\"name\":\"NotaryReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastNotaryBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"}],\"name\":\"VestInChain\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"confirmDepositWithdrawalFromChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"confirmVestInChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batch\",\"type\":\"uint256\"}],\"name\":\"getAllowedToValidate\",\"outputs\":[{\"internalType\":\"address[100]\",\"name\":\"validators\",\"type\":\"address[100]\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"end\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getChainDynamicDetails\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalVesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validatorsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transactorsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastValidatorVesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastNotaryBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastNotaryTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getChainStaticDetails\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"endpoint\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minRequiredDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRequiredVesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardBonusRequiredVesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardBonusPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notaryPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxNumOfValidators\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxNumOfTransactors\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"involvedVestingNotaryCond\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"participationNotaryCond\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batch\",\"type\":\"uint256\"}],\"name\":\"getTransactors\",\"outputs\":[{\"internalType\":\"address[100]\",\"name\":\"transactors\",\"type\":\"address[100]\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"end\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"}],\"name\":\"getUserDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastVestingIncreaseTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"mining\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"prevNotaryMined\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"vestingReqExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"vestingReqNotary\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingReqValue\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"depositFullWithdrawalReqExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"depositReqNotary\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batch\",\"type\":\"uint256\"}],\"name\":\"getValidators\",\"outputs\":[{\"internalType\":\"address[100]\",\"name\":\"validators\",\"type\":\"address[100]\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"end\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notaryStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notaryEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"validators\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"blocksMined\",\"type\":\"uint32[]\"},{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint64[]\",\"name\":\"userGas\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64\",\"name\":\"largestTx\",\"type\":\"uint64\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"notary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"initEndpoint\",\"type\":\"string\"},{\"internalType\":\"contract ChainValidator\",\"name\":\"chainValidator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minRequiredDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRequiredVesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardBonusRequiredVesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardBonusPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notaryPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxNumOfValidators\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxNumOfTransactors\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"involvedVestingNotaryCond\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"participationNotaryCond\",\"type\":\"bool\"}],\"name\":\"registerChain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"validators\",\"type\":\"address[]\"}],\"name\":\"removeValidators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"requestDepositInChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"}],\"name\":\"requestVestInChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"processRequests\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"unvoteValidators\",\"type\":\"bool\"}],\"name\":\"resetNotary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batch\",\"type\":\"uint256\"}],\"name\":\"resetRequests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"end\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"endpoint\",\"type\":\"string\"}],\"name\":\"setChainStaticDetails\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"startMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"stopMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NordicEnergyRegistry","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b0e579c76d85e3814b3f17a4229c39d4fe53ba7f","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://0d97182cceb327da7024385e90dbf15b0f67c2bd45f1ae29bf92cc5e8cf2e4a5"}]}