{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\r\n\r\ncontract SimpleMultiSig {\r\n\r\n// EIP712 Precomputed hashes:\r\n// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\")\r\nbytes32 constant EIP712DOMAINTYPE_HASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n\r\n// keccak256(\"Simple MultiSig\")\r\nbytes32 constant NAME_HASH = 0xb7a0bfa1b79f2443f4d73ebb9259cddbcd510b18be6fc4da7d1aa7b1786e73e6;\r\n\r\n// keccak256(\"1\")\r\nbytes32 constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\r\n\r\n// keccak256(\"MultiSigTransaction(address destination,uint256 value,bytes data,uint256 nonce,address executor,uint256 gasLimit)\")\r\nbytes32 constant TXTYPE_HASH = 0x3ee892349ae4bbe61dce18f95115b5dc02daf49204cc602458cd4c1f540d56d7;\r\n\r\nbytes32 constant SALT = 0x251543af6a222378665a76fe38dbceae4871a070b7fdaf5c6c30cf758dc33cc0;\r\n\r\n  event Execute(address[] _confirmAddrs, address _destination, uint _value, bytes data);\r\n  event Deposit(address indexed _from,uint _value);\r\n\r\n  // debug events\r\n  // event DbgExecuteParam(bytes32 sperator, bytes32 txInputHash, bytes32 totalHash, bytes txInput);\r\n  // event DbgRecover(address _recovered);\r\n\r\n  uint public nonce;                 // (only) mutable state\r\n  uint public threshold;             // immutable state\r\n  mapping (address => bool) isOwner; // immutable state\r\n  address[] public ownersArr;        // immutable state\r\n\r\n  bytes32 DOMAIN_SEPARATOR;          // hash for EIP712, computed from contract address\r\n\r\n  // Note that owners_ must be strictly increasing, in order to prevent duplicates\r\n  constructor(uint threshold_, address[] memory owners_, uint chainId) public {\r\n    require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ > 0, \"0<threshold<owners.length\");\r\n\r\n    address lastAdd = address(0);\r\n    for (uint i = 0; i < owners_.length; i++) {\r\n      require(owners_[i] > lastAdd, \"repeated owner or not sorted\");\r\n      isOwner[owners_[i]] = true;\r\n      lastAdd = owners_[i];\r\n    }\r\n    ownersArr = owners_;\r\n    threshold = threshold_;\r\n\r\n    DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAINTYPE_HASH,\r\n                                            NAME_HASH,\r\n                                            VERSION_HASH,\r\n                                            chainId,\r\n                                            this,\r\n                                            SALT));\r\n  }\r\n\r\n  // Note that address recovered from signatures must be strictly increasing, in order to prevent duplicates\r\n  function execute(uint8[] memory sigV, bytes32[] memory sigR, bytes32[] memory sigS,\r\n    address destination, uint value, bytes memory data, address executor, uint gasLimit) public {\r\n\r\n    require(sigR.length == threshold, \"R len not equal to threshold\");\r\n    require(sigR.length == sigS.length && sigR.length == sigV.length, \"length of r/s/v not match\");\r\n    require(executor == msg.sender || executor == address(0), \"wrong executor\");\r\n\r\n    // EIP712 scheme: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\r\n    bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, executor, gasLimit));\r\n    bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, txInputHash));\r\n\r\n    // emit DbgExecuteParam(DOMAIN_SEPARATOR, txInputHash, totalHash, abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, executor, gasLimit));\r\n\r\n    address lastAdd = address(0); // cannot have address(0) as an owner\r\n    address[] memory confirmAddrs = new address[](threshold);\r\n    for (uint i = 0; i < threshold; i++) {\r\n      address recovered = ecrecover(totalHash, sigV[i], sigR[i], sigS[i]);\r\n      require(recovered > lastAdd && isOwner[recovered], \"Verify sig failed\");\r\n      // emit DbgRecover(recovered);\r\n      confirmAddrs[i] = recovered;\r\n      lastAdd = recovered;\r\n    }\r\n\r\n    // If we make it here all signatures are accounted for.\r\n    // The address.call() syntax is no longer recommended, see:\r\n    // https://github.com/ethereum/solidity/issues/2884\r\n    nonce = nonce + 1;\r\n    bool success = false;\r\n    assembly { success := call(gasLimit, destination, value, add(data, 0x20), mload(data), 0, 0) }\r\n    require(success, \"not_success\");\r\n    emit Execute(confirmAddrs, destination, value, data);\r\n  }\r\n\r\n  function getVersion() external pure returns (string memory) {\r\n    return \"1\"; //\r\n  }\r\n\r\n  function getOwersLength() external view returns (int8) {\r\n    return int8(ownersArr.length); //owners.length <= 10 (see constructor), so type convert is ok\r\n  }\r\n\r\n  function () external payable {\r\n    emit Deposit(msg.sender, msg.value);\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"owners_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_confirmAddrs\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"sigV\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"sigR\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"sigS\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwersLength\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownersArr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SimpleMultiSig","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000040000000000000000000000005b13592c8da41424a8c9fa44cf9f1d650c88ff220000000000000000000000006ad9ecaa8ad12dbc5609ddc26fed29a56d1167c9000000000000000000000000f1648230e7e4e424fd74aca03927dc9c74cbe1d8000000000000000000000000f3a343a8df046536837ee5d72beee70bed1d324d","Library":"","LicenseType":"None","SwarmSource":"bzzr://8a338c23a8dcb57ab0a9aef014ea47599ddc7af766dd538f7bb535b2a2f23187"}]}