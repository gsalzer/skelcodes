{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title Quotation data contract\r\n * @dev Verification of quotation contract\r\n */\r\ncontract NEST_3_OfferData {\r\n\r\n    mapping (address => bool) addressMapping;       //  Deployed quote contracts\r\n    NEST_2_Mapping mappingContract;                 //  Mapping contract\r\n    \r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    constructor(address map) public{\r\n        mappingContract = NEST_2_Mapping(map);                                                      \r\n    }\r\n    \r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    function changeMapping(address map) public onlyOwner {\r\n        mappingContract = NEST_2_Mapping(map);                                                    \r\n    }\r\n    \r\n    /**\r\n    * @dev Initialization method\r\n    * @param contractAddress Address of quotation contract\r\n    * @return existence of quotation contract\r\n    */\r\n    function checkContract(address contractAddress) public view returns (bool){\r\n        require(contractAddress != address(0x0));\r\n        return addressMapping[contractAddress];\r\n    }\r\n    \r\n    /**\r\n    * @dev Add quote contract address\r\n    * @param contractAddress Address of quotation contract\r\n    */\r\n    function addContractAddress(address contractAddress) public {\r\n        require(address(mappingContract.checkAddress(\"offerFactory\")) == msg.sender);\r\n        addressMapping[contractAddress] = true;\r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n        require(mappingContract.checkOwners(msg.sender) == true);\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Quotation factory\r\n * @dev Quotation mining\r\n */\r\ncontract NEST_3_OfferFactory {\r\n    using SafeMath for uint256;\r\n    using address_make_payable for address;\r\n    mapping(address => bool) tokenAllow;                //  Insured mining token\r\n    NEST_2_Mapping mappingContract;                     //  Mapping contract\r\n    NEST_3_OfferData dataContract;                      //  Data contract\r\n    NEST_2_OfferPrice offerPrice;                       //  Price contract\r\n    NEST_3_OrePoolLogic orePoolLogic;                   //  Mining contract\r\n    NEST_NodeAssignment NNcontract;                     //  NestNode contract\r\n    ERC20 nestToken;                                    //  nestToken\r\n    address abonusAddress;                              //  Dividend pool\r\n    address coderAddress;                               //  Developer address\r\n    uint256 miningETH = 10;                             //  Quotation mining service charge mining proportion, 10 thousandths\r\n    uint256 tranEth = 2;                                //  Service charge proportion of the bill of lading, 2 ‰\r\n    uint256 blockLimit = 25;                            //  Block interval upper limit\r\n    uint256 tranAddition = 2;                           //  Transaction bonus\r\n    uint256 coderAmount = 5;                            //  Developer ratio\r\n    uint256 NNAmount = 15;                              //  Guardian node proportion\r\n    uint256 otherAmount = 80;                           //  Distributable proportion\r\n    uint256 leastEth = 1 ether;                         //  Minimum offer eth\r\n    uint256 offerSpan = 1 ether;                        //  Quotation eth span\r\n    \r\n    //  log Personal asset contract\r\n    event offerTokenContractAddress(address contractAddress);    \r\n    //  log Quotation contract, token address, ETH quantity, erc20 quantity     \r\n    event offerContractAddress(address contractAddress, address tokenAddress, uint256 ethAmount, uint256 erc20Amount); \r\n    //  log Transaction, transaction initiator, transaction token address, transaction token quantity, purchase token address, purchase token quantity, traded quotation contract address, traded user address  \r\n    event offerTran(address tranSender, address tranToken, uint256 tranAmount,address otherToken, uint256 otherAmount, address tradedContract, address tradedOwner);        \r\n    \r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    constructor (address map) public {\r\n        mappingContract = NEST_2_Mapping(map);                                                      \r\n        offerPrice = NEST_2_OfferPrice(address(mappingContract.checkAddress(\"offerPrice\")));        \r\n        orePoolLogic = NEST_3_OrePoolLogic(address(mappingContract.checkAddress(\"miningCalculation\")));\r\n        abonusAddress = mappingContract.checkAddress(\"abonus\");\r\n        nestToken = ERC20(mappingContract.checkAddress(\"nest\"));                                        \r\n        NNcontract = NEST_NodeAssignment(address(mappingContract.checkAddress(\"nodeAssignment\")));      \r\n        coderAddress = mappingContract.checkAddress(\"coder\");\r\n        dataContract = NEST_3_OfferData(address(mappingContract.checkAddress(\"offerData\")));\r\n    }\r\n    \r\n    /**\r\n    * @dev Change mapping contract\r\n    * @param map Mapping contract address\r\n    */\r\n    function changeMapping(address map) public onlyOwner {\r\n        mappingContract = NEST_2_Mapping(map);                                                          \r\n        offerPrice = NEST_2_OfferPrice(address(mappingContract.checkAddress(\"offerPrice\")));            \r\n        orePoolLogic = NEST_3_OrePoolLogic(address(mappingContract.checkAddress(\"miningCalculation\")));\r\n        abonusAddress = mappingContract.checkAddress(\"abonus\");\r\n        nestToken = ERC20(mappingContract.checkAddress(\"nest\"));                                         \r\n        NNcontract = NEST_NodeAssignment(address(mappingContract.checkAddress(\"nodeAssignment\")));      \r\n        coderAddress = mappingContract.checkAddress(\"coder\");\r\n        dataContract = NEST_3_OfferData(address(mappingContract.checkAddress(\"offerData\")));\r\n    }\r\n    \r\n    /**\r\n    * @dev Quotation mining\r\n    * @param ethAmount ETH amount\r\n    * @param erc20Amount erc20 amount\r\n    * @param erc20Address erc20Token address\r\n    */\r\n    function offer(uint256 ethAmount, uint256 erc20Amount, address erc20Address) public payable {\r\n        require(address(msg.sender) == address(tx.origin));\r\n        uint256 ethMining = ethAmount.mul(miningETH).div(1000);\r\n        require(msg.value == ethAmount.add(ethMining));\r\n        require(tokenAllow[erc20Address]);\r\n        createOffer(ethAmount,erc20Amount,erc20Address,ethMining);\r\n        orePoolLogic.oreDrawing.value(ethMining)(erc20Address);\r\n    }\r\n    \r\n    /**\r\n    * @dev Generate quote\r\n    * @param ethAmount ETH amount\r\n    * @param erc20Amount erc20 amount\r\n    * @param erc20Address erc20Token address\r\n    * @param mining Mining Commission\r\n    */\r\n    function createOffer(uint256 ethAmount, uint256 erc20Amount, address erc20Address, uint256 mining) private {\r\n        require(ethAmount >= leastEth);\r\n        require(ethAmount % offerSpan == 0);\r\n        require(erc20Amount % (ethAmount.div(offerSpan)) == 0);\r\n        ERC20 token = ERC20(erc20Address);\r\n        require(token.balanceOf(address(msg.sender)) >= erc20Amount);\r\n        require(token.allowance(address(msg.sender), address(this)) >= erc20Amount);\r\n        NEST_3_OfferContract newContract = new NEST_3_OfferContract(ethAmount,erc20Amount,erc20Address,mining,address(mappingContract));\r\n        dataContract.addContractAddress(address(newContract));\r\n        emit offerContractAddress(address(newContract), address(erc20Address), ethAmount, erc20Amount);\r\n        token.transferFrom(address(msg.sender), address(newContract), erc20Amount);\r\n        newContract.offerAssets.value(ethAmount)();\r\n        offerPrice.addPrice(ethAmount,erc20Amount,erc20Address);\r\n    }\r\n    \r\n    /**\r\n    * @dev Take out quoted assets\r\n    * @param contractAddress Address of quotation contract\r\n    */\r\n    function turnOut(address contractAddress) public {\r\n        require(address(msg.sender) == address(tx.origin));\r\n        require(dataContract.checkContract(contractAddress));\r\n        NEST_3_OfferContract offerContract = NEST_3_OfferContract(contractAddress);\r\n        offerContract.turnOut();\r\n        uint256 miningEth = offerContract.checkServiceCharge();\r\n        uint256 blockNum = offerContract.checkBlockNum();\r\n        address tokenAddress = offerContract.checkTokenAddress();\r\n        if (miningEth > 0) {\r\n            uint256 miningAmount = orePoolLogic.mining(miningEth, blockNum, address(this),tokenAddress);\r\n            uint256 coder = miningAmount.mul(coderAmount).div(100);\r\n            uint256 NN = miningAmount.mul(NNAmount).div(100);\r\n            uint256 other = miningAmount.mul(otherAmount).div(100);\r\n            nestToken.transfer(address(tx.origin), other);\r\n            require(nestToken.approve(address(NNcontract), NN));\r\n            NNcontract.bookKeeping(NN);                                               \r\n            nestToken.transfer(coderAddress, coder);\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Transfer erc20 to buy eth\r\n    * @param ethAmount Offer ETH amount\r\n    * @param tokenAmount Offer erc20 amount\r\n    * @param contractAddress Address of quotation contract\r\n    * @param tranEthAmount ETH amount of transaction\r\n    * @param tranTokenAmount erc20 amount of transaction\r\n    * @param tranTokenAddress erc20Token address\r\n    */\r\n    function ethTran(uint256 ethAmount, uint256 tokenAmount, address contractAddress, uint256 tranEthAmount, uint256 tranTokenAmount, address tranTokenAddress) public payable {\r\n        require(address(msg.sender) == address(tx.origin));\r\n        require(dataContract.checkContract(contractAddress));\r\n        require(ethAmount >= tranEthAmount.mul(tranAddition));\r\n        uint256 serviceCharge = tranEthAmount.mul(tranEth).div(1000);\r\n        require(msg.value == ethAmount.add(tranEthAmount).add(serviceCharge));\r\n        require(tranEthAmount % offerSpan == 0);\r\n        createOffer(ethAmount,tokenAmount,tranTokenAddress,0);\r\n        NEST_3_OfferContract offerContract = NEST_3_OfferContract(contractAddress);\r\n        offerContract.changeOfferEth.value(tranEthAmount)(tranTokenAmount, tranTokenAddress);\r\n        offerPrice.changePrice(tranEthAmount,tranTokenAmount,tranTokenAddress,offerContract.checkBlockNum());\r\n        emit offerTran(address(tx.origin), address(0x0), tranEthAmount,address(tranTokenAddress),tranTokenAmount,contractAddress,offerContract.checkOwner());\r\n        repayEth(abonusAddress,serviceCharge);\r\n    }\r\n    \r\n    /**\r\n    * @dev Transfer eth to buy erc20\r\n    * @param ethAmount Offer ETH amount\r\n    * @param tokenAmount Offer erc20 amount\r\n    * @param contractAddress Address of quotation contract\r\n    * @param tranEthAmount ETH amount of transaction\r\n    * @param tranTokenAmount erc20 amount of transaction\r\n    * @param tranTokenAddress erc20Token address\r\n    */\r\n    function ercTran(uint256 ethAmount, uint256 tokenAmount, address contractAddress, uint256 tranEthAmount, uint256 tranTokenAmount, address tranTokenAddress) public payable {\r\n        require(address(msg.sender) == address(tx.origin));\r\n        require(dataContract.checkContract(contractAddress));\r\n        require(ethAmount >= tranEthAmount.mul(tranAddition));\r\n        uint256 serviceCharge = tranEthAmount.mul(tranEth).div(1000);\r\n        require(msg.value == ethAmount.add(serviceCharge));\r\n        require(tranEthAmount % offerSpan == 0);\r\n        createOffer(ethAmount,tokenAmount,tranTokenAddress,0);\r\n        NEST_3_OfferContract offerContract = NEST_3_OfferContract(contractAddress);\r\n        ERC20 token = ERC20(tranTokenAddress);\r\n        require(token.balanceOf(address(msg.sender)) >= tranTokenAmount);\r\n        require(token.allowance(address(msg.sender), address(this)) >= tranTokenAmount);\r\n        token.transferFrom(address(msg.sender), address(offerContract), tranTokenAmount);\r\n        offerContract.changeOfferErc(tranEthAmount,tranTokenAmount, tranTokenAddress);\r\n        offerPrice.changePrice(tranEthAmount,tranTokenAmount,tranTokenAddress,offerContract.checkBlockNum());\r\n        emit offerTran(address(tx.origin),address(tranTokenAddress),tranTokenAmount, address(0x0), tranEthAmount,contractAddress,offerContract.checkOwner());\r\n        repayEth(abonusAddress,serviceCharge);\r\n    }\r\n    \r\n    function repayEth(address accountAddress, uint256 asset) private {\r\n        address payable addr = accountAddress.make_payable();\r\n        addr.transfer(asset);\r\n    }\r\n\r\n    //  View block interval upper limit\r\n    function checkBlockLimit() public view returns(uint256) {\r\n        return blockLimit;\r\n    }\r\n\r\n    //  View quotation handling fee\r\n    function checkMiningETH() public view returns (uint256) {\r\n        return miningETH;\r\n    }\r\n\r\n    //  View transaction charges\r\n    function checkTranEth() public view returns (uint256) {\r\n        return tranEth;\r\n    }\r\n\r\n    //  View whether token allows mining\r\n    function checkTokenAllow(address token) public view returns(bool) {\r\n        return tokenAllow[token];\r\n    }\r\n\r\n    //  View transaction bonus\r\n    function checkTranAddition() public view returns(uint256) {\r\n        return tranAddition;\r\n    }\r\n\r\n    //  View development allocation proportion\r\n    function checkCoderAmount() public view returns(uint256) {\r\n        return coderAmount;\r\n    }\r\n\r\n    //  View the allocation proportion of guardian nodes\r\n    function checkNNAmount() public view returns(uint256) {\r\n        return NNAmount;\r\n    }\r\n\r\n    //  View user assignable proportion\r\n    function checkOtherAmount() public view returns(uint256) {\r\n        return otherAmount;\r\n    }\r\n\r\n    //  View minimum quote eth\r\n    function checkleastEth() public view returns(uint256) {\r\n        return leastEth;\r\n    }\r\n\r\n    //  View quote eth span\r\n    function checkOfferSpan() public view returns(uint256) {\r\n        return offerSpan;\r\n    }\r\n\r\n    function changeMiningETH(uint256 num) public onlyOwner {\r\n        miningETH = num;\r\n    }\r\n\r\n    function changeTranEth(uint256 num) public onlyOwner {\r\n        tranEth = num;\r\n    }\r\n\r\n    function changeBlockLimit(uint256 num) public onlyOwner {\r\n        blockLimit = num;\r\n    }\r\n\r\n    function changeTokenAllow(address token, bool allow) public onlyOwner {\r\n        tokenAllow[token] = allow;\r\n    }\r\n\r\n    function changeTranAddition(uint256 num) public onlyOwner {\r\n        require(num > 0);\r\n        tranAddition = num;\r\n    }\r\n\r\n    function changeInitialRatio(uint256 coderNum, uint256 NNNum, uint256 otherNum) public onlyOwner {\r\n        require(coderNum > 0 && coderNum <= 5);\r\n        require(NNNum > 0 && coderNum <= 15);\r\n        require(coderNum.add(NNNum).add(otherNum) == 100);\r\n        coderAmount = coderNum;\r\n        NNAmount = NNNum;\r\n        otherAmount = otherNum;\r\n    }\r\n\r\n    function changeLeastEth(uint256 num) public onlyOwner {\r\n        require(num > 0);\r\n        leastEth = num;\r\n    }\r\n\r\n    function changeOfferSpan(uint256 num) public onlyOwner {\r\n        require(num > 0);\r\n        offerSpan = num;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(mappingContract.checkOwners(msg.sender) == true);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Quotation contract\r\n */\r\ncontract NEST_3_OfferContract {\r\n    using SafeMath for uint256;\r\n    using address_make_payable for address;\r\n    address owner;                              //  Owner\r\n    uint256 ethAmount;                          //  ETH amount\r\n    uint256 tokenAmount;                        //  Token amount\r\n    address tokenAddress;                       //  Token address\r\n    uint256 dealEthAmount;                      //  Transaction eth quantity\r\n    uint256 dealTokenAmount;                    //  Transaction token quantity\r\n    uint256 blockNum;                           //  This quotation block\r\n    uint256 serviceCharge;                      //  Service Charge\r\n    bool hadReceive = false;                    //  Received\r\n    NEST_2_Mapping mappingContract;             //  Mapping contract\r\n    NEST_3_OfferFactory offerFactory;           //  Quotation factory\r\n    \r\n    /**\r\n    * @dev initialization\r\n    * @param _ethAmount Offer ETH amount\r\n    * @param _tokenAmount Offer erc20 amount\r\n    * @param _tokenAddress Token address\r\n    * @param miningEth Service Charge\r\n    * @param map Mapping contract\r\n    */\r\n    constructor (uint256 _ethAmount, uint256 _tokenAmount, address _tokenAddress, uint256 miningEth,address map) public {\r\n        mappingContract = NEST_2_Mapping(address(map));\r\n        offerFactory = NEST_3_OfferFactory(address(mappingContract.checkAddress(\"offerFactory\")));\r\n        require(msg.sender == address(offerFactory));\r\n        owner = address(tx.origin);\r\n        ethAmount = _ethAmount;\r\n        tokenAmount = _tokenAmount;\r\n        tokenAddress = _tokenAddress;\r\n        dealEthAmount = _ethAmount;\r\n        dealTokenAmount = _tokenAmount;\r\n        serviceCharge = miningEth;\r\n        blockNum = block.number;\r\n    }\r\n    \r\n    function offerAssets() public payable onlyFactory {\r\n        require(ERC20(tokenAddress).balanceOf(address(this)) == tokenAmount);\r\n    }\r\n    \r\n    function changeOfferEth(uint256 _tokenAmount, address _tokenAddress) public payable onlyFactory {\r\n       require(checkContractState() == 0);\r\n       require(dealEthAmount >= msg.value);\r\n       require(dealTokenAmount >= _tokenAmount);\r\n       require(_tokenAddress == tokenAddress);\r\n       require(_tokenAmount == dealTokenAmount.mul(msg.value).div(dealEthAmount));\r\n       ERC20(tokenAddress).transfer(address(tx.origin), _tokenAmount);\r\n       dealEthAmount = dealEthAmount.sub(msg.value);\r\n       dealTokenAmount = dealTokenAmount.sub(_tokenAmount);\r\n    }\r\n    \r\n    function changeOfferErc(uint256 _ethAmount, uint256 _tokenAmount, address _tokenAddress) public onlyFactory {\r\n       require(checkContractState() == 0);\r\n       require(dealEthAmount >= _ethAmount);\r\n       require(dealTokenAmount >= _tokenAmount);\r\n       require(_tokenAddress == tokenAddress);\r\n       require(_tokenAmount == dealTokenAmount.mul(_ethAmount).div(dealEthAmount));\r\n       repayEth(address(tx.origin), _ethAmount);\r\n       dealEthAmount = dealEthAmount.sub(_ethAmount);\r\n       dealTokenAmount = dealTokenAmount.sub(_tokenAmount);\r\n    }\r\n   \r\n    function repayEth(address accountAddress, uint256 asset) private {\r\n        address payable addr = accountAddress.make_payable();\r\n        addr.transfer(asset);\r\n    }\r\n\r\n    function turnOut() public onlyFactory {\r\n        require(address(tx.origin) == owner);\r\n        require(checkContractState() == 1);\r\n        require(hadReceive == false);\r\n        uint256 ethAssets;\r\n        uint256 tokenAssets;\r\n        (ethAssets, tokenAssets,) = checkAssets();\r\n        repayEth(owner, ethAssets);\r\n        ERC20(address(tokenAddress)).transfer(owner, tokenAssets);\r\n        hadReceive = true;\r\n    }\r\n    \r\n    function checkContractState() public view returns (uint256) {\r\n        if (block.number.sub(blockNum) > offerFactory.checkBlockLimit()) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function checkDealAmount() public view returns(uint256 leftEth, uint256 leftErc20, address erc20Address) {\r\n        return (dealEthAmount, dealTokenAmount, tokenAddress);\r\n    }\r\n\r\n    function checkPrice() public view returns(uint256 _ethAmount, uint256 _tokenAmount, address _tokenAddress) {\r\n        return (ethAmount, tokenAmount, tokenAddress);\r\n    }\r\n\r\n    function checkAssets() public view returns(uint256 _ethAmount, uint256 _tokenAmount, address _tokenAddress) {\r\n        return (address(this).balance, ERC20(address(tokenAddress)).balanceOf(address(this)), address(tokenAddress));\r\n    }\r\n\r\n    function checkTokenAddress() public view returns(address){\r\n        return tokenAddress;\r\n    }\r\n\r\n    function checkOwner() public view returns(address) {\r\n        return owner;\r\n    }\r\n\r\n    function checkBlockNum() public view returns (uint256) {\r\n        return blockNum;\r\n    }\r\n\r\n    function checkServiceCharge() public view returns(uint256) {\r\n        return serviceCharge;\r\n    }\r\n\r\n    function checkHadReceive() public view returns(bool) {\r\n        return hadReceive;\r\n    }\r\n    \r\n    modifier onlyFactory(){\r\n        require(msg.sender == address(offerFactory));\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Price contract\r\n */\r\ncontract NEST_2_OfferPrice{\r\n    using SafeMath for uint256;\r\n    using address_make_payable for address;\r\n    NEST_2_Mapping mappingContract;                                 //  Mapping contract\r\n    NEST_3_OfferFactory offerFactory;                               //  Quotation factory contract\r\n    struct Price {                                                  //  Price structure\r\n        uint256 ethAmount;                                          //  ETH amount\r\n        uint256 erc20Amount;                                        //  erc20 amount\r\n        uint256 blockNum;                                           //  Last quotation block number, current price block\r\n    }\r\n    struct addressPrice {                                           //  Token price information structure\r\n        mapping(uint256 => Price) tokenPrice;                       //  Token price, Block number = > price\r\n        Price latestPrice;                                          //  Latest price\r\n    }\r\n    mapping(address => addressPrice) tokenInfo;                     //  Token price information\r\n    uint256 priceCost = 0.01 ether;                                 //  Price charge\r\n    uint256 priceCostUser = 2;                                      //  Price expense user proportion\r\n    uint256 priceCostAbonus = 8;                                    //  Proportion of price expense dividend pool\r\n    mapping(uint256 => mapping(address => address)) blockAddress;   //  Last person of block quotation\r\n    address abonusAddress;                                          //  Dividend pool\r\n    \r\n    //  Real time price toekn, ETH quantity, erc20 quantity\r\n    event nowTokenPrice(address a, uint256 b, uint256 c);\r\n\r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    constructor (address map) public {\r\n        mappingContract = NEST_2_Mapping(address(map));\r\n        offerFactory = NEST_3_OfferFactory(address(mappingContract.checkAddress(\"offerFactory\")));\r\n        abonusAddress = address(mappingContract.checkAddress(\"abonus\"));\r\n    }\r\n    \r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    function changeMapping(address map) public onlyOwner {\r\n        mappingContract = NEST_2_Mapping(map);                                                      \r\n        offerFactory = NEST_3_OfferFactory(address(mappingContract.checkAddress(\"offerFactory\")));\r\n        abonusAddress = address(mappingContract.checkAddress(\"abonus\"));\r\n    }\r\n    \r\n    /**\r\n    * @dev Increase price\r\n    * @param _ethAmount ETH amount\r\n    * @param _tokenAmount Token amount\r\n    * @param _tokenAddress Token address\r\n    */\r\n    function addPrice(uint256 _ethAmount, uint256 _tokenAmount, address _tokenAddress) public onlyFactory {\r\n        uint256 blockLimit = offerFactory.checkBlockLimit();                                        \r\n        uint256 middleBlock = block.number.sub(blockLimit);                                         \r\n        \r\n        uint256 priceBlock = tokenInfo[_tokenAddress].latestPrice.blockNum;                         \r\n        while(priceBlock >= middleBlock || tokenInfo[_tokenAddress].tokenPrice[priceBlock].ethAmount == 0){                         \r\n            priceBlock = tokenInfo[_tokenAddress].tokenPrice[priceBlock].blockNum;\r\n            if (priceBlock == 0) {\r\n                break;\r\n            }\r\n        }\r\n        tokenInfo[_tokenAddress].latestPrice.ethAmount = tokenInfo[_tokenAddress].tokenPrice[priceBlock].ethAmount;\r\n        tokenInfo[_tokenAddress].latestPrice.erc20Amount = tokenInfo[_tokenAddress].tokenPrice[priceBlock].erc20Amount;\r\n        tokenInfo[_tokenAddress].tokenPrice[block.number].ethAmount = tokenInfo[_tokenAddress].tokenPrice[block.number].ethAmount.add(_ethAmount);                  //  增加eth数\r\n        tokenInfo[_tokenAddress].tokenPrice[block.number].erc20Amount = tokenInfo[_tokenAddress].tokenPrice[block.number].erc20Amount.add(_tokenAmount);            //  增加ercrc20数\r\n        if (tokenInfo[_tokenAddress].latestPrice.blockNum != block.number) {\r\n            tokenInfo[_tokenAddress].tokenPrice[block.number].blockNum = tokenInfo[_tokenAddress].latestPrice.blockNum;                                                 //  记录上一次报价区块号\r\n            tokenInfo[_tokenAddress].latestPrice.blockNum = block.number;                                                                                               //  记录本次报价区块号\r\n        }\r\n\r\n        blockAddress[block.number][_tokenAddress] = address(tx.origin);\r\n        \r\n        emit nowTokenPrice(_tokenAddress,tokenInfo[_tokenAddress].latestPrice.ethAmount, tokenInfo[_tokenAddress].latestPrice.erc20Amount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Update price\r\n    * @param _tokenAddress Token address\r\n    * @return ethAmount ETH amount\r\n    * @return erc20Amount Token amount\r\n    * @return token Token address\r\n    */\r\n    function updateAndCheckPriceNow(address _tokenAddress) public payable returns(uint256 ethAmount, uint256 erc20Amount, address token) {\r\n        if (msg.sender != tx.origin && msg.sender != address(offerFactory)) {\r\n            require(msg.value == priceCost);\r\n        }\r\n        uint256 blockLimit = offerFactory.checkBlockLimit();                                       \r\n        uint256 middleBlock = block.number.sub(blockLimit);                                   \r\n        \r\n        uint256 priceBlock = tokenInfo[_tokenAddress].latestPrice.blockNum;                     \r\n        while(priceBlock >= middleBlock || tokenInfo[_tokenAddress].tokenPrice[priceBlock].ethAmount == 0){                         \r\n            priceBlock = tokenInfo[_tokenAddress].tokenPrice[priceBlock].blockNum;\r\n            if (priceBlock == 0) {\r\n                break;\r\n            }\r\n        }\r\n        tokenInfo[_tokenAddress].latestPrice.ethAmount = tokenInfo[_tokenAddress].tokenPrice[priceBlock].ethAmount;\r\n        tokenInfo[_tokenAddress].latestPrice.erc20Amount = tokenInfo[_tokenAddress].tokenPrice[priceBlock].erc20Amount;\r\n        if (msg.value > 0) {\r\n            repayEth(abonusAddress, msg.value.mul(priceCostAbonus).div(10));\r\n            repayEth(blockAddress[priceBlock][_tokenAddress], msg.value.mul(priceCostUser).div(10));\r\n        }\r\n        return (tokenInfo[_tokenAddress].latestPrice.ethAmount,tokenInfo[_tokenAddress].latestPrice.erc20Amount, _tokenAddress);\r\n    }\r\n    \r\n    function repayEth(address accountAddress, uint256 asset) private {\r\n        address payable addr = accountAddress.make_payable();\r\n        addr.transfer(asset);\r\n    }\r\n    \r\n    /**\r\n    * @dev Change price\r\n    * @param _ethAmount ETH amount\r\n    * @param _tokenAmount Token amount\r\n    * @param _tokenAddress Token address\r\n    * @param blockNum Block number\r\n    */\r\n    function changePrice(uint256 _ethAmount, uint256 _tokenAmount, address _tokenAddress, uint256 blockNum) public onlyFactory {\r\n        tokenInfo[_tokenAddress].tokenPrice[blockNum].ethAmount = tokenInfo[_tokenAddress].tokenPrice[blockNum].ethAmount.sub(_ethAmount);\r\n        tokenInfo[_tokenAddress].tokenPrice[blockNum].erc20Amount = tokenInfo[_tokenAddress].tokenPrice[blockNum].erc20Amount.sub(_tokenAmount);\r\n    }\r\n    \r\n    function checkPriceForBlock(address tokenAddress, uint256 blockNum) public view returns (uint256 ethAmount, uint256 erc20Amount, uint256 frontBlock) {\r\n        require(msg.sender == tx.origin);\r\n        return (tokenInfo[tokenAddress].tokenPrice[blockNum].ethAmount, tokenInfo[tokenAddress].tokenPrice[blockNum].erc20Amount,tokenInfo[tokenAddress].tokenPrice[blockNum].blockNum);\r\n    }    \r\n\r\n    function checkPriceNow(address tokenAddress) public view returns (uint256 ethAmount, uint256 erc20Amount,uint256 frontBlock) {\r\n        require(msg.sender == tx.origin);\r\n        return (tokenInfo[tokenAddress].latestPrice.ethAmount,tokenInfo[tokenAddress].latestPrice.erc20Amount,tokenInfo[tokenAddress].latestPrice.blockNum);\r\n    }\r\n\r\n    function checkPriceHistoricalAverage(address tokenAddress, uint256 blockNum) public view returns (uint256) {\r\n        require(msg.sender == tx.origin);\r\n        uint256 blockLimit = offerFactory.checkBlockLimit();                                       \r\n        uint256 middleBlock = block.number.sub(blockLimit);                                         \r\n        uint256 priceBlock = tokenInfo[tokenAddress].latestPrice.blockNum;                         \r\n        while(priceBlock >= middleBlock){                         \r\n            priceBlock = tokenInfo[tokenAddress].tokenPrice[priceBlock].blockNum;\r\n            if (priceBlock == 0) {\r\n                break;\r\n            }\r\n        }\r\n        uint256 frontBlock = priceBlock;\r\n        uint256 price = 0;\r\n        uint256 priceTimes = 0;\r\n        while(frontBlock >= blockNum){   \r\n            uint256 erc20Amount = tokenInfo[tokenAddress].tokenPrice[frontBlock].erc20Amount;\r\n            uint256 ethAmount = tokenInfo[tokenAddress].tokenPrice[frontBlock].ethAmount;\r\n            price = price.add(erc20Amount.mul(1 ether).div(ethAmount));\r\n            priceTimes = priceTimes.add(1);\r\n            frontBlock = tokenInfo[tokenAddress].tokenPrice[frontBlock].blockNum;\r\n            if (frontBlock == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return price.div(priceTimes);\r\n    }\r\n    \r\n    function checkPriceForBlockPay(address tokenAddress, uint256 blockNum) public payable returns (uint256 ethAmount, uint256 erc20Amount, uint256 frontBlock) {\r\n        require(msg.value == priceCost);\r\n        require(tokenInfo[tokenAddress].tokenPrice[blockNum].ethAmount != 0);\r\n        repayEth(abonusAddress, msg.value.mul(priceCostAbonus).div(10));\r\n        repayEth(blockAddress[blockNum][tokenAddress], msg.value.mul(priceCostUser).div(10));\r\n        return (tokenInfo[tokenAddress].tokenPrice[blockNum].ethAmount, tokenInfo[tokenAddress].tokenPrice[blockNum].erc20Amount,tokenInfo[tokenAddress].tokenPrice[blockNum].blockNum);\r\n    }\r\n    \r\n    function checkPriceHistoricalAveragePay(address tokenAddress, uint256 blockNum) public payable returns (uint256) {\r\n        require(msg.value == priceCost);\r\n        uint256 blockLimit = offerFactory.checkBlockLimit();                                        \r\n        uint256 middleBlock = block.number.sub(blockLimit);                                         \r\n        uint256 priceBlock = tokenInfo[tokenAddress].latestPrice.blockNum;                          \r\n        while(priceBlock >= middleBlock){                         \r\n            priceBlock = tokenInfo[tokenAddress].tokenPrice[priceBlock].blockNum;\r\n            if (priceBlock == 0) {\r\n                break;\r\n            }\r\n        }\r\n        repayEth(abonusAddress, msg.value.mul(priceCostAbonus).div(10));\r\n        repayEth(blockAddress[priceBlock][tokenAddress], msg.value.mul(priceCostUser).div(10));\r\n        uint256 frontBlock = priceBlock;\r\n        uint256 price = 0;\r\n        uint256 priceTimes = 0;\r\n        while(frontBlock >= blockNum){   \r\n            uint256 erc20Amount = tokenInfo[tokenAddress].tokenPrice[frontBlock].erc20Amount;\r\n            uint256 ethAmount = tokenInfo[tokenAddress].tokenPrice[frontBlock].ethAmount;\r\n            price = price.add(erc20Amount.mul(1 ether).div(ethAmount));\r\n            priceTimes = priceTimes.add(1);\r\n            frontBlock = tokenInfo[tokenAddress].tokenPrice[frontBlock].blockNum;\r\n            if (frontBlock == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return price.div(priceTimes);\r\n    }\r\n\r\n    \r\n    function checkLatestBlock(address token) public view returns(uint256) {\r\n        return tokenInfo[token].latestPrice.blockNum;\r\n    }\r\n    \r\n    function changePriceCost(uint256 amount) public onlyOwner {\r\n        require(amount > 0);\r\n        priceCost = amount;\r\n    }\r\n     \r\n    function checkPriceCost() public view returns(uint256) {\r\n        return priceCost;\r\n    }\r\n    \r\n    function changePriceCostProportion(uint256 user, uint256 abonus) public onlyOwner {\r\n        require(user.add(abonus) == 10);\r\n        priceCostUser = user;\r\n        priceCostAbonus = abonus;\r\n    }\r\n    \r\n    function checkPriceCostProportion() public view returns(uint256 user, uint256 abonus) {\r\n        return (priceCostUser, priceCostAbonus);\r\n    }\r\n    \r\n    modifier onlyFactory(){\r\n        require(msg.sender == address(mappingContract.checkAddress(\"offerFactory\")));\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n        require(mappingContract.checkOwners(msg.sender) == true);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract NEST_NodeAssignment {\r\n    function bookKeeping(uint256 amount) public;\r\n}\r\n\r\ncontract NEST_3_OrePoolLogic {\r\n    function oreDrawing(address token) public payable;\r\n    function mining(uint256 amount, uint256 blockNum, address target, address token) public returns(uint256);\r\n}\r\n\r\ncontract NEST_2_Mapping {\r\n    function checkAddress(string memory name) public view returns (address contractAddress);\r\n    function checkOwners(address man) public view returns (bool);\r\n}\r\n\r\nlibrary address_make_payable {\r\n   function make_payable(address x) internal pure returns (address payable) {\r\n      return address(uint160(x));\r\n   }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf( address who ) public view returns (uint value);\r\n    function allowance( address owner, address spender ) public view returns (uint _allowance);\r\n\r\n    function transfer( address to, uint256 value) external;\r\n    function transferFrom( address from, address to, uint value) public;\r\n    function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"map\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"}],\"name\":\"offerContractAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"offerTokenContractAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tranSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tranToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tranAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"otherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tradedContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tradedOwner\",\"type\":\"address\"}],\"name\":\"offerTran\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeBlockLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coderNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NNNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"otherNum\",\"type\":\"uint256\"}],\"name\":\"changeInitialRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeLeastEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"map\",\"type\":\"address\"}],\"name\":\"changeMapping\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeMiningETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeOfferSpan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"changeTokenAllow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeTranAddition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeTranEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkBlockLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkCoderAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkMiningETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkNNAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkOfferSpan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkOtherAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"checkTokenAllow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkTranAddition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkTranEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkleastEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tranEthAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tranTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tranTokenAddress\",\"type\":\"address\"}],\"name\":\"ercTran\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tranEthAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tranTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tranTokenAddress\",\"type\":\"address\"}],\"name\":\"ethTran\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"}],\"name\":\"offer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"turnOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NEST_3_OfferFactory","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005e7db2ffc5b2c7c47103e4f21c702bc402603fbf","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://309f645fe0b005a8a312fef5b74188b55d08b69832686b02c84d6b864a41da0a"}]}