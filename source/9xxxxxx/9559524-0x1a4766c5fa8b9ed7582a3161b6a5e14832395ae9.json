{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity 0.4.25;\r\n\r\n    library DappDatasets {\r\n\r\n        struct Player {\r\n\r\n            uint withdrawalAmount;\r\n\r\n            uint wallet;\r\n\r\n            uint fomoTotalRevenue;\r\n\r\n            uint lotteryTotalRevenue;\r\n\r\n            uint dynamicIncome;\r\n\r\n            uint rechargeAmount;\r\n\r\n            uint staticIncome;\r\n\r\n            uint shareholderLevel;\r\n\r\n            uint underUmbrellaLevel;\r\n\r\n            uint subbordinateTotalPerformance;\r\n\r\n            bool isExist;\r\n\r\n            bool superior;\r\n\r\n            address superiorAddr;\r\n\r\n            address[] subordinates;\r\n        }\r\n\r\n        struct Fomo {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint endTime;\r\n\r\n            uint fomoPrizePool;\r\n\r\n            address[] participant;\r\n        }\r\n\r\n        struct Lottery {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint lotteryPool;\r\n\r\n            uint unopenedBonus;\r\n\r\n            uint number;\r\n\r\n            uint todayAmountTotal;\r\n\r\n            uint totayLotteryAmountTotal;\r\n\r\n            uint grandPrizeNum;\r\n\r\n            uint[] firstPrizeNum;\r\n\r\n            uint[] secondPrizeNum;\r\n\r\n            uint[] thirdPrizeNum;\r\n\r\n            mapping(address => uint[]) lotteryMap;\r\n\r\n            mapping(uint => address) numToAddr;\r\n\r\n            mapping(address => uint) personalAmount;\r\n\r\n            mapping(uint => uint) awardAmount;\r\n        }\r\n\r\n\r\n        function getNowTime() internal view returns(uint) {\r\n            return now;\r\n        }\r\n\r\n        function rand(uint256 _length, uint num) internal view returns(uint256) {\r\n            uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, now - num)));\r\n            return random%_length;\r\n        }\r\n        \r\n        function returnArray(uint len, uint range, uint number) internal view returns(uint[]) {\r\n            uint[] memory numberArray = new uint[](len);\r\n            uint i = 0;\r\n            while(true) {\r\n                number = number + 9;\r\n                uint temp = rand(range, number);\r\n                if(temp == 0) {\r\n                    continue;\r\n                }\r\n                numberArray[i] = temp;\r\n                i++;\r\n                if(i == len) {\r\n                    break;\r\n                }\r\n            }\r\n            return numberArray;\r\n        }\r\n    }\r\n\r\npragma solidity 0.4.25;\r\n\r\n    contract GODGame {\r\n\r\n        address owner;\r\n\r\n        address technologyAddr;\r\n\r\n        address themisAddr;\r\n\r\n        address lotteryAddr;\r\n\r\n        address[] allPlayer;\r\n\r\n        address[] temp = new address[](0);\r\n\r\n        struct GlobalShareholder {\r\n\r\n            address[] shareholdersV1;\r\n\r\n            address[] shareholdersV2;\r\n\r\n            address[] shareholdersV3;\r\n\r\n            address[] shareholdersV4;\r\n        }\r\n\r\n        uint fomoSession;\r\n\r\n        uint depositBalance;\r\n\r\n        GODThemis themis;\r\n\r\n        GODToken godToken;\r\n\r\n        TetherToken tether;\r\n\r\n        GODLottery lottery;\r\n\r\n        mapping(uint => DappDatasets.Fomo) fomoGame;  \r\n\r\n        mapping(address => DappDatasets.Player) playerMap;\r\n\r\n        mapping(address => GlobalShareholder) globalShareholder;\r\n\r\n\r\n        constructor(\r\n                address _owner,\r\n                address _tetherAddr,\r\n                address _godAddr,\r\n                address _themisAddr,\r\n                address _lotteryAddr,\r\n                address _technologyAddr\r\n        )  public {\r\n            owner = _owner;\r\n            tether = TetherToken(_tetherAddr);\r\n            godToken = GODToken(_godAddr);\r\n            themis = GODThemis(_themisAddr);\r\n            lotteryAddr = _lotteryAddr;\r\n            lottery = GODLottery(_lotteryAddr);\r\n            DappDatasets.Player memory player = DappDatasets.Player(\r\n                {\r\n                    withdrawalAmount : 0,\r\n                    wallet : 0,\r\n                    fomoTotalRevenue : 0,\r\n                    lotteryTotalRevenue : 0,\r\n                    dynamicIncome : 0,\r\n                    rechargeAmount : 0,\r\n                    staticIncome : 0,\r\n                    shareholderLevel : 0,\r\n                    underUmbrellaLevel : 0,\r\n                    subbordinateTotalPerformance : 0,\r\n                    isExist : true,\r\n                    superior : false,\r\n                    superiorAddr : address(0x0),\r\n                    subordinates : temp\r\n                }\r\n            );\r\n            playerMap[owner] = player;\r\n            allPlayer.push(owner);\r\n            technologyAddr = _technologyAddr;\r\n            themisAddr = _themisAddr;\r\n            if(owner != technologyAddr) {\r\n                playerMap[technologyAddr] = player;\r\n                allPlayer.push(technologyAddr);\r\n            }\r\n            globalShareholder[owner] = GlobalShareholder(\r\n                {\r\n                    shareholdersV1 : temp,\r\n                    shareholdersV2 : temp,\r\n                    shareholdersV3 : temp,\r\n                    shareholdersV4 : temp\r\n                }\r\n            );\r\n        }\r\n\r\n        function() public payable {\r\n            withdrawImpl(msg.sender);\r\n        }\r\n\r\n        function redeemGod(uint usdtVal, address superiorAddr) external {\r\n            register(msg.sender, superiorAddr);\r\n            lottery.exchange(usdtVal, msg.sender);\r\n            tether.transferFrom(msg.sender, this, usdtVal);\r\n        }\r\n\r\n        function buyLotto(uint usdtVal, address superiorAddr) external {\r\n            register(msg.sender, superiorAddr);\r\n            lottery.participateLottery(usdtVal, msg.sender);\r\n            tether.transferFrom(msg.sender, this, usdtVal);\r\n        }\r\n\r\n        function interactive(address addr, uint amount) internal {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            if(player.subordinates.length > 0) {\r\n                uint length = player.subordinates.length;\r\n                if(player.subordinates.length > 30) {\r\n                    length = 30;\r\n                }\r\n                uint splitEqually = SafeMath.div(amount, length);\r\n                for(uint i = 0; i < length; i++) {\r\n                    playerMap[player.subordinates[i]].wallet = SafeMath.add(\r\n                        playerMap[player.subordinates[i]].wallet,\r\n                        splitEqually\r\n                    );\r\n                    playerMap[player.subordinates[i]].dynamicIncome = SafeMath.add(\r\n                        playerMap[player.subordinates[i]].dynamicIncome,\r\n                        splitEqually\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        function withdrawImpl(address addr) internal {\r\n            require(owner != addr, \"admin no allow withdraw\");\r\n            require(playerMap[addr].wallet > 0, \"Insufficient wallet balance\");\r\n            require(lottery.getLotteryIsEnd() == false,\"Game over\");\r\n\r\n            uint number = 0;\r\n            uint motionAndStaticAmount = SafeMath.add(playerMap[addr].staticIncome, playerMap[addr].dynamicIncome);\r\n            uint withdrawableBalance = SafeMath.mul(playerMap[addr].rechargeAmount, 3);\r\n\r\n            if(motionAndStaticAmount > withdrawableBalance) {\r\n                number = SafeMath.sub(motionAndStaticAmount, withdrawableBalance);\r\n            }\r\n            uint amount = SafeMath.sub(playerMap[addr].wallet, number);\r\n            uint value = amount;\r\n            if(amount > 1000 * 10 ** 6) {\r\n                value = 1000 * 10 ** 6;\r\n            }\r\n            playerMap[addr].wallet = SafeMath.sub(playerMap[addr].wallet, value);\r\n            playerMap[addr].withdrawalAmount = SafeMath.add(playerMap[addr].withdrawalAmount, value);\r\n\r\n            uint lotteryPool = SafeMath.div(value, 10);\r\n            uint count = SafeMath.div(lotteryPool, 10 ** 6);\r\n            lottery.getLottoCodeByGameAddr(addr, count);\r\n            tether.transfer(addr, SafeMath.sub(value, count * 10 ** 6));\r\n        }\r\n\r\n        function withdraw() external {\r\n            withdrawImpl(msg.sender);\r\n        }\r\n\r\n        function startFomoGame() external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            fomoSession++;\r\n            if(fomoSession > 1) {\r\n                require(fomoGame[fomoSession - 1].whetherToEnd == true, \"The game is not over yet\");\r\n            }\r\n            fomoGame[fomoSession] = DappDatasets.Fomo(\r\n                {\r\n                    whetherToEnd : false,\r\n                    endTime : now + 48 * 60 * 60,\r\n                    fomoPrizePool : 0,\r\n                    participant : temp\r\n                }\r\n            );\r\n        }\r\n\r\n        function participateFomo(uint usdtVal, address superiorAddr) external {\r\n            require(usdtVal >= 10 ** 6, \"Redeem at least 1USDT\");\r\n            require(fomoSession > 0, \"fomo game has not started yet\");\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            require(fomo.whetherToEnd == false,\"fomo game has not started yet\");\r\n            require(lottery.lotterySession() > 0, \"Big Lotto game has not started yet\");\r\n            require(lottery.getLotteryIsEnd() == false,\"Big Lotto game has not started yet\");\r\n            register(msg.sender, superiorAddr);\r\n            depositBalance = usdtVal;\r\n\r\n            uint needGOD = godToken.calculationNeedGOD(usdtVal);\r\n            godToken.burn(msg.sender, needGOD);\r\n\r\n            fomo.participant.push(msg.sender);\r\n\r\n            DappDatasets.Player storage player = playerMap[msg.sender];\r\n            player.rechargeAmount = SafeMath.add(player.rechargeAmount, usdtVal);\r\n\r\n            uint lotteryPool = SafeMath.div(usdtVal, 10);\r\n            depositBalance = SafeMath.sub(depositBalance, lotteryPool);\r\n            lottery.updateLotteryPoolAndTodayAmountTotal(usdtVal, lotteryPool);\r\n\r\n            increasePerformance(msg.sender, usdtVal);\r\n\r\n            fomoPenny(msg.sender, usdtVal);\r\n\r\n            uint fomoPool = SafeMath.div(SafeMath.mul(usdtVal, 8), 100);\r\n            depositBalance = SafeMath.sub(depositBalance, fomoPool);\r\n\r\n            if(SafeMath.add(fomo.fomoPrizePool, fomoPool) > 2100 * 10 ** 4 * 10 ** 6 ) {\r\n                if(fomo.fomoPrizePool < 2100 * 10 ** 4 * 10 ** 6) {\r\n                    uint n = SafeMath.sub(2100 * 10 ** 4 * 10 ** 6, fomo.fomoPrizePool);\r\n                    fomo.fomoPrizePool = SafeMath.add(fomo.fomoPrizePool, n);\r\n                    uint issue = SafeMath.sub(fomoPool, n);\r\n                    releaseStaticPoolAndV4(issue);\r\n                }else {\r\n                    releaseStaticPoolAndV4(fomoPool);\r\n                }\r\n            }else {\r\n                fomo.fomoPrizePool = SafeMath.add(fomo.fomoPrizePool, fomoPool);\r\n            }\r\n\r\n            timeExtended(usdtVal);\r\n            themis.addStaticTotalRechargeAndStaticPool(usdtVal, depositBalance);\r\n            tether.transferFrom(msg.sender, this, usdtVal);\r\n        }\r\n\t\t\r\n\r\n        function timeExtended(uint usdtVal) internal {\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            uint count = SafeMath.div(usdtVal, SafeMath.mul(10, 10 ** 6));\r\n            uint nowTime = DappDatasets.getNowTime();\r\n            uint laveTime = SafeMath.sub(fomo.endTime, nowTime);\r\n            uint day = 48 * 60 * 60;\r\n            uint hour = 2 * 60 * 60;\r\n            if(count > 0) {\r\n                laveTime = SafeMath.add(laveTime, SafeMath.mul(hour, count));\r\n                if(laveTime <= day) {\r\n                    fomo.endTime = SafeMath.add(nowTime, laveTime);\r\n                }else {\r\n                    fomo.endTime = SafeMath.add(nowTime, day);\r\n                }\r\n            }\r\n        }\r\n\r\n        function fomoPenny(address addr, uint usdtVal) internal {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            uint num = 9;\r\n            for(uint i = 0; i < 3; i++) {\r\n                if(player.superior) {\r\n                    uint usdt = SafeMath.div(SafeMath.mul(usdtVal, num), 100);\r\n                    playerMap[player.superiorAddr].wallet = SafeMath.add(\r\n                        playerMap[player.superiorAddr].wallet,\r\n                        usdt\r\n                    );\r\n                    playerMap[player.superiorAddr].dynamicIncome = SafeMath.add(\r\n                        playerMap[player.superiorAddr].dynamicIncome,\r\n                        usdt\r\n                    );\r\n                    depositBalance = SafeMath.sub(depositBalance, usdt);\r\n                    uint reward = SafeMath.div(usdt, 10);\r\n                    interactive(player.superiorAddr, reward);\r\n                    if(playerMap[player.superiorAddr].superior) {\r\n                        playerMap[playerMap[player.superiorAddr].superiorAddr].wallet = SafeMath.add(\r\n                            playerMap[playerMap[player.superiorAddr].superiorAddr].wallet,\r\n                            reward\r\n                        );\r\n                        playerMap[playerMap[player.superiorAddr].superiorAddr].dynamicIncome = SafeMath.add(\r\n                            playerMap[playerMap[player.superiorAddr].superiorAddr].dynamicIncome,\r\n                            reward\r\n                        );\r\n                    }else {\r\n                        break;\r\n                    }\r\n                    num -= 3;\r\n                    player = playerMap[player.superiorAddr];\r\n                }else {\r\n                    break;\r\n                }\r\n                \r\n            }\r\n\r\n            uint technicalRewards = SafeMath.div(SafeMath.mul(usdtVal, 3), 100);\r\n            depositBalance = SafeMath.sub(depositBalance, technicalRewards);\r\n            playerMap[technologyAddr].wallet = SafeMath.add(playerMap[technologyAddr].wallet, technicalRewards);\r\n\r\n            uint vUsdt = SafeMath.div(SafeMath.mul(usdtVal, 4), 100);\r\n            uint vUsdt4 = SafeMath.div(SafeMath.mul(usdtVal, 3), 100);\r\n            depositBalance = SafeMath.sub(depositBalance, SafeMath.mul(vUsdt, 3));\r\n            depositBalance = SafeMath.sub(depositBalance, vUsdt4);\r\n            themis.addUsdtPool(vUsdt, vUsdt4);\r\n        }\r\n\r\n\r\n        function increasePerformance(address addr, uint usdtVal) internal {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            uint length = 0;\r\n            while(player.superior) {\r\n                address tempAddr = player.superiorAddr;\r\n                player = playerMap[player.superiorAddr];\r\n                player.subbordinateTotalPerformance = SafeMath.add(player.subbordinateTotalPerformance, usdtVal);\r\n                promotionMechanisms(tempAddr);\r\n                length++;\r\n                if(length == 50) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function promotionMechanisms(address addr) internal {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            if(player.subbordinateTotalPerformance >= 10 * 10 ** 4 * 10 ** 6) {\r\n                uint len = player.subordinates.length;\r\n                if(player.subordinates.length > 30) {\r\n                    len = 30;\r\n                }\r\n                for(uint i = 0; i < 4; i++) {\r\n                    if(player.shareholderLevel == i) {\r\n                        uint levelCount = 0;\r\n                        for(uint j = 0; j < len; j++) {\r\n                            if(i == 0) {\r\n                                uint areaTotal = SafeMath.add(\r\n                                            playerMap[player.subordinates[j]].subbordinateTotalPerformance,\r\n                                            playerMap[player.subordinates[j]].rechargeAmount\r\n                                );\r\n                                if(areaTotal >= 3 * 10 ** 4 * 10 ** 6) {\r\n                                    levelCount++;\r\n                                }\r\n                            }else {\r\n                                if(playerMap[player.subordinates[j]].shareholderLevel >= i || playerMap[player.subordinates[j]].underUmbrellaLevel >= i) {\r\n                                    levelCount++;\r\n                                }\r\n                            }\r\n\r\n                            if(levelCount >= 2) {\r\n                                player.shareholderLevel = i + 1;\r\n                                if(i == 0) {\r\n                                    globalShareholder[owner].shareholdersV1.push(addr);\r\n                                }else if(i == 1) {\r\n                                    globalShareholder[owner].shareholdersV2.push(addr);\r\n                                }else if(i == 2) {\r\n                                    globalShareholder[owner].shareholdersV3.push(addr);\r\n                                }else if(i == 3) {\r\n                                    globalShareholder[owner].shareholdersV4.push(addr);\r\n                                }\r\n                                \r\n                                DappDatasets.Player storage tempPlayer = player;\r\n                                uint count = 0;\r\n                                while(tempPlayer.superior) {\r\n                                    tempPlayer = playerMap[tempPlayer.superiorAddr];\r\n                                    if(tempPlayer.underUmbrellaLevel < i + 1) {\r\n                                        tempPlayer.underUmbrellaLevel = i + 1;\r\n                                    }else {\r\n                                        break;\r\n                                    }\r\n                                    count++;\r\n                                    if(count == 49) {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                break;\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        function releaseStaticPoolAndV4(uint usdtVal) internal {\r\n            uint staticPool60 = SafeMath.div(SafeMath.mul(usdtVal, 6), 10);\r\n            themis.addStaticPrizePool(staticPool60);\r\n\r\n            if(globalShareholder[owner].shareholdersV4.length > 0) {\r\n                uint length = globalShareholder[owner].shareholdersV4.length;\r\n                if(globalShareholder[owner].shareholdersV4.length > 100) {\r\n                    length = 100;\r\n                }\r\n                uint splitEqually = SafeMath.div(SafeMath.sub(usdtVal, staticPool60), length);\r\n                for(uint i = 0; i < length; i++) {\r\n                    playerMap[globalShareholder[owner].shareholdersV4[i]].wallet = SafeMath.add(\r\n                        playerMap[globalShareholder[owner].shareholdersV4[i]].wallet,\r\n                        splitEqually\r\n                    );\r\n                }\r\n            }else{\r\n\t\t\t\tthemis.addStaticPrizePool(SafeMath.sub(usdtVal, staticPool60));\r\n\t\t\t}\r\n\r\n        }\r\n\r\n        function register(address addr, address superiorAddr) internal{\r\n            if(playerMap[addr].isExist == true) {\r\n                return;\r\n            }\r\n            DappDatasets.Player memory player;\r\n            if(superiorAddr == address(0x0) || playerMap[superiorAddr].isExist == false) {\r\n                player = DappDatasets.Player(\r\n                    {\r\n                        withdrawalAmount : 0,\r\n                        wallet : 0,\r\n                        fomoTotalRevenue : 0,\r\n                        lotteryTotalRevenue : 0,\r\n                        dynamicIncome : 0,\r\n                        rechargeAmount : 0,\r\n                        staticIncome : 0,\r\n                        shareholderLevel : 0,\r\n                        underUmbrellaLevel : 0,\r\n                        subbordinateTotalPerformance : 0,\r\n                        isExist : true,\r\n                        superior : false,\r\n                        superiorAddr : address(0x0),\r\n                        subordinates : temp\r\n                    }\r\n                );\r\n                playerMap[addr] = player;\r\n            }else {\r\n                player = DappDatasets.Player(\r\n                    {\r\n                        withdrawalAmount : 0,\r\n                        wallet : 0,\r\n                        fomoTotalRevenue : 0,\r\n                        lotteryTotalRevenue : 0,\r\n                        dynamicIncome : 0,\r\n                        rechargeAmount : 0,\r\n                        staticIncome : 0,\r\n                        shareholderLevel : 0,\r\n                        underUmbrellaLevel : 0,\r\n                        subbordinateTotalPerformance : 0,\r\n                        isExist : true,\r\n                        superior : true,\r\n                        superiorAddr : superiorAddr,\r\n                        subordinates : temp\r\n                    }\r\n                );\r\n                DappDatasets.Player storage superiorPlayer = playerMap[superiorAddr];\r\n                superiorPlayer.subordinates.push(addr);\r\n                playerMap[addr] = player;\r\n            }\r\n            allPlayer.push(addr);\r\n        }\r\n        function endFomoGame() external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            require(fomoSession > 0, \"The game has not started\");\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            require(fomo.whetherToEnd == false,\"Game over\");\r\n            require(DappDatasets.getNowTime() >= fomo.endTime, \"The game is not over\");\r\n            fomo.whetherToEnd = true;\r\n        }\r\n\r\n        function getFomoParticpantLength() external view returns(uint) {\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            return fomo.participant.length;\r\n        }\r\n\r\n        function fomoBatchDistribution(uint number, uint frequency, uint index) external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            require(fomo.whetherToEnd == true,\"fomo is not over\");\r\n            require(fomo.fomoPrizePool > 0, \"fomo pool no bonus\");\r\n\r\n            uint fomoPool = SafeMath.div(SafeMath.mul(fomo.fomoPrizePool, number), 10);\r\n\r\n            uint length = frequency;\r\n            if(fomo.participant.length < frequency) {\r\n                length = fomo.participant.length;\r\n            }\r\n            uint personalAmount = SafeMath.div(fomoPool, length);\r\n            uint num = 0;\r\n            for(uint i = fomo.participant.length - index; i > 0; i--) {\r\n                DappDatasets.Player storage player = playerMap[fomo.participant[i - 1]];\r\n                player.wallet = SafeMath.add(\r\n                    player.wallet,\r\n                    personalAmount\r\n                );\r\n                player.fomoTotalRevenue = SafeMath.add(\r\n                    player.fomoTotalRevenue,\r\n                    personalAmount\r\n                );\r\n                num++;\r\n                if(num == 100 || num == length) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function getFOMOInfo() external view returns(uint session, uint nowTime, uint endTime, uint prizePool, bool isEnd) {\r\n            DappDatasets.Fomo storage fomo = fomoGame[fomoSession];\r\n            return (fomoSession, DappDatasets.getNowTime(), fomo.endTime, fomo.fomoPrizePool, fomo.whetherToEnd);\r\n        }\r\n\r\n        function getSubordinatesAndPerformanceByAddr(address addr) external view returns(address[], uint[], uint[]) {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            uint[] memory performance = new uint[](player.subordinates.length);\r\n            uint[] memory numberArray = new uint[](player.subordinates.length);\r\n            for(uint i = 0; i < player.subordinates.length; i++) {\r\n                performance[i] = SafeMath.add(\r\n                    playerMap[player.subordinates[i]].subbordinateTotalPerformance,\r\n                    playerMap[player.subordinates[i]].rechargeAmount\r\n                );\r\n                numberArray[i] = playerMap[player.subordinates[i]].subordinates.length;\r\n            }\r\n            return (player.subordinates, performance, numberArray);\r\n        }\r\n\r\n        function getPlayerInfo() external view returns(address superiorAddr, address ownerAddr, uint numberOfInvitations, bool exist) {\r\n            return (playerMap[msg.sender].superiorAddr,  msg.sender, playerMap[msg.sender].subordinates.length, playerMap[msg.sender].isExist);\r\n        }\r\n\r\n        function getStatistics() external view returns(\r\n            uint level,\r\n            uint destroyedQuantity,\r\n            uint fomoTotalRevenue,\r\n            uint lotteryTotalRevenue,\r\n            uint difference\r\n        ) {\r\n            return (\r\n                playerMap[msg.sender].shareholderLevel,\r\n                godToken.balanceOf(address(0x0)),\r\n                playerMap[msg.sender].fomoTotalRevenue,\r\n                playerMap[msg.sender].lotteryTotalRevenue,\r\n                SafeMath.sub(\r\n                    SafeMath.mul(playerMap[msg.sender].rechargeAmount, 3),\r\n                    playerMap[msg.sender].staticIncome\r\n                )\r\n            );\r\n        }\r\n\r\n        function getRevenueAndPerformance() external view returns(\r\n            uint withdrawalAmount,\r\n            uint subbordinateTotalPerformance,\r\n            uint dynamicIncome,\r\n            uint staticIncome,\r\n            uint withdrawn,\r\n            uint outboundDifference\r\n        ) {\r\n            uint number = 0;\r\n            uint motionAndStaticAmount = SafeMath.add(playerMap[msg.sender].staticIncome, playerMap[msg.sender].dynamicIncome);\r\n            uint withdrawableBalance = SafeMath.mul(playerMap[msg.sender].rechargeAmount, 3);\r\n            if(motionAndStaticAmount > withdrawableBalance) {\r\n                number = SafeMath.sub(motionAndStaticAmount, withdrawableBalance);\r\n            }\r\n            uint difference = 0;\r\n            if(motionAndStaticAmount < withdrawableBalance) {\r\n                difference = SafeMath.sub(withdrawableBalance, motionAndStaticAmount);\r\n            }\r\n            return (\r\n                SafeMath.sub(playerMap[msg.sender].wallet, number),\r\n                playerMap[msg.sender].subbordinateTotalPerformance,\r\n                playerMap[msg.sender].dynamicIncome,\r\n                playerMap[msg.sender].staticIncome,\r\n                playerMap[msg.sender].withdrawalAmount,\r\n                difference\r\n            );\r\n        }\r\n        function getAllPlayer() external view returns(address[]) {\r\n            return allPlayer;\r\n        }\r\n        function getAllPlayerLength() external view returns(uint) {\r\n            return allPlayer.length;\r\n        }\r\n\r\n        function getShareholder() external view returns(uint, uint, uint, uint) {\r\n            return (\r\n                globalShareholder[owner].shareholdersV1.length,\r\n                globalShareholder[owner].shareholdersV2.length,\r\n                globalShareholder[owner].shareholdersV3.length,\r\n                globalShareholder[owner].shareholdersV4.length\r\n            );\r\n        }\r\n\r\n        function getGlobalShareholder() external view returns(address[], address[], address[], address[]) {\r\n            return (\r\n                globalShareholder[owner].shareholdersV1,\r\n                globalShareholder[owner].shareholdersV2,\r\n                globalShareholder[owner].shareholdersV3,\r\n                globalShareholder[owner].shareholdersV4\r\n            );\r\n        }\r\n\r\n        function getPlayer(address addr) external view returns(uint, uint, uint, address, address[]) {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            return(\r\n                player.rechargeAmount,\r\n                player.staticIncome,\r\n                player.dynamicIncome,\r\n                player.superiorAddr,\r\n                player.subordinates\r\n            );\r\n        }\r\n\r\n        function updatePlayer(address addr, uint amount, bool flag) external {\r\n            require(themisAddr == msg.sender, \"Insufficient permissions\");\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            player.wallet = SafeMath.add(player.wallet, amount);\r\n            if(flag) {\r\n                player.staticIncome = SafeMath.add(player.staticIncome, amount);\r\n            }else {\r\n                player.dynamicIncome = SafeMath.add(player.dynamicIncome, amount);\r\n            }\r\n        }\r\n\r\n        function updatePlayer(address addr, uint amount) external {\r\n            require(lotteryAddr == msg.sender, \"Insufficient permissions\");\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            player.wallet = SafeMath.add(player.wallet, amount);\r\n            player.lotteryTotalRevenue = SafeMath.add(player.lotteryTotalRevenue, amount);\r\n        }\r\n    }\r\n\r\n    contract GODThemis {\r\n        function addStaticPrizePool(uint usdtVal) external;\r\n        function addStaticTotalRechargeAndStaticPool(uint usdtVal, uint depositBalance) external;\r\n        function addUsdtPool(uint vUsdt, uint vUsdt4) external;\r\n    }\r\n\r\n    contract GODToken {\r\n        function burn(address addr, uint value) public;\r\n        function usdtPrice() public view returns(uint);\r\n        function balanceOf(address who) external view returns (uint);\r\n        function calculationNeedGOD(uint usdtVal) external view returns(uint);\r\n    }\r\n\r\n    contract TetherToken {\r\n        function transferFrom(address from, address to, uint value) public;\r\n        function transfer(address to, uint value) public;\r\n    }\r\n\r\n    contract GODLottery {\r\n        function getLottoCodeByGameAddr(address addr, uint count) external;\r\n        function lotterySession() public view returns(uint);\r\n        function getLotteryIsEnd() external view returns(bool);\r\n        function updateLotteryPoolAndTodayAmountTotal(uint usdtVal, uint lotteryPool) external;\r\n        function exchange(uint usdtVal, address addr) external;\r\n        function participateLottery(uint usdtVal, address addr) external;\r\n    }","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"redeemGod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"number\",\"type\":\"uint256\"},{\"name\":\"frequency\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"fomoBatchDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFOMOInfo\",\"outputs\":[{\"name\":\"session\",\"type\":\"uint256\"},{\"name\":\"nowTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"prizePool\",\"type\":\"uint256\"},{\"name\":\"isEnd\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFomoParticpantLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStatistics\",\"outputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"destroyedQuantity\",\"type\":\"uint256\"},{\"name\":\"fomoTotalRevenue\",\"type\":\"uint256\"},{\"name\":\"lotteryTotalRevenue\",\"type\":\"uint256\"},{\"name\":\"difference\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllPlayerLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"participateFomo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"buyLotto\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startFomoGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getSubordinatesAndPerformanceByAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalShareholder\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updatePlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRevenueAndPerformance\",\"outputs\":[{\"name\":\"withdrawalAmount\",\"type\":\"uint256\"},{\"name\":\"subbordinateTotalPerformance\",\"type\":\"uint256\"},{\"name\":\"dynamicIncome\",\"type\":\"uint256\"},{\"name\":\"staticIncome\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"name\":\"outboundDifference\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"updatePlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getShareholder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"superiorAddr\",\"type\":\"address\"},{\"name\":\"ownerAddr\",\"type\":\"address\"},{\"name\":\"numberOfInvitations\",\"type\":\"uint256\"},{\"name\":\"exist\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endFomoGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tetherAddr\",\"type\":\"address\"},{\"name\":\"_godAddr\",\"type\":\"address\"},{\"name\":\"_themisAddr\",\"type\":\"address\"},{\"name\":\"_lotteryAddr\",\"type\":\"address\"},{\"name\":\"_technologyAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"GODGame","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003b2c68f61a2c98bb0a4cf2ddc8cb0bec3957e1c1000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000004dc90fa739385848340349cf5c9efd123655a7e30000000000000000000000008e3f5172cc10f0f920f3677625056f43d47e4aea000000000000000000000000a4e973366d50e117f0f8c27353ca063d9aea0cd50000000000000000000000002e6f48e434856b1df1ab3c054de462fffc0838b4","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://beb5d11fd8cf6cdd923ca62b5bd6f73a0de6877ac799881ca5d34a1c18c6ced4"}]}