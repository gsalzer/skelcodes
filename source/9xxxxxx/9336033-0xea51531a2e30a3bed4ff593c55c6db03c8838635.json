{"status":"1","message":"OK","result":[{"SourceCode":"//orfeed.org oracle aggregator\r\n\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IKyberNetworkProxy {\r\n    function maxGasPrice() external view returns(uint);\r\n\r\n    function getUserCapInWei(address user) external view returns(uint);\r\n\r\n    function getUserCapInTokenWei(address user, ERC20 token) external view returns(uint);\r\n\r\n    function enabled() external view returns(bool);\r\n\r\n    function info(bytes32 id) external view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view returns(uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) external payable returns(uint);\r\n\r\n    function swapEtherToToken(ERC20 token, uint minRate) external payable returns(uint);\r\n\r\n    function swapTokenToEther(ERC20 token, uint tokenQty, uint minRate) external returns(uint);\r\n}\r\n\r\ninterface SynthetixExchange {\r\n    function effectiveValue(bytes32 from, uint256 amount, bytes32 to) external view returns(uint256);\r\n}\r\n\r\ninterface Kyber {\r\n    function getOutputAmount(ERC20 from, ERC20 to, uint256 amount) external view returns(uint256);\r\n\r\n    function getInputAmount(ERC20 from, ERC20 to, uint256 amount) external view returns(uint256);\r\n}\r\n\r\ninterface Synthetix {\r\n    function getOutputAmount(bytes32 from, bytes32 to, uint256 amount) external view returns(uint256);\r\n\r\n    function getInputAmount(bytes32 from, bytes32 to, uint256 amount) external view returns(uint256);\r\n}\r\n\r\ninterface premiumSubInterface {\r\n    function getExchangeRate(string fromSymbol, string toSymbol, string venue, uint256 amount, address requestAddress) external view returns(uint256);\r\n\r\n}\r\n\r\ninterface arbInterface {\r\n    function arb(address fundsReturnToAddress, address liquidityProviderContractAddress, string[] tokens,  uint256 amount, string[] exchanges) external payable returns(bool);\r\n    function extraFunction(string param1, string param2, string param3, string param4) external  returns(string);\r\n}\r\n\r\ninterface priceAsyncInterface {\r\n    function requestPriceResult(string fromSymbol, string toSymbol, string venue, uint256 amount) external returns(string);\r\n    function getRequestedPriceResult(string fromSymbol, string toSymbol, string venue, uint256 amount, string referenceId) external view returns(uint256);\r\n}\r\n\r\ninterface eventsAsyncInterface {\r\n    function requestEventResult(string eventName, string source) external returns(string);\r\n    function getRequestedEventResult(string eventName, string source, string referenceId) external view returns(string);\r\n\r\n}\r\n\r\ninterface eventsSyncInterface {\r\n    function getEventResult(string eventName, string source) external view returns(string);\r\n\r\n}\r\n\r\ninterface synthetixMain {\r\n    function getOutputAmount(bytes32 from, bytes32 to, uint256 amount) external view returns(uint256);\r\n\r\n    function getInputAmount(bytes32 from, bytes32 to, uint256 amount) external view returns(uint256);\r\n}\r\n\r\ncontract synthConvertInterface {\r\n    function name() external view returns(string);\r\n\r\n    function setGasPriceLimit(uint256 _gasPriceLimit) external;\r\n\r\n    function approve(address spender, uint256 value) external returns(bool);\r\n\r\n    function removeSynth(bytes32 currencyKey) external;\r\n\r\n    function issueSynths(bytes32 currencyKey, uint256 amount) external;\r\n\r\n    function mint() external returns(bool);\r\n\r\n    function setIntegrationProxy(address _integrationProxy) external;\r\n\r\n    function nominateNewOwner(address _owner) external;\r\n\r\n    function initiationTime() external view returns(uint256);\r\n\r\n    function totalSupply() external view returns(uint256);\r\n\r\n    function setFeePool(address _feePool) external;\r\n\r\n    function exchange(bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey, address destinationAddress) external returns(bool);\r\n\r\n    function setSelfDestructBeneficiary(address _beneficiary) external;\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\r\n\r\n    function decimals() external view returns(uint8);\r\n\r\n    function synths(bytes32) external view returns(address);\r\n\r\n    function terminateSelfDestruct() external;\r\n\r\n    function rewardsDistribution() external view returns(address);\r\n\r\n    function exchangeRates() external view returns(address);\r\n\r\n    function nominatedOwner() external view returns(address);\r\n\r\n    function setExchangeRates(address _exchangeRates) external;\r\n\r\n    function effectiveValue(bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey) external view returns(uint256);\r\n\r\n    function transferableSynthetix(address account) external view returns(uint256);\r\n\r\n    function validateGasPrice(uint256 _givenGasPrice) external view;\r\n\r\n    function balanceOf(address account) external view returns(uint256);\r\n\r\n    function availableCurrencyKeys() external view returns(bytes32[]);\r\n\r\n    function acceptOwnership() external;\r\n\r\n    function remainingIssuableSynths(address issuer, bytes32 currencyKey) external view returns(uint256);\r\n\r\n    function availableSynths(uint256) external view returns(address);\r\n\r\n    function totalIssuedSynths(bytes32 currencyKey) external view returns(uint256);\r\n\r\n    function addSynth(address synth) external;\r\n\r\n    function owner() external view returns(address);\r\n\r\n    function setExchangeEnabled(bool _exchangeEnabled) external;\r\n\r\n    function symbol() external view returns(string);\r\n\r\n    function gasPriceLimit() external view returns(uint256);\r\n\r\n    function setProxy(address _proxy) external;\r\n\r\n    function selfDestruct() external;\r\n\r\n    function integrationProxy() external view returns(address);\r\n\r\n    function setTokenState(address _tokenState) external;\r\n\r\n    function collateralisationRatio(address issuer) external view returns(uint256);\r\n\r\n    function rewardEscrow() external view returns(address);\r\n\r\n    function SELFDESTRUCT_DELAY() external view returns(uint256);\r\n\r\n    function collateral(address account) external view returns(uint256);\r\n\r\n    function maxIssuableSynths(address issuer, bytes32 currencyKey) external view returns(uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns(bool);\r\n\r\n    function synthInitiatedExchange(address from, bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey, address destinationAddress) external returns(bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value, bytes data) external returns(bool);\r\n\r\n    function feePool() external view returns(address);\r\n\r\n    function selfDestructInitiated() external view returns(bool);\r\n\r\n    function setMessageSender(address sender) external;\r\n\r\n    function initiateSelfDestruct() external;\r\n\r\n    function transfer(address to, uint256 value, bytes data) external returns(bool);\r\n\r\n    function supplySchedule() external view returns(address);\r\n\r\n    function selfDestructBeneficiary() external view returns(address);\r\n\r\n    function setProtectionCircuit(bool _protectionCircuitIsActivated) external;\r\n\r\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns(uint256);\r\n\r\n    function synthetixState() external view returns(address);\r\n\r\n    function availableSynthCount() external view returns(uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns(uint256);\r\n\r\n    function escrow() external view returns(address);\r\n\r\n    function tokenState() external view returns(address);\r\n\r\n    function burnSynths(bytes32 currencyKey, uint256 amount) external;\r\n\r\n    function proxy() external view returns(address);\r\n\r\n    function issueMaxSynths(bytes32 currencyKey) external;\r\n\r\n    function exchangeEnabled() external view returns(bool);\r\n}\r\n\r\ninterface Uniswap {\r\n    function getEthToTokenInputPrice(uint256 ethSold) external view returns(uint256);\r\n\r\n    function getEthToTokenOutputPrice(uint256 tokensBought) external view returns(uint256);\r\n\r\n    function getTokenToEthInputPrice(uint256 tokensSold) external view returns(uint256);\r\n\r\n    function getTokenToEthOutputPrice(uint256 ethBought) external view returns(uint256);\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) public view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) public returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) public returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) public view returns(uint remaining);\r\n\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns(string) {}\r\n\r\n    function symbol() public view returns(string) {}\r\n\r\n    function decimals() public view returns(uint8) {}\r\n\r\n    function totalSupply() public view returns(uint256) {}\r\n\r\n    function balanceOf(address _owner) public view returns(uint256) {\r\n        _owner;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns(uint256) {\r\n        _owner;\r\n        _spender;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns(bool success);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// Oracle Feed Contract\r\ncontract orfeed {\r\n    using SafeMath\r\n    for uint256;\r\n\r\n    address owner;\r\n    mapping(string => address) freeRateTokenSymbols;\r\n    mapping(string => address) freeRateForexSymbols;\r\n    mapping(string => bytes32) freeRateForexBytes;\r\n\r\n    uint256 rateDivide1;\r\n    uint256 rateMultiply1;\r\n\r\n    uint256 rateDivide2;\r\n    uint256 rateMultiply2;\r\n\r\n    uint256 rateDivide3;\r\n    uint256 rateMultiply3;\r\n\r\n    uint256 rateDivide4;\r\n    uint256 rateMultiply4;\r\n\r\n    address ethTokenAddress;\r\n\r\n    address tokenPriceOracleAddress;\r\n    address synthetixExchangeAddress;\r\n\r\n    address tokenPriceOracleAddress2;\r\n\r\n    //forex price oracle address. Can be changed by DAO\r\n    address forexPriceOracleAddress;\r\n\r\n    //premium price oracle address. Can be changed by DAO\r\n    address premiumSubPriceOracleAddress;\r\n    \r\n    //external async price oracle \r\n    address asyncProxyContractAddress;\r\n    \r\n    //events (no price oracle)\r\n    address eventsProxySyncContractAddress;\r\n    \r\n    //events ( async, no price oracle)\r\n    address eventsProxyAsyncContractAddress;\r\n    \r\n    //arb contract\r\n    address arbContractAddress;\r\n    \r\n\r\n    premiumSubInterface psi;\r\n    IKyberNetworkProxy ki;\r\n    SynthetixExchange se;\r\n    synthConvertInterface s;\r\n    synthetixMain si;\r\n    Kyber kyber;\r\n    Synthetix synthetix;\r\n    Uniswap uniswap;\r\n    ERC20 ethToken;\r\n\r\n   \r\n\r\n    // Functions with this modifier can only be executed by the owner DAO\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    //free ERC20 rates. Can be changed/updated by ownerDAO\r\n    constructor() public payable {\r\n        freeRateTokenSymbols['SAI'] = 0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359;\r\n        freeRateTokenSymbols['DAI'] = 0x6b175474e89094c44da98b954eedeac495271d0f;\r\n        freeRateTokenSymbols['USDC'] = 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48;\r\n        freeRateTokenSymbols['MKR'] = 0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2;\r\n        freeRateTokenSymbols['LINK'] = 0x514910771af9ca656af840dff83e8264ecf986ca;\r\n        freeRateTokenSymbols['BAT'] = 0x0d8775f648430679a709e98d2b0cb6250d2887ef;\r\n        freeRateTokenSymbols['WBTC'] = 0x2260fac5e5542a773aa44fbcfedf7c193bc2c599;\r\n        freeRateTokenSymbols['BTC'] = 0x2260fac5e5542a773aa44fbcfedf7c193bc2c599;\r\n        freeRateTokenSymbols['OMG'] = 0xd26114cd6EE289AccF82350c8d8487fedB8A0C07;\r\n        freeRateTokenSymbols['ZRX'] = 0xe41d2489571d322189246dafa5ebde1f4699f498;\r\n        freeRateTokenSymbols['TUSD'] = 0x0000000000085d4780B73119b644AE5ecd22b376;\r\n        freeRateTokenSymbols['ETH'] = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n        freeRateTokenSymbols['WETH'] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;\r\n        freeRateTokenSymbols['SNX'] = 0xc011a72400e58ecd99ee497cf89e3775d4bd732f;\r\n        freeRateTokenSymbols['CSAI'] = 0xf5dce57282a584d2746faf1593d3121fcac444dc;\r\n        freeRateTokenSymbols['CUSDC'] = 0x39aa39c021dfbae8fac545936693ac917d5e7563;\r\n        freeRateTokenSymbols['KNC'] = 0xdd974d5c2e2928dea5f71b9825b8b646686bd200;\r\n        freeRateTokenSymbols['USDT'] = 0xdac17f958d2ee523a2206206994597c13d831ec7;\r\n        freeRateTokenSymbols['GST1'] = 0x88d60255F917e3eb94eaE199d827DAd837fac4cB;\r\n        freeRateTokenSymbols['GST2'] = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\r\n        \r\n        \r\n        \r\n  \r\n        \r\n        \r\n\r\n        //free forex rates. Can be changed/updated by ownerDAO        \r\n        freeRateForexSymbols['USD'] = 0x57ab1e02fee23774580c119740129eac7081e9d3;\r\n        freeRateForexSymbols['EUR'] = 0xd71ecff9342a5ced620049e616c5035f1db98620;\r\n        freeRateForexSymbols['CHF'] = 0x0f83287ff768d1c1e17a42f44d644d7f22e8ee1d;\r\n        freeRateForexSymbols['JPY'] = 0xf6b1c627e95bfc3c1b4c9b825a032ff0fbf3e07d;\r\n        freeRateForexSymbols['GBP'] = 0x97fe22e7341a0cd8db6f6c021a24dc8f4dad855f;\r\n\r\n        freeRateForexBytes['USD'] = 0x7355534400000000000000000000000000000000000000000000000000000000;\r\n        freeRateForexBytes['EUR'] = 0x7345555200000000000000000000000000000000000000000000000000000000;\r\n        freeRateForexBytes['CHF'] = 0x7343484600000000000000000000000000000000000000000000000000000000;\r\n        freeRateForexBytes['JPY'] = 0x734a505900000000000000000000000000000000000000000000000000000000;\r\n        freeRateForexBytes['GBP'] = 0x7347425000000000000000000000000000000000000000000000000000000000;\r\n        freeRateForexBytes['iETH'] = 0x6945544800000000000000000000000000000000000000000000000000000000;\r\n\r\n\r\n        //when returning rates they will be first divided by and then multiplied by these rates\r\n        rateDivide1 = 100;\r\n        rateMultiply1 = 100;\r\n\r\n        rateDivide2 = 100;\r\n        rateMultiply2 = 100;\r\n\r\n        rateDivide3 = 100;\r\n        rateMultiply3 = 100;\r\n\r\n        rateDivide4 = 100;\r\n        rateMultiply4 = 100;\r\n\r\n        //erc20 price oracle address. Can be changed by DAO\r\n        tokenPriceOracleAddress = 0xFd9304Db24009694c680885e6aa0166C639727D6;\r\n        synthetixExchangeAddress = 0xE95Ef4e7a04d2fB05cb625c62CA58da10112c605;\r\n\r\n        tokenPriceOracleAddress2 = 0xe9Cf7887b93150D4F2Da7dFc6D502B216438F244;\r\n\r\n        //forex price oracle address. Can be changed by DAO\r\n        forexPriceOracleAddress = 0xE86C848De6e4457720A1eb7f37B519010CD26d35;\r\n\r\n        //premium price oracle address. Can be changed by DAO\r\n        premiumSubPriceOracleAddress = 0xbf2e5dc9b5c25911c68edcebd57438da1abd7ed6;\r\n        \r\n        //arb proxy contract address. Can be cahnged... will be changed by DAO\r\n        arbContractAddress = 0x0;\r\n        \r\n\r\n        ethTokenAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n\r\n        ethToken = ERC20(ethTokenAddress);\r\n\r\n        \r\n\r\n        ki = IKyberNetworkProxy(tokenPriceOracleAddress);\r\n        se = SynthetixExchange(synthetixExchangeAddress);\r\n\r\n        si = synthetixMain(forexPriceOracleAddress);\r\n\r\n        kyber = Kyber(tokenPriceOracleAddress); // Kyber oracle\r\n        synthetix = Synthetix(forexPriceOracleAddress); // Synthetix oracle\r\n\r\n        uniswap = Uniswap(tokenPriceOracleAddress2);\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function() payable {\r\n        throw;\r\n    }\r\n\r\n    function getTokenToSynthOutputAmount(ERC20 token, bytes32 synth, uint256 inputAmount) returns(uint256) {\r\n        kyber = Kyber(tokenPriceOracleAddress); \r\n        uint256 ethAmount = kyber.getOutputAmount(token, ethToken, inputAmount);\r\n        uniswap = Uniswap(tokenPriceOracleAddress2);\r\n        uint256 sethAmount = uniswap.getEthToTokenInputPrice(ethAmount);\r\n        se = SynthetixExchange(synthetixExchangeAddress);\r\n        uint256 outputAmount = se.effectiveValue(freeRateForexBytes['iETH'], sethAmount, synth);\r\n        return outputAmount;\r\n    }\r\n\r\n    function getSynthToTokenOutputAmount(bytes32 synth, ERC20 token, uint256 inputAmount) returns(uint256) {\r\n         kyber = Kyber(tokenPriceOracleAddress); \r\n        se = SynthetixExchange(synthetixExchangeAddress);\r\n        uint256 sethAmount = se.effectiveValue(synth, inputAmount, freeRateForexBytes['iETH']);\r\n        uniswap = Uniswap(tokenPriceOracleAddress2);\r\n        uint256 ethAmount = uniswap.getTokenToEthInputPrice(sethAmount);\r\n        uint256 outputAmount = kyber.getOutputAmount(ethToken, token, ethAmount);\r\n        return outputAmount;\r\n    }\r\n\r\n    //this will go to a DAO\r\n    function changeOwner(address newOwner) onlyOwner external returns(bool) {\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n\r\n    function updateMulDivConverter1(uint256 newDiv, uint256 newMul) onlyOwner external returns(bool) {\r\n        rateMultiply1 = newMul;\r\n        rateDivide1 = newDiv;\r\n        return true;\r\n    }\r\n\r\n    function updateMulDivConverter2(uint256 newDiv, uint256 newMul) onlyOwner external returns(bool) {\r\n        rateMultiply2 = newMul;\r\n        rateDivide2 = newDiv;\r\n        return true;\r\n    }\r\n\r\n    function updateMulDivConverter3(uint256 newDiv, uint256 newMul) onlyOwner external returns(bool) {\r\n        rateMultiply3 = newMul;\r\n        rateDivide3 = newDiv;\r\n        return true;\r\n    }\r\n\r\n    function updateMulDivConverter4(uint256 newDiv, uint256 newMul) onlyOwner external returns(bool) {\r\n        rateMultiply4 = newMul;\r\n        rateDivide4 = newDiv;\r\n        return true;\r\n    }\r\n\r\n    //this will go to a DAO\r\n    function updateTokenOracleAddress(address newOracle) onlyOwner external returns(bool) {\r\n        tokenPriceOracleAddress = newOracle;\r\n        return true;\r\n    }\r\n\r\n    function updateEthTokenAddress(address newOracle) onlyOwner external returns(bool) {\r\n        ethTokenAddress = newOracle;\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    function updateTokenOracleAddress2(address newOracle) onlyOwner external returns(bool) {\r\n        tokenPriceOracleAddress2 = newOracle;\r\n        return true;\r\n    }\r\n\r\n\r\n    //this will go to a DAO\r\n    function updateForexOracleAddress(address newOracle) onlyOwner external returns(bool) {\r\n        forexPriceOracleAddress = newOracle;\r\n        return true;\r\n    }\r\n\r\n\r\n    function updateSynthAddress(address newOracle) onlyOwner external returns(bool) {\r\n        synthetixExchangeAddress = newOracle;\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    //this will go to a DAO\r\n    function updatePremiumSubOracleAddress(address newOracle) onlyOwner external returns(bool) {\r\n        premiumSubPriceOracleAddress = newOracle;\r\n        return true;\r\n    }\r\n    \r\n      //this will go to a DAO\r\n    function updateAsyncOracleAddress (address newOracle) onlyOwner external returns(bool) {\r\n        asyncProxyContractAddress = newOracle;\r\n        return true;\r\n    }\r\n    \r\n     function updateAsyncEventsAddress (address newOracle) onlyOwner external returns(bool) {\r\n        eventsProxyAsyncContractAddress = newOracle;\r\n        return true;\r\n    }\r\n    \r\n     function updateSyncEventsAddress (address newOracle) onlyOwner external returns(bool) {\r\n        eventsProxySyncContractAddress = newOracle;\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function updateArbContractAddress (address newAddress) onlyOwner external returns(bool) {\r\n        arbContractAddress = newAddress;\r\n        return true;\r\n    }\r\n    \r\n\r\n    //this will go to a DAO\r\n    function addFreeToken(string symb, address tokenAddress) onlyOwner external returns(bool) {\r\n        if (freeRateTokenSymbols[symb] != 0x0) {\r\n            //this token already exists\r\n            return false;\r\n        }\r\n        freeRateTokenSymbols[symb] = tokenAddress;\r\n        return true;\r\n    }\r\n\r\n    function addFreeCurrency(string symb, address tokenAddress, bytes32 byteCode) onlyOwner external returns(bool) {\r\n        if (freeRateForexSymbols[symb] != 0x0) {\r\n            //this token already exists\r\n            return false;\r\n        }\r\n        freeRateForexSymbols[symb] = tokenAddress;\r\n        freeRateForexBytes[symb] = byteCode;\r\n        return true;\r\n    }\r\n\r\n    function removeFreeToken(string symb) onlyOwner external returns(bool) {\r\n        freeRateTokenSymbols[symb] = 0x0;\r\n        return true;\r\n    }\r\n\r\n\r\n    function removeFreeCurrency(string symb) onlyOwner external returns(bool) {\r\n        freeRateForexSymbols[symb] = 0x0;\r\n        return true;\r\n    }\r\n\r\n   \r\n\r\n    //returns zero if the rate cannot be found\r\n    function getExchangeRate(string fromSymbol, string toSymbol, string venue, uint256 amount) constant external returns(uint256) {\r\n        bool isFreeFrom = isFree(fromSymbol);\r\n        bool isFreeTo = isFree(toSymbol);\r\n        bool isFreeVenue = isFreeVenueCheck(venue);\r\n        uint256 rate;\r\n\r\n        if (isFreeFrom == true && isFreeTo == true && isFreeVenue == true) {\r\n            rate = getFreeExchangeRate(fromSymbol, toSymbol, amount);\r\n            return rate;\r\n        } else {\r\n            psi = premiumSubInterface(premiumSubPriceOracleAddress);\r\n            //init.sender and msg.sender must have premium\r\n            rate = psi.getExchangeRate(fromSymbol, toSymbol, venue, amount, msg.sender);\r\n            return rate;\r\n        }\r\n    }\r\n    \r\n    function requestAsyncExchangeRate(string fromSymbol, string toSymbol, string venue, uint256 amount)  external returns(string) {\r\n    \r\n        priceAsyncInterface api = priceAsyncInterface(asyncProxyContractAddress);\r\n        string memory resString = api.requestPriceResult(fromSymbol, toSymbol, venue, amount);\r\n        //resString ideally is a reference id\r\n        return resString;\r\n    }\r\n    \r\n     function requestAsyncExchangeRateResult(string fromSymbol, string toSymbol, string venue, uint256 amount, string referenceId) constant  external returns(uint256) {\r\n    \r\n        priceAsyncInterface api = priceAsyncInterface(asyncProxyContractAddress);\r\n        uint256 resPrice = api.getRequestedPriceResult(fromSymbol, toSymbol, venue, amount,referenceId);\r\n        return resPrice;\r\n    }\r\n    \r\n    \r\n    function getEventResult(string eventName, string source)  constant external returns(string) {\r\n    \r\n        eventsSyncInterface epiSync = eventsSyncInterface(eventsProxySyncContractAddress);\r\n        string memory resString = epiSync.getEventResult(eventName, source);\r\n        return resString;\r\n    }\r\n    \r\n    \r\n   \r\n    \r\n    function requestAsyncEvent(string eventName, string source)  external returns(string) {\r\n    \r\n        eventsAsyncInterface epi = eventsAsyncInterface(eventsProxyAsyncContractAddress);\r\n        string memory resString = epi.requestEventResult(eventName, source);\r\n        return resString;\r\n    }\r\n    \r\n    function getAsyncEventResult(string eventName, string source, string referenceId) constant  external returns(string) {\r\n    \r\n        eventsAsyncInterface epi = eventsAsyncInterface(eventsProxyAsyncContractAddress);\r\n        string memory resString = epi.getRequestedEventResult(eventName, source, referenceId);\r\n        return resString;\r\n    }\r\n    \r\n\r\n\r\n    function arb(address fundsReturnToAddress, address liquidityProviderContractAddress, string[] tokens,  uint256 amount, string[] exchanges) payable returns (bool){\r\n       \r\n        arbInterface arbContract = arbInterface(arbContractAddress);\r\n       address tokenAddress = getTokenAddress(tokens[0]);\r\n       if(tokenAddress != getTokenAddress(\"ETH\")){\r\n           require(ERC20(tokenAddress).transferFrom(msg.sender, arbContractAddress, amount));\r\n       }\r\n       \r\n        bool arbResp = arbContract.arb.value(msg.value)(fundsReturnToAddress, liquidityProviderContractAddress, tokens, amount, exchanges);\r\n        if(arbResp != true){\r\n            throw;\r\n        }\r\n        return arbResp;\r\n    }\r\n    \r\n    function callExtraFunction(string param1, string param2, string param3, string param4) returns (string){\r\n         arbInterface arbContract = arbInterface(arbContractAddress);\r\n         string memory extraResp = arbContract.extraFunction(param1, param2, param3, param4);\r\n         return extraResp;\r\n    }\r\n    \r\n\r\n    \r\n\r\n\r\n    function getTokenAddress(string symbol) constant  returns(address){\r\n        if(freeRateTokenSymbols[symbol] == 0x0){\r\n             address tokenAddress = address(stringToBytes32(symbol));\r\n             return tokenAddress;\r\n        }\r\n       \r\n        return freeRateTokenSymbols[symbol];\r\n    }\r\n    \r\n    \r\n\r\n\r\n    function getForexAddress(string symbol) constant external returns(address){\r\n         return freeRateForexSymbols[symbol];\r\n    }\r\n\r\n    function getSynthBytes32(string symbol)  constant external returns(bytes32){\r\n        return freeRateForexBytes[symbol];\r\n    }\r\n\r\n    function getTokenDecimalCount(address tokenAddress) constant external returns(uint256){\r\n        ERC20 thisToken = ERC20(tokenAddress);\r\n        uint256 decimalCount = thisToken.decimals();\r\n    }\r\n\r\n\r\n\r\n    function compareStrings(string memory a, string memory b) public view returns(bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    function isFreeVenueCheck(string venueToCheck) returns(bool) {\r\n        string memory blankString = '';\r\n        string memory defaultString = 'DEFAULT';\r\n        \r\n        if (compareStrings(venueToCheck, blankString)) {\r\n            return true;\r\n        } \r\n        \r\n        if (compareStrings(venueToCheck, defaultString)) {\r\n            return true;\r\n        } \r\n    \r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isFree(string symToCheck) returns(bool) {\r\n        if (freeRateTokenSymbols[symToCheck] != 0x0) {\r\n            return true;\r\n        }\r\n        if (freeRateForexSymbols[symToCheck] != 0x0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function getFreeExchangeRate(string fromSymb, string toSymb, uint256 amount) returns(uint256) {\r\n        uint256 ethAmount;\r\n\r\n         //token to token\r\n        if (freeRateTokenSymbols[fromSymb] != 0x0 && freeRateTokenSymbols[toSymb] != 0x0) {\r\n           \r\n             kyber = Kyber(tokenPriceOracleAddress); \r\n            uint256 toRate = kyber.getOutputAmount(ERC20(freeRateTokenSymbols[fromSymb]), ERC20(freeRateTokenSymbols[toSymb]), amount);\r\n            return toRate;\r\n           \r\n        } \r\n\r\n        //token to forex\r\n        else if (freeRateTokenSymbols[fromSymb] != 0x0 && freeRateTokenSymbols[toSymb] == 0x0) {\r\n           \r\n            uint256 toRate2 = getTokenToSynthOutputAmount(ERC20(freeRateTokenSymbols[fromSymb]), freeRateForexBytes[toSymb], amount);\r\n            return toRate2.mul(rateMultiply2).div(rateDivide2);\r\n        } \r\n\r\n        //forex to token\r\n        else if (freeRateTokenSymbols[fromSymb] == 0x0 && freeRateTokenSymbols[toSymb] != 0x0) {\r\n            \r\n            uint256 toRate3 = getSynthToTokenOutputAmount(freeRateForexBytes[fromSymb], ERC20(freeRateTokenSymbols[toSymb]), amount);\r\n            return toRate3.mul(rateMultiply3).div(rateDivide3);\r\n        } \r\n\r\n\r\n        //forex to forex\r\n\r\n        else if (freeRateTokenSymbols[fromSymb] == 0x0 && freeRateTokenSymbols[toSymb] == 0x0) {\r\n\r\n            se = SynthetixExchange(synthetixExchangeAddress);\r\n            uint256 toRate4 = se.effectiveValue(freeRateForexBytes[fromSymb], amount, freeRateForexBytes[toSymb]);\r\n            return toRate4.mul(rateMultiply4).div(rateDivide4);\r\n        } \r\n        //something's wrong\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    function stringToBytes32(string memory source) returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n    \r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    \r\n    //end contract\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"symb\",\"type\":\"string\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"byteCode\",\"type\":\"bytes32\"}],\"name\":\"addFreeCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fromSymbol\",\"type\":\"string\"},{\"name\":\"toSymbol\",\"type\":\"string\"},{\"name\":\"venue\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"referenceId\",\"type\":\"string\"}],\"name\":\"requestAsyncExchangeRateResult\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"eventName\",\"type\":\"string\"},{\"name\":\"source\",\"type\":\"string\"},{\"name\":\"referenceId\",\"type\":\"string\"}],\"name\":\"getAsyncEventResult\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDiv\",\"type\":\"uint256\"},{\"name\":\"newMul\",\"type\":\"uint256\"}],\"name\":\"updateMulDivConverter2\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"synth\",\"type\":\"bytes32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"getSynthToTokenOutputAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symb\",\"type\":\"string\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"addFreeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateForexOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"eventName\",\"type\":\"string\"},{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"getEventResult\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateSynthAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDiv\",\"type\":\"uint256\"},{\"name\":\"newMul\",\"type\":\"uint256\"}],\"name\":\"updateMulDivConverter1\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDiv\",\"type\":\"uint256\"},{\"name\":\"newMul\",\"type\":\"uint256\"}],\"name\":\"updateMulDivConverter3\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fromSymbol\",\"type\":\"string\"},{\"name\":\"toSymbol\",\"type\":\"string\"},{\"name\":\"venue\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symb\",\"type\":\"string\"}],\"name\":\"removeFreeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateEthTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fundsReturnToAddress\",\"type\":\"address\"},{\"name\":\"liquidityProviderContractAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"string[]\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"exchanges\",\"type\":\"string[]\"}],\"name\":\"arb\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updatePremiumSubOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symb\",\"type\":\"string\"}],\"name\":\"removeFreeCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateAsyncOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"venueToCheck\",\"type\":\"string\"}],\"name\":\"isFreeVenueCheck\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symToCheck\",\"type\":\"string\"}],\"name\":\"isFree\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateArbContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateAsyncEventsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenDecimalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"string\"},{\"name\":\"b\",\"type\":\"string\"}],\"name\":\"compareStrings\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventName\",\"type\":\"string\"},{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"requestAsyncEvent\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"synth\",\"type\":\"bytes32\"},{\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenToSynthOutputAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromSymbol\",\"type\":\"string\"},{\"name\":\"toSymbol\",\"type\":\"string\"},{\"name\":\"venue\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestAsyncExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateTokenOracleAddress2\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateSyncEventsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getSynthBytes32\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromSymb\",\"type\":\"string\"},{\"name\":\"toSymb\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getFreeExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateTokenOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDiv\",\"type\":\"uint256\"},{\"name\":\"newMul\",\"type\":\"uint256\"}],\"name\":\"updateMulDivConverter4\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getForexAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"param1\",\"type\":\"string\"},{\"name\":\"param2\",\"type\":\"string\"},{\"name\":\"param3\",\"type\":\"string\"},{\"name\":\"param4\",\"type\":\"string\"}],\"name\":\"callExtraFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"orfeed","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://920b35625bb903115b010305dd15dbfb9f800ba0e030c4df92f9bd0601d55f6e"}]}