{"status":"1","message":"OK","result":[{"SourceCode":"{\"EtherSwap.sol\":{\"content\":\"pragma solidity ^0.6.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Swap.sol\\\";\\n\\n// solium-disable security/no-call-value\\ncontract EtherSwap is Swap {\\n    enum OrderState { HasFundingBalance, Claimed, Refunded }\\n\\n    struct FundDetails {\\n        bytes16 orderUUID;\\n        bytes32 paymentHash;\\n    }\\n    struct FundDetailsWithAdminRefundEnabled {\\n        bytes16 orderUUID;\\n        bytes32 paymentHash;\\n        bytes32 refundHash;\\n    }\\n    struct ClaimDetails {\\n        bytes16 orderUUID;\\n        bytes32 paymentPreimage;\\n    }\\n    struct AdminRefundDetails {\\n        bytes16 orderUUID;\\n        bytes32 refundPreimage;\\n    }\\n    struct SwapOrder {\\n        address payable user;\\n        bytes32 paymentHash;\\n        bytes32 refundHash;\\n        uint256 onchainAmount;\\n        uint256 refundBlockHeight;\\n        OrderState state;\\n        bool exist;\\n    }\\n\\n    mapping(bytes16 =\\u003e SwapOrder) orders;\\n\\n    event OrderFundingReceived(\\n        bytes16 orderUUID,\\n        uint256 onchainAmount,\\n        bytes32 paymentHash,\\n        uint256 refundBlockHeight\\n    );\\n    event OrderFundingReceivedWithAdminRefundEnabled(\\n        bytes16 orderUUID,\\n        uint256 onchainAmount,\\n        bytes32 paymentHash,\\n        uint256 refundBlockHeight,\\n        bytes32 refundHash\\n    );\\n    event OrderClaimed(bytes16 orderUUID);\\n    event OrderRefunded(bytes16 orderUUID);\\n    event OrderAdminRefunded(bytes16 orderUUID);\\n\\n    /**\\n     * Delete the order data that is no longer necessary after a swap is claimed or refunded.\\n     */\\n    function deleteUnnecessaryOrderData(SwapOrder storage order) internal {\\n        delete order.user;\\n        delete order.paymentHash;\\n        delete order.onchainAmount;\\n        delete order.refundBlockHeight;\\n    }\\n\\n    /**\\n     * Allow the sender to fund a swap in one or more transactions.\\n     */\\n    function fund(FundDetails memory details) public payable {\\n        SwapOrder storage order = orders[details.orderUUID];\\n\\n        if (!order.exist) {\\n            order.user = msg.sender;\\n            order.exist = true;\\n            order.paymentHash = details.paymentHash;\\n            order.refundBlockHeight = block.number + refundDelay;\\n            order.state = OrderState.HasFundingBalance;\\n        } else {\\n            require(order.state == OrderState.HasFundingBalance, \\\"Order already claimed or refunded.\\\");\\n        }\\n        order.onchainAmount += msg.value;\\n\\n        emit OrderFundingReceived(details.orderUUID, order.onchainAmount, order.paymentHash, order.refundBlockHeight);\\n    }\\n\\n    /**\\n     * Allow the sender to fund a swap in one or more transactions and provide a refund\\n     * hash, which can enable faster refunds if the refund preimage is supplied by the\\n     * counterparty once it\\u0027s decided that a claim transaction will not be submitted.\\n     */\\n    function fundWithAdminRefundEnabled(FundDetailsWithAdminRefundEnabled memory details) public payable {\\n        SwapOrder storage order = orders[details.orderUUID];\\n\\n        if (!order.exist) {\\n            order.user = msg.sender;\\n            order.exist = true;\\n            order.paymentHash = details.paymentHash;\\n            order.refundHash = details.refundHash;\\n            order.refundBlockHeight = block.number + refundDelay;\\n            order.state = OrderState.HasFundingBalance;\\n        } else {\\n            require(order.state == OrderState.HasFundingBalance, \\\"Order already claimed or refunded.\\\");\\n        }\\n        order.onchainAmount += msg.value;\\n\\n        emit OrderFundingReceivedWithAdminRefundEnabled(\\n            details.orderUUID,\\n            order.onchainAmount,\\n            order.paymentHash,\\n            order.refundBlockHeight,\\n            order.refundHash\\n        );\\n    }\\n\\n    /**\\n     * Allow the recipient to claim the funds once they know the preimage of the hashlock.\\n     * Anyone can claim, but the tokens will always be sent to the owner.\\n     */\\n    function claim(ClaimDetails memory details) public {\\n        SwapOrder storage order = orders[details.orderUUID];\\n\\n        require(order.exist == true, \\\"Order does not exist.\\\");\\n        require(order.state == OrderState.HasFundingBalance, \\\"Order not in claimable state.\\\");\\n        require(sha256(abi.encodePacked(details.paymentPreimage)) == order.paymentHash, \\\"Incorrect payment preimage.\\\");\\n        require(block.number \\u003c= order.refundBlockHeight, \\\"Too late to claim.\\\");\\n\\n        order.state = OrderState.Claimed;\\n\\n        (bool success, ) = owner.call.value(order.onchainAmount)(\\\"\\\");\\n        require(success, \\\"Transfer failed.\\\");\\n\\n        deleteUnnecessaryOrderData(order);\\n        emit OrderClaimed(details.orderUUID);\\n    }\\n\\n    /**\\n     * Refund the sent amount back to the funder if the timelock has expired.\\n     */\\n    function refund(bytes16 orderUUID) public {\\n        SwapOrder storage order = orders[orderUUID];\\n\\n        require(order.exist == true, \\\"Order does not exist.\\\");\\n        require(order.state == OrderState.HasFundingBalance, \\\"Order not in refundable state.\\\");\\n        require(block.number \\u003e order.refundBlockHeight, \\\"Too early to refund.\\\");\\n\\n        order.state = OrderState.Refunded;\\n\\n        (bool success, ) = order.user.call.value(order.onchainAmount)(\\\"\\\");\\n        require(success, \\\"Transfer failed.\\\");\\n\\n        deleteUnnecessaryOrderData(order);\\n        emit OrderRefunded(orderUUID);\\n    }\\n\\n    /**\\n     * Refund the sent amount back to the funder if a valid refund preimage is supplied.\\n     * This provides a better UX than a timelocked refund. It is entirely at the discretion\\n     * of the counterparty (claimer) as to whether the refund preimage will be provided to\\n     * the funder, but is recommended once it\\u0027s decided that a claim transaction will not\\n     * be submitted.\\n     */\\n    function adminRefund(AdminRefundDetails memory details) public {\\n        SwapOrder storage order = orders[details.orderUUID];\\n\\n        require(order.exist == true, \\\"Order does not exist.\\\");\\n        require(order.state == OrderState.HasFundingBalance, \\\"Order not in refundable state.\\\");\\n        require(order.refundHash != 0, \\\"Admin refund not allowed.\\\");\\n        require(sha256(abi.encodePacked(details.refundPreimage)) == order.refundHash, \\\"Incorrect refund preimage.\\\");\\n\\n        order.state = OrderState.Refunded;\\n\\n        (bool success, ) = order.user.call.value(order.onchainAmount)(\\\"\\\");\\n        require(success, \\\"Transfer failed.\\\");\\n\\n        deleteUnnecessaryOrderData(order);\\n        emit OrderAdminRefunded(details.orderUUID);\\n    }\\n}\\n\"},\"Owned.sol\":{\"content\":\"pragma solidity ^0.6.1;\\n\\ncontract Owned {\\n    constructor() public { owner = msg.sender; }\\n    address payable public owner;\\n\\n    modifier onlyOwner {\\n        require(\\n            msg.sender == owner,\\n            \\\"Only owner can call this function.\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n    * Allow the owner of this contract to transfer ownership to another address\\n    * @param newOwner The address of the new owner\\n    */\\n    function transferOwnership(address payable newOwner) external onlyOwner {\\n        owner = newOwner;\\n    }\\n}\\n\"},\"Swap.sol\":{\"content\":\"pragma solidity ^0.6.1;\\n\\nimport \\\"./Owned.sol\\\";\\n\\ncontract Swap is Owned {\\n    // Refund delay. Default: 4 hours\\n    uint public refundDelay = 4 * 60 * 4;\\n\\n    // Max possible refund delay: 5 days\\n    uint constant MAX_REFUND_DELAY = 60 * 60 * 2 * 4;\\n\\n    /**\\n     * Set the block height at which a refund will successfully process.\\n     */\\n    function setRefundDelay(uint delay) external onlyOwner {\\n        require(delay \\u003c= MAX_REFUND_DELAY, \\\"Delay is too large.\\\");\\n        refundDelay = delay;\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"}],\"name\":\"OrderAdminRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"}],\"name\":\"OrderClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"onchainAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"paymentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundBlockHeight\",\"type\":\"uint256\"}],\"name\":\"OrderFundingReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"onchainAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"paymentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundBlockHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refundHash\",\"type\":\"bytes32\"}],\"name\":\"OrderFundingReceivedWithAdminRefundEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"}],\"name\":\"OrderRefunded\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"},{\"internalType\":\"bytes32\",\"name\":\"refundPreimage\",\"type\":\"bytes32\"}],\"internalType\":\"struct EtherSwap.AdminRefundDetails\",\"name\":\"details\",\"type\":\"tuple\"}],\"name\":\"adminRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"},{\"internalType\":\"bytes32\",\"name\":\"paymentPreimage\",\"type\":\"bytes32\"}],\"internalType\":\"struct EtherSwap.ClaimDetails\",\"name\":\"details\",\"type\":\"tuple\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"},{\"internalType\":\"bytes32\",\"name\":\"paymentHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct EtherSwap.FundDetails\",\"name\":\"details\",\"type\":\"tuple\"}],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"},{\"internalType\":\"bytes32\",\"name\":\"paymentHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"refundHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct EtherSwap.FundDetailsWithAdminRefundEnabled\",\"name\":\"details\",\"type\":\"tuple\"}],\"name\":\"fundWithAdminRefundEnabled\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"orderUUID\",\"type\":\"bytes16\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setRefundDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtherSwap","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://07275dc6d6fe385721a37fd25bf1a32c98166903174163f084406cbcb9478acd"}]}