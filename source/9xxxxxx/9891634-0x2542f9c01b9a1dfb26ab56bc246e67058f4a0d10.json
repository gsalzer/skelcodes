{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.2;\r\n\r\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/GSNRecipient.sol\r\n// But kept minimalist.\r\ncontract MsgSender {\r\n\r\n    address public relayHub;\r\n\r\n    /**\r\n     * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,\r\n     * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).\r\n     *\r\n     * IMPORTANT: Contracts derived from {MsgSender} should never use `msg.sender`, and use {_msgSender} instead.\r\n     */\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        if (msg.sender != relayHub) {\r\n            return msg.sender;\r\n        } else {\r\n            return _getRelayedCallSender();\r\n        }\r\n    }\r\n\r\n    function _getRelayedCallSender() private pure returns (address payable result) {\r\n        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array\r\n        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing\r\n        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would\r\n        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20\r\n        // bytes. This can always be done due to the 32-byte prefix.\r\n\r\n        // The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the\r\n        // easiest/most-efficient way to perform this operation.\r\n\r\n        // These fields are not accessible from assembly\r\n        bytes memory array = msg.data;\r\n        uint256 index = msg.data.length;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\r\n            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// Fetch beacon\r\ncontract CommunityOracle is MsgSender {\r\n\r\n  // Used to count submissions\r\n  mapping (address => bool) public appointedOracle;\r\n  mapping (address => bool) public oracleSubmitted;\r\n  mapping (string => uint) public proposals;\r\n  string[] public proposalList;\r\n  uint public submitted;\r\n  uint public minimumOracles;\r\n\r\n  event Beacon(string bls, uint beacon);\r\n\r\n  /**\r\n   * Sets up the community oracle service for CyberDice.\r\n   * @param _oracles A list of appointed oracles.\r\n   * @param _minimumOracles Minimum number of votes required for a beacon proposal.\r\n   **/\r\n  constructor(address[] memory _oracles, uint _minimumOracles, address _relayHub) public {\r\n    require(_oracles.length > _minimumOracles, \"More appointed oracles are required\");\r\n    for(uint i=0; i<_oracles.length; i++) {\r\n        appointedOracle[_oracles[i]] = true;\r\n\r\n    }\r\n    minimumOracles = _minimumOracles;\r\n    relayHub = _relayHub;\r\n  }\r\n\r\n  /**\r\n   * Collect beacon proposal from an appointed oracle\r\n   */\r\n  function submitBeacon(string memory _proposal) public {\r\n      require(appointedOracle[_msgSender()], \"Only appointed oracle\");\r\n      require(!oracleSubmitted[_msgSender()], \"Appointed oracle has already submitted\");\r\n      oracleSubmitted[_msgSender()] = true;\r\n      submitted = submitted + 1;\r\n\r\n      // Easy to iterate list.\r\n      if(proposals[_proposal] == 0) {\r\n          proposalList.push(_proposal);\r\n      }\r\n\r\n      proposals[_proposal] = proposals[_proposal] + 1;\r\n  }\r\n\r\n  // Count submissions by the oracles\r\n  // Returns 0 if beacon is not yet ready.\r\n  function getBeacon() public returns (uint) {\r\n    require(submitted >= minimumOracles, \"A minimum number of oracles must respond before fetching beacon\");\r\n\r\n    string memory winningProposal = proposalList[0];\r\n\r\n    // Compare votes for each unique solution sent\r\n    for(uint i=1; i<proposalList.length; i++) {\r\n      string memory proposal = proposalList[i];\r\n\r\n      // More votes?\r\n      if(proposals[proposal] > proposals[winningProposal]) {\r\n        winningProposal = proposal;\r\n      }\r\n    }\r\n\r\n    uint beacon = uint(keccak256(abi.encode(winningProposal)));\r\n    emit Beacon(winningProposal, beacon);\r\n    return beacon;\r\n  }\r\n}\r\n/*\r\n * Author: Patrick McCorry (anydot)\r\n *\r\n * An on-chain competition to win prize money.\r\n *\r\n * How to enter:\r\n * Developers simply need to call submit() and send it via the any.sender service.\r\n *\r\n * - Skills required to play:\r\n * All tickets must be sent via the any.sender service, so it requires techncial skill (e.g. developer)\r\n * to participate in the competition. We have added some extra \"ticket bumps\" during the game,\r\n * so it might be worth writing a script that can watch out for the bumps to purchase extra tickets.\r\n *\r\n * - How it works:\r\n * Users can have one or more tickets, and all tickets are appended to a list.\r\n * When the game ends, we'll use the blockhash as a random beacon and it will\r\n * a random index in the list of tickets. Whoever owns that ticket is the winner.\r\n * We took inspiration from https://www.cl.cam.ac.uk/~fms27/papers/2008-StajanoCla-cyberdice.pdf\r\n *\r\n * - Minting tickets:\r\n * We have added rules on how the tickets are minted, so please\r\n * check out getNoTickets() for up to date information.\r\n *\r\n * - Why did we make a competition?\r\n * It really demonstrates the power of Ethereum and the any.sender service.\r\n *\r\n */\r\ncontract CyberDice is MsgSender {\r\n\r\n    // Let thy explode\r\n    mapping(address => uint) public userTickets;\r\n    address[] public entries;\r\n\r\n    // any.sender relayers\r\n    mapping(address => bool) public relayers;\r\n\r\n    uint public startBlock; // used for the bumping feature \r\n    uint public deadline; // competition end-time \r\n\r\n    // senpai\r\n    address public oracleCon; \r\n    address public winner;\r\n\r\n    // League of Entropy \r\n    uint public roundNumber;\r\n\r\n    // Beacon details\r\n    uint public beacon;\r\n\r\n    // Notify world of new entry\r\n    event Entry(address signer, uint newTickets, string message);\r\n    event Deposit(address depositor, uint deposit);\r\n    event RequestBeacon();\r\n    event Winner(uint winningTicket, address winner, uint prize); \r\n\r\n    /** \r\n     * Hard-codes the relevant contracts and the competition's finish time (block).\r\n     * @param _deadline Random beacon is computed based on this block.\r\n     */\r\n    constructor(address[] memory _relayers, address _relayHub, address _oracleCon, uint _deadline, uint _roundNumber) public {\r\n        // Register the any.sender relayers\r\n        for(uint i=0; i<_relayers.length; i++) {\r\n            relayers[_relayers[i]] = true;\r\n        }\r\n\r\n        relayHub = _relayHub; // Relay hub address\r\n        startBlock = block.number; // Used for the bump feature \r\n        deadline = _deadline; // Unix timestamp (to sync with League of Entropy)\r\n        oracleCon = _oracleCon; // Oracle contract\r\n        roundNumber = _roundNumber; // League of Entropy round number\r\n    }\r\n\r\n    /*\r\n     * Fetch the beacon and then compute the winner.\r\n     * Must be called within 256 blocks of deadline\r\n     * Just in case there is spam near end of competition,\r\n     * all expired entries will auto-call computeWinner().\r\n     */\r\n    function computeWinner() public {\r\n        require(now > deadline, \"We must wait until the competition deadline before computing the winner.\");\r\n        require(winner == address(0), \"Winner already set\");\r\n\r\n        beacon = CommunityOracle(oracleCon).getBeacon();\r\n        require(beacon != 0, \"Beacon is not ready\");\r\n\r\n        uint winningTicket = beacon % entries.length;\r\n        winner = entries[winningTicket];\r\n\r\n        emit Winner(winningTicket, winner, address(this).balance);\r\n    }\r\n\r\n    /*\r\n     * @param _signer Ticket owner\r\n     * @param _tickets New tickets\r\n     *\r\n     * We append the owner's tickets to the global pool!\r\n     */\r\n    function appendTickets(address _signer, uint _tickets) internal {\r\n        userTickets[_signer] = userTickets[_signer] + _tickets;\r\n        for(uint i=0; i<_tickets; i++) {\r\n            entries.push(_signer);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Mints new tickets for the user and posts a message to the board.\r\n     * @param _message Message to broadcast\r\n     */\r\n    function submit(string memory _message) public\r\n    {\r\n        require(relayers[tx.origin], \"All entries must be sent via any.sender\");\r\n        require(msg.sender == relayHub, \"All entries must be sent via the RelayHub\");\r\n        require(deadline > now, \"You have missed your chance to submit a ticket!\");\r\n        address ticketOwner = _msgSender();\r\n        uint tickets = getNoTickets();\r\n        appendTickets(ticketOwner, tickets);\r\n\r\n        // Post message\r\n        emit Entry(ticketOwner, tickets, _message);\r\n    }\r\n\r\n    /**\r\n     * Ticket issuance is based on the progress of lottery.\r\n     * - Favours early in the game\r\n     * - Periodic bumps of tickets\r\n     *\r\n     * ~240 blocks an hour\r\n     * ~5760 blocks a day\r\n     */\r\n    function getNoTickets() internal view returns (uint) {\r\n\r\n        // We offer high ticket issueance during the first day\r\n        if(5760 > block.number - startBlock) {\r\n            return 3;\r\n        }\r\n\r\n        // Four hour period of bumps\r\n        if(block.number % 5760 < 960) {\r\n            return 2;\r\n        }\r\n\r\n        // Four hour period of bumps\r\n        if(block.number % 5760 > 1920 && block.number % 5760 < 2880) {\r\n            return 2;\r\n        }\r\n\r\n        // Period bumps\r\n        return 1;\r\n    }\r\n\r\n    // Total tickets minted \r\n    function totalTickets() public view returns(uint) {\r\n        return entries.length;\r\n    }\r\n\r\n    /**\r\n     * Winner authorises withdrawal of prize\r\n     */\r\n    function sendPrize() public payable {\r\n        require(winner != address(0), \"Winner must be set\");\r\n        payable(winner).transfer(address(this).balance);\r\n      \r\n    }\r\n\r\n    // Deposit function \r\n    receive() external payable {\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_relayers\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_relayHub\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracleCon\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTickets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Entry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RequestBeacon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningTicket\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"beacon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"computeWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entries\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleCon\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayHub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"relayers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendPrize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CyberDice","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000070107abb312db18bd9addec39ce711374b09ebc1000000000000000000000000aa0017e80099029013de2509db47f7bc9a7331d9000000000000000000000000000000000000000000000000000000005e9dee78000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000000120000000000000000000000007eab13a632d77587e0d26e1c7ea3695333bb24010000000000000000000000003a0319d7df4e3f0de81a6b90ddce0c7edca693b30000000000000000000000002ab923dbfb8791de6c18e01f6ccc881e3b80d42f00000000000000000000000009bde3a72d28da518a712f8bcc50ef85eddd488f000000000000000000000000d1d50c62a507184968b06a9470f059f232ddea4800000000000000000000000096906e748334586a6ff9240f99e0d72f7a9be9be0000000000000000000000007eb5e43888923cc3882ff2a09c9c5459bec57c380000000000000000000000000f407683cfc5ba78ffe43a467c4aba3af4ae53c1000000000000000000000000a7c55addabb28dbcec16ccab784138894e60eb40000000000000000000000000fdf9983d6982385be9b3b13cafa0d69242ed98f9000000000000000000000000c80ab885847c0916fc0dca312e167b068722f39d000000000000000000000000f8e558ec1f1f215ff0059cdcc2e6e78d7a40cc3b00000000000000000000000005d580b76a03a6206cbd110c303fd2bda3a576870000000000000000000000004d105dc9a63cfc4c2bccccd7ebef25565c6faa3e000000000000000000000000d6b13fc02400fffda18264c3a7de0aac42536b17000000000000000000000000156dabb25ac5b57153da36867c980db1cf195763000000000000000000000000405cb096ac6269d044730b45b5c63128bf2113800000000000000000000000001d016dd45027fcc760998d84b28a2bbb98607202","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://a3226e686d09f5db3621df92e6fe501f065176a89fd5f71e98f21af113a890b2"}]}