{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n* _________                        __           .____    .__  _____       \r\n* \\_   ___ \\_______ ___.__._______/  |_  ____   |    |   |__|/ ____\\____  \r\n* /    \\  \\/\\_  __ <   |  |\\____ \\   __\\/  _ \\  |    |   |  \\   __\\/ __ \\ \r\n* \\     \\____|  | \\/\\___  ||  |_> >  | (  <_> ) |    |___|  ||  | \\  ___/ \r\n*  \\______  /|__|   / ____||   __/|__|  \\____/  |_______ \\__||__|  \\___  >\r\n*         \\/        \\/     |__|                         \\/             \\/\r\n * https://cryptolife.top\r\n**/\r\n\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns(uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\ncontract CryptoLife is SafeMath {\r\n    uint public currentUserID;\r\n\r\n    mapping (uint => User) public users;\r\n    mapping (address => uint) public userWallets;\r\n    uint[5] public levelBase;\r\n    uint[7] public regBase;\r\n    address public token_contract;\r\n\r\n    struct User {\r\n        bool exists;\r\n        address wallet;\r\n        uint referrer;\r\n        mapping (uint => uint) uplines;\r\n        mapping (uint => uint[]) referrals;\r\n        mapping (uint => uint) levelExpiry;\r\n    }\r\n\r\n    event RegisterUserEvent(address indexed user, address indexed referrer, uint time);\r\n    event BuyLevelEvent(address indexed user, uint indexed level, uint time);\r\n    event TransferEvent(address indexed recipient, address indexed sender, uint indexed amount, uint time, uint recipientID, uint senderID, bool superprofit);\r\n    event LostProfitEvent(address indexed recipient, address indexed sender, uint indexed amount, uint time, uint senderID);\r\n    event CommissionEvent(address indexed recipient, address indexed sender, uint indexed amount, address referral, uint time, uint recipientID, uint senderID, uint referralID);\r\n\r\n    constructor(address _owner, address _token, address[2] memory techAccounts) public {\r\n\r\n      currentUserID++;\r\n      levelBase = [0.1 ether, 0.2 ether, 0.5 ether, 1.5 ether, 2.3 ether];\r\n      regBase = [0.21 ether, 1.61 ether, 3.22 ether, 6.33 ether, 12.44 ether, 24.55 ether, 48.66 ether];\r\n\r\n      users[currentUserID] =  User({ exists: true, wallet: _owner, referrer: 1});\r\n      userWallets[_owner] = currentUserID;\r\n      emit RegisterUserEvent(_owner, _owner, now);\r\n      \r\n      token_contract = _token;\r\n\r\n      for (uint i = 0; i < 35; i++) {\r\n        users[currentUserID].levelExpiry[i] = 1 << 37;\r\n      }\r\n      \r\n      for (uint i = 1; i < 8; i++) {\r\n          users[currentUserID].uplines[i] = 1;\r\n          users[currentUserID].referrals[i] = new uint[](0);\r\n      }\r\n      \r\n      for(uint i = 0; i < techAccounts.length; i++){\r\n          currentUserID++;\r\n          users[currentUserID] =  User({ exists: true, wallet: techAccounts[i], referrer: 1});\r\n          userWallets[techAccounts[i]] = currentUserID;\r\n          emit RegisterUserEvent(techAccounts[i], _owner, now);\r\n          \r\n          for(uint levelID = 0; levelID < 35; levelID+= 5){\r\n             users[currentUserID].levelExpiry[levelID] = 1 << 37;\r\n            //  emit BuyLevelEvent(techAccounts[levelID], levelID, now);\r\n          }\r\n          \r\n        for (uint j = 1; j < 8; j++) {\r\n        users[currentUserID].uplines[j] = 1;\r\n        users[currentUserID].referrals[j] = new uint[](0);\r\n        users[1].referrals[j].push(currentUserID);\r\n        }\r\n          \r\n      }\r\n      \r\n    }\r\n\r\n    function () external payable {\r\n        if (userWallets[msg.sender] == 0) {\r\n            require(msg.value == 0.21 ether, 'Wrong amount');\r\n            registerUser(userWallets[bytesToAddress(msg.data)]);\r\n        } else {\r\n            buyLevel(0);\r\n        }\r\n    }\r\n\r\n    function registerUser(uint _referrer) public payable {\r\n        require(_referrer > 0 && _referrer <= currentUserID, 'Invalid referrer ID');\r\n        require(msg.value == regBase[0], 'Wrong amount');\r\n        require(userWallets[msg.sender] == 0, 'User already registered');\r\n\r\n        currentUserID++;\r\n        users[currentUserID] = User({ exists: true, wallet: msg.sender, referrer: _referrer });\r\n        userWallets[msg.sender] = currentUserID;\r\n\r\n        levelUp(0, 1, 1, currentUserID, _referrer);\r\n        \r\n        emit RegisterUserEvent(msg.sender, users[_referrer].wallet, now);\r\n    }\r\n\r\n    function buyLevel(uint _upline) public payable {\r\n        uint userID = userWallets[msg.sender];\r\n        require (userID > 0, 'User not registered');\r\n        (uint round, uint level, uint levelID) = getLevel(msg.value);\r\n        \r\n        if (level == 1 && round > 1) {\r\n            bool prev = false;\r\n            for (uint l = levelID - 2; l < levelID; l++) {\r\n                if (users[userID].levelExpiry[l] >= now) {\r\n                    prev = true;\r\n                    break;\r\n                }\r\n                require(prev == true, 'Previous round not active');\r\n            }\r\n        } else {\r\n            for (uint l = level - 1; l > 0; l--) {\r\n                require(users[userID].levelExpiry[levelID - level + l] >= now, 'Previous level not active');\r\n            }\r\n        }\r\n\r\n        levelUp(levelID, level, round, userID, _upline);\r\n\r\n        if (level == 4 && round < 7 && users[userID].levelExpiry[levelID + 3] <= now) levelUp(levelID + 2, 1, round + 1, userID, _upline);\r\n\r\n        if (address(this).balance > 0) msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    function levelUp(uint _levelid, uint _level, uint _round, uint _userid, uint _upline) internal {\r\n\r\n        uint duration = 30 days * _round + 150 days;\r\n        IERC20 token = IERC20(token_contract);\r\n        uint clft = token.balanceOf(msg.sender);\r\n\r\n        if (users[_userid].levelExpiry[_levelid] == 0 || (users[_userid].levelExpiry[_levelid] < now && clft >= _round)) {\r\n            users[_userid].levelExpiry[_levelid] = now + duration;\r\n        } else {\r\n            users[_userid].levelExpiry[_levelid] += duration;\r\n        }\r\n        \r\n        if (_level == 1 && users[_userid].uplines[_round] == 0) {\r\n            if (_upline == 0) _upline = users[_userid].referrer;\r\n            if (_round > 1) _upline = findUplineUp(_upline, _round);\r\n            _upline = findUplineDown(_upline, _round);\r\n            users[_userid].uplines[_round] = _upline;\r\n            users[_upline].referrals[_round].push(_userid);\r\n        }\r\n\r\n        payForLevel(_levelid, _userid, _level, _round, false);\r\n        emit BuyLevelEvent(msg.sender, _levelid, now);\r\n    }\r\n\r\n    function payForLevel(uint _levelid, uint _userid, uint _height, uint _round, bool _superprofit) internal {\r\n        \r\n      uint refer = users[_userid].referrer;\r\n      uint referrer = getUserUpline(_userid, _height, _round);\r\n      uint amount = lvlAmount(_levelid);\r\n\r\n      if (users[referrer].levelExpiry[_levelid] < now) {\r\n        emit LostProfitEvent(users[referrer].wallet, msg.sender, amount, now, userWallets[msg.sender]);\r\n        payForLevel(_levelid, referrer, _height, _round, true);\r\n        return;\r\n      }\r\n\r\n        if(_levelid == 0 && refer != referrer){\r\n            uint comission = safeDiv(amount, 10);\r\n            \r\n            emit CommissionEvent(users[refer].wallet, users[referrer].wallet, comission, msg.sender, now, refer, referrer, userWallets[msg.sender]);\r\n            \r\n              if (address(uint160(users[refer].wallet)).send(safeDiv(amount, 10))) {\r\n                emit TransferEvent(users[refer].wallet, msg.sender, comission, now, refer, userWallets[msg.sender], _superprofit);\r\n              }\r\n              if (address(uint160(users[referrer].wallet)).send(safeMul(safeDiv(amount, 100), 90))) {\r\n                emit TransferEvent(users[referrer].wallet, msg.sender, (amount - comission), now, referrer, userWallets[msg.sender], _superprofit);\r\n              }\r\n        } else {\r\n            \r\n              \r\n              if (address(uint160(users[referrer].wallet)).send(amount)) {\r\n                emit TransferEvent(users[referrer].wallet, msg.sender, amount, now, referrer, userWallets[msg.sender], _superprofit);\r\n              }\r\n        }\r\n    }\r\n\r\n    function getUserUpline(uint _user, uint _height, uint _round) public view returns (uint) {\r\n        while (_height > 0) {\r\n            _user = users[_user].uplines[_round];\r\n            _height--;\r\n        }\r\n        return _user;\r\n    }\r\n\r\n    function findUplineUp(uint _user, uint _round) public view returns (uint) {\r\n        while (users[_user].uplines[_round] == 0) {\r\n            _user = users[_user].uplines[1];\r\n        }\r\n        return _user;\r\n    }\r\n\r\n    function findUplineDown(uint _user, uint _round) public view returns (uint) {\r\n      if (users[_user].referrals[_round].length < 2) {\r\n        return _user;\r\n      }\r\n\r\n      uint[1024] memory referrals;\r\n      referrals[0] = users[_user].referrals[_round][0];\r\n      referrals[1] = users[_user].referrals[_round][1];\r\n\r\n      uint referrer;\r\n\r\n      for (uint i = 0; i < 1024; i++) {\r\n        if (users[referrals[i]].referrals[_round].length < 2) {\r\n          referrer = referrals[i];\r\n          break;\r\n        }\r\n\r\n        if (i >= 512) {\r\n          continue;\r\n        }\r\n\r\n        referrals[(i+1)*2] = users[referrals[i]].referrals[_round][0];\r\n        referrals[(i+1)*2+1] = users[referrals[i]].referrals[_round][1];\r\n      }\r\n\r\n      require(referrer != 0, 'Referrer not found');\r\n      return referrer;\r\n    }\r\n\r\n\r\n    function getLevel(uint _amount) public view returns(uint, uint, uint) {\r\n\r\n        uint level = 0;\r\n        uint tmp = _amount % 0.1 ether;\r\n        uint round = tmp / 0.01 ether;\r\n        require(round != 0, 'Wrong amount');\r\n\r\n        tmp = (_amount - (0.11 ether * round)) / (2 ** (round - 1));\r\n\r\n        for (uint i = 1; i <= 5; i++) {\r\n            if (tmp == levelBase[i - 1]) {\r\n                    level = i;\r\n                    break;\r\n            }\r\n        }\r\n        require(level > 0, 'Wrong amount');\r\n\r\n        uint levelID = (round - 1) * 5 + level - 1;\r\n        \r\n        return (round, level, levelID);\r\n    }\r\n\r\n    function lvlAmount (uint _levelID) public view returns(uint) {\r\n        uint level = _levelID % 5;\r\n        uint round = (_levelID - level) / 5;\r\n        uint tmp = levelBase[level] * (2 ** round);\r\n        uint price = (tmp  + (0.11 ether * (round + 1)));\r\n        if(level == 3 && round < 6) return (price - (levelBase[0] * (2 ** (round + 1) ) ) - (0.11 ether * ( round + 2)));\r\n        return price;\r\n    }\r\n\r\n    function getReferralTree(uint _user, uint _treeLevel, uint _round) external view returns (uint[] memory, uint[] memory, uint) {\r\n\r\n        uint tmp = 2 ** (_treeLevel + 1) - 2;\r\n        uint[] memory ids = new uint[](tmp);\r\n        uint[] memory lvl = new uint[](tmp);\r\n\r\n        ids[0] = (users[_user].referrals[_round].length > 0)? users[_user].referrals[_round][0]: 0;\r\n        ids[1] = (users[_user].referrals[_round].length > 1)? users[_user].referrals[_round][1]: 0;\r\n        lvl[0] = getMaxLevel(ids[0], _round);\r\n        lvl[1] = getMaxLevel(ids[1], _round);\r\n\r\n        for (uint i = 0; i < (2 ** _treeLevel - 2); i++) {\r\n            tmp = i * 2 + 2;\r\n            ids[tmp] = (users[ids[i]].referrals[_round].length > 0)? users[ids[i]].referrals[_round][0]: 0;\r\n            ids[tmp + 1] = (users[ids[i]].referrals[_round].length > 1)? users[ids[i]].referrals[_round][1]: 0;\r\n            lvl[tmp] = getMaxLevel(ids[tmp], _round);\r\n            lvl[tmp + 1] = getMaxLevel(ids[tmp + 1], _round);\r\n        }\r\n        \r\n        uint curMax = getMaxLevel(_user, _round);\r\n\r\n        return(ids, lvl, curMax);\r\n    }\r\n\r\n    function getMaxLevel(uint _user, uint _round) private view returns (uint){\r\n        uint max = 0;\r\n        if (_user == 0) return 0;\r\n        if (!users[_user].exists) return 0;\r\n        for (uint i = 1; i <= 5; i++) {\r\n            if (users[_user].levelExpiry[_round * 5 - i] > now) {\r\n                max = 6 - i;\r\n                break;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n    \r\n    function getUplines(uint _user, uint _round) public view returns (uint[5] memory uplines, address[5] memory uplinesWallets) {\r\n        for(uint i = 0; i < 5; i++) {\r\n            _user = users[_user].uplines[_round];\r\n            uplines[i] = _user;\r\n            uplinesWallets[i] = users[_user].wallet;\r\n        }\r\n    }\r\n\r\n    function getUserLevels(uint _user) external view returns (uint[35] memory levels) {\r\n        for (uint i = 0; i < 35; i++) {\r\n            levels[i] = users[_user].levelExpiry[i];\r\n        }\r\n    }\r\n\r\n    function bytesToAddress(bytes memory _addr) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(_addr, 20))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"regBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referrer\",\"type\":\"uint256\"}],\"name\":\"registerUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"findUplineUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userWallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"}],\"name\":\"getUserLevels\",\"outputs\":[{\"internalType\":\"uint256[35]\",\"name\":\"levels\",\"type\":\"uint256[35]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentUserID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_height\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getUserUpline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_levelID\",\"type\":\"uint256\"}],\"name\":\"lvlAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"findUplineDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getUplines\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"uplines\",\"type\":\"uint256[5]\"},{\"internalType\":\"address[5]\",\"name\":\"uplinesWallets\",\"type\":\"address[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_upline\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treeLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getReferralTree\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"techAccounts\",\"type\":\"address[2]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"RegisterUserEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"BuyLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recipientID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"senderID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"superprofit\",\"type\":\"bool\"}],\"name\":\"TransferEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"senderID\",\"type\":\"uint256\"}],\"name\":\"LostProfitEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recipientID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"senderID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralID\",\"type\":\"uint256\"}],\"name\":\"CommissionEvent\",\"type\":\"event\"}]","ContractName":"CryptoLife","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a0403a3dedd1e4d5b7590c9764ec235b4dc1003200000000000000000000000041634a7cb08ee639a751973e63577ddcfe9e7101000000000000000000000000af522f27cde2357831349011fa8450e87469cb14000000000000000000000000e0ab3da943e8fffa5ef53064cb8173a4aa95a6fe","Library":"","LicenseType":"None","SwarmSource":"bzzr://21120fe3eadde4d80f8df7bf85172cc633339a2a11aaf7ae559a4b8fbcd99b6c"}]}