{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n/*\r\n\thttps://dragonETH.com\r\n*/\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancyLock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n *      See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * @dev Supports unlimited numbers of roles and addresses.\r\n * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n *  for you to write your own implementation of this interface using Enums or similar.\r\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\r\n *  to avoid typos.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string memory roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string memory roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string memory roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string memory roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string memory roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title RBACWithAdmin\r\n * @author Matt Condon (@Shrugs)\r\n * @dev It's recommended that you define constants in the contract,\r\n * @dev like ROLE_ADMIN below, to avoid typos.\r\n */\r\ncontract RBACWithAdmin is RBAC { // , DESTROYER {\r\n  /**\r\n   * A constant role name for indicating admins.\r\n   */\r\n  string public constant ROLE_ADMIN = \"admin\";\r\n  string public constant ROLE_PAUSE_ADMIN = \"pauseAdmin\";\r\n\r\n  /**\r\n   * @dev modifier to scope access to admins\r\n   * // reverts\r\n   */\r\n  modifier onlyAdmin()\r\n  {\r\n    checkRole(msg.sender, ROLE_ADMIN);\r\n    _;\r\n  }\r\n  modifier onlyPauseAdmin()\r\n  {\r\n    checkRole(msg.sender, ROLE_PAUSE_ADMIN);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev constructor. Sets msg.sender as admin by default\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    addRole(msg.sender, ROLE_ADMIN);\r\n    addRole(msg.sender, ROLE_PAUSE_ADMIN);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminAddRole(address addr, string memory roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    addRole(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminRemoveRole(address addr, string memory roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    removeRole(addr, roleName);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is RBACWithAdmin {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyPauseAdmin whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyPauseAdmin whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\ncontract DragonsETH {\r\n    struct Dragon {\r\n        uint256 gen1;\r\n        uint8 stage; // 0 - Dead, 1 - Egg, 2 - Young Dragon \r\n        uint8 currentAction; // 0 - free, 1 - fight place, 0xFF - Necropolis,  2 - random fight,\r\n                             // 3 - breed market, 4 - breed auction, 5 - random breed, 6 - market place ...\r\n        uint240 gen2;\r\n        uint256 nextBlock2Action;\r\n    }\r\n    Dragon[] public dragons;\r\n    \r\n    function ownerOf(uint256 _tokenId) public view returns (address);\r\n    function checkDragonStatus(uint256 _dragonID, uint8 _stage) public view;\r\n    function setCurrentAction(uint256 _dragonID, uint8 _currentAction) external;\r\n    function setTime2Rest(uint256 _dragonID, uint256 _addNextBlock2Action) external;\r\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) public view returns (bool);\r\n}\r\n\r\ncontract DragonsFight {\r\n    function getWinner(uint256 _dragonOneID, uint256 _dragonTwoID) external returns (uint256 _winerID);\r\n}\r\n\r\ncontract DragonsStats {\r\n    function incFightWin(uint256 _dragonID) external;\r\n    function incFightLose(uint256 _dragonID) external;\r\n    function setLastAction(uint256 _dragonID, uint256 _lastActionDragonID, uint8 _lastActionID) external;\r\n}\r\n\r\ncontract Mutagen {\r\n    function mint(address _to, uint256 _amount)  public returns (bool);\r\n}\r\n\r\ncontract DragonsFightGC is Pausable {\r\n    Mutagen public mutagenContract;\r\n    DragonsETH public mainContract;\r\n    DragonsFight public dragonsFightContract;\r\n    DragonsStats public dragonsStatsContract;\r\n    address payable wallet;\r\n    uint256 public mutagenToWin = 10;\r\n    uint256 public mutagenToLose =1;\r\n    uint256 public addTime2Rest = 240; // ~ 60 min\r\n    \r\n    event FightFP(uint256 _winnerId, uint256 _loserId, address indexed _ownerWinner, address indexed _onwerLoser);\r\n    event AddDragonFP(address indexed _from, uint256 _tokenId);\r\n    event RemoveDragonFP(address indexed _from, uint256 _tokenId);\r\n    \r\n \r\n    function changeAddressMutagenContract(address _newAddress) external onlyAdmin {\r\n        mutagenContract = Mutagen(_newAddress);\r\n    }\r\n    function changeAddressMainContract(address _newAddress) external onlyAdmin {\r\n        mainContract = DragonsETH(_newAddress);\r\n    }\r\n    function changeAddressFightContract(address _newAddress) external onlyAdmin {\r\n        dragonsFightContract = DragonsFight(_newAddress);\r\n    }\r\n    function changeAddressStatsContract(address _newAddress) external onlyAdmin {\r\n        dragonsStatsContract = DragonsStats(_newAddress);\r\n    }\r\n    function changeWallet(address payable _wallet) external onlyAdmin {\r\n        wallet = _wallet;\r\n    }\r\n    function changeMutagenToWin(uint256 _mutagenToWin) external onlyAdmin {\r\n        mutagenToWin = _mutagenToWin;\r\n    }\r\n    \r\n    function changeMutagenToLose(uint256 _mutagenToLose) external onlyAdmin {\r\n        mutagenToLose = _mutagenToLose;\r\n    }\r\n    function changeAddTime2Rest(uint256 _addTime2Rest) external onlyAdmin {\r\n        addTime2Rest = _addTime2Rest;\r\n    }\r\n    function withdrawAllEther() external onlyAdmin {\r\n        require(wallet != address(0), \"Withdraw address can't be zero!\");\r\n        wallet.transfer(address(this).balance);\r\n    }\r\n}\r\n\r\ncontract DragonsFightPlace is DragonsFightGC, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    uint256 public priceToFight = 0.001 ether; // price for test\r\n    uint256 public priceToAdd = 0.0001 ether;  // price for test\r\n    mapping(uint256 => address) dragonOwners;\r\n    mapping(address => uint256) public ownerDragonsCount;\r\n    mapping(uint256 => uint256) public dragonsListIndex;\r\n    uint256[] public dragonsList;\r\n    \r\n    \r\n    constructor(address payable _wallet) public {\r\n        wallet = _wallet;\r\n    }\r\n\r\n    \r\n    function addToFightPlace(uint256 _dragonID) external payable whenNotPaused nonReentrant {\r\n        require(mainContract.isApprovedOrOwner(msg.sender, _dragonID), \"The sender is not an owner!\");\r\n        require(msg.value >= priceToAdd, \"Not enough ether!\");\r\n        mainContract.checkDragonStatus(_dragonID, 2);\r\n        uint256 valueToReturn = msg.value.sub(priceToAdd);\r\n        if (priceToAdd != 0) {\r\n            wallet.transfer(priceToAdd);\r\n        }\r\n        \r\n        if (valueToReturn != 0) {\r\n            msg.sender.transfer(valueToReturn);\r\n        }\r\n        dragonOwners[_dragonID] = mainContract.ownerOf(_dragonID);\r\n        ownerDragonsCount[dragonOwners[_dragonID]]++;\r\n        dragonsListIndex[_dragonID] = dragonsList.length;\r\n        dragonsList.push(_dragonID);\r\n        mainContract.setCurrentAction(_dragonID, 1);\r\n        emit AddDragonFP(dragonOwners[_dragonID], _dragonID);\r\n        \r\n    }\r\n    \r\n    function delFromFightPlace(uint256 _dragonID) external {\r\n        require(mainContract.isApprovedOrOwner(msg.sender, _dragonID), \"Only the owner or approved address can do this!\");\r\n        emit RemoveDragonFP(dragonOwners[_dragonID], _dragonID);\r\n        _delItem(_dragonID);\r\n    }\r\n\r\n    function fightWithDragon(uint256 _yourDragonID,uint256 _thisDragonID) external payable whenNotPaused nonReentrant {\r\n        require(msg.value >= priceToFight, \"Not enough ether!\");\r\n        require(mainContract.isApprovedOrOwner(msg.sender, _yourDragonID), \"The sender is not an owner!\");\r\n        uint8 stage;\r\n        uint8 currentAction;\r\n        uint256 nextBlock2Action;\r\n        (,stage,currentAction,,nextBlock2Action) = mainContract.dragons(_yourDragonID);\r\n        require(stage >= 2, \"No eggs, No dead dragons!\");\r\n        require(nextBlock2Action <= block.number, \"Dragon is resting!\");\r\n        require(currentAction == 0 || currentAction == 1, \"Dragon is busy!\");\r\n        uint256 valueToReturn = msg.value - priceToFight;\r\n        if (priceToFight != 0) {\r\n            wallet.transfer(priceToFight);\r\n        }\r\n        if (valueToReturn != 0) {\r\n            msg.sender.transfer(valueToReturn);\r\n        }\r\n        if (dragonsFightContract.getWinner(_yourDragonID, _thisDragonID) == _yourDragonID ) {\r\n            _setFightResult(_yourDragonID, _thisDragonID);\r\n            _closeFight(_yourDragonID, _thisDragonID);\r\n            emit FightFP(_yourDragonID, _thisDragonID, mainContract.ownerOf(_yourDragonID), dragonOwners[_thisDragonID]);\r\n        } else {\r\n            _setFightResult(_thisDragonID, _yourDragonID);\r\n            _closeFight(_thisDragonID, _yourDragonID);\r\n            emit FightFP(_thisDragonID, _yourDragonID, dragonOwners[_thisDragonID], mainContract.ownerOf(_yourDragonID));\r\n        }\r\n        _delItem(_thisDragonID);\r\n        if (dragonOwners[_yourDragonID] != address(0))\r\n            _delItem(_yourDragonID);\r\n    }\r\n    function getAllDragonsFight() external view returns(uint256[] memory) {\r\n        return dragonsList;\r\n    }\r\n    function getSlicedDragonsSale(uint256 _firstIndex, uint256 _aboveLastIndex) external view returns(uint256[] memory) {\r\n        require(_firstIndex < dragonsList.length, \"First index greater than totalDragonsToFight!\");\r\n        uint256 lastIndex = _aboveLastIndex;\r\n        if (_aboveLastIndex > dragonsList.length) lastIndex = dragonsList.length;\r\n        require(_firstIndex <= lastIndex, \"First index greater than last!\");\r\n        uint256 resultCount = lastIndex - _firstIndex;\r\n        if (resultCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](resultCount);\r\n            uint256 _dragonIndex;\r\n            uint256 _resultIndex = 0;\r\n\r\n            for (_dragonIndex = _firstIndex; _dragonIndex < lastIndex; _dragonIndex++) {\r\n                result[_resultIndex] = dragonsList[_dragonIndex];\r\n                _resultIndex++;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n    function getFewDragons(uint256[] calldata _dragonIDs) external view returns(uint256[] memory) {\r\n        uint256 dragonCount = _dragonIDs.length;\r\n        if (dragonCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](dragonCount * 3);\r\n            uint256 resultIndex = 0;\r\n\r\n            for (uint256 dragonIndex = 0; dragonIndex < dragonCount; dragonIndex++) {\r\n                uint256 dragonID = _dragonIDs[dragonIndex];\r\n                if (dragonOwners[dragonID] == address(0))\r\n                    continue;\r\n                result[resultIndex++] = dragonID;\r\n                uint8 dragonStage;\r\n                (,dragonStage,,,) = mainContract.dragons(dragonID);\r\n                result[resultIndex++] = uint256(dragonStage);\r\n                result[resultIndex++] = uint256(dragonOwners[dragonID]);\r\n            }\r\n            return result; \r\n        }\r\n    }\r\n    function getAddressDragons(address _owner) external view returns(uint256[] memory) {\r\n        uint256 dragonCount = ownerDragonsCount[_owner];\r\n        if (dragonCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](dragonCount * 2);\r\n            uint256 resultIndex = 0;\r\n\r\n            for (uint256 dragonIndex = 0; dragonIndex < dragonsList.length; dragonIndex++) {\r\n                uint256 dragonID = dragonsList[dragonIndex];\r\n                if (_owner != dragonOwners[dragonID])\r\n                    continue;\r\n                result[resultIndex++] = dragonID;\r\n                uint8 dragonStage;\r\n                (,dragonStage,,,) = mainContract.dragons(dragonID);\r\n                result[resultIndex++] = uint256(dragonStage);\r\n            }\r\n            return result; \r\n        }\r\n    }\r\n    function totalDragonsToFight() external view returns(uint256) {\r\n        return dragonsList.length;\r\n    }\r\n    function _delItem(uint256 _dragonID) private {\r\n        require(dragonOwners[_dragonID] != address(0), \"An attempt to remove an unregistered dragon!\");\r\n        mainContract.setCurrentAction(_dragonID, 0);\r\n        ownerDragonsCount[dragonOwners[_dragonID]]--;\r\n        delete(dragonOwners[_dragonID]);\r\n        if (dragonsList.length - 1 != dragonsListIndex[_dragonID]) {\r\n            dragonsList[dragonsListIndex[_dragonID]] = dragonsList[dragonsList.length - 1];\r\n            dragonsListIndex[dragonsList[dragonsList.length - 1]] = dragonsListIndex[_dragonID];\r\n        }\r\n        dragonsList.length--;\r\n        delete(dragonsListIndex[_dragonID]);\r\n    }\r\n    function _setFightResult(uint256 _dragonWin, uint256 _dragonLose) private {\r\n        dragonsStatsContract.incFightWin(_dragonWin);\r\n        dragonsStatsContract.incFightLose(_dragonLose);\r\n        dragonsStatsContract.setLastAction(_dragonWin, _dragonLose, 13);\r\n        dragonsStatsContract.setLastAction(_dragonLose, _dragonWin, 14);\r\n    }\r\n    function _closeFight(uint256 _dragonWin, uint256 _dragonLose) private {\r\n        mainContract.setTime2Rest(_dragonWin, addTime2Rest);\r\n        mainContract.setTime2Rest(_dragonLose, addTime2Rest);\r\n        mutagenContract.mint(mainContract.ownerOf(_dragonWin), mutagenToWin);\r\n        mutagenContract.mint(mainContract.ownerOf(_dragonLose), mutagenToLose);\r\n    }\r\n    function clearFightPlace(uint256[] calldata _dragonIDs) external onlyAdmin whenPaused {\r\n        uint256 dragonCount = _dragonIDs.length;\r\n        for (uint256 dragonIndex = 0; dragonIndex < dragonCount; dragonIndex++) {\r\n            uint256 dragonID = _dragonIDs[dragonIndex];\r\n            if (dragonOwners[dragonID] != address(0))\r\n                _delItem(dragonID);\r\n        }\r\n    }\r\n    function changePrices(uint256 _priceToFight,uint256 _priceToAdd) external onlyAdmin {\r\n        priceToFight = _priceToFight;\r\n        priceToAdd = _priceToAdd;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"AddDragonFP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_winnerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_loserId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ownerWinner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_onwerLoser\",\"type\":\"address\"}],\"name\":\"FightFP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"RemoveDragonFP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_ADMIN\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_PAUSE_ADMIN\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addTime2Rest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dragonID\",\"type\":\"uint256\"}],\"name\":\"addToFightPlace\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminAddRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminRemoveRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addTime2Rest\",\"type\":\"uint256\"}],\"name\":\"changeAddTime2Rest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeAddressFightContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeAddressMainContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeAddressMutagenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeAddressStatsContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mutagenToLose\",\"type\":\"uint256\"}],\"name\":\"changeMutagenToLose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mutagenToWin\",\"type\":\"uint256\"}],\"name\":\"changeMutagenToWin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceToFight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceToAdd\",\"type\":\"uint256\"}],\"name\":\"changePrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"changeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_dragonIDs\",\"type\":\"uint256[]\"}],\"name\":\"clearFightPlace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dragonID\",\"type\":\"uint256\"}],\"name\":\"delFromFightPlace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dragonsFightContract\",\"outputs\":[{\"internalType\":\"contract DragonsFight\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dragonsList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dragonsListIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dragonsStatsContract\",\"outputs\":[{\"internalType\":\"contract DragonsStats\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_yourDragonID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_thisDragonID\",\"type\":\"uint256\"}],\"name\":\"fightWithDragon\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getAddressDragons\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllDragonsFight\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_dragonIDs\",\"type\":\"uint256[]\"}],\"name\":\"getFewDragons\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_firstIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_aboveLastIndex\",\"type\":\"uint256\"}],\"name\":\"getSlicedDragonsSale\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainContract\",\"outputs\":[{\"internalType\":\"contract DragonsETH\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mutagenContract\",\"outputs\":[{\"internalType\":\"contract Mutagen\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mutagenToLose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mutagenToWin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerDragonsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceToAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceToFight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDragonsToFight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DragonsFightPlace","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d0d50ae97443aa9615d87129feb9681417e92f41","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://749f08423488a2fda29a612289f3acbbea007de70ae72b77c799c15c903536da"}]}