{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract SwapperFactory {\r\n  address public admin;\r\n  address public swapperLibrary;\r\n\r\n  event SwapPerformed(\r\n    address indexed user\r\n  );\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, 'Only the admin address can call this function.');\r\n    _;\r\n  }\r\n\r\n  constructor(address _swapperLibrary) public {\r\n    admin = msg.sender;\r\n    swapperLibrary = _swapperLibrary;\r\n  }\r\n\r\n  function performSwap(\r\n    address payable user,\r\n    address srcToken,\r\n    address dstToken,\r\n    string memory uniqueId,\r\n    TotlePrimary primary,\r\n    TotlePrimaryUtils.SwapCollection memory swapCollection\r\n  ) public onlyAdmin() {\r\n    require(swapCollection.swaps.length == 1, 'Must only be 1 swap');\r\n    require(swapCollection.swaps[0].trades[0].sourceToken == srcToken, 'Incorrect source token for swap');\r\n    require(swapCollection.swaps[0].redirectAddress == user, 'User address does not match swap redirect address');\r\n\r\n    Swapper swapper = createClone(user, srcToken, dstToken, uniqueId);\r\n\r\n    require(swapper.getBalance(srcToken) > 0, 'Swapper balance empty');\r\n    require(swapCollection.swaps[0].sourceAmount == swapper.getBalance(srcToken), 'Token balance does not match swap amount');\r\n\r\n    if (srcToken != address(0)) {\r\n      address tokenTransferProxy = 0x74758AcFcE059f503a7E6B0fC2c8737600f9F2c4;\r\n      swapper.approve(srcToken, tokenTransferProxy);\r\n    }\r\n\r\n    swapper.swap(primary, swapCollection);\r\n    swapper.destroy(user);\r\n\r\n    emit SwapPerformed(user);\r\n  }\r\n\r\n  function claimBalance(\r\n    address payable user,\r\n    address srcToken,\r\n    address dstToken,\r\n    string memory uniqueId,\r\n    address token\r\n  ) public onlyAdmin() {\r\n    Swapper swapper = createClone(user, srcToken, dstToken, uniqueId);\r\n    swapper.claimBalance(user, token);\r\n    swapper.destroy(user);\r\n  }\r\n\r\n  function createClone(\r\n    address user,\r\n    address srcToken,\r\n    address dstToken,\r\n    string memory uniqueId\r\n  ) private onlyAdmin() returns (Swapper) {\r\n    bytes32 salt = computeCloneSalt(user, srcToken, dstToken, uniqueId);\r\n    bytes memory bytecode = getCloneBytecode();\r\n\r\n    address payable cloneAddress = computeAddress(salt);\r\n    if (!isContract(cloneAddress)) {\r\n      assembly {\r\n        cloneAddress := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\r\n      }\r\n    }\r\n\r\n    return Swapper(cloneAddress);\r\n  }\r\n\r\n  function getCloneBytecode() public view returns (bytes memory) {\r\n    bytes20 targetBytes = bytes20(swapperLibrary);\r\n\r\n    bytes memory bytecode = new bytes(0x37);\r\n    assembly {\r\n      mstore(add(bytecode, 0x20), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(bytecode, 0x34), targetBytes)\r\n      mstore(add(bytecode, 0x48), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n    }\r\n\r\n    return bytecode;\r\n  }\r\n\r\n  function isContract(address _address) public view returns (bool) {\r\n    uint32 size;\r\n    assembly {\r\n      size := extcodesize(_address)\r\n    }\r\n    return (size > 0);\r\n  }\r\n\r\n  function computeCloneSalt(address user, address srcToken, address dstToken, string memory uniqueId) public pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(user, srcToken, dstToken, uniqueId));\r\n  }\r\n\r\n  function computeAddress(bytes32 salt) public view returns (address payable) {\r\n    bytes32 data = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(getCloneBytecode())));\r\n    return address(bytes20(data << 96));\r\n  }\r\n}\r\n\r\ncontract Swapper {\r\n  function swap(\r\n    TotlePrimary primary,\r\n    TotlePrimaryUtils.SwapCollection calldata swapCollection\r\n  ) external {\r\n    primary.performSwapCollection.value(address(this).balance)(swapCollection);\r\n  }\r\n\r\n  function approve(address token, address spender) public {\r\n    ERC20(token).approve(spender, getBalance(token));\r\n  }\r\n\r\n  function getBalance(address token) public view returns (uint256) {\r\n    return token == address(0)\r\n      ? address(this).balance\r\n      : ERC20(token).balanceOf(address(this));\r\n  }\r\n\r\n  function claimBalance(address payable user, address token) external {\r\n    uint256 balance = getBalance(token);\r\n    if (balance == 0)\r\n      return;\r\n\r\n    if (token == address(0)) {\r\n      user.transfer(balance);\r\n    } else {\r\n      ERC20(token).transfer(user, balance);\r\n    }\r\n  }\r\n\r\n  function destroy(address payable user) external {\r\n    selfdestruct(user);\r\n  }\r\n\r\n  function() external payable {\r\n\r\n  }\r\n}\r\n\r\ncontract ERC20 {\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender) public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n  function decimals() public view returns (uint256);\r\n}\r\n\r\ncontract TotlePrimary {\r\n  function performSwapCollection(\r\n    TotlePrimaryUtils.SwapCollection calldata swaps\r\n  ) external payable {\r\n\r\n  }\r\n}\r\n\r\nlibrary TotlePrimaryUtils {\r\n  struct Order {\r\n    address payable exchangeHandler;\r\n    bytes encodedPayload;\r\n  }\r\n\r\n  struct Trade {\r\n    address sourceToken;\r\n    address destinationToken;\r\n    uint256 amount;\r\n    bool isSourceAmount; //true if amount is sourceToken, false if it's destinationToken\r\n    Order[] orders;\r\n  }\r\n\r\n  struct Swap {\r\n    Trade[] trades;\r\n    uint256 minimumExchangeRate;\r\n    uint256 minimumDestinationAmount;\r\n    uint256 sourceAmount;\r\n    uint256 tradeToTakeFeeFrom;\r\n    bool takeFeeFromSource; //Takes the fee before the trade if true, takes it after if false\r\n    address payable redirectAddress;\r\n    bool required;\r\n  }\r\n\r\n  struct SwapCollection {\r\n    Swap[] swaps;\r\n    address payable partnerContract;\r\n    uint256 expirationBlock;\r\n    bytes32 id;\r\n    uint256 maxGasPrice;\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapperLibrary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"SwapPerformed\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"computeAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"}],\"name\":\"computeCloneSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCloneBytecode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"},{\"internalType\":\"contract TotlePrimary\",\"name\":\"primary\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSourceAmount\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"exchangeHandler\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encodedPayload\",\"type\":\"bytes\"}],\"internalType\":\"struct TotlePrimaryUtils.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TotlePrimaryUtils.Trade[]\",\"name\":\"trades\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minimumExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDestinationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradeToTakeFeeFrom\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"takeFeeFromSource\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"redirectAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"required\",\"type\":\"bool\"}],\"internalType\":\"struct TotlePrimaryUtils.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address payable\",\"name\":\"partnerContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct TotlePrimaryUtils.SwapCollection\",\"name\":\"swapCollection\",\"type\":\"tuple\"}],\"name\":\"performSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapperLibrary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SwapperFactory","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006adcf6b00b73162fd16606dca8db621216825c75","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://1d20d98992fc4cc742c5a58676adc770f5d3f956c748a2fc9bc3f39d0f203a8e"}]}