{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\tlibrary SafeMath {\r\n\r\n\t  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tif (a == 0) {\r\n\t\t  return 0;\r\n\t\t}\r\n\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t  }\r\n\r\n\t  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a / b;\r\n\t  }\r\n\r\n\t  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t  }\r\n\r\n\t  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t  }\r\n\t}\r\n\t\r\n\tcontract ReentrancyGuard {\r\n\r\n\tuint256 private guardCounter = 1;\r\n\t\tmodifier nonReentrant() {\r\n\t\t\tguardCounter += 1;\r\n\t\t\tuint256 localCounter = guardCounter;\r\n\t\t\t_;\r\n\t\t\trequire(localCounter == guardCounter);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tinterface ERC165 {\r\n\t  function supportsInterface(bytes4 _interfaceId)\r\n\t\texternal view\treturns (bool);\r\n\t}\r\n\r\n\tcontract ERC721Receiver {\r\n\t  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\r\n\t  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data)\r\n\t\tpublic returns(bytes4);\r\n\t}\r\n\r\n\tlibrary AddressUtils {\r\n\t  function isContract(address addr) internal view returns (bool) {\r\n\t\tuint256 size;\r\n\t\tassembly { size := extcodesize(addr) }\r\n\t\treturn size > 0;\r\n\t  }\r\n\t}\r\n\r\n\tcontract Ownable {\r\n\t  address public owner;\r\n\r\n\t  event OwnershipRenounced(address indexed previousOwner);\r\n\t  event OwnershipTransferred(\r\n\t\taddress indexed previousOwner,\r\n\t\taddress indexed newOwner\r\n\t  );\r\n\r\n\t  constructor() public {\r\n\t\towner = msg.sender;\r\n\t  }\r\n\r\n\t  modifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t  }\r\n\r\n\t  function renounceOwnership() public onlyOwner {\r\n\t\temit OwnershipRenounced(owner);\r\n\t\towner = address(0);\r\n\t  }\r\n\r\n\t  function transferOwnership(address _newOwner) public onlyOwner {\r\n\t\t_transferOwnership(_newOwner);\r\n\t  }\r\n\r\n\t  function _transferOwnership(address _newOwner) internal {\r\n\t\trequire(_newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, _newOwner);\r\n\t\towner = _newOwner;\r\n\t  }\r\n\t}\r\n\r\n\tcontract SupportsInterfaceWithLookup is ERC165 {\r\n\t  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n\r\n\t  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n\t  constructor() public {_registerInterface(InterfaceId_ERC165);}\r\n\r\n\t  function supportsInterface(bytes4 _interfaceId)\r\n\t\texternal view returns (bool) {return supportedInterfaces[_interfaceId];\r\n\t  }\r\n\r\n\t  function _registerInterface(bytes4 _interfaceId) internal {\r\n\t\trequire(_interfaceId != 0xffffffff);\r\n\t\tsupportedInterfaces[_interfaceId] = true;\r\n\t  }\r\n\t}\r\n\r\n\tcontract ERC721Basic is ERC165 {\r\n\t  event Transfer(address indexed _from,\taddress indexed _to, uint256 indexed _tokenId);\r\n\t  event Approval(address indexed _owner, address indexed _approved,\tuint256 indexed _tokenId);\r\n\t  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n\t  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n\t  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n\t  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n\t  function approve(address _to, uint256 _tokenId) public;\r\n\t  function getApproved(uint256 _tokenId)\r\n\t\tpublic view returns (address _operator);\r\n\r\n\t  function setApprovalForAll(address _operator, bool _approved) public;\r\n\t  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n\t  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\t  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\tpublic;\r\n\r\n\t  function safeTransferFrom(\r\n\t\taddress _from, address _to,\tuint256 _tokenId,\tbytes _data)\r\n\t\tpublic;\r\n\t}\r\n\r\n\tcontract ERC721Enumerable is ERC721Basic {\r\n\t  function totalSupply() public view returns (uint256);\r\n\t  function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n\t\tpublic view\treturns (uint256 _tokenId);\r\n\t  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n\t}\r\n\r\n\tcontract ERC721Metadata is ERC721Basic {\r\n\t  function name() external view returns (string _name);\r\n\t  function symbol() external view returns (string _symbol);\r\n\t  function tokenURI(uint256 _tokenId) public view returns (string);\r\n\t}\r\n\r\n\tcontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {}\r\n\r\n\tcontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\r\n\r\n\t  bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;\r\n\t  bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n\t  using SafeMath for uint256;\r\n\t  using AddressUtils for address;\r\n\t  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n\t  mapping (uint256 => address) internal tokenOwner;\r\n\t  mapping (uint256 => address) internal tokenApprovals;\r\n\t  mapping (address => uint256) internal ownedTokensCount;\r\n\t  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\t  modifier onlyOwnerOf(uint256 _tokenId) {\r\n\t\trequire(ownerOf(_tokenId) == msg.sender);\r\n\t\t_;\r\n\t  }\r\n\r\n\t  modifier canTransfer(uint256 _tokenId) {\r\n\t\trequire(isApprovedOrOwner(msg.sender, _tokenId));\r\n\t\t_;\r\n\t  }\r\n\r\n\t  constructor() public {\r\n\t\t_registerInterface(InterfaceId_ERC721);\r\n\t\t_registerInterface(InterfaceId_ERC721Exists);\r\n\t  }\r\n\r\n\t  function balanceOf(address _owner) public view returns (uint256) {\r\n\t\trequire(_owner != address(0));\r\n\t\treturn ownedTokensCount[_owner];\r\n\t  }\r\n\r\n\t  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n\t\taddress owner = tokenOwner[_tokenId];\r\n\t\trequire(owner != address(0));\r\n\t\treturn owner;\r\n\t  }\r\n\r\n\t  function exists(uint256 _tokenId) public view returns (bool) {\r\n\t\taddress owner = tokenOwner[_tokenId];\r\n\t\treturn owner != address(0);\r\n\t  }\r\n\r\n\t  function approve(address _to, uint256 _tokenId) public {\r\n\t\taddress owner = ownerOf(_tokenId);\r\n\t\trequire(_to != owner);\r\n\t\trequire(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\t\ttokenApprovals[_tokenId] = _to;\r\n\t\temit Approval(owner, _to, _tokenId);\r\n\t  }\r\n\r\n\t  function getApproved(uint256 _tokenId) public view returns (address) {\r\n\t\treturn tokenApprovals[_tokenId];\r\n\t  }\r\n\r\n\t  function setApprovalForAll(address _to, bool _approved) public {\r\n\t\trequire(_to != msg.sender);\r\n\t\toperatorApprovals[msg.sender][_to] = _approved;\r\n\t\temit ApprovalForAll(msg.sender, _to, _approved);\r\n\t  }\r\n\r\n\t  function isApprovedForAll(address _owner,\taddress _operator)\tpublic view\treturns (bool)\r\n\t  {return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n\t  function transferFrom(address _from, address _to,\tuint256 _tokenId)\tpublic canTransfer(_tokenId) {\r\n\t\trequire(_from != address(0));\r\n\t\trequire(_to != address(0));\r\n\t\tclearApproval(_from, _tokenId);\r\n\t\tremoveTokenFrom(_from, _tokenId);\r\n\t\taddTokenTo(_to, _tokenId);\r\n\t\temit Transfer(_from, _to, _tokenId);\r\n\t  }\r\n\r\n\t  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\r\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\r\n\t  }\r\n\r\n\t  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public canTransfer(_tokenId) {\r\n\t\ttransferFrom(_from, _to, _tokenId);\r\n\t\trequire(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n\t  }\r\n\r\n\t  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n\t\taddress owner = ownerOf(_tokenId);\r\n\t\treturn (\r\n\t\t  _spender == owner ||\r\n\t\t  getApproved(_tokenId) == _spender ||\r\n\t\t  isApprovedForAll(owner, _spender)\r\n\t\t);\r\n\t  }\r\n\r\n\t  function _mint(address _to, uint256 _tokenId) internal {\r\n\t\trequire(_to != address(0));\r\n\t\taddTokenTo(_to, _tokenId);\r\n\t\temit Transfer(address(0), _to, _tokenId);\r\n\t  }\r\n\r\n\t  function _burn(address _owner, uint256 _tokenId) internal {\r\n\t\tclearApproval(_owner, _tokenId);\r\n\t\tremoveTokenFrom(_owner, _tokenId);\r\n\t\temit Transfer(_owner, address(0), _tokenId);\r\n\t  }\r\n\r\n\t  function clearApproval(address _owner, uint256 _tokenId) internal {\r\n\t\trequire(ownerOf(_tokenId) == _owner);\r\n\t\tif (tokenApprovals[_tokenId] != address(0)) {\r\n\t\t  tokenApprovals[_tokenId] = address(0);\r\n\t\t}\r\n\t  }\r\n\r\n\t  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n\t\trequire(tokenOwner[_tokenId] == address(0));\r\n\t\ttokenOwner[_tokenId] = _to;\r\n\t\townedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n\t  }\r\n\r\n\t  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n\t\trequire(ownerOf(_tokenId) == _from);\r\n\t\townedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n\t\ttokenOwner[_tokenId] = address(0);\r\n\t  }\r\n\r\n\t  function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes _data) internal returns (bool) {\r\n\t\tif (!_to.isContract()) {return true;\r\n    }\r\n\r\n\t\tbytes4 retval = ERC721Receiver(_to).onERC721Received(\r\n\t\tmsg.sender, _from, _tokenId, _data);\r\n\t\treturn (retval == ERC721_RECEIVED);\r\n\t  }\r\n\t}\r\n\r\n\tcontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\r\n\r\n\t  bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n\t  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n\t  string internal name_;\r\n\t  string internal symbol_;\r\n\t  mapping(address => uint256[]) internal ownedTokens;\r\n\t  mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\t  uint256[] internal allTokens;\r\n\t  mapping(uint256 => uint256) internal allTokensIndex;\r\n\t  mapping(uint256 => string) internal tokenURIs;\r\n\r\n\t  constructor(string _name, string _symbol) public {\r\n\t\tname_ = _name;\r\n\t\tsymbol_ = _symbol;\r\n\t\t_registerInterface(InterfaceId_ERC721Enumerable);\r\n\t\t_registerInterface(InterfaceId_ERC721Metadata);\r\n\t  }\r\n\r\n\t  function name() external view returns (string) {return name_;}\r\n\r\n\t  function symbol() external view returns (string) {return symbol_;}\r\n\r\n\t  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n      require(_index < balanceOf(_owner));\r\n      return ownedTokens[_owner][_index];\r\n\t  }\r\n\r\n\t  function totalSupply() public view returns (uint256) {\r\n      return allTokens.length;\r\n\t  }\r\n\r\n\t  function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n      require(_index < totalSupply());\r\n      return allTokens[_index];\r\n\t  }\r\n\r\n\t  function _setTokenURI(uint256 _tokenId, string _uri) internal {\r\n      require(exists(_tokenId));\r\n      tokenURIs[_tokenId] = _uri;\r\n\t  }\r\n\r\n\t  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n      super.addTokenTo(_to, _tokenId);\r\n      uint256 length = ownedTokens[_to].length;\r\n      ownedTokens[_to].push(_tokenId);\r\n      ownedTokensIndex[_tokenId] = length;\r\n\t  }\r\n\r\n\t  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n      super.removeTokenFrom(_from, _tokenId);\r\n      uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n      uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n      uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n      ownedTokens[_from][tokenIndex] = lastToken;\r\n      ownedTokens[_from][lastTokenIndex] = 0;\r\n      ownedTokens[_from].length--;\r\n      ownedTokensIndex[_tokenId] = 0;\r\n      ownedTokensIndex[lastToken] = tokenIndex;\r\n\t  }\r\n\r\n\t  function _mint(address _to, uint256 _tokenId) internal {\r\n      super._mint(_to, _tokenId);\r\n      allTokensIndex[_tokenId] = allTokens.length;\r\n      allTokens.push(_tokenId);\r\n\t  }\r\n\r\n\t  function _burn(address _owner, uint256 _tokenId) internal {\r\n      super._burn(_owner, _tokenId);\r\n      if (bytes(tokenURIs[_tokenId]).length != 0) {\r\n        delete tokenURIs[_tokenId];\r\n\t\t}\r\n\r\n\t\tuint256 tokenIndex = allTokensIndex[_tokenId];\r\n\t\tuint256 lastTokenIndex = allTokens.length.sub(1);\r\n\t\tuint256 lastToken = allTokens[lastTokenIndex];\r\n\t\tallTokens[tokenIndex] = lastToken;\r\n\t\tallTokens[lastTokenIndex] = 0;\r\n\t\tallTokens.length--;\r\n\t\tallTokensIndex[_tokenId] = 0;\r\n\t\tallTokensIndex[lastToken] = tokenIndex;\r\n\t  }\r\n\t}\r\n\r\n\tcontract Memes is ERC721Token, Ownable {\r\n\r\n    constructor() ERC721Token(\"0xBitcoinMemes\", \"0xMEME\") public {\r\n        addIpfs(\"IPFS_INIT\"); // easy management of tokenIDs and edits 1=1\r\n    }\r\n\r\n    // CONSTANTS\r\n    address client;\r\n    uint256 max_supply = 1000;\r\n    string baseurl = \"https://ipfs.io/ipfs/\";\r\n\r\n    struct IpfsAddress {\r\n      uint ipfsID;\r\n      string ipfsHash;\r\n    }\r\n\r\n    uint numIpfs;\r\n    mapping (uint => IpfsAddress) ipfsaddresses;\r\n\r\n    function addIpfs(string _ipfshash) internal {\r\n        uint ipfsID = numIpfs++;\r\n        ipfsaddresses[ipfsID] = IpfsAddress(ipfsID, _ipfshash);\r\n    }\r\n\r\n    function getIpfs(uint get_ipfsID) external view returns (uint nof_addresses, uint _ipfsID, string _ipfsHash) {\r\n        IpfsAddress storage i = ipfsaddresses[get_ipfsID];\r\n        nof_addresses = numIpfs;\r\n        _ipfsID = i.ipfsID;\r\n        _ipfsHash = i.ipfsHash;\r\n    }\r\n\r\n    function editIpfs(uint ipfsID, string newHash) external onlyOwner {\r\n        ipfsaddresses[ipfsID] = IpfsAddress(ipfsID, newHash);\r\n    }\r\n\r\n    function manageBaseURL(string new_baseurl) public onlyOwner {\r\n      baseurl = new_baseurl;\r\n    }\r\n\r\n    function viewBaseURL() public view returns (string base_url) {\r\n      base_url = baseurl;\r\n    }\r\n\r\n    event BoughtToken(address indexed buyer, uint256 tokenId);\r\n\r\n    function moreSupply() internal view returns (bool moreOK) {\r\n      moreOK = true;\r\n      if (allTokens.length + 1 > max_supply) {moreOK = false;}\r\n      return moreOK;\r\n    }\r\n\r\n\t  function mintToken (string ipfs) onlyOwner external {\r\n      uint256 index = allTokens.length + 1;\r\n      require(moreSupply() == true, \"All allowed tokens have been created already!\");\r\n      addIpfs(ipfs);\r\n      _mint(msg.sender, index);\r\n      emit BoughtToken(msg.sender, index);\r\n    }\r\n\r\n\t  function mintTokenForClient (address _client, string ipfs) onlyOwner external {\r\n      uint256 index = allTokens.length + 1;\r\n      require(moreSupply() == true, \"All allowed tokens have been minted already!\");\r\n      addIpfs(ipfs);\r\n      _mint(_client, index);\r\n      emit BoughtToken(_client, index);\r\n\t  }\r\n\r\n\t  function transferOwnTokens (uint256[] _ids, address _to) external {\r\n          uint256 n_tokens = _ids.length;\r\n          address _from = msg.sender;\r\n          require(_to != address(0));\r\n    \r\n          for (uint it = 0; it < n_tokens; it++) {\r\n            require(isApprovedOrOwner(msg.sender, _ids[it]));}\t\r\n          for (uint i = 0; i < n_tokens; i++) {\r\n            clearApproval(_from, _ids[i]);\r\n            removeTokenFrom(_from, _ids[i]);\r\n            addTokenTo(_to, _ids[i]);\r\n            emit Transfer(_from, _to, _ids[i]);}\r\n\t  }\r\n\r\n\t  function myTokens() external view returns (uint256[]) {\r\n  \t\treturn ownedTokens[msg.sender];\r\n\t  }\r\n\r\n    function uintTostr(uint i) internal pure returns (string){\r\n      if (i == 0) return \"0\"; uint j = i; uint length;\r\n      while (j != 0){length++;j /= 10;} bytes memory bstr = new bytes(length); uint k = length - 1;\r\n      while (i != 0){bstr[k--] = byte(48 + i % 10);i /= 10;}\r\n      return string(bstr);\r\n    }\r\n\r\n    function tokenURI(uint256 _ID) public view returns (string URI) {\r\n      require(exists(_ID));\r\n      IpfsAddress storage i = ipfsaddresses[_ID];\r\n      string storage ipfs = i.ipfsHash;\r\n      URI = string(abi.encodePacked(baseurl, ipfs));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ipfs\",\"type\":\"string\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_baseurl\",\"type\":\"string\"}],\"name\":\"manageBaseURL\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_client\",\"type\":\"address\"},{\"name\":\"ipfs\",\"type\":\"string\"}],\"name\":\"mintTokenForClient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"get_ipfsID\",\"type\":\"uint256\"}],\"name\":\"getIpfs\",\"outputs\":[{\"name\":\"nof_addresses\",\"type\":\"uint256\"},{\"name\":\"_ipfsID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewBaseURL\",\"outputs\":[{\"name\":\"base_url\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ipfsID\",\"type\":\"uint256\"},{\"name\":\"newHash\",\"type\":\"string\"}],\"name\":\"editIpfs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ID\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"URI\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"BoughtToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"Memes","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://13927f04022007b8b364a019a550ac4dfb46c871cd1631b4d9752bfb073895d2"}]}