{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\nlibrary AddressArray{\r\n  function exists(address[] storage self, address addr) public view returns(bool){\r\n    for (uint i = 0; i< self.length;i++){\r\n      if (self[i]==addr){\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function index_of(address[] storage self, address addr) public view returns(uint){\r\n    for (uint i = 0; i< self.length;i++){\r\n      if (self[i]==addr){\r\n        return i;\r\n      }\r\n    }\r\n    require(false, \"AddressArray:index_of, not exist\");\r\n  }\r\n\r\n  function remove(address[] storage self, address addr) public returns(bool){\r\n    uint index = index_of(self, addr);\r\n    self[index] = self[self.length - 1];\r\n\r\n    delete self[self.length-1];\r\n    self.length--;\r\n  }\r\n\r\n  function replace(address[] storage self, address old_addr, address new_addr) public returns(bool){\r\n    uint index = index_of(self, old_addr);\r\n    self[index] = new_addr;\r\n  }\r\n}\r\n\r\ncontract MultiSigInterface{\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\r\n  function is_signer(address addr) public view returns(bool);\r\n}\r\n\r\ncontract MultiSigTools{\r\n  MultiSigInterface public multisig_contract;\r\n  constructor(address _contract) public{\r\n    require(_contract!= address(0x0));\r\n    multisig_contract = MultiSigInterface(_contract);\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(multisig_contract.is_signer(msg.sender), \"only a signer can call in MultiSigTools\");\r\n    _;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n  }\r\n\r\n  event TransferMultiSig(address _old, address _new);\r\n\r\n  function transfer_multisig(uint64 id, address _contract) public only_signer\r\n  is_majority_sig(id, \"transfer_multisig\"){\r\n    require(_contract != address(0x0));\r\n    address old = address(multisig_contract);\r\n    multisig_contract = MultiSigInterface(_contract);\r\n    emit TransferMultiSig(old, _contract);\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract AddressList{\r\n  using AddressArray for address[];\r\n  mapping(address => bool) private address_status;\r\n  address[] public addresses;\r\n\r\n  constructor() public{}\r\n\r\n  function get_all_addresses() public view returns(address[] memory){\r\n    return addresses;\r\n  }\r\n\r\n  function get_address(uint i) public view returns(address){\r\n    require(i < addresses.length, \"AddressList:get_address, out of range\");\r\n    return addresses[i];\r\n  }\r\n\r\n  function get_address_num() public view returns(uint){\r\n    return addresses.length;\r\n  }\r\n\r\n  function is_address_exist(address addr) public view returns(bool){\r\n    return address_status[addr];\r\n  }\r\n\r\n  function _add_address(address addr) internal{\r\n    if(address_status[addr]) return;\r\n    address_status[addr] = true;\r\n    addresses.push(addr);\r\n  }\r\n\r\n  function _remove_address(address addr) internal{\r\n    if(!address_status[addr]) return;\r\n    address_status[addr] = false;\r\n    addresses.remove(addr);\r\n  }\r\n\r\n  function _reset() internal{\r\n    for(uint i = 0; i < addresses.length; i++){\r\n      address_status[addresses[i]] = false;\r\n    }\r\n    delete addresses;\r\n  }\r\n}\r\n\r\ncontract TrustList is AddressList, MultiSigTools{\r\n\r\n  event AddTrust(address addr);\r\n  event RemoveTrust(address addr);\r\n\r\n  constructor(address[] memory _list, address _multisig) public MultiSigTools(_multisig){\r\n    for(uint i = 0; i < _list.length; i++){\r\n      _add_address(_list[i]);\r\n    }\r\n  }\r\n\r\n  function is_trusted(address addr) public view returns(bool){\r\n    return is_address_exist(addr);\r\n  }\r\n\r\n  function get_trusted(uint i) public view returns(address){\r\n    return get_address(i);\r\n  }\r\n\r\n  function get_trusted_num() public view returns(uint){\r\n    return get_address_num();\r\n  }\r\n\r\n  function add_trusted(uint64 id, address addr) public\r\n    only_signer is_majority_sig(id, \"add_trusted\"){\r\n    _add_address(addr);\r\n    emit AddTrust(addr);\r\n  }\r\n  function add_multi_trusted(uint64 id, address[] memory _list) public\r\n    only_signer is_majority_sig(id, \"add_multi_trusted\"){\r\n    for(uint i = 0; i < _list.length; i++){\r\n      _add_address(_list[i]);\r\n      emit AddTrust(_list[i]);\r\n    }\r\n  }\r\n\r\n  function remove_trusted(uint64 id, address addr) public\r\n    only_signer is_majority_sig(id, \"remove_trusted\"){\r\n    _remove_address(addr);\r\n    emit RemoveTrust(addr);\r\n  }\r\n\r\n  function remove_multi_trusted(uint64 id, address[] memory _list) public\r\n  only_signer is_majority_sig(id, \"remove_multi_trusted\"){\r\n    for(uint i = 0; i < _list.length; i++){\r\n      _remove_address(_list[i]);\r\n      emit RemoveTrust(_list[i]);\r\n    }\r\n  }\r\n}\r\n\r\ncontract TrustListFactory{\r\n  event NewTrustList(address addr, address[] list, address multisig);\r\n\r\n  function createTrustList(address[] memory _list, address _multisig) public returns(address){\r\n    TrustList tl = new TrustList(_list, _multisig);\r\n    emit NewTrustList(address(tl), _list, _multisig);\r\n    return address(tl);\r\n  }\r\n}\r\n\r\ncontract IERC20AuctionOpProxy {\r\n  function add_auction(address _auction) public;\r\n  function apply_bid(address addr, uint amount, uint price, uint price_unit) public;\r\n  function revoke_bid(address addr, uint amount, uint price, uint price_unit) public;\r\n  function apply_auction(address addr, uint amount, uint price, uint price_unit) public;\r\n  function object_token() public view returns(address, string memory);\r\n  function object_total_amount() public view returns(uint);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract TransferableToken{\r\n    function balanceOf(address _owner) public returns (uint256 balance) ;\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) ;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) ;\r\n}\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        TransferableToken token = TransferableToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, balance));\r\n        require(status, \"call failed\");\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\ncontract ERC20TokenBankInterface{\r\n  function balance() public view returns(uint);\r\n  function token() public view returns(address, string memory);\r\n  function issue(address _to, uint _amount) public returns (bool success);\r\n}\r\n\r\ncontract ERC20AuctionOpProxy is AddressList, IERC20AuctionOpProxy, MultiSigTools{\r\n  using SafeMath for uint;\r\n\r\n  ERC20TokenBankInterface public object_erc20_pool;\r\n  address public exchange_erc20_token;\r\n  address public benifit_pool;\r\n\r\n  address public auction_mgr_contract;\r\n\r\n  constructor(address _object_erc20_pool,\r\n              address _exchange_erc20_token,\r\n              address _benifit_pool,\r\n             address _auction_mgr,\r\n             address _multisig) public AddressList()\r\n             MultiSigTools(_multisig){\r\n\r\n    object_erc20_pool = ERC20TokenBankInterface(_object_erc20_pool);\r\n    exchange_erc20_token = _exchange_erc20_token;\r\n    benifit_pool = _benifit_pool;\r\n    auction_mgr_contract = _auction_mgr;\r\n  }\r\n\r\n\r\n  function add_auction(address _auction) public{\r\n    require (msg.sender == auction_mgr_contract, \"only auction mgr can op this\");\r\n    _add_address(_auction);\r\n  }\r\n\r\n  function apply_bid(address addr, uint amount, uint price, uint price_unit) public{\r\n    require(is_address_exist(msg.sender), \"only trusted auction contract can op this\");\r\n\r\n    uint total = amount.safeMul(price).safeDiv(price_unit);\r\n    //exchange_deposit_pool.lock(addr, total);\r\n    TransferableToken token = TransferableToken(exchange_erc20_token);\r\n    uint old_balance = token.balanceOf(address(this));\r\n    (bool ret, ) = exchange_erc20_token.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addr, address(this), total));\r\n    require(ret, \"ERC20AuctionOpProxy, transferFrom return false. Please make sure you have enough token and approved them for auction.\");\r\n    uint new_balance = token.balanceOf(address(this));\r\n    require(new_balance == old_balance + total, \"ERC20TokenAuctionOpProxy, apply_bid, invalid bid\");\r\n  }\r\n\r\n  function revoke_bid(address addr, uint amount, uint price, uint price_unit) public{\r\n    require(is_address_exist(msg.sender), \"only trusted auction contract can op this\");\r\n    uint old_total = amount.safeMul(price).safeDiv(price_unit);\r\n\r\n    (bool ret, ) = exchange_erc20_token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", addr, old_total));\r\n    require(ret, \"ERC20AuctionOpProxy, revoke_bid, transfer return false\");\r\n    //exchange_deposit_pool.unlock(addr, old_total);\r\n  }\r\n\r\n  function apply_auction(address addr, uint amount, uint price, uint price_unit) public{\r\n    require(is_address_exist(msg.sender), \"only trusted auction contract can op this\");\r\n    uint total = amount.safeMul(price).safeDiv(price_unit);\r\n\r\n    TransferableToken token = TransferableToken(exchange_erc20_token);\r\n    uint old_balance = token.balanceOf(benifit_pool);\r\n    (bool ret, ) = exchange_erc20_token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", benifit_pool, total));\r\n    require(ret, \"ERC20AuctionOpProxy, apply_auction, transfer return false\");\r\n    uint new_balance = token.balanceOf(benifit_pool);\r\n    require(new_balance == old_balance + total, \"ERC20AuctionOpProxy, apply_auction, invalid transfer\");\r\n\r\n    //exchange_deposit_pool.outside_transfer(addr, benifit_pool, total);\r\n    //exchange_deposit_pool.unlock(addr, total);\r\n    object_erc20_pool.issue(addr, amount);\r\n  }\r\n\r\n  function object_token() public view returns(address, string memory){\r\n    return object_erc20_pool.token();\r\n  }\r\n  function object_total_amount() public view returns(uint){\r\n    return object_erc20_pool.balance();\r\n  }\r\n\r\n  event ChangeObjectERC20Pool(address old_addr, address new_addr);\r\n  function change_object_erc20_pool(uint64 id, address new_pool) public only_signer is_majority_sig(id, \"change_object_erc20_pool\"){\r\n    require(new_pool != address(0x0), \"invalid address\");\r\n    address old_addr = address(object_erc20_pool);\r\n    object_erc20_pool = ERC20TokenBankInterface(new_pool);\r\n\r\n    emit ChangeObjectERC20Pool(old_addr, new_pool);\r\n  }\r\n\r\n  event ChangeBenifitPool(address old_addr, address new_addr);\r\n  function change_benifit_pool(uint64 id, address new_pool) public only_signer is_majority_sig(id, \"change_benifit_pool\"){\r\n    require(new_pool != address(0x0), \"invalid address\");\r\n    address old = benifit_pool;\r\n    benifit_pool = new_pool;\r\n    emit ChangeBenifitPool(old, benifit_pool);\r\n  }\r\n}\r\n\r\ncontract ERC20AuctionOpProxyFactory{\r\n  event NewERC20AuctionOpProxy(address addr);\r\n  function createERC20AuctionOpProxy(address _object_erc20_pool,\r\n              address _exchange_erc20_token,\r\n              address _benifit_pool, address _auction_mgr, address _multisig) public returns(address){\r\n                ERC20AuctionOpProxy proxy = new ERC20AuctionOpProxy(_object_erc20_pool,\r\n                                                                   _exchange_erc20_token, _benifit_pool, _auction_mgr, _multisig);\r\n\r\n                emit NewERC20AuctionOpProxy(address(proxy));\r\n                return address(proxy);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_object_erc20_pool\",\"type\":\"address\"},{\"name\":\"_exchange_erc20_token\",\"type\":\"address\"},{\"name\":\"_benifit_pool\",\"type\":\"address\"},{\"name\":\"_auction_mgr\",\"type\":\"address\"},{\"name\":\"_multisig\",\"type\":\"address\"}],\"name\":\"createERC20AuctionOpProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NewERC20AuctionOpProxy\",\"type\":\"event\"}]","ContractName":"ERC20AuctionOpProxyFactory","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"SafeMath:a37426cdca2be3d52c950d5ca1ffac842b89b06a","LicenseType":"MIT","SwarmSource":"bzzr://9b9537726441273c4407a4070537212b25dd479da51f474083eba36f026d7a23"}]}