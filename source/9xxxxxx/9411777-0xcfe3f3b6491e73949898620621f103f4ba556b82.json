{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\npragma experimental ABIEncoderV2;\n// File: @airswap/types/contracts/Types.sol\n/*\n  Copyright 2020 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n/**\n  * @title Types: Library of Swap Protocol Types and Hashes\n  */\nlibrary Types {\n  bytes constant internal EIP191_HEADER = \"\\x19\\x01\";\n  struct Order {\n    uint256 nonce;                // Unique per order and should be sequential\n    uint256 expiry;               // Expiry in seconds since 1 January 1970\n    Party signer;                 // Party to the trade that sets terms\n    Party sender;                 // Party to the trade that accepts terms\n    Party affiliate;              // Party compensated for facilitating (optional)\n    Signature signature;          // Signature of the order\n  }\n  struct Party {\n    bytes4 kind;                  // Interface ID of the token\n    address wallet;               // Wallet address of the party\n    address token;                // Contract address of the token\n    uint256 amount;               // Amount for ERC-20 or ERC-1155\n    uint256 id;                   // ID for ERC-721 or ERC-1155\n  }\n  struct Signature {\n    address signatory;            // Address of the wallet used to sign\n    address validator;            // Address of the intended swap contract\n    bytes1 version;               // EIP-191 signature version\n    uint8 v;                      // `v` value of an ECDSA signature\n    bytes32 r;                    // `r` value of an ECDSA signature\n    bytes32 s;                    // `s` value of an ECDSA signature\n  }\n  bytes32 constant internal DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\n    \"EIP712Domain(\",\n    \"string name,\",\n    \"string version,\",\n    \"address verifyingContract\",\n    \")\"\n  ));\n  bytes32 constant internal ORDER_TYPEHASH = keccak256(abi.encodePacked(\n    \"Order(\",\n    \"uint256 nonce,\",\n    \"uint256 expiry,\",\n    \"Party signer,\",\n    \"Party sender,\",\n    \"Party affiliate\",\n    \")\",\n    \"Party(\",\n    \"bytes4 kind,\",\n    \"address wallet,\",\n    \"address token,\",\n    \"uint256 amount,\",\n    \"uint256 id\",\n    \")\"\n  ));\n  bytes32 constant internal PARTY_TYPEHASH = keccak256(abi.encodePacked(\n    \"Party(\",\n    \"bytes4 kind,\",\n    \"address wallet,\",\n    \"address token,\",\n    \"uint256 amount,\",\n    \"uint256 id\",\n    \")\"\n  ));\n  /**\n    * @notice Hash an order into bytes32\n    * @dev EIP-191 header and domain separator included\n    * @param order Order The order to be hashed\n    * @param domainSeparator bytes32\n    * @return bytes32 A keccak256 abi.encodePacked value\n    */\n  function hashOrder(\n    Order calldata order,\n    bytes32 domainSeparator\n  ) external pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\n      EIP191_HEADER,\n      domainSeparator,\n      keccak256(abi.encode(\n        ORDER_TYPEHASH,\n        order.nonce,\n        order.expiry,\n        keccak256(abi.encode(\n          PARTY_TYPEHASH,\n          order.signer.kind,\n          order.signer.wallet,\n          order.signer.token,\n          order.signer.amount,\n          order.signer.id\n        )),\n        keccak256(abi.encode(\n          PARTY_TYPEHASH,\n          order.sender.kind,\n          order.sender.wallet,\n          order.sender.token,\n          order.sender.amount,\n          order.sender.id\n        )),\n        keccak256(abi.encode(\n          PARTY_TYPEHASH,\n          order.affiliate.kind,\n          order.affiliate.wallet,\n          order.affiliate.token,\n          order.affiliate.amount,\n          order.affiliate.id\n        ))\n      ))\n    ));\n  }\n  /**\n    * @notice Hash domain parameters into bytes32\n    * @dev Used for signature validation (EIP-712)\n    * @param name bytes\n    * @param version bytes\n    * @param verifyingContract address\n    * @return bytes32 returns a keccak256 abi.encodePacked value\n    */\n  function hashDomain(\n    bytes calldata name,\n    bytes calldata version,\n    address verifyingContract\n  ) external pure returns (bytes32) {\n    return keccak256(abi.encode(\n      DOMAIN_TYPEHASH,\n      keccak256(name),\n      keccak256(version),\n      verifyingContract\n    ));\n  }\n}\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n// File: openzeppelin-solidity/contracts/introspection/ERC165Checker.sol\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function _supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function _supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return _supportsERC165(account) &&\n            _supportsERC165Interface(account, interfaceId);\n    }\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function _supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!_supportsERC165(account)) {\n            return false;\n        }\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n        // all interfaces supported\n        return true;\n    }\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with the `supportsERC165` method in this library.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // success determines whether the staticcall succeeded and result determines\n        // whether the contract at account indicates support of _interfaceId\n        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);\n        return (success && result);\n    }\n    /**\n     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return success true if the STATICCALL succeeded, false otherwise\n     * @return result true if the STATICCALL succeeded and the contract at account\n     * indicates support of the interface with identifier interfaceId, false otherwise\n     */\n    function _callERC165SupportsInterface(address account, bytes4 interfaceId)\n        private\n        view\n        returns (bool success, bool result)\n    {\n        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encodedParams_data := add(0x20, encodedParams)\n            let encodedParams_size := mload(encodedParams)\n            let output := mload(0x40)    // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(\n                30000,                   // 30k gas\n                account,                 // To addr\n                encodedParams_data,\n                encodedParams_size,\n                output,\n                0x20                     // Outputs are 32 bytes long\n            )\n            result := mload(output)      // Load the result\n        }\n    }\n}\n// File: @airswap/transfers/contracts/interfaces/ITransferHandler.sol\n/*\n  Copyright 2020 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n/**\n  * @title ITransferHandler: interface for token transfers\n  */\ninterface ITransferHandler {\n /**\n  * @notice Function to wrap token transfer for different token types\n  * @param from address Wallet address to transfer from\n  * @param to address Wallet address to transfer to\n  * @param amount uint256 Amount for ERC-20\n  * @param id token ID for ERC-721\n  * @param token address Contract address of token\n  * @return bool on success of the token transfer\n  */\n  function transferTokens(\n    address from,\n    address to,\n    uint256 amount,\n    uint256 id,\n    address token\n  ) external returns (bool);\n}\n// File: openzeppelin-solidity/contracts/GSN/Context.sol\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n// File: @airswap/transfers/contracts/TransferHandlerRegistry.sol\n/*\n  Copyright 2020 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n/**\n  * @title TransferHandlerRegistry: holds registry of contract to\n  * facilitate token transfers\n  */\ncontract TransferHandlerRegistry is Ownable {\n  event AddTransferHandler(\n    bytes4 kind,\n    address contractAddress\n  );\n  // Mapping of bytes4 to contract interface type\n  mapping (bytes4 => ITransferHandler) public transferHandlers;\n  /**\n  * @notice Adds handler to mapping\n  * @param kind bytes4 Key value that defines a token type\n  * @param transferHandler ITransferHandler\n  */\n  function addTransferHandler(bytes4 kind, ITransferHandler transferHandler)\n    external onlyOwner {\n      require(address(transferHandlers[kind]) == address(0), \"HANDLER_EXISTS_FOR_KIND\");\n      transferHandlers[kind] = transferHandler;\n      emit AddTransferHandler(kind, address(transferHandler));\n    }\n}\n// File: @airswap/swap/contracts/interfaces/ISwap.sol\n/*\n  Copyright 2020 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\ninterface ISwap {\n  event Swap(\n    uint256 indexed nonce,\n    uint256 timestamp,\n    address indexed signerWallet,\n    uint256 signerAmount,\n    uint256 signerId,\n    address signerToken,\n    address indexed senderWallet,\n    uint256 senderAmount,\n    uint256 senderId,\n    address senderToken,\n    address affiliateWallet,\n    uint256 affiliateAmount,\n    uint256 affiliateId,\n    address affiliateToken\n  );\n  event Cancel(\n    uint256 indexed nonce,\n    address indexed signerWallet\n  );\n  event CancelUpTo(\n    uint256 indexed nonce,\n    address indexed signerWallet\n  );\n  event AuthorizeSender(\n    address indexed authorizerAddress,\n    address indexed authorizedSender\n  );\n  event AuthorizeSigner(\n    address indexed authorizerAddress,\n    address indexed authorizedSigner\n  );\n  event RevokeSender(\n    address indexed authorizerAddress,\n    address indexed revokedSender\n  );\n  event RevokeSigner(\n    address indexed authorizerAddress,\n    address indexed revokedSigner\n  );\n  /**\n    * @notice Atomic Token Swap\n    * @param order Types.Order\n    */\n  function swap(\n    Types.Order calldata order\n  ) external;\n  /**\n    * @notice Cancel one or more open orders by nonce\n    * @param nonces uint256[]\n    */\n  function cancel(\n    uint256[] calldata nonces\n  ) external;\n  /**\n    * @notice Cancels all orders below a nonce value\n    * @dev These orders can be made active by reducing the minimum nonce\n    * @param minimumNonce uint256\n    */\n  function cancelUpTo(\n    uint256 minimumNonce\n  ) external;\n  /**\n    * @notice Authorize a delegated sender\n    * @param authorizedSender address\n    */\n  function authorizeSender(\n    address authorizedSender\n  ) external;\n  /**\n    * @notice Authorize a delegated signer\n    * @param authorizedSigner address\n    */\n  function authorizeSigner(\n    address authorizedSigner\n  ) external;\n  /**\n    * @notice Revoke an authorization\n    * @param authorizedSender address\n    */\n  function revokeSender(\n    address authorizedSender\n  ) external;\n  /**\n    * @notice Revoke an authorization\n    * @param authorizedSigner address\n    */\n  function revokeSigner(\n    address authorizedSigner\n  ) external;\n  function senderAuthorizations(address, address) external view returns (bool);\n  function signerAuthorizations(address, address) external view returns (bool);\n  function signerNonceStatus(address, uint256) external view returns (byte);\n  function signerMinimumNonce(address) external view returns (uint256);\n  function registry() external view returns (TransferHandlerRegistry);\n}\n// File: @airswap/tokens/contracts/interfaces/IWETH.sol\ninterface IWETH {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// File: @airswap/delegate/contracts/interfaces/IDelegate.sol\n/*\n  Copyright 2020 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\ninterface IDelegate {\n  struct Rule {\n    uint256 maxSenderAmount;      // The maximum amount of ERC-20 token the delegate would send\n    uint256 priceCoef;            // Number to be multiplied by 10^(-priceExp) - the price coefficient\n    uint256 priceExp;             // Indicates location of the decimal priceCoef * 10^(-priceExp)\n  }\n  event SetRule(\n    address indexed owner,\n    address indexed senderToken,\n    address indexed signerToken,\n    uint256 maxSenderAmount,\n    uint256 priceCoef,\n    uint256 priceExp\n  );\n  event UnsetRule(\n    address indexed owner,\n    address indexed senderToken,\n    address indexed signerToken\n  );\n  event ProvideOrder(\n    address indexed owner,\n    address tradeWallet,\n    address indexed senderToken,\n    address indexed signerToken,\n    uint256 senderAmount,\n    uint256 priceCoef,\n    uint256 priceExp\n  );\n  function setRule(\n    address senderToken,\n    address signerToken,\n    uint256 maxSenderAmount,\n    uint256 priceCoef,\n    uint256 priceExp\n  ) external;\n  function unsetRule(\n    address senderToken,\n    address signerToken\n  ) external;\n  function provideOrder(\n    Types.Order calldata order\n  ) external;\n  function rules(address, address) external view returns (Rule memory);\n  function getSignerSideQuote(\n    uint256 senderAmount,\n    address senderToken,\n    address signerToken\n  ) external view returns (\n    uint256 signerAmount\n  );\n  function getSenderSideQuote(\n    uint256 signerAmount,\n    address signerToken,\n    address senderToken\n  ) external view returns (\n    uint256 senderAmount\n  );\n  function getMaxQuote(\n    address senderToken,\n    address signerToken\n  ) external view returns (\n    uint256 senderAmount,\n    uint256 signerAmount\n  );\n  function owner()\n    external view returns (address);\n  function tradeWallet()\n    external view returns (address);\n}\n// File: contracts/PreSwapChecker.sol\n/**\n  * @title PreSwapChecker: Helper contract to Swap protocol\n  * @notice contains several helper methods that check whether\n  * a Swap.order is well-formed and counterparty criteria is met\n  */\ncontract PreSwapChecker {\n  using ERC165Checker for address;\n  bytes constant internal DOM_NAME = \"SWAP\";\n  bytes constant internal DOM_VERSION = \"2\";\n  bytes4 constant internal ERC721_INTERFACE_ID = 0x80ac58cd;\n  bytes4 constant internal ERC20_INTERFACE_ID = 0x36372b07;\n  IWETH public wethContract;\n  /**\n    * @notice Contract Constructor\n    * @param preSwapCheckerWethContract address\n    */\n  constructor(\n    address preSwapCheckerWethContract\n  ) public {\n    wethContract = IWETH(preSwapCheckerWethContract);\n  }\n  /**\n    * @notice If order is going through delegate via provideOrder\n    * ensure necessary checks are set\n    * @param order Types.Order\n    * @param delegate IDelegate\n    * @return uint256 errorCount if any\n    * @return bytes32[] memory array of error messages\n    */\n  function checkSwapDelegate(\n    Types.Order calldata order,\n    IDelegate delegate\n    ) external view returns (uint256, bytes32[] memory ) {\n    bytes32[] memory errors = new bytes32[](20);\n    uint256 errorCount;\n    address swap = order.signature.validator;\n    IDelegate.Rule memory rule = delegate.rules(order.sender.token,order.signer.token);\n    (uint256 swapErrorCount, bytes32[] memory swapErrors) = checkSwapSwap(order, false);\n    if (swapErrorCount > 0) {\n      errorCount = swapErrorCount;\n      // copies over errors from checkSwapSwap to be outputted\n      for (uint256 i = 0; i < swapErrorCount; i++) {\n        errors[i] = swapErrors[i];\n      }\n    }\n    // signature must be filled in order to use the Delegate\n    if (order.signature.v == 0) {\n      errors[errorCount] = \"SIGNATURE_MUST_BE_SENT\";\n      errorCount++;\n    }\n    // check that the sender.wallet == tradewallet\n    if (order.sender.wallet != delegate.tradeWallet()) {\n      errors[errorCount] = \"SENDER_WALLET_INVALID\";\n      errorCount++;\n    }\n    // ensure signer kind is ERC20\n    if (order.signer.kind != ERC20_INTERFACE_ID) {\n      errors[errorCount] = \"SIGNER_KIND_MUST_BE_ERC20\";\n      errorCount++;\n    }\n    // ensure sender kind is ERC20\n    if (order.sender.kind != ERC20_INTERFACE_ID) {\n      errors[errorCount] = \"SENDER_KIND_MUST_BE_ERC20\";\n      errorCount++;\n    }\n    // ensure that token pair is active with non-zero maxSenderAmount\n    if (rule.maxSenderAmount == 0) {\n      errors[errorCount] = \"TOKEN_PAIR_INACTIVE\";\n      errorCount++;\n    }\n    if (order.sender.amount > rule.maxSenderAmount) {\n      errors[errorCount] = \"ORDER_AMOUNT_EXCEEDS_MAX\";\n      errorCount++;\n    }\n    // calls the getSenderSize quote to determine how much needs to be paid\n    uint256 senderAmount = delegate.getSenderSideQuote(order.signer.amount, order.signer.token, order.sender.token);\n    if (senderAmount == 0) {\n      errors[errorCount] = \"DELEGATE_UNABLE_TO_PRICE\";\n      errorCount++;\n    } else if (order.sender.amount > senderAmount) {\n      errors[errorCount] = \"PRICE_INVALID\";\n      errorCount++;\n    }\n    // ensure that tradeWallet has approved delegate contract on swap\n    if (!ISwap(swap).senderAuthorizations(order.sender.wallet, address(delegate))) {\n      errors[errorCount] = \"SENDER_UNAUTHORIZED\";\n      errorCount++;\n    }\n    return (errorCount, errors);\n  }\n  /**\n    * @notice If order is going through wrapper to swap\n    * @param order Types.Order\n    * @param fromAddress address\n    * @param wrapper address\n    * @return uint256 errorCount if any\n    * @return bytes32[] memory array of error messages\n    */\n  function checkSwapWrapper(\n    Types.Order calldata order,\n    address fromAddress,\n    address wrapper\n    ) external view returns (uint256, bytes32[] memory ) {\n    address swap = order.signature.validator;\n    // max size of the number of errors that could exist\n    bytes32[] memory errors = new bytes32[](20);\n    uint256 errorCount;\n    (uint256 swapErrorCount, bytes32[] memory swapErrors) = checkSwapSwap(order, true);\n    if (swapErrorCount > 0) {\n      errorCount = swapErrorCount;\n      // copies over errors from checkSwapSwap to be outputted\n      for (uint256 i = 0; i < swapErrorCount; i++) {\n        errors[i] = swapErrors[i];\n      }\n    }\n    if (order.sender.wallet != fromAddress) {\n      errors[errorCount] = \"MSG_SENDER_MUST_BE_ORDER_SENDER\";\n      errorCount++;\n    }\n    // ensure that sender has approved wrapper contract on swap\n    if (!ISwap(swap).senderAuthorizations(order.sender.wallet, wrapper)) {\n      errors[errorCount] = \"SENDER_UNAUTHORIZED\";\n      errorCount++;\n    }\n    // signature must be filled in order to use the Wrapper\n    if (order.signature.v == 0) {\n      errors[errorCount] = \"SIGNATURE_MUST_BE_SENT\";\n      errorCount++;\n    }\n    // if sender has WETH token, ensure sufficient ETH balance\n    if (order.sender.token == address(wethContract)) {\n      if (address(order.sender.wallet).balance < order.sender.amount) {\n        errors[errorCount] = \"SENDER_INSUFFICIENT_ETH\";\n        errorCount++;\n      }\n    }\n    // ensure that sender wallet if receiving weth has approved\n    // the wrapper to transfer weth and deliver eth to the sender\n    if (order.signer.token == address(wethContract)) {\n      uint256 allowance = wethContract.allowance(order.sender.wallet, wrapper);\n      if (allowance < order.signer.amount) {\n        errors[errorCount] = \"LOW_SENDER_ALLOWANCE_ON_WRAPPER\";\n        errorCount++;\n      }\n    }\n    return (errorCount, errors);\n  }\n  /**\n    * @notice Takes in an order and outputs any\n    * errors that Swap would revert on\n    * @param order Types.Order Order to settle\n    * @return uint256 errorCount if any\n    * @return bytes32[] memory array of error messages\n    */\n  function checkSwapSwap(\n    Types.Order memory order,\n    bool usingWrapper\n  ) public view returns (uint256, bytes32[] memory) {\n    address swap = order.signature.validator;\n    bytes32 domainSeparator = Types.hashDomain(DOM_NAME, DOM_VERSION, swap);\n    // max size of the number of errors that could exist\n    bytes32[] memory errors = new bytes32[](14);\n    uint256 errorCount;\n    // Check self transfer\n    if (order.signer.wallet == order.sender.wallet) {\n      errors[errorCount] = \"SELF_TRANSFER_INVALID\";\n      errorCount++;\n    }\n    // Check expiry\n    if (order.expiry < block.timestamp) {\n      errors[errorCount] = \"ORDER_EXPIRED\";\n      errorCount++;\n    }\n    if (ISwap(swap).signerNonceStatus(order.signer.wallet, order.nonce) != 0x00) {\n      errors[errorCount] = \"ORDER_TAKEN_OR_CANCELLED\";\n      errorCount++;\n    }\n    if (order.nonce < ISwap(swap).signerMinimumNonce(order.signer.wallet)) {\n      errors[errorCount] = \"NONCE_TOO_LOW\";\n      errorCount++;\n    }\n    // check if ERC721 or ERC20 only amount or id set for sender\n    if (order.sender.kind == ERC20_INTERFACE_ID && order.sender.id != 0) {\n      errors[errorCount] = \"SENDER_INVALID_ID\";\n      errorCount++;\n    } else if (order.sender.kind == ERC721_INTERFACE_ID && order.sender.amount != 0) {\n      errors[errorCount] = \"SENDER_INVALID_AMOUNT\";\n      errorCount++;\n    }\n    // check if ERC721 or ERC20 only amount or id set for signer\n    if (order.signer.kind == ERC20_INTERFACE_ID && order.signer.id != 0) {\n      errors[errorCount] = \"SIGNER_INVALID_ID\";\n      errorCount++;\n    } else if (order.signer.kind == ERC721_INTERFACE_ID && order.signer.amount != 0) {\n      errors[errorCount] = \"SIGNER_INVALID_AMOUNT\";\n      errorCount++;\n    }\n    // Check valid token registry handler for sender\n    if (hasValidKind(order.sender.kind, swap)) {\n      // Check the order sender\n      if (order.sender.wallet != address(0)) {\n        // The sender was specified\n        // Check if sender kind interface can correctly check balance\n        if (order.sender.kind == ERC721_INTERFACE_ID && !hasValidERC71Interface(order.sender.token)) {\n          errors[errorCount] = \"SENDER_INVALID_ERC721\";\n          errorCount++;\n        } else {\n          // Check the order sender token balance\n          if ((usingWrapper && order.sender.token != address(wethContract)) || !usingWrapper) {\n            //do the balance check\n            if (!hasBalance(order.sender)) {\n              errors[errorCount] = \"SENDER_BALANCE\";\n              errorCount++;\n            }\n          }\n          // Check their approval\n          if (!isApproved(order.sender, swap)) {\n            errors[errorCount] = \"SENDER_ALLOWANCE\";\n            errorCount++;\n          }\n        }\n      }\n    } else {\n      errors[errorCount] = \"SENDER_TOKEN_KIND_UNKNOWN\";\n      errorCount++;\n    }\n     // Check valid token registry handler for signer\n    if (hasValidKind(order.signer.kind, swap)) {\n      // Check if sender kind interface can correctly check balance\n      if (order.signer.kind == ERC721_INTERFACE_ID && !hasValidERC71Interface(order.signer.token)) {\n        errors[errorCount] = \"SIGNER_INVALID_ERC721\";\n        errorCount++;\n      } else {\n        // Check the order signer token balance\n        if (!hasBalance(order.signer)) {\n          errors[errorCount] = \"SIGNER_BALANCE\";\n          errorCount++;\n        }\n        // Check their approval\n        if (!isApproved(order.signer, swap)) {\n          errors[errorCount] = \"SIGNER_ALLOWANCE\";\n          errorCount++;\n        }\n      }\n    } else {\n      errors[errorCount] = \"SIGNER_TOKEN_KIND_UNKNOWN\";\n      errorCount++;\n    }\n    if (!isValid(order, domainSeparator)) {\n      errors[errorCount] = \"SIGNATURE_INVALID\";\n      errorCount++;\n    }\n    if (order.signature.signatory != order.signer.wallet) {\n      if(!ISwap(swap).signerAuthorizations(order.signer.wallet, order.signature.signatory)) {\n        errors[errorCount] = \"SIGNER_UNAUTHORIZED\";\n        errorCount++;\n      }\n    }\n    return (errorCount, errors);\n  }\n  /**\n    * @notice Checks if kind is found in\n    * Swap's Token Registry\n    * @param kind bytes4 token type to search for\n    * @param swap address Swap contract address\n    * @return bool whether kind inserted is valid\n    */\n  function hasValidKind(\n    bytes4 kind,\n    address swap\n  ) internal view returns (bool) {\n    TransferHandlerRegistry tokenRegistry = ISwap(swap).registry();\n    return (address(tokenRegistry.transferHandlers(kind)) != address(0));\n  }\n  /**\n    * @notice Checks token has valid ERC721 interface\n    * @param tokenAddress address potential ERC721 token address\n    * @return bool whether address has valid interface\n    */\n  function hasValidERC71Interface(\n    address tokenAddress\n  ) internal view returns (bool) {\n    return (tokenAddress._supportsInterface(ERC721_INTERFACE_ID));\n  }\n  /**\n    * @notice Check a party has enough balance to swap\n    * for ERC721 and ERC20 tokens\n    * @param party Types.Party party to check balance for\n    * @return bool whether party has enough balance\n    */\n  function hasBalance(\n    Types.Party memory party\n  ) internal view returns (bool) {\n    if (party.kind == ERC721_INTERFACE_ID) {\n      address owner = IERC721(party.token).ownerOf(party.id);\n      return (owner == party.wallet);\n    }\n    uint256 balance = IERC20(party.token).balanceOf(party.wallet);\n    return (balance >= party.amount);\n  }\n  /**\n    * @notice Check a party has enough allowance to swap\n    * for ERC721 and ERC20 tokens\n    * @param party Types.Party party to check allowance for\n    * @param swap address Swap address\n    * @return bool whether party has sufficient allowance\n    */\n  function isApproved(\n    Types.Party memory party,\n    address swap\n  ) internal view returns (bool) {\n    if (party.kind == ERC721_INTERFACE_ID) {\n      address approved = IERC721(party.token).getApproved(party.id);\n      return (swap == approved);\n    }\n    uint256 allowance = IERC20(party.token).allowance(party.wallet, swap);\n    return (allowance >= party.amount);\n  }\n  /**\n    * @notice Check order signature is valid\n    * @param order Types.Order Order to validate\n    * @param domainSeparator bytes32 Domain identifier used in signatures (EIP-712)\n    * @return bool True if order has a valid signature\n    */\n  function isValid(\n    Types.Order memory order,\n    bytes32 domainSeparator\n  ) internal pure returns (bool) {\n    if (order.signature.v == 0) {\n      return true;\n    }\n    if (order.signature.version == byte(0x01)) {\n      return order.signature.signatory == ecrecover(\n        Types.hashOrder(\n          order,\n          domainSeparator\n        ),\n        order.signature.v,\n        order.signature.r,\n        order.signature.s\n      );\n    }\n    if (order.signature.version == byte(0x45)) {\n      return order.signature.signatory == ecrecover(\n        keccak256(\n          abi.encodePacked(\n            \"\\x19Ethereum Signed Message:\\n32\",\n            Types.hashOrder(order, domainSeparator)\n          )\n        ),\n        order.signature.v,\n        order.signature.r,\n        order.signature.s\n      );\n    }\n    return false;\n  }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"preSwapCheckerWethContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"signer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"affiliate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"version\",\"type\":\"bytes1\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Types.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"contract IDelegate\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"checkSwapDelegate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"signer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"affiliate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"version\",\"type\":\"bytes1\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Types.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"usingWrapper\",\"type\":\"bool\"}],\"name\":\"checkSwapSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"signer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"affiliate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"version\",\"type\":\"bytes1\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Types.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"}],\"name\":\"checkSwapWrapper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethContract\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PreSwapChecker","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","Library":"Types:a42d613d8b8b6cb9507f46a5dd3fd98276570fd7","LicenseType":"","SwarmSource":"bzzr://6b7cbf54cd2796f7437be50ffa2be5ad99e9794f8e7a2d531eadd48f4e6f0051"}]}