{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    // counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * NOTE: This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\nlibrary DateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        uint year;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        uint year;\n        uint month;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        uint fromYear;\n        uint fromMonth;\n        uint fromDay;\n        uint toYear;\n        uint toMonth;\n        uint toDay;\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        uint fromYear;\n        uint fromMonth;\n        uint fromDay;\n        uint toYear;\n        uint toMonth;\n        uint toDay;\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\ncontract BaseSubscription is ReentrancyGuard, Initializable {\n  using SafeMath for uint;\n  using ECDSA for bytes32;\n  enum Plan { Invalid, Standard, Pro, Premium, Enterprise }\n  enum TransactionType { Subscribe, Unsubscribe, UpgradePlan, DowngradePlan, ExtendSubscription }\n\n  struct Subscription {\n    uint startTimestamp;\n    uint depositValue;\n    bool canceled;\n    Plan plan;\n    uint index;\n  }\n  mapping(address => Subscription) public subscriptions;\n  address[] public sortedSubscriptions;\n  uint startIndex;\n\n  struct Billing {\n    uint previousClearingDate;\n    uint incomeSpeed;\n  }\n  Billing public billing;\n\n  address payable public transactionSplitBox;\n  address payable public serviceProvider;\n  address public ticketProvider;\n  uint public duration;\n  uint internal constant MULTI = 10**18;\n\n  modifier onlyServiceProvider() {\n    require(msg.sender == serviceProvider, 'only serviceProvider');\n    _;\n  }\n\n  event Subscribed(address indexed user, Plan plan, uint price);\n  event Unsubscribed(address indexed user, uint refund);\n  event UpgradedPlan(address indexed user, Plan plan);\n  event DowngradedPlan(address indexed user, Plan plan, uint refund);\n  event ExtendedSubscription(address indexed user, uint newExpiration);\n  event Transaction(address indexed wallet, TransactionType indexed transactionType, Plan plan, uint amount, uint timestamp);\n\n  function initialize(\n    address payable _serviceProvider,\n    address payable _transactionSplitBox,\n    address _ticketProvider,\n    uint _duration\n  ) public initializer {\n    require(_ticketProvider != address(0), \"ticketProvider cannot be empty\");\n    require(_duration != 0 && _duration % 365 days == 0, \"should be multiple of the year\");\n    serviceProvider = _serviceProvider;\n    transactionSplitBox = _transactionSplitBox;\n    ticketProvider = _ticketProvider;\n    duration = _duration;\n  }\n\n  function subscribe(\n    Plan _plan,\n    uint _price,\n    uint _ticketExpiration,\n    address _contractAddress,\n    bytes calldata _signature\n  ) external payable {\n    _validateTicket(_plan, _price, _ticketExpiration, _contractAddress, _signature);\n    Subscription storage subscription = subscriptions[msg.sender];\n    require(subscription.startTimestamp == 0 || subscription.canceled, \"you still have going subscription\");\n    subscription.depositValue = _price;\n    subscription.startTimestamp = currentTime();\n    subscription.plan = _plan;\n\n    _subscribe(_price);\n\n    if (subscription.canceled) {\n      subscription.canceled = false;\n      sortedSubscriptions[subscription.index] = address(0);\n    }\n\n    // update subscriptions list\n    subscription.index = sortedSubscriptions.length;\n    sortedSubscriptions.push(msg.sender);\n\n    // if it's first customer we should initialize timestamp that takes part of billing caclulations\n    if (billing.previousClearingDate == 0) {\n      billing.previousClearingDate = currentTime();\n    }\n\n    emit Subscribed(msg.sender, _plan, _price);\n    emit Transaction(msg.sender, TransactionType.Subscribe, _plan, _price, now);\n  }\n\n  function _subscribe(uint _price) internal;\n\n  function getSubscriptionStatus(address _account) public view returns(\n    uint leftMonths,\n    uint usedMonths,\n    uint monthlyPayment,\n    uint balance,\n    Plan plan,\n    uint expiration,\n    bool isCanceled\n  ) {\n    uint totalMonths = duration / 365 days * 12;\n    Subscription storage subscription = subscriptions[_account];\n    if (subscription.startTimestamp == 0) {\n      // subscription does not exist\n      return (leftMonths, usedMonths, monthlyPayment, balance, plan, expiration, isCanceled);\n    }\n    expiration = _getExpiration(subscription);\n    if (currentTime() >= subscription.startTimestamp && currentTime() < expiration) {\n      // this subscription goes\n      leftMonths = _diffMonths(currentTime(), expiration);\n      usedMonths = totalMonths.sub(leftMonths);\n    } else { // if (currentTime() >= expiration)\n      // this subscription is expired\n      leftMonths = 0;\n      usedMonths = totalMonths;\n    }\n    monthlyPayment = subscription.depositValue.div(totalMonths);\n    if (subscription.canceled) {\n      balance = 0;\n    } else {\n      balance = subscription.depositValue.sub(usedMonths.mul(monthlyPayment));\n    }\n    plan = subscription.plan;\n    isCanceled = subscription.canceled;\n  }\n\n  function _diffMonths(uint from, uint to) internal pure returns(uint numberOfMonths) {\n    numberOfMonths = DateTimeLibrary.diffMonths(from, to);\n    (,,uint fromDay, uint fromHour, uint fromMinute, uint fromSecond) = DateTimeLibrary.timestampToDateTime(from);\n    (,,uint toDay, uint toHour, uint toMinute, uint toSecond) = DateTimeLibrary.timestampToDateTime(to);\n    if (numberOfMonths != 0) {\n      if (fromDay > toDay) {\n        numberOfMonths--;\n      } else if(fromDay >= toDay && fromHour > toHour) {\n        numberOfMonths--;\n      } else if(fromDay >= toDay && fromHour >= toHour && fromMinute > toMinute) {\n        numberOfMonths--;\n      } else if(fromDay >= toDay && fromHour >= toHour && fromMinute >= toMinute && fromSecond > toSecond) {\n        numberOfMonths--;\n      }\n    }\n  }\n\n  function currentTime() public view returns(uint) {\n    return block.timestamp;\n  }\n\n  function unsubscribe() external {\n    (,,,uint balance,,,) = getSubscriptionStatus(msg.sender);\n    Subscription storage subscription = subscriptions[msg.sender];\n    require(!subscription.canceled, \"subscription is canceled\");\n    _cancelSubscription(subscription);\n\n    // first of all we do withdraw to send all earned ether before\n    // it also makes `billing.previousClearingDate` equal `currentTime()`\n    withdraw();\n\n    // calculate how match ether user still should be charged for current month\n    uint vaultOutcomeSpeed = subscription.depositValue.mul(MULTI).div(duration);\n    uint paidTime = currentTime().sub(subscription.startTimestamp);\n    uint paidEther = vaultOutcomeSpeed.mul(paidTime).div(MULTI);\n    uint etherToCharge = subscription.depositValue.sub(balance).sub(paidEther);\n\n    // then we update incomeSpeed\n    billing.incomeSpeed = billing.incomeSpeed.sub(vaultOutcomeSpeed);\n\n    _payToOwner(etherToCharge);\n    _payToUser(balance);\n\n    emit Unsubscribed(msg.sender, balance);\n    emit Transaction(msg.sender, TransactionType.Unsubscribe, subscription.plan, balance, now);\n  }\n\n  function upgradePlan(\n    Plan _plan,\n    uint _price,\n    uint _ticketExpiration,\n    address _contractAddress,\n    bytes calldata _signature\n  ) external payable {\n    _validateTicket(_plan, _price, _ticketExpiration, _contractAddress, _signature);\n    Subscription storage subscription = subscriptions[msg.sender];\n    uint expiration = _getExpiration(subscription);\n    require(!subscription.canceled, \"subscription is canceled\");\n    require(expiration > currentTime(), \"cannot upgrade. Subscription is over\");\n    require(_plan > subscription.plan, \"cannot upgrade to the same or lower plan, use downgradePlan\");\n    // first of all we do withdraw to send all earned ether before\n    // it also makes `billing.previousClearingDate` equal `currentTime()`\n    withdraw();\n\n    _upgradePlan(_price);\n\n    // then we update the subscription\n    subscription.depositValue = _price;\n    subscription.plan = _plan;\n\n    emit UpgradedPlan(msg.sender, _plan);\n    emit Transaction(msg.sender, TransactionType.UpgradePlan, _plan, _price, now);\n  }\n\n  function _upgradePlan(uint _price) internal;\n\n  /// @dev negative paymentDiff means refund\n  function planPriceDifference(address _user, uint _price) public view returns(\n    uint payment,\n    uint refund,\n    uint incomeSpeedDiff\n  ) {\n    Subscription storage subscription = subscriptions[_user];\n    uint expiration = _getExpiration(subscription);\n    uint oldIncomeSpeed = subscription.depositValue.mul(MULTI).div(duration);\n    uint newIncomeSpeed = _price.mul(MULTI).div(duration);\n    if (oldIncomeSpeed <= newIncomeSpeed) {\n      incomeSpeedDiff = newIncomeSpeed.sub(oldIncomeSpeed);\n      payment = expiration.sub(currentTime()).mul(incomeSpeedDiff).div(MULTI);\n    } else {\n      incomeSpeedDiff = oldIncomeSpeed.sub(newIncomeSpeed);\n      refund = expiration.sub(currentTime()).mul(incomeSpeedDiff).div(MULTI);\n    }\n  }\n\n  function downgradePlan(\n    Plan _plan,\n    uint _price,\n    uint _ticketExpiration,\n    address _contractAddress,\n    bytes calldata _signature\n  ) external {\n    _validateTicket(_plan, _price, _ticketExpiration, _contractAddress, _signature);\n    Subscription storage subscription = subscriptions[msg.sender];\n    uint expiration = _getExpiration(subscription);\n    require(!subscription.canceled, \"subscription is canceled\");\n    require(expiration > currentTime(), \"cannot downgrade. Subscription is over\");\n    require(_plan < subscription.plan, \"cannot downgrade to the same or plan above, use upgradePlan\");\n\n    // first of all we do withdraw to send all earned ether before\n    // it also makes `billing.previousClearingDate` equal `currentTime()`\n    withdraw();\n\n    // calculate how match ether contact should return\n    (uint payment, uint refund, uint incomeSpeedDiff) = planPriceDifference(msg.sender, _price);\n    require(payment == 0, \"New plan should be less expensive\");\n\n    // then we update incomeSpeed and subscription\n    billing.incomeSpeed = billing.incomeSpeed.sub(incomeSpeedDiff);\n    subscription.depositValue = _price;\n    subscription.plan = _plan;\n\n    _payToUser(refund);\n    emit DowngradedPlan(msg.sender, _plan, refund);\n    emit Transaction(msg.sender, TransactionType.DowngradePlan, _plan, refund, now);\n  }\n\n  function extensionPayment(address _user, uint _price) public view returns(\n    uint payment,\n    uint incomeSpeedDiff,\n    uint newDepositValue\n  ) {\n    Subscription storage subscription = subscriptions[_user];\n    uint passedTime = currentTime().sub(subscription.startTimestamp);\n    uint oldIncomeSpeed = subscription.depositValue.mul(MULTI).div(duration);\n    uint newIncomeSpeed = _price.mul(MULTI).div(duration);\n\n    uint paidEther = passedTime.mul(oldIncomeSpeed).div(MULTI);\n    payment = passedTime.mul(newIncomeSpeed).div(MULTI);\n    newDepositValue = subscription.depositValue.sub(paidEther).add(payment);\n    uint extensionIncomeSpeed = newDepositValue.mul(MULTI).div(duration);\n\n    if (oldIncomeSpeed <= extensionIncomeSpeed) {\n      // new price is higher, so we should add this diff to the total income speed.\n      // See the _extendSubscription func\n      incomeSpeedDiff = extensionIncomeSpeed.sub(oldIncomeSpeed);\n    } else {\n      // new price is lower, so we should sub this diff from the total income speed.\n      // See the _extendSubscription func\n      incomeSpeedDiff = oldIncomeSpeed.sub(extensionIncomeSpeed);\n    }\n  }\n  /// @dev The function allows a user to prolong a subscription up to `duration`.\n  /// e.g. A user bought a subscription using `subscribe` func 7 months ago and he still has a 5-month service.\n  /// Today the user can call `extendSubscription` to extend the subscription for 7 months (that passed so far).\n  /// Today's `_price` could be higher, lower or the same.\n  /// So for SubscriptionETH the user should always send a msg.value that equals to `_price` * extension_time .\n  /// For SubscriptionVGT the payment will be withdrawn automatically.\n  function extendSubscription(\n    Plan _plan,\n    uint _price,\n    uint _ticketExpiration,\n    address _contractAddress,\n    bytes calldata _signature\n  ) external payable {\n    _validateTicket(_plan, _price, _ticketExpiration, _contractAddress, _signature);\n    Subscription storage subscription = subscriptions[msg.sender];\n    uint expiration = _getExpiration(subscription);\n    require(!subscription.canceled, \"subscription is canceled\");\n    require(expiration > currentTime(), \"cannot extend. Subscription is over\");\n    require(_plan == subscription.plan, \"cannot extend. The plan should be the same as current one\");\n\n    // first of all we do withdraw to send all earned ether before\n    // it also makes `billing.previousClearingDate` equal `currentTime()`\n    withdraw();\n\n    _extendSubscription(subscription, _price);\n\n    uint newExpiration = currentTime().add(duration);\n    emit ExtendedSubscription(msg.sender, newExpiration);\n    emit Transaction(msg.sender, TransactionType.ExtendSubscription, _plan, _price, now);\n  }\n\n  function _extendSubscription(Subscription storage subscription, uint _price) internal;\n\n  function disableOldestSubsription() public {\n    require(startIndex < sortedSubscriptions.length, \"there is no subscriptions to disable\");\n    address _account = sortedSubscriptions[startIndex];\n    if (_account != address(0)) {\n      Subscription storage subscription = subscriptions[_account];\n      require(_getExpiration(subscription) < currentTime(), \"it's still going subscription\");\n      if (!subscription.canceled) {\n        // how many ether left to charge for this particular subscription ?\n        uint incomeSpeed = subscription.depositValue.mul(MULTI).div(duration);\n        uint paidTime;\n        if (billing.previousClearingDate <= subscription.startTimestamp) {\n          paidTime = 0;\n        } else {\n          paidTime = billing.previousClearingDate.sub(subscription.startTimestamp);\n        }\n        uint chargedEther = incomeSpeed.mul(paidTime).div(MULTI);\n        uint etherToCharge = subscription.depositValue.sub(chargedEther);\n\n        // descrease total incomeSpeed\n        billing.incomeSpeed = billing.incomeSpeed.sub(incomeSpeed);\n\n        _payToOwner(etherToCharge);\n      } // else: subscription was canceled so all the money has been already withdrawn\n\n      _clearSubscription(_account);\n      sortedSubscriptions[startIndex] = address(0);\n    } // else: subscription was extended so we just skip it\n    startIndex++;\n  }\n\n  function disableBatchOfSubsriptions(uint count) external {\n    for(uint i = 0; i < count; i++) {\n      disableOldestSubsription();\n    }\n  }\n\n  /**\n    * @return the address of the Vault12 signing Oracle\n    * @dev msgLength = 1 + 32 + 32 + 20 = 85\n    */\n  function getSignerAddress(\n    Plan _plan,\n    uint256 _price,\n    uint256 _ticketExpiration,\n    address _contractAddress,\n    bytes memory signature\n  )\n    public\n    pure\n    returns (address signer)\n  {\n    bytes32 hash = keccak256(abi.encodePacked(_plan, _price, _ticketExpiration, _contractAddress));\n    bytes32 hashedMsg = hash.toEthSignedMessageHash();\n    signer = hashedMsg.recover(signature);\n  }\n\n  function withdraw() public {\n    while(isOldestSubscriptionExpired()) {\n      disableOldestSubsription();\n    }\n    uint income = approximateIncome();\n    billing.previousClearingDate = currentTime();\n    _payToOwner(income);\n  }\n\n  /// @dev this function gives approximate results\n  // if the `isOldestSubscriptionExpired` returns `true` then the result is totally wrong\n  // exact values and leftovers for particular subscription are calculated during the `disableOldestSubsription` call\n  function approximateIncome() public view returns(uint income) {\n    income = currentTime().sub(billing.previousClearingDate).mul(billing.incomeSpeed).div(MULTI);\n  }\n\n  function _validateTicket(\n    Plan _plan,\n    uint _price,\n    uint _ticketExpiration,\n    address _contractAddress,\n    bytes memory _signature\n  ) internal view {\n    require(address(this) == _contractAddress, \"ticket is signed for different address\");\n    require(_ticketExpiration > currentTime(), \"ticket is expired\");\n    address _ticketProvider = getSignerAddress(_plan, _price, _ticketExpiration, _contractAddress, _signature);\n    require(_ticketProvider == ticketProvider, \"ticket signer is invalid\");\n  }\n\n  /// @dev don't forget to apply the nonReentrant modifier\n  function _payToOwner(uint value) internal;\n\n  /// @dev don't forget to apply the nonReentrant modifier\n  function _payToUser(uint _balance) internal;\n\n  function _clearSubscription(address _user) internal {\n    delete subscriptions[_user];\n  }\n\n  function _cancelSubscription(Subscription storage subscription) internal {\n    subscription.canceled = true;\n  }\n\n  function _getExpiration(Subscription storage subscription) internal view returns(uint) {\n    return subscription.startTimestamp.add(duration);\n  }\n\n  function isOldestSubscriptionExpired() public view returns(bool) {\n    if (startIndex >= sortedSubscriptions.length) {\n      return false;\n    }\n    address user = sortedSubscriptions[startIndex];\n    if (user == address(0)) {\n      // subscription was extended so it was moved within sortedSubscriptions\n      return true;\n    }\n    Subscription storage closestSubscriptionToFinish = subscriptions[user];\n    return _getExpiration(closestSubscriptionToFinish) < currentTime();\n  }\n}\n\ncontract SubscriptionVGT is BaseSubscription {\n  IERC20 public token;\n  using SafeERC20 for IERC20;\n  function initialize(\n    address payable _serviceProvider,\n    address payable _transactionSplitBox,\n    address _ticketProvider,\n    uint _duration,\n    IERC20 _tokenAddress\n  ) public {\n    super.initialize(_serviceProvider, _transactionSplitBox, _ticketProvider, _duration);\n    token = _tokenAddress;\n  }\n\n  function _subscribe(uint _price) internal {\n    require(msg.value == 0, \"this is the VGT subscription, dont send ETH\");\n    token.safeTransferFrom(msg.sender, address(this), _price);\n\n    billing.incomeSpeed = billing.incomeSpeed.add(\n      _price.mul(MULTI).div(duration)\n    );\n  }\n\n  function _upgradePlan(uint _price) internal {\n    require(msg.value == 0, \"this is the VGT subscription, dont send ETH\");\n    // calculate how match ether user should send\n    (uint payment, uint refund, uint incomeSpeedDiff) = planPriceDifference(msg.sender, _price);\n    if (payment > 0) {\n      token.safeTransferFrom(msg.sender, address(this), payment);\n      billing.incomeSpeed = billing.incomeSpeed.add(incomeSpeedDiff);\n    } else if (refund > 0) {\n      billing.incomeSpeed = billing.incomeSpeed.sub(incomeSpeedDiff);\n      _payToUser(refund);\n    } else {\n      require(refund == 0 && payment == 0);\n    }\n  }\n\n  function _extendSubscription(Subscription storage subscription, uint _price) internal {\n    require(msg.value == 0, \"this is the VGT subscription, dont send ETH\");\n\n    (uint payment, uint incomeSpeedDiff, uint newDepositValue) = extensionPayment(msg.sender, _price);\n    token.safeTransferFrom(msg.sender, address(this), payment);\n\n    // then we update incomeSpeed and subscription\n    if(newDepositValue > subscription.depositValue) {\n      billing.incomeSpeed = billing.incomeSpeed.add(incomeSpeedDiff);\n    } else if(newDepositValue < subscription.depositValue) {\n      billing.incomeSpeed = billing.incomeSpeed.sub(incomeSpeedDiff);\n    } // else billing.incomeSpeed is remained the same\n\n    subscription.startTimestamp = currentTime();\n    subscription.depositValue = newDepositValue;\n\n    // update subscriptions list\n    sortedSubscriptions.push(msg.sender);\n    sortedSubscriptions[subscription.index] = address(0);\n    subscription.index = sortedSubscriptions.length - 1;\n  }\n\n  function _payToOwner(uint amount) internal {\n    uint splitedTokens = amount.div(5); // take 20%\n    token.safeTransfer(transactionSplitBox, splitedTokens);\n    token.safeTransfer(serviceProvider, amount.sub(splitedTokens));\n  }\n\n  function _payToUser(uint amount) internal {\n    token.safeTransfer(msg.sender, amount);\n  }\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"plan\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"DowngradedPlan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExpiration\",\"type\":\"uint256\"}],\"name\":\"ExtendedSubscription\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"plan\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Subscribed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum BaseSubscription.TransactionType\",\"name\":\"transactionType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"plan\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Transaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"Unsubscribed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"plan\",\"type\":\"uint8\"}],\"name\":\"UpgradedPlan\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"approximateIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"income\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"billing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"previousClearingDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeSpeed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"disableBatchOfSubsriptions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableOldestSubsription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"_plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketExpiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"downgradePlan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"_plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketExpiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"extendSubscription\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"extensionPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeSpeedDiff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDepositValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"_plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketExpiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"getSignerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getSubscriptionStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"leftMonths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usedMonths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monthlyPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCanceled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_serviceProvider\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_transactionSplitBox\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ticketProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_serviceProvider\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_transactionSplitBox\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ticketProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOldestSubscriptionExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"planPriceDifference\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeSpeedDiff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceProvider\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sortedSubscriptions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"_plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketExpiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"subscribe\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"subscriptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositValue\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionSplitBox\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unsubscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum BaseSubscription.Plan\",\"name\":\"_plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketExpiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"upgradePlan\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SubscriptionVGT","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}