{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n  * @author @veronicaLC (Veronica Coutts) & @RyRy79261 (Ryan Nobel)\r\n  * @title Market\r\n  */\r\ninterface IMarket {\r\n\t// Emitted when a spender is approved\r\n    event Approval(\r\n      address indexed owner,\r\n      address indexed spender,\r\n      uint256 value\r\n    );\r\n    // Emitted when a transfer, mint or burn occurs\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    // Emitted when tokens are minted\r\n    event Mint(\r\n      address indexed to,\t\t\t// The address reciving the tokens\r\n      uint256 amountMinted,\t\t\t// The amount of tokens minted\r\n      uint256 collateralAmount,\t\t// The amount of DAI spent\r\n      uint256 researchContribution\t// The tax donatedd (in DAI)\r\n    );\r\n    // Emitted when tokens are burnt\r\n    event Burn(\r\n      address indexed from,\t\t\t// The address burning the tokens\r\n      uint256 amountBurnt,\t\t\t// The amount of tokens burnt\r\n      uint256 collateralReturned\t//  DAI being recived (in DAI)\r\n    );\r\n\t// Emitted when the market is terminated\r\n    event MarketTerminated();\r\n\r\n    /**\r\n      * @notice Approves transfers for a given address.\r\n      * @param  _spender : The account that will receive the funds.\r\n      * @param  _value : The value of funds accessed.\r\n      * @return boolean : Indicating the action was successful.\r\n      */\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n     /**\r\n      * @dev    Selling tokens back to the bonding curve for collateral.\r\n      * @param  _numTokens: The number of tokens that you want to burn.\r\n      */\r\n    function burn(uint256 _numTokens) external returns(bool);\r\n\r\n    /**\r\n      * @dev\tWe have modified the minting function to divert a portion of the\r\n      *         collateral for the purchased tokens to the vault.\r\n      * @param  _to : Address to mint tokens to.\r\n      * @param  _numTokens : The number of tokens you want to mint.\r\n      */\r\n    function mint(address _to, uint256 _numTokens) external returns(bool);\r\n\r\n    /**\r\n      * @notice Transfer ownership token from msg.sender to a specified address.\r\n      * @param  _to : The address to transfer to.\r\n      * @param  _value : The amount to be transferred.\r\n      */\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    /**\r\n      * @notice Transfer tokens from one address to another.\r\n      * @param  _from: The address which you want to send tokens from.\r\n      * @param  _to: The address which you want to transfer to.\r\n      * @param  _value: The amount of tokens to be transferred.\r\n      */\r\n    function transferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _value\r\n\t)\r\n\t\texternal\r\n\t\treturns(bool);\r\n\r\n    /**\r\n\t  * @notice\tCan only be called by this markets vault\r\n      * @dev    Allows the market to end once all funds have been raised.\r\n      *         Ends the market so that no more tokens can be bought or sold.\r\n\t  *\t\t\tTokens can still be transfered, or \"withdrawn\" for an enven\r\n\t  *\t\t\tdistribution of remaining collateral.\r\n      */\r\n    function finaliseMarket() external returns(bool);\r\n\r\n    /**\r\n      * @dev    Allows token holders to withdraw collateral in return for tokens\r\n      * \t\tafter the market has been finalised.\r\n      * @param \t_amount: The amount of tokens they want to withdraw\r\n      */\r\n    function withdraw(uint256 _amount) external returns(bool);\r\n\r\n    /**\r\n\t  * @dev\tReturns the required collateral amount for a volume of bonding\r\n\t  *\t\t\tcurve tokens\r\n\t  * @param\t_numTokens: The number of tokens to calculate the price of\r\n      * @return uint256 : The required collateral amount for a volume of bonding\r\n      *         curve tokens.\r\n      */\r\n    function priceToMint(uint256 _numTokens) external view returns(uint256);\r\n\r\n    /**\r\n\t  * @dev\tReturns the required collateral amount for a volume of bonding\r\n\t  *\t\t\tcurve tokens\r\n\t  * @param\t_numTokens: The number of tokens to work out the collateral\r\n\t  *\t\t\tvaule of\r\n      * @return uint256: The required collateral amount for a volume of bonding\r\n      *         curve tokens\r\n      */\r\n    function rewardForBurn(uint256 _numTokens) external view returns(uint256);\r\n\r\n    /**\r\n      * @notice This function returns the amount of tokens one can receive for a\r\n      *         specified amount of collateral token. Including molecule &\r\n\t  *\t\t\tmarket contributions\r\n      * @param  _collateralTokenOffered: Amount of reserve token offered for\r\n      *         purchase\r\n      * @return uint256: The amount of tokens one can purchase with the\r\n      *         specified collateral\r\n      */\r\n    function collateralToTokenBuying(\r\n\t\tuint256 _collateralTokenOffered\r\n\t)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns(uint256);\r\n\r\n    /**\r\n      * @notice This function returns the amount of tokens needed to be burnt to\r\n      *         withdraw a specified amount of reserve token.\r\n      * @param  _collateralTokenNeeded: Amount of dai to be withdraw.\r\n\t  * @return\tuint256: The amount of tokens needed to burn to reach goal\r\n\t  *\t\t\tcolalteral\r\n      */\r\n    function collateralToTokenSelling(\r\n\t\tuint256 _collateralTokenNeeded\r\n\t)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns(uint256);\r\n\r\n    /**\r\n      * @notice Gets the value of the current allowance specifed for that\r\n      *         account.\r\n      * @param  _owner: The account sending the funds.\r\n      * @param  _spender: The account that will receive the funds.\r\n\t  * @return\tuint256: representing the amount the spender can spend\r\n      */\r\n    function allowance(\r\n\t\taddress _owner,\r\n\t\taddress _spender\r\n\t)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns(uint256);\r\n\r\n    /**\r\n      * @notice Gets the balance of the specified address.\r\n      * @param  _owner: The address to query the the balance of.\r\n      * @return  uint256: Represents the amount owned by the passed address.\r\n      */\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /**\r\n      * @notice Total collateral backing the curve.\r\n      * @return uint256: Represents the total collateral backing the curve.\r\n      */\r\n    function poolBalance() external view returns (uint256);\r\n\r\n    /**\r\n      * @notice Total number of tokens in existence\r\n      * @return uint256: Represents the total supply of tokens in this market.\r\n      */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n      * @dev \tThe rate of fee (%) the market pays towards the vault on token\r\n\t    *\t\t\t  purchases.\r\n      */\r\n    function feeRate() external view returns(uint256);\r\n\r\n    /**\r\n      * @return\tuint256: The decimals set for the market\r\n      */\r\n    function decimals() external view returns(uint256);\r\n\r\n    /**\r\n      * @return\tbool: The active stat of the market. Inactive markets have\r\n\t    *\t\t\t    ended.\r\n      */\r\n    function active() external view returns(bool);\r\n}\r\n\r\n\r\n/**\r\n  * @author @veronicaLC (Veronica Coutts) & @RyRy79261 (Ryan Nobel)\r\n  * @title  Storage and collection of market tax.\r\n  * @notice The vault stores the tax from the market until the funding goal is\r\n  *         reached, thereafter the creator may withdraw the funds. If the\r\n  *         funding is not reached within the stipulated time-frame, or the\r\n  *         creator terminates the market, the funding is sent back to the\r\n  *         market to be re-distributed.\r\n  * @dev    The vault pulls the mol tax directly from the molecule vault.\r\n  */\r\ninterface IVault {\r\n\t// States for each funding round\r\n\tenum FundingState { NOT_STARTED, STARTED, ENDED, PAID }\r\n\t// Emitted when funding is withdrawn by the creator\r\n\tevent FundingWithdrawn(uint256 phase, uint256 amount);\r\n\t// Emitted when a phase has been successfully filled\r\n\tevent PhaseFinalised(uint256 phase, uint256 amount);\r\n\r\n   \t/**\r\n      * @dev    Initialized the contract, sets up owners and gets the market\r\n      *         address. This function exists because the Vault does not have\r\n      *         an address until the constructor has finished running. The\r\n      *         cumulative funding threshold is set here because of gas issues\r\n      *         within the constructor.\r\n      * @param _market: The market that will be sending this vault it's\r\n      *         collateral.\r\n      */\r\n    function initialize(address _market) external returns(bool);\r\n\r\n    /**\r\n\t  * @notice\tAAllows the creator to withdraw the various phases as they are\r\n\t  *\t\t\tcompleted.\r\n      * @return bool: The funding has successfully been transferred.\r\n\t  */\r\n    function withdraw() external returns(bool);\r\n\r\n    /**\r\n      * @notice\tVerifies that the phase passed in: has not been withdrawn,\r\n\t  *\t\t\tfunding goal has been reached, and that the phase has not\r\n\t  *\t\t\texpired. Adds fee amount to the vault pool.\r\n      * @param  _receivedFunding: The amount of funding recived\r\n      * @return bool: Wheather or not the funding is valid\r\n      */\r\n    function validateFunding(uint256 _receivedFunding) external returns(bool);\r\n\r\n\t/**\r\n      * @dev    This function sends the vaults funds to the market, and sets the\r\n      *         outstanding withdraw to 0.\r\n      * @notice If this function is called before the end of all phases, all\r\n      *         unclaimed (outstanding) funding will be sent to the market to be\r\n      *         redistributed.\r\n      */\r\n    function terminateMarket() external;\r\n\r\n\t/**\r\n      * @notice Returns all the details (relavant to external code) for a\r\n      *         specific phase.\r\n      * @param  _phase: The phase that you want the information of\r\n      * @return uint256: The funding goal (including mol tax) of the round\r\n      * @return uint256: The amount of funding currently raised for the round\r\n      * @return uint256: The duration of the phase\r\n      * @return uint256: The timestamp of the start date of the round\r\n      * @return FundingState: The enum state of the round (see IVault)\r\n      */\r\n    function fundingPhase(\r\n      uint256 _phase\r\n    )\r\n\t\texternal\r\n\t\tview\r\n\t\treturns(\r\n\t\t\tuint256,\r\n\t\t\tuint256,\r\n\t\t\tuint256,\r\n\t\t\tuint256,\r\n\t\t\tFundingState\r\n\t\t);\r\n\r\n\t/**\r\n\t  * @return\tuint256: The amount of funding that the creator has earned by\r\n\t  *\t\t\tnot withdrawn.\r\n\t  */\r\n    function outstandingWithdraw() external view returns(uint256);\r\n\r\n\t/**\r\n      * @dev    The current active phase of funding\r\n      * @return uint256: The current phase the project is in.\r\n      */\r\n    function currentPhase() external view returns(uint256);\r\n\r\n\t/**\r\n      * @return uint256: The total number of rounds for this project.\r\n      */\r\n    function getTotalRounds() external view returns(uint256);\r\n\r\n\t/**\r\n\t  * @return\taddress: The address of the market that is funding this vault.\r\n\t  */\r\n    function market() external view returns(address);\r\n\r\n\t/**\r\n\t  * @return\taddress: The address of the creator of this project.\r\n\t  */\r\n    function creator() external view returns(address);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n  * @author @veronicaLC (Veronica Coutts) & @BenSchZA (Ben Scholtz)\r\n  * @title  The interface for the curve functions.\r\n  */\r\ninterface ICurveFunctions {\r\n    /**\r\n      * @dev    Calculates the definite integral of the curve\r\n      * @param  _x : Token value for upper limit of definite integral\r\n      */\r\n    function curveIntegral(uint256 _x) external pure returns(uint256);\r\n\r\n    /**\r\n      * @dev    Calculates the definite inverse integral of the curve\r\n      * @param  _x : collateral value for upper limit of definite integral\r\n      */\r\n    function inverseCurveIntegral(uint256 _x) external pure returns(uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @author @veronicaLC (Veronica Coutts) & @RyRy79261 (Ryan Nobel)\r\n  * @title  Creation and storage of project tokens, fills vault with fee.\r\n  * @notice The market will send a portion of all collateral on mint to the\r\n  *         vault to fill the funding rounds.\r\n  * @dev    Checks with vault on every mint to ensure rounds are still active,\r\n  *         goal has not been met, and that the round has not expired.\r\n  */\r\ncontract Market is IMarket, IERC20 {\r\n    // For math functions with overflow & underflow checks\r\n    using SafeMath for uint256;\r\n\r\n    // Allows market to be deactivated after funding\r\n    bool internal active_ = true;\r\n    // Vault that recives fee\r\n    IVault internal creatorVault_;\r\n    // Percentage of vault fee e.g. 20\r\n    uint256 internal feeRate_;\r\n    // Address of curve function\r\n    ICurveFunctions internal curveLibrary_;\r\n    // Underlying collateral token\r\n    IERC20 internal collateralToken_;\r\n    // Total minted tokens\r\n    uint256 internal totalSupply_;\r\n    // Decimal accuracy of token\r\n    uint256 internal decimals_ = 18;\r\n\r\n    // Allowances for spenders\r\n    mapping(address => mapping (address => uint256)) internal allowed;\r\n    // Balances of token holders\r\n    mapping(address => uint256) internal balances;\r\n\r\n    /**\r\n\t  * @notice\tSets the needed variables for the market\r\n      * @param  _feeRate : The percentage for the fee i.e 20\r\n      * @param  _creatorVault : The vault for fee to go to\r\n      * @param  _curveLibrary : Math module.\r\n      * @param  _collateralToken : The ERC20 collateral tokem\r\n      */\r\n    constructor(\r\n        uint256 _feeRate,\r\n        address _creatorVault,\r\n        address _curveLibrary,\r\n        address _collateralToken\r\n    )\r\n        public\r\n    {\r\n        // Sets the storage variables\r\n        feeRate_ = _feeRate;\r\n        creatorVault_ = IVault(_creatorVault);\r\n        curveLibrary_ = ICurveFunctions(_curveLibrary);\r\n        collateralToken_ = IERC20(_collateralToken);\r\n    }\r\n\r\n    /**\r\n      * @notice Ensures the market's key functionality is only available when\r\n      *         the market is active.\r\n      */\r\n    modifier onlyActive(){\r\n        require(active_, \"Market inactive\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @notice Enaures a function is only callable by the vault.\r\n      */\r\n    modifier onlyVault(){\r\n        require(msg.sender == address(creatorVault_), \"Invalid requestor\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev    Selling tokens back to the bonding curve for collateral.\r\n      * @param  _numTokens: The number of tokens that you want to burn.\r\n      */\r\n    function burn(uint256 _numTokens) external onlyActive() returns(bool) {\r\n        require(\r\n            balances[msg.sender] >= _numTokens,\r\n            \"Not enough tokens available\"\r\n        );\r\n\r\n        uint256 reward = rewardForBurn(_numTokens);\r\n\r\n        totalSupply_ = totalSupply_.sub(_numTokens);\r\n        balances[msg.sender] = balances[msg.sender].sub(_numTokens);\r\n\r\n        require(\r\n            collateralToken_.transfer(\r\n                msg.sender,\r\n                reward\r\n            ),\r\n            \"Tokens not sent\"\r\n        );\r\n\r\n        emit Transfer(msg.sender, address(0), _numTokens);\r\n        emit Burn(msg.sender, _numTokens, reward);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev\tWe have modified the minting function to divert a portion of the\r\n      *         collateral for the purchased tokens to the vault. \r\n      * @notice If a mint transaction exceeded the needed funding for the last\r\n      *         round, the excess funds WILL NOT BE RETURNED TO SENDER. The\r\n      *         Molecule Catalyst front end prevents this.\r\n      *         The curve intergral code will reject any values that are too\r\n      *         small or large, that could result in over/under flows.\r\n      * @param  _to : Address to mint tokens to.\r\n      * @param  _numTokens : The number of tokens you want to mint.\r\n      */\r\n    function mint(\r\n        address _to,\r\n        uint256 _numTokens\r\n    )\r\n        external\r\n        onlyActive()\r\n        returns(bool)\r\n    {\r\n        // Gets the price (in collateral) for the tokens\r\n        uint256 priceForTokens = priceToMint(_numTokens);\r\n        \r\n        // Ensures there is no overflow\r\n        require(priceForTokens > 0, \"Tokens requested too low\");\r\n\r\n        // Works out how much fee needs to be sent to the vault\r\n        uint256 fee = priceForTokens.mul(feeRate_).div(100);\r\n        // Sends the collateral from the buyer to this market\r\n        require(\r\n            collateralToken_.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                priceForTokens\r\n            ),\r\n            \"Collateral transfer failed\"\r\n        );\r\n        // Sends the fee to the vault\r\n        require(\r\n            collateralToken_.transfer(\r\n                address(creatorVault_),\r\n                fee\r\n            ),\r\n            \"Vault fee not transferred\"\r\n        );\r\n\r\n        // Adds the tokens to the total supply\r\n        totalSupply_ = totalSupply_.add(_numTokens);\r\n        // Adds the tokens to the balance of the buyer\r\n        balances[msg.sender] = balances[msg.sender].add(_numTokens);\r\n        // Validates the funding with the vault\r\n        require(\r\n            creatorVault_.validateFunding(fee),\r\n            \"Funding validation failed\"\r\n        );\r\n        // Works out the vaule of the tokens without the fee\r\n        uint256 priceWithoutFee = priceForTokens.sub(fee);\r\n\r\n        emit Transfer(address(0), _to, _numTokens);\r\n        emit Mint(_to, _numTokens, priceWithoutFee, fee);\r\n        return true;\r\n    }\r\n\r\n\t    /**\r\n      * @notice This function returns the amount of tokens one can receive for a\r\n      *         specified amount of collateral token.\r\n      * @param  _collateralTokenOffered : Amount of reserve token offered for\r\n      *         purchase.\r\n      * @return uint256 : The amount of tokens once can purchase with the\r\n      *         specified collateral.\r\n      */\r\n    function collateralToTokenBuying(\r\n        uint256 _collateralTokenOffered\r\n    )\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // Works out the amount of collateral for fee\r\n        uint256 fee = _collateralTokenOffered.mul(feeRate_).div(100);\r\n        // Removes the fee amount from the collateral offered\r\n        uint256 amountLessFee = _collateralTokenOffered.sub(fee);\r\n        // Works out the inverse curve of the pool with the fee removed amount\r\n        return _inverseCurveIntegral(\r\n                _curveIntegral(totalSupply_).add(amountLessFee)\r\n            ).sub(totalSupply_);\r\n    }\r\n\r\n    /**\r\n      * @notice This function returns the amount of tokens needed to be burnt to\r\n      *         withdraw a specified amount of reserve token.\r\n      * @param  _collateralTokenNeeded : Amount of dai to be withdraw.\r\n      */\r\n    function collateralToTokenSelling(\r\n        uint256 _collateralTokenNeeded\r\n    )\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return uint256(\r\n            totalSupply_.sub(\r\n                _inverseCurveIntegral(\r\n                    _curveIntegral(totalSupply_).sub(_collateralTokenNeeded)\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @notice Total collateral backing the curve.\r\n      * @return uint256 : Represents the total collateral backing the curve.\r\n      */\r\n    function poolBalance() external view returns (uint256){\r\n        return collateralToken_.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n      * @dev \tThe rate of fee the market pays towards the vault on token\r\n\t  *         purchases.\r\n      */\r\n    function feeRate() external view returns(uint256) {\r\n        return feeRate_;\r\n    }\r\n\r\n    /**\r\n      * @return\tuint256 : The decimals set for the market\r\n      */\r\n    function decimals() external view returns(uint256) {\r\n        return decimals_;\r\n    }\r\n\r\n    /**\r\n      * @return\tbool : The active stat of the market. Inactive markets have\r\n\t  *         ended.\r\n      */\r\n    function active() external view returns(bool){\r\n        return active_;\r\n    }\r\n\r\n    /**\r\n\t  * @notice\tCan only be called by this markets vault\r\n      * @dev    Allows the market to end once all funds have been raised.\r\n      *         Ends the market so that no more tokens can be bought or sold.\r\n\t  *\t\t\tTokens can still be transfered, or \"withdrawn\" for an enven\r\n\t  *\t\t\tdistribution of remaining collateral.\r\n      */\r\n    function finaliseMarket() public onlyVault() returns(bool) {\r\n        require(active_, \"Market deactivated\");\r\n        active_ = false;\r\n        emit MarketTerminated();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev    Allows token holders to withdraw collateral in return for tokens\r\n      * \t\tafter the market has been finalised.\r\n      * @param \t_amount: The amount of tokens they want to withdraw\r\n      */\r\n    function withdraw(uint256 _amount) public returns(bool) {\r\n        // Ensures withdraw can only be called in an inactive market\r\n        require(!active_, \"Market not finalised\");\r\n        // Ensures the sender has enough tokens\r\n        require(_amount <= balances[msg.sender], \"Insufficient funds\");\r\n        // Ensures there are no anomaly withdraws that might break calculations\r\n        require(_amount > 0, \"Cannot withdraw 0\");\r\n\r\n        // Removes amount from user balance\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        // Gets the balance of the market (vault may send excess funding)\r\n        uint256 balance = collateralToken_.balanceOf(address(this));\r\n\r\n        // Performs a flat linear 100% collateralized sale\r\n        uint256 collateralToTransfer = balance.mul(_amount).div(totalSupply_);\r\n        // Removes token amount from the total supply\r\n        totalSupply_ = totalSupply_.sub(_amount);\r\n\r\n        // Ensures the sender is sent their collateral amount\r\n        require(\r\n            collateralToken_.transfer(msg.sender, collateralToTransfer),\r\n            \"Dai transfer failed\"\r\n        );\r\n\r\n        emit Transfer(msg.sender, address(0), _amount);\r\n        emit Burn(msg.sender, _amount, collateralToTransfer);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n\t  * @dev\tReturns the required collateral amount for a volume of bonding\r\n\t  *\t\t\tcurve tokens.\r\n      * @notice The curve intergral code will reject any values that are too\r\n      *         small or large, that could result in over/under flows.\r\n\t  * @param\t_numTokens: The number of tokens to calculate the price of\r\n      * @return uint256 : The required collateral amount for a volume of bonding\r\n      *         curve tokens.\r\n      */\r\n    function priceToMint(uint256 _numTokens) public view returns(uint256) {\r\n        // Gets the balance of the market\r\n        uint256 balance = collateralToken_.balanceOf(address(this));\r\n        // Performs the curve intergral with the relavant vaules\r\n        uint256 collateral = _curveIntegral(\r\n                totalSupply_.add(_numTokens)\r\n            ).sub(balance);\r\n        // Sets the base unit for decimal shift\r\n        uint256 baseUnit = 100;\r\n        // Adds the fee amount\r\n        uint256 result = collateral.mul(100).div(baseUnit.sub(feeRate_));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n\t  * @dev\tReturns the required collateral amount for a volume of bonding\r\n\t  *\t\t\tcurve tokens\r\n\t  * @param\t_numTokens: The number of tokens to work out the collateral\r\n\t  *\t\t\tvaule of\r\n      * @return uint256: The required collateral amount for a volume of bonding\r\n      *         curve tokens\r\n      */\r\n    function rewardForBurn(uint256 _numTokens) public view returns(uint256) {\r\n        // Gets the curent balance of the market\r\n        uint256 poolBalanceFetched = collateralToken_.balanceOf(address(this));\r\n        // Returns the pool balance minus the curve intergral of the removed\r\n        // tokens\r\n        return poolBalanceFetched.sub(\r\n            _curveIntegral(totalSupply_.sub(_numTokens))\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @dev    Calculate the integral from 0 to x tokens supply. Calls the\r\n      *         curve integral function on the math library.\r\n      * @param  _x : The number of tokens supply to integrate to.\r\n      * @return he total supply in tokens, not wei.\r\n      */\r\n    function _curveIntegral(uint256 _x) internal view returns (uint256) {\r\n        return curveLibrary_.curveIntegral(_x);\r\n    }\r\n\r\n    /**\r\n      * @dev    Inverse integral to convert the incoming colateral value to\r\n      *         token volume.\r\n      * @param  _x : The volume to identify the root off\r\n      */\r\n    function _inverseCurveIntegral(uint256 _x) internal view returns(uint256) {\r\n        return curveLibrary_.inverseCurveIntegral(_x);\r\n    }\r\n\r\n\t//--------------------------------------------------------------------------\r\n\t// ERC20 functions\r\n\t//--------------------------------------------------------------------------\r\n\r\n\t/**\r\n      * @notice Total number of tokens in existence\r\n      * @return uint256: Represents the total supply of tokens in this market.\r\n      */\r\n    function totalSupply() external view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n\t/**\r\n      * @notice Gets the balance of the specified address.\r\n      * @param  _owner : The address to query the the balance of.\r\n      * @return  uint256 : Represents the amount owned by the passed address.\r\n      */\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\t/**\r\n      * @notice Gets the value of the current allowance specifed for that\r\n      *         account.\r\n      * @param  _owner: The account sending the funds.\r\n      * @param  _spender: The account that will receive the funds.\r\n\t  * @return\tuint256: representing the amount the spender can spend\r\n      */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n      * @notice Approves transfers for a given address.\r\n      * @param  _spender : The account that will receive the funds.\r\n      * @param  _value : The value of funds accessed.\r\n      * @return boolean : Indicating the action was successful.\r\n      */\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        external\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev    Atomically increases the allowance granted to `spender` by the\r\n      *         caller.\r\n      * @notice This is an alternative to {approve} that can be used as a\r\n      *         mitigation for problems described in {IERC20-approve}.\r\n      */\r\n    function increaseAllowance(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n        public\r\n        returns(bool) \r\n    {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender]\r\n            .add(_addedValue);\r\n        emit Approval(msg.sender, _spender, _addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev    Atomically decreases the allowance granted to `spender` by the\r\n      *         caller.\r\n      * @notice This is an alternative to {approve} that can be used as a\r\n      *         mitigation for problems described in {IERC20-approve}.\r\n      */\r\n    function decreaseAllowance(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n        public\r\n        returns(bool)\r\n    {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender]\r\n            .sub(_subtractedValue);\r\n        emit Approval(msg.sender, _spender, _subtractedValue);\r\n        return true;\r\n    }\r\n\r\n\t/**\r\n      * @notice Transfer tokens from one address to another.\r\n      * @param  _from : The address which you want to send tokens from.\r\n      * @param  _to : The address which you want to transfer to.\r\n      * @param  _value : The amount of tokens to be transferred.\r\n      */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_value <= balances[_from], \"Requested amount exceeds balance\");\r\n        require(_value <= allowed[_from][msg.sender], \"Allowance exceeded\");\r\n        require(_to != address(0), \"Target account invalid\");\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n\t/**\r\n      * @notice Transfer ownership token from msg.sender to a specified address.\r\n      * @param  _to : The address to transfer to.\r\n      * @param  _value : The amount to be transferred.\r\n      */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= balances[msg.sender], \"Insufficient funds\");\r\n        require(_to != address(0), \"Target account invalid\");\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"priceToMint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"rewardForBurn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finaliseMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collateralTokenNeeded\",\"type\":\"uint256\"}],\"name\":\"collateralToTokenSelling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collateralTokenOffered\",\"type\":\"uint256\"}],\"name\":\"collateralToTokenBuying\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_feeRate\",\"type\":\"uint256\"},{\"name\":\"_creatorVault\",\"type\":\"address\"},{\"name\":\"_curveLibrary\",\"type\":\"address\"},{\"name\":\"_collateralToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"researchContribution\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collateralReturned\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MarketTerminated\",\"type\":\"event\"}]","ContractName":"Market","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004b000000000000000000000000EF7b02511dA3c36B7aD1e80ac3F82d4655f6676A00000000000000000000000097e93539E74c556f6f0068D7BEd581C7a97DfD2A0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://f42d9800c2ffc989c85f74268352710536ff320697f6f74baa0fa5c404ec53ca"}]}