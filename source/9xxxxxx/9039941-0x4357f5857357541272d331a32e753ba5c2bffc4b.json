{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\n\r\n    interface IERC20 {\r\n        \r\n        function totalSupply() external view returns (uint256);\r\n\r\n        \r\n        function balanceOf(address account) external view returns (uint256);\r\n\r\n        \r\n        function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n        \r\n        function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n        \r\n        function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n        \r\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n        \r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n        \r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    }\r\n\r\n    contract ERC20Detailed is IERC20 {\r\n        string private _name;\r\n        string private _symbol;\r\n        uint8 private _decimals;\r\n\r\n        \r\n        constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n            _name = name;\r\n            _symbol = symbol;\r\n            _decimals = decimals;\r\n        }\r\n\r\n        \r\n        function name() public view returns (string memory) {\r\n            return _name;\r\n        }\r\n\r\n        \r\n        function symbol() public view returns (string memory) {\r\n            return _symbol;\r\n        }\r\n\r\n        \r\n        function decimals() public view returns (uint8) {\r\n            return _decimals;\r\n        }\r\n    }\r\n\r\n    library SafeMath {\r\n        \r\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            uint256 c = a + b;\r\n            require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n            return c;\r\n        }\r\n\r\n        \r\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            require(b <= a, \"SafeMath: subtraction overflow\");\r\n            uint256 c = a - b;\r\n\r\n            return c;\r\n        }\r\n\r\n        \r\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            \r\n            \r\n            \r\n            if (a == 0) {\r\n                return 0;\r\n            }\r\n\r\n            uint256 c = a * b;\r\n            require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n            return c;\r\n        }\r\n\r\n        \r\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            \r\n            require(b > 0, \"SafeMath: division by zero\");\r\n            uint256 c = a / b;\r\n            \r\n\r\n            return c;\r\n        }\r\n\r\n        \r\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            require(b != 0, \"SafeMath: modulo by zero\");\r\n            return a % b;\r\n        }\r\n    }\r\n\r\n    contract ERC20 is IERC20 {\r\n        using SafeMath for uint256;\r\n\r\n        mapping (address => uint256) private _balances;\r\n\r\n        mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n        uint256 private _totalSupply;\r\n\r\n        \r\n        function totalSupply() public view returns (uint256) {\r\n            return _totalSupply;\r\n        }\r\n\r\n        \r\n        function balanceOf(address account) public view returns (uint256) {\r\n            return _balances[account];\r\n        }\r\n\r\n        \r\n        function transfer(address recipient, uint256 amount) public returns (bool) {\r\n            _transfer(msg.sender, recipient, amount);\r\n            return true;\r\n        }\r\n\r\n        \r\n        function allowance(address owner, address spender) public view returns (uint256) {\r\n            return _allowances[owner][spender];\r\n        }\r\n\r\n        \r\n        function approve(address spender, uint256 value) public returns (bool) {\r\n            _approve(msg.sender, spender, value);\r\n            return true;\r\n        }\r\n\r\n        \r\n        function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n            _transfer(sender, recipient, amount);\r\n            _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n            return true;\r\n        }\r\n\r\n        \r\n        function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n            _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n            return true;\r\n        }\r\n\r\n        \r\n        function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n            _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n            return true;\r\n        }\r\n\r\n        \r\n        function _transfer(address sender, address recipient, uint256 amount) internal {\r\n            require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n            require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n            _balances[sender] = _balances[sender].sub(amount);\r\n            _balances[recipient] = _balances[recipient].add(amount);\r\n            emit Transfer(sender, recipient, amount);\r\n        }\r\n\r\n        \r\n        function _mint(address account, uint256 amount) internal {\r\n            require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n            _totalSupply = _totalSupply.add(amount);\r\n            _balances[account] = _balances[account].add(amount);\r\n            emit Transfer(address(0), account, amount);\r\n        }\r\n\r\n        \r\n        function _burn(address account, uint256 value) internal {\r\n            require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n            _totalSupply = _totalSupply.sub(value);\r\n            _balances[account] = _balances[account].sub(value);\r\n            emit Transfer(account, address(0), value);\r\n        }\r\n\r\n        \r\n        function _approve(address owner, address spender, uint256 value) internal {\r\n            require(owner != address(0), \"ERC20: approve from the zero address\");\r\n            require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n            _allowances[owner][spender] = value;\r\n            emit Approval(owner, spender, value);\r\n        }\r\n\r\n        \r\n        function _burnFrom(address account, uint256 amount) internal {\r\n            _burn(account, amount);\r\n            _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n        }\r\n    }\r\n\r\n    library Roles {\r\n        struct Role {\r\n            mapping (address => bool) bearer;\r\n        }\r\n\r\n        \r\n        function add(Role storage role, address account) internal {\r\n            require(!has(role, account), \"Roles: account already has role\");\r\n            role.bearer[account] = true;\r\n        }\r\n\r\n        \r\n        function remove(Role storage role, address account) internal {\r\n            require(has(role, account), \"Roles: account does not have role\");\r\n            role.bearer[account] = false;\r\n        }\r\n\r\n        \r\n        function has(Role storage role, address account) internal view returns (bool) {\r\n            require(account != address(0), \"Roles: account is the zero address\");\r\n            return role.bearer[account];\r\n        }\r\n    }\r\n\r\n    contract MinterRole {\r\n        using Roles for Roles.Role;\r\n\r\n        event MinterAdded(address indexed account);\r\n        event MinterRemoved(address indexed account);\r\n\r\n        Roles.Role private _minters;\r\n\r\n        constructor () internal {\r\n            _addMinter(msg.sender);\r\n        }\r\n\r\n        modifier onlyMinter() {\r\n            require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\r\n            _;\r\n        }\r\n\r\n        function isMinter(address account) public view returns (bool) {\r\n            return _minters.has(account);\r\n        }\r\n\r\n        function addMinter(address account) public onlyMinter {\r\n            _addMinter(account);\r\n        }\r\n\r\n        function renounceMinter() public {\r\n            _removeMinter(msg.sender);\r\n        }\r\n\r\n        function _addMinter(address account) internal {\r\n            _minters.add(account);\r\n            emit MinterAdded(account);\r\n        }\r\n\r\n        function _removeMinter(address account) internal {\r\n            _minters.remove(account);\r\n            emit MinterRemoved(account);\r\n        }\r\n    }\r\n\r\n    contract ERC20Mintable is ERC20, MinterRole {\r\n        \r\n        function mint(address account, uint256 amount) public onlyMinter returns (bool) {\r\n            _mint(account, amount);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    contract ERC20Capped is ERC20Mintable {\r\n        uint256 private _cap;\r\n\r\n        \r\n        constructor (uint256 cap) public {\r\n            require(cap > 0, \"ERC20Capped: cap is 0\");\r\n            _cap = cap;\r\n        }\r\n\r\n        \r\n        function cap() public view returns (uint256) {\r\n            return _cap;\r\n        }\r\n\r\n        \r\n        function _mint(address account, uint256 value) internal {\r\n            require(totalSupply().add(value) <= _cap, \"ERC20Capped: cap exceeded\");\r\n            super._mint(account, value);\r\n        }\r\n    }\r\n\r\n    contract ERC20Burnable is ERC20 {\r\n        \r\n        function burn(uint256 amount) public {\r\n            _burn(msg.sender, amount);\r\n        }\r\n\r\n        \r\n        function burnFrom(address account, uint256 amount) public {\r\n            _burnFrom(account, amount);\r\n        }\r\n    }\r\n\r\n    library Address {\r\n        \r\n        function isContract(address account) internal view returns (bool) {\r\n            \r\n            \r\n            \r\n\r\n            uint256 size;\r\n            \r\n            assembly { size := extcodesize(account) }\r\n            return size > 0;\r\n        }\r\n    }\r\n\r\n    library SafeERC20 {\r\n        using SafeMath for uint256;\r\n        using Address for address;\r\n\r\n        function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n            callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n        }\r\n\r\n        function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n            callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n        }\r\n\r\n        function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n            \r\n            \r\n            \r\n            \r\n            require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n                \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n            );\r\n            callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n        }\r\n\r\n        function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n            uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n            callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n\r\n        function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n            uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n            callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n\r\n        \r\n        function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n            \r\n            \r\n\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n            \r\n            (bool success, bytes memory returndata) = address(token).call(data);\r\n            require(success, \"SafeERC20: low-level call failed\");\r\n\r\n            if (returndata.length > 0) { \r\n                \r\n                require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n            }\r\n        }\r\n    }\r\n\r\n    contract ReentrancyGuard {\r\n        \r\n        uint256 private _guardCounter;\r\n\r\n        constructor () internal {\r\n            \r\n            \r\n            _guardCounter = 1;\r\n        }\r\n\r\n        \r\n        modifier nonReentrant() {\r\n            _guardCounter += 1;\r\n            uint256 localCounter = _guardCounter;\r\n            _;\r\n            require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n        }\r\n    }\r\n\r\n    contract Crowdsale is ReentrancyGuard {\r\n        using SafeMath for uint256;\r\n        using SafeERC20 for IERC20;\r\n\r\n        \r\n        IERC20 private _token;\r\n\r\n        \r\n        address payable private _wallet;\r\n\r\n        \r\n        \r\n        \r\n        \r\n        uint256 private _rate;\r\n\r\n        \r\n        uint256 private _weiRaised;\r\n\r\n        \r\n        event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n        event RateAdjusted(uint256 adjustedRate);\r\n\r\n        \r\n        constructor (uint256 rate, address payable wallet, IERC20 token) public {\r\n            require(rate > 0, \"Crowdsale: rate is 0\");\r\n            require(wallet != address(0), \"Crowdsale: wallet is the zero address\");\r\n            require(address(token) != address(0), \"Crowdsale: token is the zero address\");\r\n\r\n            _rate = rate;\r\n            _wallet = wallet;\r\n            _token = token;\r\n        }\r\n\r\n        \r\n        function () external payable {\r\n            buyTokens(msg.sender);\r\n        }\r\n\r\n        \r\n        function token() public view returns (IERC20) {\r\n            return _token;\r\n        }\r\n\r\n        \r\n        function wallet() public view returns (address payable) {\r\n            return _wallet;\r\n        }\r\n\r\n        \r\n        function rate() public view returns (uint256) {\r\n            return _rate;\r\n        }\r\n\r\n        \r\n        function weiRaised() public view returns (uint256) {\r\n            return _weiRaised;\r\n        }\r\n\r\n        \r\n        function buyTokens(address beneficiary) public nonReentrant payable {\r\n            uint256 weiAmount = msg.value;\r\n            _preValidatePurchase(beneficiary, weiAmount);\r\n\r\n            \r\n            uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n            \r\n            _weiRaised = _weiRaised.add(weiAmount);\r\n\r\n            _processPurchase(beneficiary, tokens);\r\n            emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);\r\n\r\n            _updatePurchasingState(beneficiary, weiAmount);\r\n\r\n            _forwardFunds();\r\n            _postValidatePurchase(beneficiary, weiAmount);\r\n        }\r\n\r\n        \r\n        function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n            require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");\r\n            require(weiAmount != 0, \"Crowdsale: weiAmount is 0\");\r\n        }\r\n\r\n        \r\n        function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n            \r\n        }\r\n\r\n        \r\n        function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\r\n            _token.safeTransfer(beneficiary, tokenAmount);\r\n        }\r\n\r\n        \r\n        function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\r\n            _deliverTokens(beneficiary, tokenAmount);\r\n        }\r\n\r\n        \r\n        function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\r\n            \r\n        }\r\n\r\n        \r\n        function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\r\n            return weiAmount.mul(_rate);\r\n        }\r\n\r\n        \r\n        function adjustRate(uint256 newRate) public {\r\n            require(newRate > 0, \"Crowdsale-adjustRate: Rate has to be non-zero\");\r\n            _rate = newRate;\r\n            emit RateAdjusted(newRate);\r\n        }\r\n\r\n        \r\n        function _forwardFunds() internal {\r\n            _wallet.transfer(msg.value);\r\n        }\r\n    }\r\n\r\n    contract TimedCrowdsale is Crowdsale {\r\n        using SafeMath for uint256;\r\n\r\n        uint256 private _openingTime;\r\n        uint256 private _closingTime;\r\n\r\n        \r\n        event TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime);\r\n\r\n        \r\n        modifier onlyWhileOpen {\r\n            require(isOpen(), \"TimedCrowdsale: not open\");\r\n            _;\r\n        }\r\n\r\n        \r\n        constructor (uint256 openingTime, uint256 closingTime) public {\r\n            \r\n            require(openingTime >= block.timestamp, \"TimedCrowdsale: opening time is before current time\");\r\n            \r\n            require(closingTime > openingTime, \"TimedCrowdsale: opening time is not before closing time\");\r\n\r\n            _openingTime = openingTime;\r\n            _closingTime = closingTime;\r\n        }\r\n\r\n        \r\n        function openingTime() public view returns (uint256) {\r\n            return _openingTime;\r\n        }\r\n\r\n        \r\n        function closingTime() public view returns (uint256) {\r\n            return _closingTime;\r\n        }\r\n\r\n        \r\n        function isOpen() public view returns (bool) {\r\n            \r\n            return block.timestamp >= _openingTime && block.timestamp <= _closingTime;\r\n        }\r\n\r\n        \r\n        function hasClosed() public view returns (bool) {\r\n            \r\n            return block.timestamp > _closingTime;\r\n        }\r\n\r\n        \r\n        function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {\r\n            super._preValidatePurchase(beneficiary, weiAmount);\r\n        }\r\n\r\n        \r\n        function _extendTime(uint256 newClosingTime) internal {\r\n            require(!hasClosed(), \"TimedCrowdsale: already closed\");\r\n            \r\n            require(newClosingTime > _closingTime, \"TimedCrowdsale: new closing time is before current closing time\");\r\n\r\n            emit TimedCrowdsaleExtended(_closingTime, newClosingTime);\r\n            _closingTime = newClosingTime;\r\n        }\r\n    }\r\n\r\n    contract Secondary {\r\n        address private _primary;\r\n\r\n        \r\n        event PrimaryTransferred(\r\n            address recipient\r\n        );\r\n\r\n        \r\n        constructor () internal {\r\n            _primary = msg.sender;\r\n            emit PrimaryTransferred(_primary);\r\n        }\r\n\r\n        \r\n        modifier onlyPrimary() {\r\n            require(msg.sender == _primary, \"Secondary: caller is not the primary account\");\r\n            _;\r\n        }\r\n\r\n        \r\n        function primary() public view returns (address) {\r\n            return _primary;\r\n        }\r\n\r\n        \r\n        function transferPrimary(address recipient) public onlyPrimary {\r\n            require(recipient != address(0), \"Secondary: new primary is the zero address\");\r\n            _primary = recipient;\r\n            emit PrimaryTransferred(_primary);\r\n        }\r\n    }\r\n\r\n    contract Ownable {\r\n        address private _owner;\r\n\r\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n        \r\n        constructor () internal {\r\n            _owner = msg.sender;\r\n            emit OwnershipTransferred(address(0), _owner);\r\n        }\r\n\r\n        \r\n        function owner() public view returns (address) {\r\n            return _owner;\r\n        }\r\n\r\n        \r\n        modifier onlyOwner() {\r\n            require(isOwner(), \"Ownable: caller is not the owner\");\r\n            _;\r\n        }\r\n\r\n        \r\n        function isOwner() public view returns (bool) {\r\n            return msg.sender == _owner;\r\n        }\r\n\r\n        \r\n        function renounceOwnership() public onlyOwner {\r\n            emit OwnershipTransferred(_owner, address(0));\r\n            _owner = address(0);\r\n        }\r\n\r\n        \r\n        function transferOwnership(address newOwner) public onlyOwner {\r\n            _transferOwnership(newOwner);\r\n        }\r\n\r\n        \r\n        function _transferOwnership(address newOwner) internal {\r\n            require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n            emit OwnershipTransferred(_owner, newOwner);\r\n            _owner = newOwner;\r\n        }\r\n    }\r\n\r\n    contract ManagerRole is Ownable {\r\n        using Roles for Roles.Role;\r\n        using SafeMath for uint256;\r\n\r\n        event ManagerAdded(address indexed account);\r\n        event ManagerRemoved(address indexed account);\r\n\r\n        Roles.Role private managers;\r\n        uint256 private _numManager;\r\n\r\n        constructor() internal {\r\n            _addManager(msg.sender);\r\n            _numManager = 1;\r\n        }\r\n\r\n        \r\n        modifier onlyManager() {\r\n            require(isManager(msg.sender), \"ManagerRole-onlyManager: The account is not a manager\");\r\n            _;\r\n        }\r\n\r\n        \r\n        \r\n        function addManagers(address[] calldata accounts) external onlyOwner {\r\n            uint256 length = accounts.length;\r\n            require(length <= 256, \"ManagerRole-addManagers:too many accounts\");\r\n            for (uint256 i = 0; i < length; i++) {\r\n                _addManager(accounts[i]);\r\n            }\r\n        }\r\n        \r\n        \r\n        function removeManager(address account) external onlyOwner {\r\n            _removeManager(account);\r\n        }\r\n\r\n        \r\n        function isManager(address account) public view returns (bool) {\r\n            return managers.has(account);\r\n        }\r\n\r\n        \r\n        function numManager() public view returns (uint256) {\r\n            return _numManager;\r\n        }\r\n\r\n        \r\n        function addManager(address account) public onlyOwner {\r\n            require(account != address(0), \"ManagerRole-addManager: account is zero\");\r\n            _addManager(account);\r\n        }\r\n\r\n        \r\n        function renounceManager() public {\r\n            require(_numManager >= 2, \"ManagerRole-renounceManager: Managers are fewer than 2\");\r\n            _removeManager(msg.sender);\r\n        }\r\n\r\n        \r\n        function renounceOwnership() public onlyOwner {\r\n            revert(\"ManagerRole-renounceOwnership: Cannot renounce ownership\");\r\n        }\r\n\r\n        \r\n        function _addManager(address account) internal {\r\n            _numManager = _numManager.add(1);\r\n            managers.add(account);\r\n            emit ManagerAdded(account);\r\n        }\r\n\r\n        \r\n        function _removeManager(address account) internal {\r\n            _numManager = _numManager.sub(1);\r\n            managers.remove(account);\r\n            emit ManagerRemoved(account);\r\n        }\r\n    }\r\n\r\n    contract PausableManager is ManagerRole {\r\n\r\n        event BePaused(address manager);\r\n        event BeUnpaused(address manager);\r\n\r\n        bool private _paused;   \r\n\r\n        constructor() internal {\r\n            _paused = false;\r\n        }\r\n\r\n    \r\n        modifier whenNotPaused() {\r\n            require(!_paused, \"PausableManager-whenNotPaused: paused\");\r\n            _;\r\n        }\r\n\r\n        \r\n        modifier whenPaused() {\r\n            require(_paused, \"PausableManager-whenPaused: not paused\");\r\n            _;\r\n        }\r\n\r\n        \r\n        function paused() public view returns(bool) {\r\n            return _paused;\r\n        }\r\n\r\n        \r\n        function pause() public onlyManager whenNotPaused {\r\n            _paused = true;\r\n            emit BePaused(msg.sender);\r\n        }\r\n\r\n        \r\n        function unpause() public onlyManager whenPaused {\r\n            _paused = false;\r\n            emit BeUnpaused(msg.sender);\r\n        }\r\n    }\r\n\r\n    contract ValidAddress {\r\n        \r\n        modifier onlyValidAddress(address _address) {\r\n            require(_address != address(0), \"ValidAddress-onlyValidAddress:Not a valid address\");\r\n            _;\r\n        }\r\n\r\n        \r\n        modifier isSenderNot(address _address) {\r\n            require(_address != msg.sender, \"ValidAddress-isSenderNot:Address is the same as the sender\");\r\n            _;\r\n        }\r\n\r\n        \r\n        modifier isSender(address _address) {\r\n            require(_address == msg.sender, \"ValidAddress-isSender: Address is different from the sender\");\r\n            _;\r\n        }\r\n    }\r\n\r\n    contract Whitelist is ValidAddress, PausableManager {\r\n\r\n        mapping (address => bool) private _isWhitelisted;       \r\n        mapping(address => uint) public _contributionAmounts;   \r\n        uint public totalWhiteListed;                           \r\n        address[] public holdersIndex;                          \r\n\r\n        event AdddWhitelisted(address indexed user);\r\n        event RemovedWhitelisted(address indexed user);\r\n\r\n\r\n        \r\n        function addWhitelisted(address user, uint256 maxAllowed) external onlyManager {\r\n            _addWhitelisted(user, maxAllowed);\r\n        }\r\n\r\n        \r\n        \r\n        function addWhitelistedMultiple(address[] calldata users, uint256[] calldata maxAllowed) external onlyManager {\r\n            uint256 length = users.length;\r\n            require(length <= 256, \"Whitelist-addWhitelistedMultiple: List too long\");\r\n            for (uint256 i = 0; i < length; i++) {\r\n                _addWhitelisted(users[i], maxAllowed[i]);\r\n            }\r\n        }\r\n\r\n        \r\n        function removeWhitelisted(address user)\r\n            external\r\n            onlyManager\r\n        {\r\n            _removeWhitelisted(user);\r\n        }\r\n\r\n        \r\n        \r\n        function removeWhitelistedMultiple(address[] calldata users)\r\n            external\r\n            onlyManager\r\n        {\r\n            uint256 length = users.length;\r\n            require(length <= 256, \"Whitelist-removeWhitelistedMultiple: List too long\");\r\n            for (uint256 i = 0; i < length; i++) {\r\n                _removeWhitelisted(users[i]);\r\n            }\r\n        }\r\n\r\n        \r\n        function isWhitelisted(address user) public view returns (bool) {\r\n            return _isWhitelisted[user];\r\n        }\r\n\r\n        \r\n        function returnMaxAmountForUser(address user) public view returns (uint256) {\r\n            return  _contributionAmounts[user];\r\n        }\r\n\r\n        \r\n        function _addWhitelisted(address user, uint maxToContribute)\r\n            internal\r\n            onlyValidAddress(user)\r\n        {\r\n            require(_isWhitelisted[user] == false, \"Whitelist-_addWhitelisted: account already whitelisted\");\r\n            _isWhitelisted[user] = true;\r\n            _contributionAmounts[user] = maxToContribute;\r\n            totalWhiteListed++;\r\n            holdersIndex.push(user);\r\n            emit AdddWhitelisted(user);\r\n        }\r\n\r\n        \r\n        function _removeWhitelisted(address user)\r\n            internal\r\n            onlyValidAddress(user)\r\n        {\r\n            require(_isWhitelisted[user] == true, \"Whitelist-_removeWhitelisted: account was not whitelisted\");\r\n            _isWhitelisted[user] = false;\r\n            _contributionAmounts[user] = 0;\r\n            totalWhiteListed--;\r\n            emit RemovedWhitelisted(user);\r\n        }\r\n    }\r\n\r\n    contract WhitelistCrowdsale is Whitelist, Crowdsale {\r\n        \r\n        function _preValidatePurchase(address beneficiary, uint256 weiAmount)\r\n            internal\r\n            view\r\n        {\r\n            require(isWhitelisted(beneficiary), \"WhitelistCrowdsale-_preValidatePurchase: beneficiary is not whitelisted\");\r\n            super._preValidatePurchase(beneficiary, weiAmount);\r\n        }\r\n    }\r\n\r\n    contract PostDeliveryCrowdsale is TimedCrowdsale, WhitelistCrowdsale {\r\n        using SafeMath for uint256;\r\n\r\n        mapping(address => uint256) private _balances;\r\n        __unstable__TokenVault private _vault;\r\n\r\n        constructor() public {\r\n            _vault = new __unstable__TokenVault();\r\n            \r\n            _addWhitelisted(address(_vault), 0);\r\n        }\r\n\r\n        \r\n        function withdrawTokens(address beneficiary) public {\r\n            require(hasClosed(), \"PostDeliveryCrowdsale: not closed\");\r\n            uint256 amount = _balances[beneficiary];\r\n            require(amount > 0, \"PostDeliveryCrowdsale: beneficiary is not due any tokens\");\r\n\r\n            _balances[beneficiary] = 0;\r\n            _vault.transfer(token(), beneficiary, amount);\r\n        }\r\n\r\n        \r\n        function balanceOf(address account) public view returns (uint256) {\r\n            return _balances[account];\r\n        }\r\n\r\n        \r\n        function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\r\n            _balances[beneficiary] = _balances[beneficiary].add(tokenAmount);\r\n            _deliverTokens(address(_vault), tokenAmount);\r\n        }\r\n    }\r\n\r\n    contract __unstable__TokenVault is Secondary {\r\n        function transfer(IERC20 token, address to, uint256 amount) public onlyPrimary {\r\n            token.transfer(to, amount);\r\n        }\r\n    }\r\n\r\n    contract FinalizableCrowdsale is TimedCrowdsale {\r\n        using SafeMath for uint256;\r\n\r\n        bool private _finalized;\r\n\r\n        event CrowdsaleFinalized();\r\n\r\n        constructor () internal {\r\n            _finalized = false;\r\n        }\r\n\r\n        \r\n        function finalized() public view returns (bool) {\r\n            return _finalized;\r\n        }\r\n\r\n        \r\n        function finalize() public {\r\n            require(!_finalized, \"FinalizableCrowdsale: already finalized\");\r\n            require(hasClosed(), \"FinalizableCrowdsale: not closed\");\r\n\r\n            _finalized = true;\r\n\r\n            _finalization();\r\n            emit CrowdsaleFinalized();\r\n        }\r\n\r\n        \r\n        function _finalization() internal {\r\n            \r\n        }\r\n    }\r\n\r\n    contract CounterGuard {\r\n        \r\n        modifier onlyOnce(bool criterion) {\r\n            require(criterion == false, \"CounterGuard-onlyOnce: Already been set\");\r\n            _;\r\n        }\r\n    }\r\n\r\n    contract PausableCrowdsale is PausableManager, Crowdsale {\r\n\r\n        \r\n        function _preValidatePurchase(\r\n            address _beneficiary,\r\n            uint256 _weiAmount\r\n        )\r\n            internal\r\n            view\r\n            whenNotPaused\r\n        {\r\n            return super._preValidatePurchase(_beneficiary, _weiAmount);\r\n        }\r\n\r\n    }\r\n\r\n    contract ECrowdsale is CounterGuard, WhitelistCrowdsale,\r\n                            PostDeliveryCrowdsale, FinalizableCrowdsale,\r\n                            PausableCrowdsale {\r\n    \r\n        bool private _setRole;              \r\n        uint256 private _maxCryptoSale;     \r\n        uint256 private _cryptoSaleAmount;  \r\n        bool private _noCryptoLimits;       \r\n        address payable private _wallet;    \r\n        uint256 private _weiRaised;\r\n\r\n        event WithdrawTokens(address beneficiary, uint256 value);\r\n        event RefundExtra(address beneficiary, uint256 value);\r\n        event NonEthTokenPurchased(address indexed beneficiary, uint256 tokenAmount);\r\n\r\n        \r\n\r\n        constructor(\r\n            uint256 startingTime,\r\n            uint256 endingTime,\r\n            uint256 rate,\r\n            address payable wallet,\r\n            IERC20 token,\r\n            uint maxCryptoSale\r\n        )\r\n            public\r\n            Crowdsale(rate, wallet, token)\r\n            TimedCrowdsale(startingTime, endingTime)\r\n            {\r\n                _wallet = wallet;\r\n                _maxCryptoSale = maxCryptoSale;\r\n                _noCryptoLimits = false;\r\n            }\r\n\r\n        \r\n        function nonEthPurchase(address beneficiary, uint256 tokenAmount)\r\n            public onlyManager\r\n        {\r\n            require(beneficiary != address(0), \"ECrowdsale-nonEthPurchase: beneficiary is the zero address\");\r\n            _processPurchase(beneficiary, tokenAmount);\r\n            emit NonEthTokenPurchased(beneficiary, tokenAmount);\r\n        }\r\n\r\n        \r\n        function _preValidatePurchaseCrypto(address beneficiary, uint256 weiAmount) private view {\r\n            require(returnMaxAmountForUser(beneficiary).sub(balanceOf(beneficiary)) >= weiAmount,\r\n                    \"ECrowdsale-_preValidatePurchaseCrypto: contribution exceeds allowed amount\");\r\n            super._preValidatePurchase(beneficiary, weiAmount);\r\n        }\r\n\r\n\r\n        \r\n        function nonEthPurchaseMulti(\r\n            address[] calldata beneficiaries,\r\n            uint256[] calldata amounts\r\n        )\r\n            external\r\n        {\r\n            uint256 length = amounts.length;\r\n            require(beneficiaries.length == length, \"length !=\");\r\n            require(length <= 256, \"ECrowdsale-nonEthPurchaseMulti: List too long, please shorten the array\");\r\n            for (uint256 i = 0; i < length; i++) {\r\n                nonEthPurchase(beneficiaries[i], amounts[i]);\r\n            }\r\n        }\r\n\r\n        \r\n        function roleSetup(\r\n            address newOwner\r\n        )\r\n            public\r\n            onlyOwner\r\n            onlyOnce(_setRole)\r\n        {\r\n            if (address(newOwner) != address(msg.sender) ) {\r\n                addManager(newOwner);\r\n                _removeManager(msg.sender);\r\n                transferOwnership(newOwner);\r\n            }\r\n            _setRole = true;\r\n        }\r\n\r\n        \r\n        function withdrawTokens(address beneficiary) public {\r\n\r\n            require(finalized(), \"ECrowdsale:withdrawTokens - Crowdsale is not finalized\");\r\n\r\n            uint256 balanceOf = balanceOf(beneficiary);\r\n            super.withdrawTokens(beneficiary);\r\n            emit WithdrawTokens(beneficiary, balanceOf);\r\n        }\r\n\r\n        \r\n        function claimTokens() public {\r\n\r\n            address payable beneficiary = msg.sender;\r\n            withdrawTokens(beneficiary);\r\n        }\r\n\r\n        \r\n        function cryptoSaleAmount() public view returns(uint256) {\r\n\r\n            return _cryptoSaleAmount;\r\n        }\r\n\r\n        \r\n        function allowRemainingTokensForCrypto() public onlyManager {\r\n\r\n            _noCryptoLimits = true;\r\n\r\n        }\r\n\r\n        \r\n        function extendTime(uint256 newClosingTime) public onlyManager {\r\n        super._extendTime(newClosingTime);\r\n        }\r\n\r\n        \r\n        function weiRaised() public view returns (uint256) {\r\n            return _weiRaised;\r\n        }\r\n\r\n        \r\n        function finalize() public  onlyManager {\r\n            super.finalize();\r\n        }\r\n\r\n        \r\n        function buyTokens(address beneficiary) public payable   {\r\n\r\n            uint256 extra = msg.value % rate();\r\n            uint256 amountPaid;\r\n\r\n            amountPaid = msg.value - extra;\r\n\r\n            _preValidatePurchaseCrypto(beneficiary, amountPaid);\r\n            uint256 tokens = amountPaid / rate();\r\n            _cryptoSaleAmount += tokens;  \r\n\r\n            require(_cryptoSaleAmount <= _maxCryptoSale || _noCryptoLimits,\r\n            \"ECrowdsale-buyTokens: Max available for crypto sale has been reached\");\r\n\r\n            _weiRaised += amountPaid;\r\n            _processPurchase(beneficiary, tokens);\r\n            _wallet.transfer(amountPaid);\r\n            emit TokensPurchased(msg.sender, beneficiary, amountPaid, tokens);\r\n\r\n            if (extra > 0) {\r\n                msg.sender.transfer(extra);\r\n                emit RefundExtra(msg.sender, extra);\r\n            }\r\n        }\r\n\r\n        \r\n        function adjustRate(uint256 newRate) public onlyManager {\r\n            super.adjustRate(newRate);\r\n        }\r\n    }\r\n\r\n    contract Token is CounterGuard, ERC20Detailed,\r\n        ERC20Capped, ERC20Burnable, PausableManager {\r\n\r\n        uint256 private constant ALLOCATION = 10000; \r\n        bool private _setRole;\r\n        address  payable public crowdsaleContractAddress;\r\n\r\n        event logPayment(address indexed paymentAddress, uint amount, uint date);\r\n\r\n        \r\n        struct Payment {\r\n\r\n            uint date;\r\n            uint amount;\r\n            address paymentContractAddress;\r\n        }\r\n\r\n        Payment[] public payments;  \r\n\r\n\r\n        \r\n        constructor(\r\n            string memory name,\r\n            string memory symbol,\r\n            uint8 decimals,\r\n            uint256 cap\r\n        )\r\n            public\r\n            ERC20Detailed(name, symbol, decimals)\r\n            ERC20Capped(cap) {\r\n                pause();\r\n            }\r\n\r\n\r\n        \r\n        modifier onlyWhitelisted(address user) {\r\n\r\n            require(ECrowdsale(crowdsaleContractAddress).isWhitelisted(user), \"Token-onlyWhitelisted: user is not whitelisted\");\r\n            _;\r\n        }\r\n\r\n\r\n        \r\n        function registerPayment(address paymentAddress, uint amount) public  {\r\n\r\n            require(msg.sender == owner() || msg.sender == paymentAddress, \"Token-registerPayment: You are not authorized to make this call\");\r\n\r\n            require(paymentAddress != address(0), \"Token-registerPayment: Payment address can't be 0x0\");\r\n            require(amount > 0, \"Token-registerPayment: Payment amount can't be 0\");\r\n\r\n            uint index = payments.length;\r\n            payments.length ++;\r\n\r\n            payments[index].date = now;\r\n            payments[index].amount = amount;\r\n            payments[index].paymentContractAddress = paymentAddress;\r\n            emit logPayment(paymentAddress, amount, now);\r\n        }\r\n\r\n\r\n        \r\n        function returnPaymentNum() public view returns ( uint) {\r\n\r\n            return payments.length;\r\n        }\r\n\r\n\r\n        \r\n        function isWhitelisted(address user) public view returns (bool) {\r\n\r\n            return ECrowdsale(crowdsaleContractAddress).isWhitelisted(user);\r\n        }\r\n\r\n\r\n        \r\n        function transfer(address to, uint256 value)\r\n            public\r\n            whenNotPaused\r\n            onlyWhitelisted(to)\r\n            returns (bool)\r\n        {\r\n            \r\n            return super.transfer(to, value);\r\n        }\r\n\r\n        \r\n        function transferFrom(address from, address to, uint256 value)\r\n            public\r\n            whenNotPaused\r\n            onlyWhitelisted(to)\r\n            returns (bool)\r\n        {\r\n            return super.transferFrom(from, to, value);\r\n        }\r\n\r\n        \r\n        function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\r\n            return super.approve(spender, value);\r\n        }\r\n\r\n        \r\n        function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\r\n            return super.increaseAllowance(spender, addedValue);\r\n        }\r\n\r\n        \r\n        function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\r\n            return super.decreaseAllowance(spender, subtractedValue);\r\n        }\r\n\r\n        \r\n        function roleSetup(\r\n            address _newOwner,\r\n            address payable _crowdsaleContractAddress\r\n        )\r\n            public\r\n            onlyOwner\r\n            onlyOnce(_setRole)\r\n        {\r\n            _setRole = true;\r\n            crowdsaleContractAddress = _crowdsaleContractAddress;\r\n            mint(crowdsaleContractAddress, ALLOCATION);\r\n\r\n            if (address(_newOwner) != address(msg.sender) ) {\r\n                addManager(_newOwner);\r\n                addMinter(_newOwner);\r\n                _removeManager(msg.sender);\r\n                _removeMinter(msg.sender);\r\n                transferOwnership(_newOwner);\r\n            }\r\n        }\r\n    }","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"BePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"BeUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"logPayment\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addManagers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleContractAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numManager\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"registerPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnPaymentNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_crowdsaleContractAddress\",\"type\":\"address\"}],\"name\":\"roleSetup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Token","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000000000000000000a4d414a4920546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000074d414a4931393100000000000000000000000000000000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://0ab2e752437185a90ad010a036e2945d58759c958a28d11b7df7870710b12ad4"}]}