{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.1;\r\n\r\n\r\n/**\r\n\r\n * @dev IPCM锁仓解锁合约 Author: AlanYan99@outlook.com, Date:2020/04\r\n\r\n */\r\n\r\ncontract IPCMToken {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"InterPlanetary Continuous Media\"; //  token name\r\n    string public constant symbol = \"IPCM\"; //  token symbol\r\n    uint256 public decimals = 18; //  token digit\r\n\r\n    uint256 public totalSupply_; // 已经发行总量\r\n    uint256 public _maxSupply = 100000000 * 10**uint256(decimals); //最大发行总量\r\n\r\n    address owner = address(0); //合约所有者\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value); // 交易事件\r\n\r\n    /**\r\n\r\n  * @dev 接受解锁转账的账户地址\r\n\r\n  */\r\n  \r\n    uint256 public unit_first = 1 days;\r\n    uint256 public unit_second = 365 days;\r\n\r\n    address public addr_pool = 0x44a16F5Ec33c845AB10343F8Cae4093b6c028ccB; //矿池挖矿\r\n    address public addr_private = 0x970603FaD5d239070593D33772451A533d2c3C5E; //私募\r\n    address public addr_fund = 0xf4c0ee2707Da59bf57effE9Ee3034Bed18718EF5; //基金会\r\n    address public addr_promotion = 0x2D6b8F56E40296c251A88509f7Be00E97bCE27e7; //推广运营\r\n    address public addr_team = 0x27e57a6dFCF442f1cAC135285A7434E8de364cA5; //原始团队\r\n    \r\n\r\n    mapping(address => uint256) balances; // 余额\r\n\r\n    /** Reserve allocations */\r\n    mapping(address => uint256) public allocations; // 每个地址对应锁仓金额的映射表\r\n\r\n    /** When timeLocks are over (UNIX Timestamp) */\r\n    mapping(address => uint256) public timeLocks; // 每个地址对应锁仓时间的映射表\r\n\r\n    /** How many tokens each reserve wallet has claimed */\r\n    mapping(address => uint256) public claimed; // 每个地址对应锁仓后已经解锁的金额的映射表\r\n\r\n    /** When token was locked (UNIX Timestamp)*/\r\n    uint256 public lockedAt = 0;\r\n\r\n    /** Allocated reserve tokens */\r\n    event Allocated(address wallet, uint256 value);\r\n\r\n    /** Distributed reserved tokens */\r\n    event Distributed(address wallet, uint256 value);\r\n\r\n    /** Tokens have been locked */\r\n    event Locked(uint256 lockTime);\r\n\r\n    modifier isOwner {\r\n        assert(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    // 合约调用者的地址为接受解锁转账的账户地址的其中之一\r\n    modifier onlyReserveWallets {\r\n        require(\r\n            msg.sender == addr_pool ||\r\n                msg.sender == addr_private ||\r\n                msg.sender == addr_fund ||\r\n                msg.sender == addr_promotion ||\r\n                msg.sender == addr_team\r\n        );\r\n        require(allocations[msg.sender] > 0);\r\n\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        allocate();\r\n    }\r\n\r\n    /**\r\n\r\n * @dev total number of tokens in existence\r\n\r\n */\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n\r\n * @dev Gets the balance of the specified address.\r\n\r\n * @param _owner The address to query the the balance of.\r\n\r\n * @return An uint256 representing the amount owned by the passed address.\r\n\r\n */\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n\r\n        //账户余额\r\n        return balances[_owner];\r\n    }\r\n\r\n    function maxSupply() public view returns (uint256) {\r\n        return _maxSupply;\r\n    }\r\n\r\n    //私有方法从一个帐户发送给另一个帐户代币\r\n    function _transfer(address _from, address _to, uint256 _value) internal {\r\n        require(_value > 0);\r\n\r\n        //避免转帐的地址是0x0\r\n        require(_to != address(0));\r\n\r\n        //检查发送者是否拥有足够余额\r\n        require(balances[_from].sub(_value) >= 0);\r\n\r\n        //检查是否溢出\r\n        require(balances[_to].add(_value) > balances[_to]);\r\n\r\n        //从发送者减掉发送额\r\n        balances[_from] = balances[_from].sub(_value);\r\n\r\n        //给接收者加上相同的量\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    //设定各个账号的token初始分配量和锁仓量\r\n    function allocate() internal {\r\n        balances[addr_private] = 1500000 * 10**uint256(decimals);\r\n        balances[addr_fund] = 1500000 * 10**uint256(decimals);\r\n        totalSupply_ = totalSupply_.add(balances[addr_private]);\r\n        totalSupply_ = totalSupply_.add(balances[addr_fund]);\r\n\r\n        emit Transfer(address(0), addr_private, balances[addr_private]);\r\n        emit Transfer(address(0), addr_fund, balances[addr_fund]);\r\n\r\n        allocations[addr_pool] = 50000000 * 10**uint256(decimals);\r\n        allocations[addr_private] = 13500000 * 10**uint256(decimals);\r\n        allocations[addr_fund] = 13500000 * 10**uint256(decimals);\r\n        allocations[addr_promotion] = 10000000 * 10**uint256(decimals);\r\n        allocations[addr_team] = 10000000 * 10**uint256(decimals);\r\n\r\n        emit Allocated(addr_pool, allocations[addr_pool]);\r\n        emit Allocated(addr_private, allocations[addr_private]);\r\n        emit Allocated(addr_fund, allocations[addr_fund]);\r\n        emit Allocated(addr_promotion, allocations[addr_promotion]);\r\n        emit Allocated(addr_team, allocations[addr_team]);\r\n\r\n        lock();\r\n    }\r\n\r\n    //设定各个账号的锁仓时间截止期限\r\n    function lock() internal {\r\n        lockedAt = block.timestamp; // 区块当前时间\r\n\r\n        uint256 next_year = ((lockedAt / (unit_second)) + 1) * (unit_second);\r\n        uint256 third_year = ((lockedAt / (unit_second)) + 2) * (unit_second);\r\n\r\n        timeLocks[addr_pool] = lockedAt;\r\n        timeLocks[addr_private] = next_year;\r\n        timeLocks[addr_promotion] = lockedAt;\r\n        timeLocks[addr_fund] = next_year;\r\n        timeLocks[addr_team] = third_year;\r\n\r\n        emit Locked(lockedAt);\r\n    }\r\n\r\n    // Number of tokens that are still locked\r\n    function getLockedBalance()\r\n        public\r\n        view\r\n        onlyReserveWallets\r\n        returns (uint256 tokensLocked)\r\n    {\r\n        return allocations[msg.sender].sub(claimed[msg.sender]);\r\n    }\r\n\r\n    //释放矿池挖矿收益\r\n    function claimToken() public onlyReserveWallets {\r\n        if (msg.sender == addr_pool) claimToken_Pool();\r\n        else if (msg.sender == addr_private) claimToken_Private();\r\n        else if (msg.sender == addr_fund) claimToken_Fund();\r\n        else if (msg.sender == addr_promotion) claimToken_Promotion();\r\n        else if (msg.sender == addr_team) claimToken_Team();\r\n    }\r\n\r\n    //释放矿池挖矿收益，50%50,000,000，第一年每天解锁50,000，第二年每天解锁25,000，每年减半以此类推\r\n    function claimToken_Pool() public {\r\n        address addr_claim = addr_pool;\r\n        uint256 time_now = block.timestamp;\r\n\r\n        require(addr_claim == msg.sender);\r\n\r\n        //是否已过锁仓时间期限\r\n        require(time_now > timeLocks[addr_claim]);\r\n        //已经释放的总量是否小于总的计划分配数量\r\n        require(claimed[addr_claim] < allocations[addr_claim]);\r\n\r\n        uint256 amnt_unit = 50000* 10**uint256(decimals);\r\n        uint256 span_years = (time_now / (unit_second)) -\r\n            (timeLocks[addr_claim] / (unit_second));\r\n        uint256 claim_cnt = 0;\r\n        \r\n\r\n        //计算到目前为止所有应该释放token总量\r\n        for (uint256 i = 0; i <= span_years; i++) {\r\n            uint256 amnt_day = amnt_unit / (2**i);\r\n\r\n            if (i == 0) //开始年份\r\n            {\r\n                uint256 span_days;\r\n\r\n                if(span_years<1)\r\n                    span_days = ((time_now - timeLocks[addr_claim]) /\r\n            (unit_first)) + 1;\r\n                else\r\n                    span_days = (unit_second/unit_first) -\r\n                    (timeLocks[addr_claim] % (unit_second)) /\r\n                    (unit_first);\r\n\r\n                claim_cnt = claim_cnt.add(amnt_day * span_days);\r\n\r\n            } else if (i < span_years) //中间年份\r\n            {\r\n                claim_cnt = claim_cnt.add(amnt_day * (unit_second/unit_first));\r\n            } else if (i == span_years) {\r\n                //当前年份\r\n                uint256 span_days = (time_now % (unit_second)) / (unit_first) + 1;\r\n                claim_cnt = claim_cnt.add(amnt_day * span_days);\r\n            }\r\n        }\r\n       \r\n        if(claim_cnt > allocations[addr_claim])\r\n            claim_cnt = allocations[addr_claim];\r\n\r\n        if (\r\n            claimed[addr_claim] < claim_cnt\r\n        ) //将前面所有应该释放但还未释放的token全部解锁发放\r\n        {\r\n            uint256 amount = claim_cnt.sub(claimed[addr_claim]);\r\n            balances[addr_claim] = balances[addr_claim].add(amount);\r\n            claimed[addr_claim] = claim_cnt;\r\n            totalSupply_ = totalSupply_.add(amount);\r\n\r\n            emit Transfer(address(0), addr_claim, amount);\r\n            emit Distributed(addr_claim, amount);\r\n        }\r\n    }\r\n\r\n    //释放私募收益，15%15,000,000；1,500,000立即释放，次年起剩余13,500,000每天释放10,000\r\n    function claimToken_Private() public {\r\n        address addr_claim = addr_private;\r\n        uint256 time_now = block.timestamp;\r\n\r\n        require(addr_claim == msg.sender);\r\n\r\n        //是否已过锁仓时间期限\r\n        require(time_now > timeLocks[addr_claim]);\r\n\r\n        //已经释放的总量是否小于总的计划分配数量\r\n        require(claimed[addr_claim] < allocations[addr_claim]);\r\n        uint256 amnt_unit = 10000* 10**uint256(decimals);\r\n        uint256 span_days = ((time_now - timeLocks[addr_claim]) / (unit_first)) + 1;\r\n        uint256 claim_cnt = span_days.mul(amnt_unit);\r\n\r\n        if(claim_cnt > allocations[addr_claim])\r\n            claim_cnt = allocations[addr_claim];\r\n\r\n        if (\r\n            claimed[addr_claim] < claim_cnt\r\n        ) //将前面所有应该释放但还未释放的token全部解锁发放\r\n        {\r\n            uint256 amount = claim_cnt.sub(claimed[addr_claim]);\r\n            balances[addr_claim] = balances[addr_claim].add(amount);\r\n            claimed[addr_claim] = claim_cnt;\r\n            totalSupply_ = totalSupply_.add(amount);\r\n\r\n            emit Transfer(address(0), addr_claim, amount);\r\n            emit Distributed(addr_claim, amount);\r\n        }\r\n    }\r\n\r\n    //释放基金会收益，15%15,000,000；1,500,000立即释放，次年起剩余13,500,000每天释放10,000\r\n    function claimToken_Fund() public {\r\n        address addr_claim = addr_fund;\r\n        uint256 time_now = block.timestamp;\r\n\r\n        require(addr_claim == msg.sender);\r\n\r\n        //是否已过锁仓时间期限\r\n        require(time_now > timeLocks[addr_claim]);\r\n\r\n        //已经释放的总量是否小于总的计划分配数量\r\n        require(claimed[addr_claim] < allocations[addr_claim]);\r\n\r\n        uint256 amnt_unit = 10000* 10**uint256(decimals);\r\n        uint256 span_days = ((time_now - timeLocks[addr_claim]) / (unit_first)) + 1;\r\n        uint256 claim_cnt = span_days.mul(amnt_unit);\r\n\r\n        if(claim_cnt > allocations[addr_claim])\r\n            claim_cnt = allocations[addr_claim];\r\n\r\n        if (\r\n            claimed[addr_claim] < claim_cnt\r\n        ) //将前面所有应该释放但还未释放的token全部解锁发放\r\n        {\r\n            uint256 amount = claim_cnt.sub(claimed[addr_claim]);\r\n            balances[addr_claim] = balances[addr_claim].add(amount);\r\n            claimed[addr_claim] = claim_cnt;\r\n            totalSupply_ = totalSupply_.add(amount);\r\n\r\n            emit Transfer(address(0), addr_claim, amount);\r\n            emit Distributed(addr_claim, amount);\r\n        }\r\n    }\r\n\r\n    //释放推广运营收益，10%10,000,000 每天解锁20,000\r\n    function claimToken_Promotion() public {\r\n        address addr_claim = addr_promotion;\r\n        uint256 time_now = block.timestamp;\r\n\r\n        require(addr_claim == msg.sender);\r\n\r\n        //是否已过锁仓时间期限\r\n        require(time_now > timeLocks[addr_claim]);\r\n\r\n        //已经释放的总量是否小于总的计划分配数量\r\n        require(claimed[addr_claim] < allocations[addr_claim]);\r\n\r\n        uint256 amnt_unit = 20000* 10**uint256(decimals);\r\n        uint256 span_days = ((time_now - timeLocks[addr_claim]) / (unit_first)) + 1;\r\n        uint256 claim_cnt = span_days.mul(amnt_unit);\r\n\r\n        if(claim_cnt > allocations[addr_claim])\r\n            claim_cnt = allocations[addr_claim];\r\n\r\n        if (\r\n            claimed[addr_claim] < claim_cnt\r\n        ) //将前面所有应该释放但还未释放的token全部解锁发放\r\n        {\r\n            uint256 amount = claim_cnt.sub(claimed[addr_claim]);\r\n            balances[addr_claim] = balances[addr_claim].add(amount);\r\n            claimed[addr_claim] = claim_cnt;\r\n            totalSupply_ = totalSupply_.add(amount);\r\n\r\n            emit Transfer(address(0), addr_claim, amount);\r\n            emit Distributed(addr_claim, amount);\r\n        }\r\n    }\r\n\r\n    //释放原始团队收益，10%10,000,000锁仓两年，第三年开始每天释放20,000\r\n    function claimToken_Team() public {\r\n        address addr_claim = addr_team;\r\n        uint256 time_now = block.timestamp;\r\n\r\n        require(addr_claim == msg.sender);\r\n\r\n        //是否已过锁仓时间期限\r\n        require(time_now > timeLocks[addr_claim]);\r\n\r\n        //已经释放的总量是否小于总的计划分配数量\r\n        require(claimed[addr_claim] < allocations[addr_claim]);\r\n\r\n        uint256 amnt_unit = 20000* 10**uint256(decimals);\r\n        uint256 span_days = ((time_now - timeLocks[addr_claim]) / (unit_first)) + 1;\r\n        uint256 claim_cnt = span_days.mul(amnt_unit);\r\n\r\n        if(claim_cnt > allocations[addr_claim])\r\n            claim_cnt = allocations[addr_claim];\r\n\r\n        if (\r\n            claimed[addr_claim] < claim_cnt\r\n        ) //将前面所有应该释放但还未释放的token全部解锁发放\r\n        {\r\n            uint256 amount = claim_cnt.sub(claimed[addr_claim]);\r\n            balances[addr_claim] = balances[addr_claim].add(amount);\r\n            claimed[addr_claim] = claim_cnt;\r\n            totalSupply_ = totalSupply_.add(amount);\r\n\r\n            emit Transfer(address(0), addr_claim, amount);\r\n            emit Distributed(addr_claim, amount);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Allocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addr_fund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addr_pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addr_private\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addr_promotion\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addr_team\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken_Fund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken_Pool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken_Private\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken_Promotion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken_Team\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensLocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeLocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unit_first\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unit_second\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"IPCMToken","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://1ca791bfd8b9bc65c41d7cec6f15311448048dd745375ca7d83e954e76fe7bd8"}]}