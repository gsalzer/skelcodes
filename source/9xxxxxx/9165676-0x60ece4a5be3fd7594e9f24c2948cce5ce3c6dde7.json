{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract IHandleCampaignDeployment {\r\n\r\n    /**\r\n     * @notice Function which will be used as simulation for constructor under TwoKeyAcquisitionCampaign contract\r\n     * @dev This is just an interface of the function, the actual logic\r\n     * is implemented under TwoKeyAcquisitionCampaignERC20.sol contract\r\n     * This function can be called only once per proxy address\r\n     */\r\n    function setInitialParamsCampaign(\r\n        address _twoKeySingletonesRegistry,\r\n        address _twoKeyAcquisitionLogicHandler,\r\n        address _conversionHandler,\r\n        address _moderator,\r\n        address _assetContractERC20,\r\n        address _contractor,\r\n        address _twoKeyEconomy,\r\n        uint [] values\r\n    ) public;\r\n\r\n    /**\r\n     * @notice Function which will be used as simulation for constructor under TwoKeyAcquisitionLogicHandler contract\r\n     * @dev This is just an interface of the function, the actual logic\r\n     * is implemented under TwoKeyAcquisitionLogicHandler.sol contract\r\n     * This function can be called only once per proxy address\r\n     */\r\n    function setInitialParamsLogicHandler(\r\n        uint [] values,\r\n        string _currency,\r\n        address _assetContractERC20,\r\n        address _moderator,\r\n        address _contractor,\r\n        address _acquisitionCampaignAddress,\r\n        address _twoKeySingletoneRegistry,\r\n        address _twoKeyConversionHandler\r\n    ) public;\r\n\r\n    /**\r\n     * @notice Function which will be used as simulation for constructor under TwoKeyConversionHandler contract\r\n     * @dev This is just an interface of the function, the actual logic\r\n     * is implemented under TwoKeyConversionHandler.sol contract\r\n     * This function can be called only once per proxy address\r\n     */\r\n    function setInitialParamsConversionHandler(\r\n        uint [] values,\r\n        address _twoKeyAcquisitionCampaignERC20,\r\n        address _twoKeyPurchasesHandler,\r\n        address _contractor,\r\n        address _assetContractERC20,\r\n        address _twoKeySingletonRegistry\r\n    ) public;\r\n\r\n\r\n    /**\r\n     * @notice Function which will be used as simulation for constructor under TwoKeyPurchasesHandler contract\r\n     * @dev This is just an interface of the function, the actual logic\r\n     * is implemented under TwoKeyPurchasesHandler.sol contract\r\n     * This function can be called only once per proxy address\r\n     */\r\n    function setInitialParamsPurchasesHandler(\r\n        uint[] values,\r\n        address _contractor,\r\n        address _assetContractERC20,\r\n        address _twoKeyEventSource,\r\n        address _proxyConversionHandler\r\n    ) public;\r\n\r\n\r\n    /**\r\n     * @notice Function which will be used as simulation for constructor under TwoKeyDonationCampaign contract\r\n     * @dev This is just an interface of the function, the actual logic\r\n     * is implemented under TwoKeyDonationCampaign.sol contract\r\n     * This function can be called only once per proxy address\r\n     */\r\n    function setInitialParamsDonationCampaign(\r\n        address _contractor,\r\n        address _moderator,\r\n        address _twoKeySingletonRegistry,\r\n        address _twoKeyDonationConversionHandler,\r\n        address _twoKeyDonationLogicHandler,\r\n        uint [] numberValues,\r\n        bool [] booleanValues\r\n    ) public;\r\n\r\n    /**\r\n     * @notice Function which will be used as simulation for constructor under TwoKeyDonationConversionHandler contract\r\n     * @dev This is just an interface of the function, the actual logic\r\n     * is implemented under TwoKeyDonationConversionHandler.sol contract\r\n     * This function can be called only once per proxy address\r\n     */\r\n    function setInitialParamsDonationConversionHandler(\r\n        string tokenName,\r\n        string tokenSymbol,\r\n        string _currency,\r\n        address _contractor,\r\n        address _twoKeyDonationCampaign,\r\n        address _twoKeySingletonRegistry\r\n    ) public;\r\n\r\n\r\n    function setInitialParamsDonationLogicHandler(\r\n        uint[] numberValues,\r\n        string currency,\r\n        address contractor,\r\n        address moderator,\r\n        address twoKeySingletonRegistry,\r\n        address twoKeyDonationCampaign,\r\n        address twokeyDonationConversionHandler\r\n    ) public;\r\n\r\n\r\n    function setInitialParamsCPCCampaign(\r\n        address _contractor,\r\n        address _twoKeySingletonRegistry,\r\n        string _url,\r\n        address _mirrorCampaignOnPlasma,\r\n        uint _bountyPerConversion,\r\n        address _twoKeyEconomy\r\n    )\r\n    public;\r\n}\r\n\r\ncontract IStructuredStorage {\r\n\r\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\r\n    function setProxyLogicContract(address _proxyLogicContract) external;\r\n\r\n    // *** Getter Methods ***\r\n    function getUint(bytes32 _key) external view returns(uint);\r\n    function getString(bytes32 _key) external view returns(string);\r\n    function getAddress(bytes32 _key) external view returns(address);\r\n    function getBytes(bytes32 _key) external view returns(bytes);\r\n    function getBool(bytes32 _key) external view returns(bool);\r\n    function getInt(bytes32 _key) external view returns(int);\r\n    function getBytes32(bytes32 _key) external view returns(bytes32);\r\n\r\n    // *** Getter Methods For Arrays ***\r\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\r\n    function getAddressArray(bytes32 _key) external view returns (address[]);\r\n    function getUintArray(bytes32 _key) external view returns (uint[]);\r\n    function getIntArray(bytes32 _key) external view returns (int[]);\r\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\r\n\r\n    // *** Setter Methods ***\r\n    function setUint(bytes32 _key, uint _value) external;\r\n    function setString(bytes32 _key, string _value) external;\r\n    function setAddress(bytes32 _key, address _value) external;\r\n    function setBytes(bytes32 _key, bytes _value) external;\r\n    function setBool(bytes32 _key, bool _value) external;\r\n    function setInt(bytes32 _key, int _value) external;\r\n    function setBytes32(bytes32 _key, bytes32 _value) external;\r\n\r\n    // *** Setter Methods For Arrays ***\r\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\r\n    function setAddressArray(bytes32 _key, address[] _value) external;\r\n    function setUintArray(bytes32 _key, uint[] _value) external;\r\n    function setIntArray(bytes32 _key, int[] _value) external;\r\n    function setBoolArray(bytes32 _key, bool[] _value) external;\r\n\r\n    // *** Delete Methods ***\r\n    function deleteUint(bytes32 _key) external;\r\n    function deleteString(bytes32 _key) external;\r\n    function deleteAddress(bytes32 _key) external;\r\n    function deleteBytes(bytes32 _key) external;\r\n    function deleteBool(bytes32 _key) external;\r\n    function deleteInt(bytes32 _key) external;\r\n    function deleteBytes32(bytes32 _key) external;\r\n}\r\n\r\ncontract ITwoKeyCampaignValidator {\r\n    function isCampaignValidated(address campaign) public view returns (bool);\r\n    function validateAcquisitionCampaign(address campaign, string nonSingletonHash) public;\r\n    function validateDonationCampaign(address campaign, address donationConversionHandler, address donationLogicHandler, string nonSingletonHash) public;\r\n    function validateCPCCampaign(address campaign, string nonSingletonHash) public;\r\n}\r\n\r\ncontract ITwoKeyMaintainersRegistry {\r\n    function checkIsAddressMaintainer(address _sender) public view returns (bool);\r\n    function checkIsAddressCoreDev(address _sender) public view returns (bool);\r\n\r\n    function addMaintainers(address [] _maintainers) public;\r\n    function addCoreDevs(address [] _coreDevs) public;\r\n    function removeMaintainers(address [] _maintainers) public;\r\n    function removeCoreDevs(address [] _coreDevs) public;\r\n}\r\n\r\ninterface ITwoKeySingletonesRegistry {\r\n\r\n    /**\r\n    * @dev This event will be emitted every time a new proxy is created\r\n    * @param proxy representing the address of the proxy created\r\n    */\r\n    event ProxyCreated(address proxy);\r\n\r\n\r\n    /**\r\n    * @dev This event will be emitted every time a new implementation is registered\r\n    * @param version representing the version name of the registered implementation\r\n    * @param implementation representing the address of the registered implementation\r\n    * @param contractName is the name of the contract we added new version\r\n    */\r\n    event VersionAdded(string version, address implementation, string contractName);\r\n\r\n    /**\r\n    * @dev Registers a new version with its implementation address\r\n    * @param version representing the version name of the new implementation to be registered\r\n    * @param implementation representing the address of the new implementation to be registered\r\n    */\r\n    function addVersion(string _contractName, string version, address implementation) public;\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation for a given version\r\n    * @param _contractName is the name of the contract we're querying\r\n    * @param version to query the implementation of\r\n    * @return address of the implementation registered for the given version\r\n    */\r\n    function getVersion(string _contractName, string version) public view returns (address);\r\n}\r\n\r\ncontract TwoKeySingletonRegistryAbstract is ITwoKeySingletonesRegistry {\r\n\r\n    address public deployer;\r\n\r\n    string congress;\r\n    string maintainersRegistry;\r\n\r\n    mapping (string => mapping(string => address)) internal versions;\r\n\r\n    mapping (string => address) contractNameToProxyAddress;\r\n    mapping (string => string) contractNameToLatestAddedVersion;\r\n    mapping (string => address) nonUpgradableContractToAddress;\r\n    mapping (string => string) campaignTypeToLastApprovedVersion;\r\n\r\n\r\n    event ProxiesDeployed(\r\n        address logicProxy,\r\n        address storageProxy\r\n    );\r\n\r\n    modifier onlyMaintainer {\r\n        address twoKeyMaintainersRegistry = contractNameToProxyAddress[maintainersRegistry];\r\n        require(msg.sender == deployer || ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyCoreDev {\r\n        address twoKeyMaintainersRegistry = contractNameToProxyAddress[maintainersRegistry];\r\n        require(msg.sender == deployer || ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressCoreDev(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the implementation for a given version\r\n     * @param version to query the implementation of\r\n     * @return address of the implementation registered for the given version\r\n     */\r\n    function getVersion(\r\n        string contractName,\r\n        string version\r\n    )\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return versions[contractName][version];\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @notice Gets the latest contract version\r\n     * @param contractName is the name of the contract\r\n     * @return string representation of the last version\r\n     */\r\n    function getLatestAddedContractVersion(\r\n        string contractName\r\n    )\r\n    public\r\n    view\r\n    returns (string)\r\n    {\r\n        return contractNameToLatestAddedVersion[contractName];\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Function to get address of non-upgradable contract\r\n     * @param contractName is the name of the contract\r\n     */\r\n    function getNonUpgradableContractAddress(\r\n        string contractName\r\n    )\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return nonUpgradableContractToAddress[contractName];\r\n    }\r\n\r\n    /**\r\n     * @notice Function to return address of proxy for specific contract\r\n     * @param _contractName is the name of the contract we'd like to get proxy address\r\n     * @return is the address of the proxy for the specific contract\r\n     */\r\n    function getContractProxyAddress(\r\n        string _contractName\r\n    )\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return contractNameToProxyAddress[_contractName];\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get latest campaign approved version\r\n     * @param campaignType is type of campaign\r\n     */\r\n    function getLatestCampaignApprovedVersion(\r\n        string campaignType\r\n    )\r\n    public\r\n    view\r\n    returns (string)\r\n    {\r\n        return campaignTypeToLastApprovedVersion[campaignType];\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Function to add non upgradable contract in registry of all contracts\r\n     * @param contractName is the name of the contract\r\n     * @param contractAddress is the contract address\r\n     * @dev only maintainer can issue call to this method\r\n     */\r\n    function addNonUpgradableContractToAddress(\r\n        string contractName,\r\n        address contractAddress\r\n    )\r\n    public\r\n    onlyCoreDev\r\n    {\r\n        require(nonUpgradableContractToAddress[contractName] == 0x0);\r\n        nonUpgradableContractToAddress[contractName] = contractAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Function in case of hard fork, or congress replacement\r\n     * @param contractName is the name of contract we want to add\r\n     * @param contractAddress is the address of contract\r\n     */\r\n    function changeNonUpgradableContract(\r\n        string contractName,\r\n        address contractAddress\r\n    )\r\n    public\r\n    {\r\n        require(msg.sender == nonUpgradableContractToAddress[congress]);\r\n        nonUpgradableContractToAddress[contractName] = contractAddress;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Registers a new version with its implementation address\r\n     * @param version representing the version name of the new implementation to be registered\r\n     * @param implementation representing the address of the new implementation to be registered\r\n     */\r\n    function addVersion(\r\n        string contractName,\r\n        string version,\r\n        address implementation\r\n    )\r\n    public\r\n    onlyCoreDev\r\n    {\r\n        require(implementation != address(0)); //Require that version implementation is not 0x0\r\n        require(versions[contractName][version] == 0x0); //No overriding of existing versions\r\n        versions[contractName][version] = implementation; //Save the version for the campaign\r\n        contractNameToLatestAddedVersion[contractName] = version;\r\n        emit VersionAdded(version, implementation, contractName);\r\n    }\r\n\r\n    function addVersionDuringCreation(\r\n        string contractLogicName,\r\n        string contractStorageName,\r\n        address contractLogicImplementation,\r\n        address contractStorageImplementation,\r\n        string version\r\n    )\r\n    public\r\n    {\r\n        require(msg.sender == deployer);\r\n        bytes memory logicVersion = bytes(contractNameToLatestAddedVersion[contractLogicName]);\r\n        bytes memory storageVersion = bytes(contractNameToLatestAddedVersion[contractStorageName]);\r\n\r\n        require(logicVersion.length == 0 && storageVersion.length == 0); //Requiring that this is first time adding a version\r\n        require(keccak256(version) == keccak256(\"1.0.0\")); //Requiring that first version is 1.0.0\r\n\r\n        versions[contractLogicName][version] = contractLogicImplementation; //Storing version\r\n        versions[contractStorageName][version] = contractStorageImplementation; //Storing version\r\n\r\n        contractNameToLatestAddedVersion[contractLogicName] = version; // Mapping latest contract name to the version\r\n        contractNameToLatestAddedVersion[contractStorageName] = version; //Mapping latest contract name to the version\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to deploy proxy for the contract\r\n     * @param contractName is the name of the contract\r\n     * @param version is the new version\r\n     */\r\n    function deployProxy(\r\n        string contractName,\r\n        string version\r\n    )\r\n    internal\r\n    returns (address)\r\n    {\r\n        UpgradeabilityProxy proxy = new UpgradeabilityProxy(contractName, version);\r\n        contractNameToProxyAddress[contractName] = proxy;\r\n        emit ProxyCreated(proxy);\r\n        return address(proxy);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to upgrade contract to new version\r\n     * @param contractName is the name of the contract\r\n     * @param version is the new version\r\n     */\r\n    function upgradeContract(\r\n        string contractName,\r\n        string version\r\n    )\r\n    public\r\n    {\r\n        require(msg.sender == nonUpgradableContractToAddress[congress]);\r\n        address proxyAddress = getContractProxyAddress(contractName);\r\n        address _impl = getVersion(contractName, version);\r\n\r\n        UpgradeabilityProxy(proxyAddress).upgradeTo(contractName, version, _impl);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to approve campaign version per type during it's creation\r\n     * @param campaignType is the type of campaign we want to approve during creation\r\n     */\r\n    function approveCampaignVersionDuringCreation(\r\n        string campaignType\r\n    )\r\n    public\r\n    onlyCoreDev\r\n    {\r\n        bytes memory campaign = bytes(campaignTypeToLastApprovedVersion[campaignType]);\r\n\r\n        require(campaign.length == 0);\r\n\r\n        campaignTypeToLastApprovedVersion[campaignType] = \"1.0.0\";\r\n    }\r\n\r\n    /**\r\n     * @notice Function to approve selected version for specific type of campaign\r\n     * @param campaignType is the type of campaign\r\n     * @param versionToApprove is the version for that type we want to approve\r\n     */\r\n    function approveCampaignVersion(\r\n        string campaignType,\r\n        string versionToApprove\r\n    )\r\n    public\r\n    {\r\n        require(msg.sender == nonUpgradableContractToAddress[congress]);\r\n        campaignTypeToLastApprovedVersion[campaignType] = versionToApprove;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates an upgradeable proxy for both Storage and Logic\r\n     * @param version representing the first version to be set for the proxy\r\n     */\r\n    function createProxy(\r\n        string contractName,\r\n        string contractNameStorage,\r\n        string version\r\n    )\r\n    public\r\n    {\r\n        require(msg.sender == deployer);\r\n        require(contractNameToProxyAddress[contractName] == address(0));\r\n        address logicProxy = deployProxy(contractName, version);\r\n        address storageProxy = deployProxy(contractNameStorage, version);\r\n\r\n        IStructuredStorage(storageProxy).setProxyLogicContractAndDeployer(logicProxy, msg.sender);\r\n        emit ProxiesDeployed(logicProxy, storageProxy);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to transfer deployer privileges to another address\r\n     * @param _newOwner is the new contract \"owner\" (called deployer in this case)\r\n     */\r\n    function transferOwnership(\r\n        address _newOwner\r\n    )\r\n    public\r\n    {\r\n        require(msg.sender == deployer);\r\n        deployer = _newOwner;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\ncontract TwoKeySingletonesRegistry is TwoKeySingletonRegistryAbstract {\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        deployer = msg.sender;\r\n        congress = \"TwoKeyCongress\";\r\n        maintainersRegistry = \"TwoKeyMaintainersRegistry\";\r\n    }\r\n\r\n}\r\n\r\ncontract Proxy {\r\n\r\n\r\n    // Gives the possibility to delegate any call to a foreign implementation.\r\n\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () payable public {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n\r\ncontract UpgradeabilityStorage {\r\n    // Versions registry\r\n    ITwoKeySingletonesRegistry internal registry;\r\n\r\n    // Address of the current implementation\r\n    address internal _implementation;\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address) {\r\n        return _implementation;\r\n    }\r\n}\r\n\r\ncontract UpgradabilityProxyAcquisition is Proxy, UpgradeabilityStorage {\r\n\r\n    constructor (string _contractName, string _version) public {\r\n        registry = ITwoKeySingletonesRegistry(msg.sender);\r\n        _implementation = registry.getVersion(_contractName, _version);\r\n    }\r\n}\r\n\r\ncontract UpgradeabilityProxy is Proxy, UpgradeabilityStorage {\r\n\r\n    //TODO: Add event through event source whenever someone calls upgradeTo\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor (string _contractName, string _version) public {\r\n        registry = ITwoKeySingletonesRegistry(msg.sender);\r\n        _implementation = registry.getVersion(_contractName, _version);\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation to the requested version\r\n    * @param _version representing the version name of the new implementation to be set\r\n    */\r\n    function upgradeTo(string _contractName, string _version, address _impl) public {\r\n        require(msg.sender == address(registry));\r\n        require(_impl != address(0));\r\n        _implementation = _impl;\r\n    }\r\n\r\n}\r\n\r\ncontract Upgradeable is UpgradeabilityStorage {\r\n    /**\r\n     * @dev Validates the caller is the versions registry.\r\n     * @param sender representing the address deploying the initial behavior of the contract\r\n     */\r\n    function initialize(address sender) public payable {\r\n        require(msg.sender == address(registry));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"contractNameStorage\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"string\"}],\"name\":\"createProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"string\"}],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"string\"}],\"name\":\"upgradeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"string\"},{\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"addVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"campaignType\",\"type\":\"string\"}],\"name\":\"approveCampaignVersionDuringCreation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getLatestAddedContractVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"addNonUpgradableContractToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignType\",\"type\":\"string\"}],\"name\":\"getLatestCampaignApprovedVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"campaignType\",\"type\":\"string\"},{\"name\":\"versionToApprove\",\"type\":\"string\"}],\"name\":\"approveCampaignVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"changeNonUpgradableContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"string\"}],\"name\":\"getContractProxyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractLogicName\",\"type\":\"string\"},{\"name\":\"contractStorageName\",\"type\":\"string\"},{\"name\":\"contractLogicImplementation\",\"type\":\"address\"},{\"name\":\"contractStorageImplementation\",\"type\":\"address\"},{\"name\":\"version\",\"type\":\"string\"}],\"name\":\"addVersionDuringCreation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getNonUpgradableContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"logicProxy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"storageProxy\",\"type\":\"address\"}],\"name\":\"ProxiesDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"implementation\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"VersionAdded\",\"type\":\"event\"}]","ContractName":"TwoKeySingletonesRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://33fb268c01ec4e82fb8ef099dd72df1bb13cd8d5a1cc1794351bc1aa191af2a0"}]}