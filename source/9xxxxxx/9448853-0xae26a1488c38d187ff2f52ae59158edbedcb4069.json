{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.2;\r\n\r\n\r\ncontract Pathogen721{\r\n\r\n    constructor() public{\r\n\r\n        supportedInterfaces[0x6466353c] = true;\r\n        supportedInterfaces[0x780e9d63] = true;\r\n        supportedInterfaces[0x5b5e139f] = true;\r\n        supportedInterfaces[0x01ffc9a7] = true;\r\n\r\n        LAST_INFECTION = now;\r\n    }\r\n\r\n    //PATHOGEN\r\n    //tokenId   => strain\r\n    mapping (   uint    =>  uint)      STRAINS;\r\n    mapping (address => uint)   IMMUNITY;\r\n    //    mapping (address => uint)   coughs; //<token balance\r\n    mapping (address => uint)  DEATH_DATE;\r\n    uint constant INFECTIOUSNESS = 3;\r\n    uint constant STABILITY = 5;\r\n\r\n    uint public LAST_INFECTION = 0;\r\n\r\n    uint public INFECTIONS = 0;\r\n\r\n\r\n    //////===721 Standard\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    ///\r\n\r\n\r\n    //////===721 Implementation\r\n    mapping(address => uint256) internal BALANCES;\r\n    mapping (uint256 => address) internal ALLOWANCE;\r\n    mapping (address => mapping (address => bool)) internal AUTHORISED;\r\n\r\n    //    uint[] PATHOGENS;\r\n    uint[] PATHOGENS;                      //Array of all tickets [tokenId,tokenId,...]\r\n    mapping(uint256 => address) OWNERS;  //Mapping of ticket owners\r\n\r\n    //    METADATA VARS\r\n    string private __name = \"EtherVirus\";\r\n    string private __symbol = \"2020-nEthV\";\r\n    string private __tokenURI = \"https://anallergytoanalogy.github.io/pathogen/metadata/2020-nEthV.json\";\r\n\r\n    //    ENUMERABLE VARS\r\n    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;\r\n    mapping(uint => uint) internal OWNER_ID_TO_INDEX;\r\n    mapping(uint => uint) internal ID_TO_INDEX;\r\n\r\n\r\n\r\n    function vitalSigns(address patient) public view returns(\r\n        bool alive,\r\n        uint pathogens,\r\n        uint immunity,\r\n        uint death_date\r\n    ){\r\n        return (\r\n        isAlive(patient),\r\n        BALANCES[patient],\r\n        IMMUNITY[patient],\r\n        DEATH_DATE[patient]\r\n        );\r\n    }\r\n\r\n    function isAlive(address patient) public view returns(bool){\r\n        return (DEATH_DATE[patient] == 0 || DEATH_DATE[patient] > now);\r\n    }\r\n\r\n\r\n    function get_now() public view returns (uint){\r\n        return now;\r\n    }\r\n    function get_block_number() public view returns(uint){\r\n        return block.number;\r\n    }\r\n    function patientZero() public{\r\n        require(INFECTIONS == 0,\"exists\");\r\n        for(uint i = 0; i < INFECTIOUSNESS; i++){\r\n            issueToken(msg.sender,1);\r\n        }\r\n        DEATH_DATE[msg.sender] = now + 1 weeks;\r\n        INFECTIONS++;\r\n\r\n        IMMUNITY[msg.sender] = 1;\r\n        LAST_INFECTION = now;\r\n    }\r\n    function infectMe() public{\r\n        require(LAST_INFECTION + 1 weeks > now ,\"extinct\");\r\n        require(isAlive(msg.sender),\"dead\");\r\n        require(BALANCES[msg.sender] == 0,\"sick\");\r\n        INFECTIONS++;\r\n\r\n        uint strain = STRAINS[PATHOGENS[PATHOGENS.length-1]];\r\n        if(strain < IMMUNITY[msg.sender]){\r\n            strain = IMMUNITY[msg.sender] + 1;\r\n        }\r\n\r\n        for(uint i = 0; i < INFECTIOUSNESS; i++){\r\n            issueToken(msg.sender,strain);\r\n        }\r\n        DEATH_DATE[msg.sender] = now + 1 weeks;\r\n\r\n        IMMUNITY[msg.sender] = strain;\r\n        LAST_INFECTION = now;\r\n    }\r\n\r\n    function vaccinate(uint tokenId, uint vaccine) public{\r\n        require(isValidToken(tokenId),\"invalid\");\r\n        require(isAlive(msg.sender),\"dead\");\r\n        require(BALANCES[msg.sender] == 0,\"sick\");\r\n        require(STRAINS[tokenId] > IMMUNITY[msg.sender],\"obsolete\");\r\n\r\n        uint vaccine_processed_0 = uint(0) - uint(keccak256(abi.encodePacked(vaccine)));\r\n        uint vaccine_processed_1 = uint(keccak256(abi.encodePacked(vaccine_processed_0)));\r\n\r\n        require(STRAINS[tokenId] - vaccine_processed_1 == 0,\"ineffective\");\r\n\r\n        IMMUNITY[msg.sender] = STRAINS[tokenId];\r\n    }\r\n\r\n\r\n\r\n    /// @notice Checks if a given tokenId is valid\r\n    /// @dev If adding the ability to burn tokens, this function will need to reflect that.\r\n    /// @param _tokenId The tokenId to check\r\n    /// @return (bool) True if valid, False if not valid.\r\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\r\n        return OWNERS[_tokenId] != address(0);\r\n    }\r\n\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256){\r\n        return BALANCES[_owner];\r\n    }\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) public view returns(address){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return OWNERS[_tokenId];\r\n    }\r\n\r\n\r\n    //TODO indexTokens indexes and PATHOGENS are functionally the same\r\n    function issueToken(address owner, uint strain) internal {\r\n        uint tokenId = PATHOGENS.length + 1;\r\n\r\n        OWNERS[tokenId] = owner;\r\n        BALANCES[owner]++;\r\n        STRAINS[tokenId] = strain;\r\n\r\n\r\n        OWNER_ID_TO_INDEX[tokenId] = OWNER_INDEX_TO_ID[owner].length;\r\n        OWNER_INDEX_TO_ID[owner].push(tokenId);\r\n\r\n        ID_TO_INDEX[tokenId] = PATHOGENS.length;\r\n        PATHOGENS.push(tokenId);\r\n\r\n        emit Transfer(address(0),owner,tokenId);\r\n    }\r\n\r\n    function canInfect(address vector, address victim, uint _tokenId) public view returns(string memory){\r\n        if(victim.balance == 0) return \"victim_inactive\";\r\n        if(DEATH_DATE[victim] > 0 && now >= DEATH_DATE[victim]) return \"victim_dead\";\r\n        if(now >= DEATH_DATE[vector]) return \"vector_dead\";\r\n        if(BALANCES[victim] > 0)    return \"victim_sick\";\r\n        if(STRAINS[_tokenId] <= IMMUNITY[victim]) return \"victim_immune\";\r\n        if(BALANCES[vector] == 0) return \"vector_healthy\";\r\n        return \"okay\";\r\n    }\r\n\r\n    function infect(address vector, address victim, uint _tokenId) internal{\r\n        require(victim.balance > 0,\"victim_inactive\");\r\n\r\n        require(DEATH_DATE[victim] == 0 || now < DEATH_DATE[victim],\"victim_dead\");\r\n        require(STRAINS[_tokenId] > IMMUNITY[victim],\"victim_immune\");\r\n        require(BALANCES[victim] == 0,\"victim_sick\");\r\n\r\n        require(now < DEATH_DATE[vector],\"vector_dead\");\r\n        require(BALANCES[vector] > 0,\"vector_healthy\");\r\n\r\n        DEATH_DATE[victim] = now + 1 weeks;\r\n        //        coughs[victim] = 3;\r\n        //transfer this token and mint 2 more the same\r\n\r\n        uint strain = STRAINS[_tokenId];\r\n        strain += (block.timestamp%STABILITY+1)/STABILITY;\r\n\r\n        for(uint i = 0; i < INFECTIOUSNESS-1; i++){\r\n            issueToken(victim,strain);\r\n        }\r\n        IMMUNITY[victim] = strain;\r\n        LAST_INFECTION = now;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId)  external{\r\n        address owner = ownerOf(_tokenId);\r\n        require( owner == msg.sender                    //Require Sender Owns Token\r\n        || AUTHORISED[owner][msg.sender]                //  or is approved for all.\r\n        ,\"permission\");\r\n        emit Approval(owner, _approved, _tokenId);\r\n        ALLOWANCE[_tokenId] = _approved;\r\n    }\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return ALLOWANCE[_tokenId];\r\n    }\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return AUTHORISED[_owner][_operator];\r\n    }\r\n\r\n\r\n\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all your assets.\r\n    /// @dev Emits the ApprovalForAll event\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        emit ApprovalForAll(msg.sender,_operator, _approved);\r\n        AUTHORISED[msg.sender][_operator] = _approved;\r\n    }\r\n\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n\r\n\r\n        //Check Transferable\r\n        //There is a token validity check in ownerOf\r\n        address owner = ownerOf(_tokenId);\r\n\r\n        require ( owner == msg.sender             //Require sender owns token\r\n        //Doing the two below manually instead of referring to the external methods saves gas\r\n        || ALLOWANCE[_tokenId] == msg.sender      //or is approved for this token\r\n        || AUTHORISED[owner][msg.sender]          //or is approved for all\r\n        ,\"permission\");\r\n        require(owner == _from,\"owner\");\r\n        require(_to != address(0),\"zero\");\r\n        //require(isValidToken(_tokenId)); <-- done by ownerOf\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n\r\n        infect(_from, _to,  _tokenId);\r\n\r\n\r\n        OWNERS[_tokenId] =_to;\r\n\r\n        BALANCES[_from]--;\r\n        BALANCES[_to]++;\r\n\r\n        //Reset approved if there is one\r\n        if(ALLOWANCE[_tokenId] != address(0)){\r\n            delete ALLOWANCE[_tokenId];\r\n        }\r\n\r\n        //Enumerable Additions\r\n        uint oldIndex = OWNER_ID_TO_INDEX[_tokenId];\r\n        //If the token isn't the last one in the owner's index\r\n        if(oldIndex != OWNER_INDEX_TO_ID[_from].length - 1){\r\n            //Move the old one in the index list\r\n            OWNER_INDEX_TO_ID[_from][oldIndex] = OWNER_INDEX_TO_ID[_from][OWNER_INDEX_TO_ID[_from].length - 1];\r\n            //Update the token's reference to its place in the index list\r\n            OWNER_ID_TO_INDEX[OWNER_INDEX_TO_ID[_from][oldIndex]] = oldIndex;\r\n        }\r\n        //OWNER_INDEX_TO_ID[_from].length--;\r\n        OWNER_INDEX_TO_ID[_from].pop();\r\n\r\n        OWNER_ID_TO_INDEX[_tokenId] = OWNER_INDEX_TO_ID[_to].length;\r\n        OWNER_INDEX_TO_ID[_to].push(_tokenId);\r\n\r\n\r\n        if(BALANCES[_from] == 0 ){\r\n            DEATH_DATE[_from] += 52000 weeks;\r\n        }else{\r\n            INFECTIONS++;\r\n        }\r\n\r\n    }\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\r\n        transferFrom(_from, _to, _tokenId);\r\n\r\n        //Get size of \"_to\" address, if 0 it's a wallet\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_to)\r\n        }\r\n        if(size > 0){\r\n            ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);\r\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\"receiver\");\r\n        }\r\n\r\n    }\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        safeTransferFrom(_from,_to,_tokenId,\"\");\r\n    }\r\n\r\n\r\n\r\n\r\n    // METADATA FUNCTIONS\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    /// @param _tokenId The tokenId of the token of which to retrieve the URI.\r\n    /// @return (string) The URI of the token.\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory){\r\n        //Note: changed visibility to public\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return __tokenURI;\r\n    }\r\n\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string memory _name){\r\n        //_name = \"Name must be hard coded\";\r\n        return __name;\r\n    }\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string memory _symbol){\r\n        //_symbol = \"Symbol must be hard coded\";\r\n        return __symbol;\r\n    }\r\n\r\n\r\n    // ENUMERABLE FUNCTIONS\r\n\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256){\r\n        return PATHOGENS.length;\r\n    }\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns(uint256){\r\n        require(_index < PATHOGENS.length,\"index\");\r\n        return PATHOGENS[_index];\r\n\r\n\r\n    }\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256){\r\n        require(_index < BALANCES[_owner],\"index\");\r\n        return OWNER_INDEX_TO_ID[_owner][_index];\r\n    }\r\n    ///===End 721 Implementation\r\n\r\n    ///////===165 Implementation\r\n    mapping (bytes4 => bool) internal supportedInterfaces;\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool){\r\n        return supportedInterfaces[interfaceID];\r\n    }\r\n    ///==End 165\r\n}\r\n\r\n\r\n\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\ncontract ValidReceiver is ERC721TokenReceiver{\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) override external returns(bytes4){\r\n        _operator;_from;_tokenId;_data;\r\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n}\r\n\r\ncontract InvalidReceiver is ERC721TokenReceiver{\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) override external returns(bytes4){\r\n        _operator;_from;_tokenId;_data;\r\n        return bytes4(keccak256(\"suck it nerd\"));\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INFECTIONS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAST_INFECTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"victim\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"canInfect\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_block_number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_now\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"infectMe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"}],\"name\":\"isAlive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"patientZero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaccine\",\"type\":\"uint256\"}],\"name\":\"vaccinate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"}],\"name\":\"vitalSigns\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"alive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pathogens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"immunity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"death_date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Pathogen721","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://d7ffdbabd34c139e5c10ef0dd06f7e8f6108ea09368567d70922c8e9a72153fc"}]}