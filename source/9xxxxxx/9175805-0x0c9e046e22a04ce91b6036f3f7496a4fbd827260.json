{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n* Absolutus smart contract by BioHazzardt\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b, 'Invalid values');\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, 'Substraction result smaller than zero');\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'Invalid values');\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public manager;\r\n    address public ownerWallet;\r\n    address public adminWallet;\r\n    uint adminPersent;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        manager = msg.sender;\r\n        adminWallet = 0xcFebf7C3Ec7B407DFf17aa20a2631c95c8ff508c;\r\n        ownerWallet = 0xcFebf7C3Ec7B407DFf17aa20a2631c95c8ff508c;\r\n        adminPersent = 10;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only for owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrManager() {\r\n        require((msg.sender == owner)||(msg.sender == manager), \"only for owner or manager\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setManager(address _manager) public onlyOwnerOrManager {\r\n        manager = _manager;\r\n    }\r\n\r\n    function setAdminWallet(address _admin) public onlyOwner {\r\n        adminWallet = _admin;\r\n    }\r\n}\r\n\r\n\r\ncontract WalletOnly {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\n\r\ncontract Absolutus is Ownable, WalletOnly {\r\n    // Events\r\n    event RegLevelEvent(address indexed _user, address indexed _referrer, uint _id, uint _time);\r\n    event BuyLevelEvent(address indexed _user, uint _level, uint _time);\r\n    event ProlongateLevelEvent(address indexed _user, uint _level, uint _time);\r\n    event GetMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time, uint _price, bool _prevLost);\r\n    event LostMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time, uint _price, bool _prevLost);\r\n\r\n    // New events\r\n    event PaymentForHolder(address indexed _addr, uint _index, uint _value);\r\n    event PaymentForHolderLost(address indexed _addr, uint _index, uint _value);\r\n\r\n    // Common values\r\n    mapping (uint => uint) public LEVEL_PRICE;\r\n    address canSetLevelPrice;\r\n    uint REFERRER_1_LEVEL_LIMIT = 3;\r\n    uint PERIOD_LENGTH = 365 days; // uncomment before production\r\n    uint MAX_AUTOPAY_COUNT = 5;     // Automatic level buying limit per one transaction (to prevent gas limit reaching)\r\n\r\n    struct UserStruct {\r\n        bool isExist;\r\n        uint id;\r\n        uint referrerID;\r\n        uint fund;          // Fund for the automatic level pushcase\r\n        uint currentLvl;    // Current user's level\r\n        address[] referral;\r\n        mapping (uint => uint) levelExpired;\r\n        mapping (uint => uint) paymentsCount;\r\n    }\r\n\r\n    mapping (address => UserStruct) public users;\r\n    mapping (uint => address) public userList;\r\n    mapping (address => uint) public allowUsers;\r\n\r\n    uint public currUserID = 0;\r\n    bool nostarted = false;\r\n\r\n    AbsDAO _dao; // DAO contract\r\n    bool daoSet = false; // if true payment processed for DAO holders\r\n\r\n    using SafeMath for uint; // <== do not forget about this\r\n\r\n    constructor() public {\r\n        // Prices in ETH: production\r\n        LEVEL_PRICE[1] = 0.5 ether;\r\n        LEVEL_PRICE[2] = 1.0 ether;\r\n        LEVEL_PRICE[3] = 2.0 ether;\r\n        LEVEL_PRICE[4] = 4.0 ether;\r\n        LEVEL_PRICE[5] = 16.0 ether;\r\n        LEVEL_PRICE[6] = 32.0 ether;\r\n        LEVEL_PRICE[7] = 64.0 ether;\r\n        LEVEL_PRICE[8] = 128.0 ether;\r\n\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n\r\n        canSetLevelPrice = owner;\r\n\r\n        // Create root user\r\n        userStruct = UserStruct({\r\n            isExist : true,\r\n            id : currUserID,\r\n            referrerID : 0,\r\n            fund: 0,\r\n            currentLvl: 1,\r\n            referral : new address[](0)\r\n        });\r\n\r\n        users[ownerWallet] = userStruct;\r\n        userList[currUserID] = ownerWallet;\r\n\r\n        users[ownerWallet].levelExpired[1] = 77777777777;\r\n        users[ownerWallet].levelExpired[2] = 77777777777;\r\n        users[ownerWallet].levelExpired[3] = 77777777777;\r\n        users[ownerWallet].levelExpired[4] = 77777777777;\r\n        users[ownerWallet].levelExpired[5] = 77777777777;\r\n        users[ownerWallet].levelExpired[6] = 77777777777;\r\n        users[ownerWallet].levelExpired[7] = 77777777777;\r\n        users[ownerWallet].levelExpired[8] = 77777777777;\r\n\r\n        // Set inviting registration only\r\n        nostarted = true;\r\n    }\r\n\r\n    function () external payable {\r\n        require(!isContract(msg.sender), 'This contract cannot support payments from other contracts');\r\n\r\n        uint level;\r\n\r\n        // Check for payment with level price\r\n        if (msg.value == LEVEL_PRICE[1]) {\r\n            level = 1;\r\n        } else if (msg.value == LEVEL_PRICE[2]) {\r\n            level = 2;\r\n        } else if (msg.value == LEVEL_PRICE[3]) {\r\n            level = 3;\r\n        } else if (msg.value == LEVEL_PRICE[4]) {\r\n            level = 4;\r\n        } else if (msg.value == LEVEL_PRICE[5]) {\r\n            level = 5;\r\n        } else if (msg.value == LEVEL_PRICE[6]) {\r\n            level = 6;\r\n        } else if (msg.value == LEVEL_PRICE[7]) {\r\n            level = 7;\r\n        } else if (msg.value == LEVEL_PRICE[8]) {\r\n            level = 8;\r\n        } else {\r\n            // Pay to user's fund\r\n            if (!users[msg.sender].isExist || users[msg.sender].currentLvl >= 8)\r\n                revert('Incorrect Value send');\r\n\r\n            users[msg.sender].fund += msg.value;\r\n            updateCurrentLevel(msg.sender);\r\n            // if the referer is have funds for autobuy next level\r\n            if (LEVEL_PRICE[users[msg.sender].currentLvl+1] <= users[msg.sender].fund) {\r\n                buyLevelByFund(msg.sender, 0);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Buy level or register user\r\n        if (users[msg.sender].isExist) {\r\n            buyLevel(level);\r\n        } else if (level == 1) {\r\n            uint refId = 0;\r\n            address referrer = bytesToAddress(msg.data);\r\n\r\n            if (users[referrer].isExist) {\r\n                refId = users[referrer].id;\r\n            } else {\r\n                revert('Incorrect referrer');\r\n                // refId = 1;\r\n            }\r\n\r\n            regUser(refId);\r\n        } else {\r\n            revert(\"Please buy first level for 0.1 ETH\");\r\n        }\r\n    }\r\n\r\n    // allow user in invite mode\r\n    function allowUser(address _user) public onlyOwner {\r\n        require(nostarted, 'You cant allow user in battle mode');\r\n        allowUsers[_user] = 1;\r\n    }\r\n\r\n    // disable inviting\r\n    function battleMode() public onlyOwner {\r\n        require(nostarted, 'Battle mode activated');\r\n        nostarted = false;\r\n    }\r\n\r\n    // this function sets the DAO contract address\r\n    function setDAOAddress(address payable _dao_addr) public onlyOwner {\r\n        require(!daoSet, 'DAO address already set');\r\n        _dao = AbsDAO(_dao_addr);\r\n        daoSet = true;\r\n    }\r\n\r\n    // process payment to administrator wallet\r\n    // or DAO holders\r\n    function payToAdmin(uint _amount) internal {\r\n        if (daoSet) {\r\n            // Pay for DAO\r\n            uint holderCount = _dao.getHolderCount();       // get the DAO holders count\r\n            for (uint i = 1; i <= holderCount; i++) {\r\n                uint val = _dao.getHolderPieAt(i);          // get pie of holder with index == i\r\n                address payable holder = _dao.getHolder(i); // get the holder address\r\n\r\n                if (val > 0) {                              // check of the holder pie value\r\n                    uint payValue = _amount.div(100).mul(val); // calculate amount for pay to the holder\r\n                    holder.transfer(payValue);\r\n                    emit PaymentForHolder(holder, i, payValue); // payment ok\r\n                } else {\r\n                    emit PaymentForHolderLost(holder, i, val); // holder's pie value is zero\r\n                }\r\n            }\r\n        } else {\r\n            // pay to admin wallet\r\n            address(uint160(adminWallet)).transfer(_amount);\r\n        }\r\n    }\r\n\r\n    // user registration\r\n    function regUser(uint referrerID) public payable {\r\n        require(!isContract(msg.sender), 'This contract cannot support payments from other contracts');\r\n\r\n        if (nostarted) {\r\n            require(allowUsers[msg.sender] > 0, 'You cannot use this contract on start');\r\n        }\r\n\r\n        require(!users[msg.sender].isExist, 'User exist');\r\n        require(referrerID > 0 && referrerID <= currUserID, 'Incorrect referrer Id');\r\n        require(msg.value==LEVEL_PRICE[1], 'Incorrect Value');\r\n\r\n        // NOTE: use one more variable to prevent 'Security/No-assign-param' error (for vscode-solidity extension).\r\n        // Need to check the gas consumtion with it\r\n        uint _referrerID = referrerID;\r\n\r\n        if (users[userList[referrerID]].referral.length >= REFERRER_1_LEVEL_LIMIT) {\r\n            _referrerID = users[findFreeReferrer(userList[referrerID])].id;\r\n        }\r\n\r\n\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n\r\n        // add user to list\r\n        userStruct = UserStruct({\r\n            isExist : true,\r\n            id : currUserID,\r\n            referrerID : _referrerID,\r\n            fund: 0,\r\n            currentLvl: 1,\r\n            referral : new address[](0)\r\n        });\r\n\r\n        users[msg.sender] = userStruct;\r\n        userList[currUserID] = msg.sender;\r\n\r\n        users[msg.sender].levelExpired[1] = now + PERIOD_LENGTH;\r\n        users[msg.sender].levelExpired[2] = 0;\r\n        users[msg.sender].levelExpired[3] = 0;\r\n        users[msg.sender].levelExpired[4] = 0;\r\n        users[msg.sender].levelExpired[5] = 0;\r\n        users[msg.sender].levelExpired[6] = 0;\r\n        users[msg.sender].levelExpired[7] = 0;\r\n        users[msg.sender].levelExpired[8] = 0;\r\n\r\n        users[userList[_referrerID]].referral.push(msg.sender);\r\n\r\n        // pay for referer\r\n        payForLevel(\r\n            1,\r\n            msg.sender,\r\n            msg.sender,\r\n            0,\r\n            false\r\n        );\r\n\r\n        emit RegLevelEvent(\r\n            msg.sender,\r\n            userList[_referrerID],\r\n            currUserID,\r\n            now\r\n        );\r\n    }\r\n\r\n    // buy level function\r\n    function buyLevel(uint _level) public payable {\r\n        require(!isContract(msg.sender), 'This contract cannot support payments from other contracts');\r\n\r\n        require(users[msg.sender].isExist, 'User not exist');\r\n        require(_level>0 && _level<=8, 'Incorrect level');\r\n        require(msg.value==LEVEL_PRICE[_level], 'Incorrect Value');\r\n\r\n        if (_level > 1) { // Replace for condition (_level == 1) on top (done)\r\n            for (uint i = _level-1; i>0; i--) {\r\n                require(users[msg.sender].levelExpired[i] >= now, 'Buy the previous level');\r\n            }\r\n        }\r\n\r\n        // if(users[msg.sender].levelExpired[_level] == 0){ <-- BUG\r\n        // if the level expired in the future, need add PERIOD_LENGTH to the level expiration time,\r\n        // or set the level expiration time to 'now + PERIOD_LENGTH' in other cases.\r\n        if (users[msg.sender].levelExpired[_level] > now) {\r\n            users[msg.sender].levelExpired[_level] += PERIOD_LENGTH;\r\n        } else {\r\n            users[msg.sender].levelExpired[_level] = now + PERIOD_LENGTH;\r\n        }\r\n\r\n        // Set user's current level\r\n        if (users[msg.sender].currentLvl < _level)\r\n            users[msg.sender].currentLvl = _level;\r\n\r\n        // provide payment for the user's referer\r\n        payForLevel(\r\n            _level,\r\n            msg.sender,\r\n            msg.sender,\r\n            0,\r\n            false\r\n        );\r\n\r\n        emit BuyLevelEvent(msg.sender, _level, now);\r\n    }\r\n\r\n    function setLevelPrice(uint _level, uint _price) public {\r\n        require(_level >= 0 && _level <= 8, 'Invalid level');\r\n        require(msg.sender == canSetLevelPrice, 'Invalid caller');\r\n        require(_price > 0, 'Price cannot be zero or negative');\r\n\r\n        LEVEL_PRICE[_level] = _price * 1.0 finney;\r\n    }\r\n\r\n    function setCanUpdateLevelPrice(address addr) public onlyOwner {\r\n        canSetLevelPrice = addr;\r\n    }\r\n\r\n    // for interactive correction of the limitations\r\n    function setMaxAutopayForLevelCount(uint _count) public onlyOwnerOrManager {\r\n        MAX_AUTOPAY_COUNT = _count;\r\n    }\r\n\r\n    // buyLevelByFund provides automatic payment for next level for user\r\n    function buyLevelByFund(address referer, uint _counter) internal {\r\n        require(users[referer].isExist, 'User not exists');\r\n\r\n        uint _level = users[referer].currentLvl + 1; // calculate a next level\r\n        require(users[referer].fund >= LEVEL_PRICE[_level], 'Not have funds to autobuy level');\r\n\r\n        uint remaining = users[referer].fund - LEVEL_PRICE[_level]; // Amount for pay to the referer\r\n\r\n        // extend the level's expiration time\r\n        if (users[referer].levelExpired[_level] >= now) {\r\n            users[referer].levelExpired[_level] += PERIOD_LENGTH;\r\n        } else {\r\n            users[referer].levelExpired[_level] = now + PERIOD_LENGTH;\r\n        }\r\n\r\n        users[referer].currentLvl = _level; // set current level for referer\r\n        users[referer].fund = 0;            // clear the referer's fund\r\n\r\n        // process payment for next referer with increment autopay counter\r\n        payForLevel(\r\n            _level,\r\n            referer,\r\n            referer,\r\n            _counter+1,\r\n            false\r\n        );\r\n        address(uint160(referer)).transfer(remaining); // send the remaining amount to referer\r\n\r\n        emit BuyLevelEvent(referer, _level, now); // emit the buy level event for referer\r\n    }\r\n\r\n    // updateCurrentLevel calculate 'currentLvl' value for given user\r\n    function updateCurrentLevel(address _user) internal {\r\n        users[_user].currentLvl = actualLevel(_user);\r\n    }\r\n\r\n    // helper function\r\n    function actualLevel(address _user) public view returns(uint) {\r\n        require(users[_user].isExist, 'User not found');\r\n\r\n        for (uint i = 1; i <= 8; i++) {\r\n            if (users[_user].levelExpired[i] <= now) {\r\n                return i-1;\r\n            }\r\n        }\r\n\r\n        return 8;\r\n    }\r\n\r\n    // payForLevel provides payment processing for user's referer and automatic buying referer's next\r\n    // level.\r\n    function payForLevel(uint _level, address _user, address _sender, uint _autoPayCtr, bool prevLost) internal {\r\n        address referer;\r\n        address referer1;\r\n        address referer2;\r\n        address referer3;\r\n\r\n        if (_level == 1 || _level == 5) {\r\n            referer = userList[users[_user].referrerID];\r\n        } else if (_level == 2 || _level == 6) {\r\n            referer1 = userList[users[_user].referrerID];\r\n            referer = userList[users[referer1].referrerID];\r\n        } else if (_level == 3 || _level == 7) {\r\n            referer1 = userList[users[_user].referrerID];\r\n            referer2 = userList[users[referer1].referrerID];\r\n            referer = userList[users[referer2].referrerID];\r\n        } else if (_level == 4 || _level == 8) {\r\n            referer1 = userList[users[_user].referrerID];\r\n            referer2 = userList[users[referer1].referrerID];\r\n            referer3 = userList[users[referer2].referrerID];\r\n            referer = userList[users[referer3].referrerID];\r\n        }\r\n\r\n        if (!users[referer].isExist) {\r\n            referer = userList[1];\r\n        }\r\n\r\n        uint amountToUser;\r\n        uint amountToAdmin;\r\n\r\n        amountToAdmin = LEVEL_PRICE[_level] / 100 * adminPersent;\r\n        amountToUser = LEVEL_PRICE[_level] - amountToAdmin;\r\n\r\n        if (users[referer].id <= 4) {\r\n            payToAdmin(LEVEL_PRICE[_level]);\r\n\r\n            emit GetMoneyForLevelEvent(\r\n                referer,\r\n                _sender,\r\n                _level,\r\n                now,\r\n                amountToUser,\r\n                prevLost\r\n            );\r\n\r\n            return;\r\n        }\r\n\r\n        if (users[referer].levelExpired[_level] >= now) {\r\n            payToAdmin(amountToAdmin);\r\n\r\n            // update current referer's level\r\n            updateCurrentLevel(referer);\r\n\r\n\r\n            // check for the user has right level and automatic payment counter\r\n            // smaller than the 'MAX_AUTOPAY_COUNT' value\r\n            if (_level == users[referer].currentLvl && _autoPayCtr < MAX_AUTOPAY_COUNT && users[referer].currentLvl < 8) {\r\n                users[referer].fund += amountToUser;\r\n\r\n                emit GetMoneyForLevelEvent(\r\n                    referer,\r\n                    _sender,\r\n                    _level,\r\n                    now,\r\n                    amountToUser,\r\n                    prevLost\r\n                );\r\n\r\n                // if the referer is have funds for autobuy next level\r\n                if (LEVEL_PRICE[users[referer].currentLvl+1] <= users[referer].fund) {\r\n                    buyLevelByFund(referer, _autoPayCtr);\r\n                }\r\n            } else {\r\n                // send the ethers to referer\r\n                address(uint160(referer)).transfer(amountToUser);\r\n\r\n                emit GetMoneyForLevelEvent(\r\n                    referer,\r\n                    _sender,\r\n                    _level,\r\n                    now,\r\n                    amountToUser,\r\n                    prevLost\r\n                );\r\n            }\r\n        } else {\r\n            // pay for the referer's referer\r\n            emit LostMoneyForLevelEvent(\r\n                referer,\r\n                _sender,\r\n                _level,\r\n                now,\r\n                amountToUser,\r\n                prevLost\r\n            );\r\n\r\n            payForLevel(\r\n                _level,\r\n                referer,\r\n                _sender,\r\n                _autoPayCtr,\r\n                true\r\n            );\r\n        }\r\n    }\r\n\r\n    function findFreeReferrer(address _user) public view returns(address) {\r\n        if (users[_user].referral.length < REFERRER_1_LEVEL_LIMIT) {\r\n            return _user;\r\n        }\r\n\r\n        address[] memory referrals = new address[](363);\r\n        referrals[0] = users[_user].referral[0];\r\n        referrals[1] = users[_user].referral[1];\r\n        referrals[2] = users[_user].referral[2];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for (uint i = 0; i<363; i++) {\r\n            if (users[referrals[i]].referral.length == REFERRER_1_LEVEL_LIMIT) {\r\n                if (i<120) {\r\n                    referrals[(i+1)*3] = users[referrals[i]].referral[0];\r\n                    referrals[(i+1)*3+1] = users[referrals[i]].referral[1];\r\n                    referrals[(i+1)*3+2] = users[referrals[i]].referral[2];\r\n                }\r\n            } else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n        return freeReferrer;\r\n    }\r\n\r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return users[_user].referral;\r\n    }\r\n\r\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\r\n        return users[_user].levelExpired[_level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address  addr ) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract AbsDAO is Ownable, WalletOnly {\r\n    // events\r\n    event TransferPie(address indexed _from, address indexed _to, uint _value);\r\n    event NewHolder(address indexed _addr, uint _index);\r\n    event HolderChanged(address indexed _from, address indexed _to, uint _index);\r\n    event PaymentReceived(address indexed _from, uint _value);\r\n    event PaymentForHolder(address indexed _addr, uint _index, uint _value);\r\n    event PaymentForHolderLost(address indexed _addr, uint _index, uint _value);\r\n\r\n    struct Holder {\r\n        bool isExist;\r\n        uint id;\r\n        uint value;\r\n        address payable addr;\r\n    }\r\n\r\n    mapping(address => Holder) public holders;\r\n    mapping(uint=>address payable) holderAddrs;\r\n\r\n    uint holderCount;\r\n    uint _initialPie = 100;\r\n\r\n    using SafeMath for uint;\r\n\r\n    constructor() public {\r\n        // creating root hoder\r\n        holderCount = 1;\r\n        holders[msg.sender] = Holder({\r\n            isExist: true,\r\n            id: 1,\r\n            value: _initialPie,\r\n            addr: msg.sender\r\n        });\r\n\r\n        holderAddrs[1] = msg.sender;\r\n    }\r\n\r\n    function () external payable {\r\n        require(!isContract(msg.sender), 'This contract cannot support payments from other contracts');\r\n\r\n        emit PaymentReceived(msg.sender, msg.value);\r\n\r\n        for (uint i = 1; i <= holderCount; i++) {\r\n            if (holders[holderAddrs[i]].value > 0) {\r\n                uint payValue = msg.value.div(100).mul(holders[holderAddrs[i]].value);\r\n                holderAddrs[i].transfer(payValue);\r\n                emit PaymentForHolder(holderAddrs[i], i, payValue);\r\n            } else {\r\n                emit PaymentForHolderLost(holderAddrs[i], i, holders[holderAddrs[i]].value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getHolderPieAt(uint i) public view returns(uint) {\r\n        return holders[holderAddrs[i]].value;\r\n    }\r\n\r\n    function getHolder(uint i) public view returns(address payable) {\r\n        return holderAddrs[i];\r\n    }\r\n\r\n    function getHolderCount() public view returns(uint) {\r\n        return holderCount;\r\n    }\r\n\r\n    function transferPie(uint _amount, address payable _to) public {\r\n        require(holders[msg.sender].isExist, 'Holder not found');\r\n        require(_amount > 0 && _amount <= holders[msg.sender].value, 'Invalid amount');\r\n\r\n        if (_amount == holders[msg.sender].value) {\r\n            uint id = holders[msg.sender].id;\r\n            delete holders[msg.sender];\r\n\r\n            holders[_to] = Holder({\r\n                isExist: true,\r\n                id: id,\r\n                value: _amount,\r\n                addr: _to\r\n            });\r\n\r\n            holderAddrs[id] = _to;\r\n\r\n            emit HolderChanged(msg.sender, _to, id);\r\n        } else {\r\n            if (holders[_to].isExist) {\r\n                holders[msg.sender].value -= _amount;\r\n                holders[_to].value += _amount;\r\n            } else if (holderCount < 20) {\r\n                holderCount += 1;\r\n                holders[msg.sender].value -= _amount;\r\n                holders[_to] = Holder({\r\n                    isExist: true,\r\n                    id: holderCount,\r\n                    value: _amount,\r\n                    addr: _to\r\n                });\r\n\r\n                holderAddrs[holderCount] = _to;\r\n\r\n                emit NewHolder(_to, holderCount);\r\n            } else {\r\n                revert('Holder limit excised');\r\n            }\r\n        }\r\n\r\n        emit TransferPie(msg.sender, _to, _amount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"setMaxAutopayForLevelCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"actualLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdminWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setCanUpdateLevelPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"allowUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEVEL_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_dao_addr\",\"type\":\"address\"}],\"name\":\"setDAOAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currUserID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLvl\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"battleMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setLevelPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"RegLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"BuyLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"ProlongateLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_prevLost\",\"type\":\"bool\"}],\"name\":\"GetMoneyForLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_prevLost\",\"type\":\"bool\"}],\"name\":\"LostMoneyForLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"PaymentForHolder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"PaymentForHolderLost\",\"type\":\"event\"}]","ContractName":"Absolutus","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://18e2dfe8ebf7cefa713c3c410c3ee6e5b2a8151cd8310b4c152a6bbe075d75d3"}]}