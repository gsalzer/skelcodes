{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20Interface.sol\":{\"content\":\"pragma solidity \\u003e= 0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n//  ERC20 Interface\\r\\n//  - interface for ERC20 token functions for compatibility\\r\\ninterface ERC20Interface {\\r\\n    function balanceOf(address _who) external view returns (uint256);\\r\\n    function transfer(address _to, uint256 _value) external returns (bool);\\r\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\r\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\r\\n    function approve(address _spender, uint256 _value) external returns (bool);\\r\\n    \\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"LockupCampaign.sol\":{\"content\":\"pragma solidity \\u003e= 0.5.3 \\u003c 0.6.0;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./TimestampMonthConv.sol\\\";\\r\\nimport \\\"./ERC20Interface.sol\\\";\\r\\n//import \\\"./ERC223ReceivingContract.sol\\\";\\r\\n\\r\\n//  Ownership contract\\r\\n//  - token contract ownership for owner \\u0026 lockup addresses\\r\\n\\r\\ncontract Ownership {\\r\\n    address private _owner;\\r\\n    \\r\\n    event OwnerOwnershipTransferred(address indexed prevOwner, address indexed newOwner);\\r\\n    \\r\\n    // Returns contract owner address\\r\\n    function owner() public view returns (address){\\r\\n        return _owner;\\r\\n    }\\r\\n    \\r\\n    // Check if caller is owner account\\r\\n    function isOwner() public view returns (bool){\\r\\n        return (msg.sender == _owner);\\r\\n    }\\r\\n    \\r\\n    // Modifier for function restricted to owner only\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownership: the caller is not the owner address\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    // Transfer owner\\u0027s ownership to new address\\r\\n    // # param newOwner: address of new owner to be transferred\\r\\n    function transferOwnerOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnerOwnership(newOwner);\\r\\n    }\\r\\n    \\r\\n    // ==== internal functions ====\\r\\n\\r\\n    function _transferOwnerOwnership(address newOwner) internal {\\r\\n        require (newOwner != address(0), \\\"Ownable: new owner is zero address\\\");\\r\\n        emit OwnerOwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n    \\r\\n    function _setupOwnership(address own) internal {\\r\\n        require (own != address(0), \\\"Ownable: owner is zero address\\\");\\r\\n        _owner = own;\\r\\n        \\r\\n        emit OwnerOwnershipTransferred(address(0), own);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract LockupCampaign is Ownership {\\r\\n    using SafeMath for uint256;\\r\\n    using TimestampMonthConv for uint;\\r\\n    \\r\\n    enum LockStatus {NULL, LOCKED, UNLOCKED, RELEASED}\\r\\n    \\r\\n    struct WowbitInfo {\\r\\n        uint256 totalLocked;\\r\\n        uint256 totalExtraGiven;\\r\\n        uint256 currentLocked;\\r\\n        uint256 incentive3;\\r\\n        uint256 incentive6;\\r\\n        uint256 incentive9;\\r\\n    }\\r\\n    \\r\\n    struct ParticipatingUsers {\\r\\n        uint256 amountWWB;\\r\\n        uint256 month;\\r\\n        uint256 lockEnd;\\r\\n        bool incCalculated;\\r\\n        LockStatus status;\\r\\n    }\\r\\n    \\r\\n    struct UsersExtraTokens {\\r\\n        address[] exTokenAddress;\\r\\n        uint8[] exTokenDecimals;\\r\\n        uint256[] exTokenAmount;\\r\\n    }\\r\\n    \\r\\n    WowbitInfo public wwbInfo;\\r\\n    address public wwbAddress;\\r\\n    address[] public tokenAddresses;\\r\\n    uint8[] public tokenDecimals;\\r\\n    bool public firstSet = false;\\r\\n    mapping (address =\\u003e ParticipatingUsers) internal userList;\\r\\n    mapping (address =\\u003e UsersExtraTokens) internal extraList;\\r\\n    \\r\\n    event PreRegister(address indexed _userAddress);\\r\\n    event ConfirmRegister(address indexed _userAddress, uint256 startLock, uint256 endLock);\\r\\n    event TokenLocked(address indexed _userAddress, uint256 amount);\\r\\n    event TokenUnlocked(address indexed _userAddress, uint256 timestamp);\\r\\n    event TokenReleased(address indexed _userAddress, uint256 amount);\\r\\n    event RegisterEtcToken(address indexed _token);\\r\\n    event RemoveEtcToken(address indexed _token);\\r\\n    event EtcTokenRequested(address indexed _userAddress, address indexed _tokenAddress);\\r\\n    event EtcTokenReleased(address indexed _userAddress, address indexed _tokenAddress, uint256 _amountIncentives);\\r\\n    \\r\\n    constructor(address owner, address WwbTokenAddress) public{\\r\\n        _setupOwnership(owner);\\r\\n        wwbAddress = WwbTokenAddress;\\r\\n    }\\r\\n    \\r\\n    // --------------- ERC223 token fallback function ---------------\\r\\n    \\r\\n    // ERC223 supported tokenFallback: use erc223 transfer from token contract\\r\\n    function tokenFallback(address _from, uint _value, bytes memory _data) public {\\r\\n        string memory str = string(_data);\\r\\n        if(_from == owner()){\\r\\n            require((keccak256(abi.encodePacked((str))) == keccak256(abi.encodePacked((\\\"supply\\\")))),\\r\\n                    \\\"LockupCampaign: bytes command not authorized\\\");\\r\\n            // balance can be require from wwbTokenBalance() / otherTokenBalance()\\r\\n        } else if(_from != owner()){\\r\\n            require(userList[_from].lockEnd == 0, \\\"LockupCampaign: user not registered\\\");\\r\\n            _confirmRegister(_from, _value);\\r\\n            emit TokenLocked(_from, _value);\\r\\n        } else {\\r\\n            revert(\\\"LockupCampaign: not authorized\\\");\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // --------------- ERC20 token deposit function ---------------\\r\\n    \\r\\n    // ERC20 deposit function: owner needs to approve token using `approve()` function in respective participating ERC20 token contract\\r\\n    // before using this function (only owner function).\\r\\n    // # params erc20TokenAddress: address of the token to deposit\\r\\n    // # params amountToken: amount of token to deposit in contract\\r\\n    function depositApprovedERC20(address erc20TokenAddress, uint256 amountToken) public onlyOwner {\\r\\n        ERC20Interface(erc20TokenAddress).transferFrom(msg.sender, address(this), amountToken);\\r\\n    }\\r\\n    \\r\\n    // --------------- WWB tokens functions ---------------\\r\\n    \\r\\n    // Set the percentage interest rates (where 7% = 700) for respective months for WWB token (only owner function).\\r\\n    // # params rate_3month: percentage rate in 3 months\\r\\n    // # params rate_6month: percentage rate in 6 months\\r\\n    // # params rate_9month: percentage rate in 9 months\\r\\n    function setWwbRate(uint256 rate_3month, uint256 rate_6month, uint256 rate_9month) public onlyOwner {\\r\\n        _setWwbRate(rate_3month, rate_6month, rate_9month);\\r\\n    }\\r\\n    \\r\\n    // Retrieve the balance of WWB tokens in this contract.\\r\\n    // * returns (uint256): the amount of token in the contract\\r\\n    function wwbTokenBalance() public view returns (uint256){\\r\\n        return ERC20Interface(wwbAddress).balanceOf(address(this));\\r\\n    }\\r\\n    \\r\\n    // Returns all WWB tokens back to the owner (only owner function).\\r\\n    function returnAllWWBTokens() public onlyOwner {\\r\\n        ERC20Interface(wwbAddress).transfer(owner(), ERC20Interface(wwbAddress).balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    // Returns WWB information (only owner function).\\r\\n    function getWwbInfo() public view onlyOwner returns (uint256, uint256, uint256, uint256, uint256, uint256){\\r\\n        return (wwbInfo.totalLocked, wwbInfo.totalExtraGiven, wwbInfo.currentLocked, wwbInfo.incentive3, wwbInfo.incentive6, wwbInfo.incentive9);\\r\\n    }\\r\\n    \\r\\n    // --------------- participating tokens functions ---------------\\r\\n    \\r\\n    // Retrieve if token address is a participating token in lockup campaign.\\r\\n    // # params tokenAddress: address of the participating token\\r\\n    // * returns (bool): indication of token participation\\r\\n    function isParticipatingTokens(address tokenAddress) public view returns(bool){\\r\\n        for(uint i = 0; i \\u003c tokenAddresses.length; i++){\\r\\n            if(tokenAddresses[i] == tokenAddress) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Retrieve the balance of participating tokens in this contract.\\r\\n    // # params tokenAddress: address of the participating token\\r\\n    // * returns (uint256): the amount of participating token in the contract\\r\\n    function participatingTokenBalance(address tokenAddress) public view returns (uint256){\\r\\n        return ERC20Interface(tokenAddress).balanceOf(address(this));\\r\\n    }\\r\\n    \\r\\n    // Adds the participating tokens to be involved in lockup campaign\\r\\n    // # params tokenAddress: address of the participating token\\r\\n    // # params decimals: decimal of the participating token\\r\\n    function addParticipatingToken(address tokenAddress, uint8 decimals) public onlyOwner {\\r\\n        require(!isParticipatingTokens(tokenAddress), \\\"LockupCampaign: token data exists\\\");\\r\\n        require(tokenAddress != address(0), \\\"LockupCampaign: token contract address is zero\\\");\\r\\n        require(decimals != 0, \\\"LockupCampaign: token contract decimals is zero\\\");\\r\\n        require(decimals \\u003c= 18, \\\"LockupCampaign: token contract decimals invalid\\\");\\r\\n        tokenAddresses.push(tokenAddress);\\r\\n        tokenDecimals.push(decimals);\\r\\n\\r\\n        emit RegisterEtcToken(tokenAddress);\\r\\n    }\\r\\n    \\r\\n    // Edit the registered participating tokens rates\\r\\n    // # params tokenAddress: address of the participating token\\r\\n    // # params incentive_6month: amount of token to be given for 6 month lock period\\r\\n    // # params incentive_9month: amount of token to be given for 9 month lock period\\r\\n    function removeParticipatingToken(address tokenAddress) public onlyOwner {\\r\\n        for (uint i = 0; i \\u003c tokenAddresses.length; i++){\\r\\n            if(tokenAddresses[i] == tokenAddress){\\r\\n                tokenAddresses[i] = tokenAddresses[i+1];\\r\\n                tokenDecimals[i] = tokenDecimals[i+1];\\r\\n            }\\r\\n        }\\r\\n        tokenAddresses.length--;\\r\\n        tokenDecimals.length--;\\r\\n        emit RemoveEtcToken(tokenAddress);\\r\\n    }\\r\\n    \\r\\n    // Returns all participating tokens to owner\\r\\n    // # params tokenAddress: address of the participating token\\r\\n    function returnAllOtherTokens(address tokenAddress) public onlyOwner {\\r\\n        ERC20Interface(tokenAddress).transfer(owner(), ERC20Interface(tokenAddress).balanceOf(address(this)));\\r\\n    }\\r\\n    \\r\\n    // --------------- register participants functions ---------------\\r\\n\\r\\n    // Checks whether the use have registered (pre-registered, not sent token to contract yet for lockup)\\r\\n    // # params userAddress: address of pre-registered user\\r\\n    // * returns (bool): indication whether user have pre-registered (true) or not registered (false)\\r\\n    function isPreParticipant(address userAddress) public view returns (bool) {\\r\\n        return (userList[userAddress].month != 0);\\r\\n    }\\r\\n\\r\\n    // Checks whether the use have registered (already sent token to contract for lockup)\\r\\n    // # params userAddress: address of registered user\\r\\n    // * returns (bool): indication whether user have pre-registered (true) or not registered (false)\\r\\n    function isRegisteredParticipant(address userAddress) public view returns (bool){\\r\\n        return (userList[userAddress].lockEnd != 0);\\r\\n    }\\r\\n\\r\\n    // Returns user\\u0027s current lock amount\\r\\n    // # params userAddress: address of registered user\\r\\n    // * returns (uint256): amount of user\\u0027s token locked in contract\\r\\n    function getParticipantLockAmount(address userAddress) public view returns (uint256){\\r\\n        return userList[userAddress].amountWWB;\\r\\n    }\\r\\n\\r\\n    // Returns the registered user\\u0027s lock info\\r\\n    // # params userAddress: address of registered user\\r\\n    // * returns (uint256): amount of user\\u0027s token locked in contract\\r\\n    // * returns (uint256): month of token lockup\\r\\n    // * returns (uint256): end date of token\\u0027s lockup period (unix timestamp)\\r\\n    // * returns (bool): indication of user\\u0027s locked token have been calculated or not\\r\\n    // * returns (uint256): indication whether token has been unlocked or not\\r\\n    function getParticipantInfo(address userAddress) public view returns (uint256, uint256, uint256, bool, bool){\\r\\n        return(userList[userAddress].amountWWB, userList[userAddress].month,\\r\\n               userList[userAddress].lockEnd, userList[userAddress].incCalculated,\\r\\n               _getLockStatus(userList[userAddress].status)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Returns if user have applied for additional tokens\\r\\n    // # params userAddress: address of registered user\\r\\n    // * returns (bool): indication whether user have applied for additional token\\r\\n    function isParticipantExtraTokens(address user) public view returns (bool){\\r\\n        return (extraList[user].exTokenAddress.length != 0);\\r\\n    }\\r\\n\\r\\n    // Returns the data of additional token requested\\r\\n    // # params userAddress: address of registered user\\r\\n    // * returns (address[]): array of participating token contract address\\r\\n    // * returns (uint256[]): array of amount of respective participating tokens should be given out\\r\\n    function getParticipantExtraTokens(address user) public view returns (address[] memory, uint256[] memory){\\r\\n        return (extraList[user].exTokenAddress, extraList[user].exTokenAmount);\\r\\n    }\\r\\n    \\r\\n    // Updates the user\\u0027s info on current time\\r\\n    // # params userAddress: address of registered user\\r\\n    function updateParticipantInfo(address userAddress) public {\\r\\n        _incentiveTimeCheck(userAddress);\\r\\n    }\\r\\n    \\r\\n    // Pre-register participants for lockup campaign, will be properly registered after user transfer tokens to contract\\r\\n    // # params userAddr: address of registered user\\r\\n    // # params wwbAmount: amount of token to lock (in wei)\\r\\n    // # params months: address of registered user\\r\\n    function preRegisterParticipant(address userAddr, uint256 months) public returns (bool) {\\r\\n        require(firstSet == true, \\\"LockupCampaign: rates data for WWB token not yet set for first time\\\");\\r\\n        require(userAddr != address(0), \\\"LockupCampaign: user address is zero\\\");\\r\\n        require(months \\u003e 0, \\\"LockupCampaign: months to lock is zero\\\");\\r\\n        \\r\\n        _registParticipant(userAddr, months);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    // Requests additional tokens for users locked more than 6 months\\r\\n    // # params user: address of registered user\\r\\n    // # params token: address of participating token to request\\r\\n    function requestExtraToken(address user, address token) public {\\r\\n        require(isRegisteredParticipant(user), \\\"LockupCampaign: User not registered.\\\");\\r\\n        require(tokenAddresses.length \\u003e 0, \\\"LockupCampaign: no participating token data is entered yet\\\");\\r\\n        require(userList[user].month \\u003e= 6, \\\"LockupCampaign: user must lock more than 6 months to request extra token\\\");\\r\\n        \\r\\n        _requestExtraTokens(user, token);\\r\\n    }\\r\\n    \\r\\n    // Releases the token and respective additional tokens to user after lock period passed\\r\\n    // # params user: address of registered user\\r\\n    function releaseParticipantTokens(address userAddr) public returns (bool){\\r\\n        require(isRegisteredParticipant(userAddr), \\\"LockupCampaign: User not registered.\\\");\\r\\n        require(_incentiveTimeCheck(userAddr));\\r\\n        require(userList[userAddr].status != LockStatus.LOCKED, \\\"LockupCampaign: Token lock period still ongoing.\\\");\\r\\n        require(userList[userAddr].status != LockStatus.RELEASED, \\\"LockupCampaign: Token already released.\\\");\\r\\n        \\r\\n        _releaseWwbTokens(userAddr);\\r\\n        \\r\\n        if(extraList[userAddr].exTokenAddress.length != 0){\\r\\n            _releaseOtherTokens(userAddr);\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    // --------------- extra functions ---------------\\r\\n    \\r\\n    // Returns string converted bytes value\\r\\n    // # params str: a string value to convert\\r\\n    // * returns (bytes): converted string in bytes value\\r\\n    function convertStrToBytes(string memory str) public pure returns (bytes memory){\\r\\n        return bytes(str);\\r\\n    }\\r\\n    \\r\\n    // --------------- internal functions ---------------\\r\\n    \\r\\n    function _setWwbRate(uint256 i3, uint256 i6, uint256 i9) internal {\\r\\n        wwbInfo.incentive3 = i3;\\r\\n        wwbInfo.incentive6 = i6;\\r\\n        wwbInfo.incentive9 = i9;\\r\\n        firstSet = true;\\r\\n    }\\r\\n    \\r\\n    function _registParticipant(address addr, uint256 month) internal {\\r\\n        ParticipatingUsers memory user = ParticipatingUsers(0, month, 0, false, LockStatus.NULL);\\r\\n        userList[addr] = user;\\r\\n        \\r\\n        emit PreRegister(addr);\\r\\n    }\\r\\n    \\r\\n    function _confirmRegister(address addr, uint256 val) internal {\\r\\n        uint256 finalDate = now.addMonths(userList[addr].month);\\r\\n        userList[addr].amountWWB = val;\\r\\n        userList[addr].lockEnd = finalDate;\\r\\n        userList[addr].status = LockStatus.LOCKED;\\r\\n        \\r\\n        wwbInfo.totalLocked = wwbInfo.totalLocked.add(val);\\r\\n        wwbInfo.currentLocked = wwbInfo.currentLocked.add(val);\\r\\n        \\r\\n        emit ConfirmRegister(addr, now, finalDate);\\r\\n    }\\r\\n    \\r\\n    function _getLockStatus(LockStatus stat) internal pure returns (bool) {\\r\\n        if (stat == LockStatus.LOCKED || stat == LockStatus.NULL){\\r\\n            return false;\\r\\n        } else {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // Updates the status and send user incentives given to lockup\\r\\n    function _incentiveTimeCheck(address user) internal returns (bool) {\\r\\n        if (now \\u003e= userList[user].lockEnd){\\r\\n            if (userList[user].status == LockStatus.LOCKED \\u0026\\u0026 userList[user].incCalculated != true) {\\r\\n                uint256 val = _calcIncentives(user);\\r\\n                if (extraList[user].exTokenAddress.length != 0) { _calcExtra(user, val); }\\r\\n                userList[user].status = LockStatus.UNLOCKED;\\r\\n                userList[user].incCalculated = true;\\r\\n                \\r\\n                emit TokenUnlocked(user, now);\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    // Incentives calculation\\r\\n    function _calcIncentives(address user) internal returns (uint256){\\r\\n        uint256 m = userList[user].month;\\r\\n        uint256 added;\\r\\n        if (m \\u003e= 3 \\u0026\\u0026 m \\u003c 6){\\r\\n            added = _calcAdd(userList[user].amountWWB, wwbInfo.incentive3);\\r\\n        } else if (m \\u003e= 6 \\u0026\\u0026 m \\u003c 12){\\r\\n            added = _calcAdd(userList[user].amountWWB, wwbInfo.incentive6);\\r\\n        } else if (m \\u003e= 12) {\\r\\n            added = _calcAdd(userList[user].amountWWB, wwbInfo.incentive9);\\r\\n        }\\r\\n        userList[user].amountWWB = userList[user].amountWWB.add(added);\\r\\n        wwbInfo.totalExtraGiven = wwbInfo.totalExtraGiven.add(added);\\r\\n        wwbInfo.currentLocked = wwbInfo.currentLocked.add(added);\\r\\n        \\r\\n        return added;\\r\\n    }\\r\\n    \\r\\n    function _calcExtra(address user, uint256 added) internal {\\r\\n        for (uint i = 0; i \\u003c extraList[user].exTokenAddress.length; i++){\\r\\n            uint8 dec = extraList[user].exTokenDecimals[i];\\r\\n            uint256 total;\\r\\n                \\r\\n            if (dec \\u003e 6) { total = added.mul((10 ** uint256(dec - 6))); }\\r\\n            else if (dec \\u003c 6) { total = added.div((10 ** uint256(6 - dec))); }\\r\\n                \\r\\n            extraList[user].exTokenAmount.push(total);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // rate calc\\r\\n    function _calcAdd(uint256 total, uint256 rate) internal pure returns (uint256){\\r\\n        uint256 r = total.mul(rate);\\r\\n        r = r.div(10000);\\r\\n        return r;\\r\\n    }\\r\\n    \\r\\n    function _requestExtraTokens(address user, address token) internal {\\r\\n        require(isParticipatingTokens(token), \\\"LockupCampaign: token address is not participating token\\\");\\r\\n        //extraList[user].exTokenAddress.push(token);\\r\\n        \\r\\n        for (uint i = 0; i \\u003c tokenAddresses.length; i++){\\r\\n            if(token == tokenAddresses[i]){\\r\\n                extraList[user].exTokenAddress.push(token);\\r\\n                extraList[user].exTokenDecimals.push(tokenDecimals[i]);\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit EtcTokenRequested(user, token);\\r\\n    }\\r\\n    \\r\\n    function _releaseWwbTokens(address user) internal {\\r\\n        uint256 amt = userList[user].amountWWB;\\r\\n        ERC20Interface(wwbAddress).transfer(user, amt);\\r\\n        wwbInfo.currentLocked = wwbInfo.currentLocked.sub(amt);\\r\\n        userList[user].status = LockStatus.RELEASED;\\r\\n\\r\\n        emit TokenReleased(user, amt);\\r\\n    }\\r\\n    \\r\\n    function _releaseOtherTokens(address user) internal {\\r\\n        for (uint i = 0; i \\u003c extraList[user].exTokenAddress.length; i++){\\r\\n            address addr =  extraList[user].exTokenAddress[i];\\r\\n            uint amt = extraList[user].exTokenAmount[i];\\r\\n            \\r\\n            ERC20Interface(addr).transfer(user, amt);\\r\\n            \\r\\n            emit EtcTokenReleased(user, addr, amt);\\r\\n        }\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity \\u003e= 0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n//  SafeMath library\\r\\n//  - uint security overflow/underflow prevention\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) { return 0; }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"TimestampMonthConv.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n//   Timestamp Month Conversion library\\r\\n//  - date and timestamp related conversion/operations for months\\r\\n\\r\\nlibrary TimestampMonthConv {\\r\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n    uint constant SECONDS_PER_HOUR = 60 * 60;\\r\\n    uint constant SECONDS_PER_MINUTE = 60;\\r\\n    int constant OFFSET19700101 = 2440588;\\r\\n    \\r\\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\\r\\n        require(year \\u003e= 1970);\\r\\n        int _year = int(year);\\r\\n        int _month = int(month);\\r\\n        int _day = int(day);\\r\\n\\r\\n        int __days = _day\\r\\n          - 32075\\r\\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\\r\\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\\r\\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\\r\\n          - OFFSET19700101;\\r\\n\\r\\n        _days = uint(__days);\\r\\n    }\\r\\n    \\r\\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\r\\n        int __days = int(_days);\\r\\n        \\r\\n        int L = __days + 68569 + OFFSET19700101;\\r\\n        int N = 4 * L / 146097;\\r\\n        L = L - (146097 * N + 3) / 4;\\r\\n        int _year = 4000 * (L + 1) / 1461001;\\r\\n        L = L - 1461 * _year / 4 + 31;\\r\\n        int _month = 80 * L / 2447;\\r\\n        int _day = L - 2447 * _month / 80;\\r\\n        L = _month / 11;\\r\\n        _month = _month + 2 - 12 * L;\\r\\n        _year = 100 * (N - 49) + _year + L;\\r\\n\\r\\n        year = uint(_year);\\r\\n        month = uint(_month);\\r\\n        day = uint(_day);\\r\\n    }\\r\\n    \\r\\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\\r\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\r\\n            daysInMonth = 31;\\r\\n        } else if (month != 2) {\\r\\n            daysInMonth = 30;\\r\\n        } else {\\r\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\\r\\n        leapYear = ((year % 4 == 0) \\u0026\\u0026 (year % 100 != 0)) || (year % 400 == 0);\\r\\n    }\\r\\n    \\r\\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\r\\n        uint year;\\r\\n        uint month;\\r\\n        uint day;\\r\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        month += _months;\\r\\n        year += (month - 1) / 12;\\r\\n        month = (month - 1) % 12 + 1;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    \\r\\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        uint fromYear;\\r\\n        uint fromMonth;\\r\\n        uint fromDay;\\r\\n        uint toYear;\\r\\n        uint toMonth;\\r\\n        uint toDay;\\r\\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"WwbTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startLock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endLock\",\"type\":\"uint256\"}],\"name\":\"ConfirmRegister\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountIncentives\",\"type\":\"uint256\"}],\"name\":\"EtcTokenReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"EtcTokenRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"PreRegister\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"RegisterEtcToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"RemoveEtcToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokenUnlocked\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"addParticipatingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"convertStrToBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"name\":\"depositApprovedERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getParticipantExtraTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getParticipantInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getParticipantLockAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWwbInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isParticipantExtraTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"isParticipatingTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"isPreParticipant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"isRegisteredParticipant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"participatingTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"months\",\"type\":\"uint256\"}],\"name\":\"preRegisterParticipant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"releaseParticipantTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"removeParticipatingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"requestExtraToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"returnAllOtherTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"returnAllWWBTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate_3month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate_6month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate_9month\",\"type\":\"uint256\"}],\"name\":\"setWwbRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnerOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"updateParticipantInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wwbAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wwbInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExtraGiven\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentive3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentive6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentive9\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wwbTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LockupCampaign","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002e5e6ebd6865effab33360d3c6102f723fd053d200000000000000000000000098c5aa4319df4c6a88679a32420121f1b184a068","Library":"","LicenseType":"None","SwarmSource":"bzzr://136263e4de3b5c2e4873c45672b448797ae19afa183e04ee016b580996055515"}]}