{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function name() external view returns(string memory);\r\n\r\n    function symbol() external view returns(string memory);\r\n\r\n    function decimals() external view returns(uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: contracts/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/CRC.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\n\r\n//import \"./Permissions.sol\";\r\n//import \"./Exchanger.sol\";\r\n\r\n\r\n\r\ncontract CRC is IERC20 {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint32;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event Buy( address account, uint256 amount, uint32 coin_id, uint256 coin_amount );\r\n    event Sell( address account, uint256 amount, uint32 coin_id, uint256 coin_amount  );\r\n    event PermissionSet(address indexed sender, address indexed to, uint8 permission);\r\n\r\n\r\n    struct Coin {\r\n        address token;\r\n        string name;\r\n        string symbol;\r\n        uint8 decimals;\r\n        uint32 rate;\r\n        uint32 spread;\r\n        uint8 status;\r\n        uint32 min_rate;\r\n        uint32 max_rate;\r\n        uint32 max_spread;\r\n    }\r\n\r\n    // Permissions \r\n    mapping(address=>uint8) _permissions;\r\n    // ERC20 data\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping(address=>address) public referrals;\r\n\r\n\r\n    mapping (uint16=>Coin) _coins;\r\n    mapping (address=>uint16) _coin_index;\r\n    \r\n    uint256 public rounding = 2;\r\n    uint256 public INITIAL_SUPPLY = 1000 * 10**18;\r\n\r\n    uint256 percentPrecision = 10 ** 12;\r\n    uint256 percentPerMinute = 36 * percentPrecision / (365 * 24 * 60);\r\n    uint32 transfer_fee = 10;\r\n    uint32 referral_fee = 20000;\r\n\r\n    uint256 referral_deposit = 0;\r\n    uint256 public INITIAL_TIME = 0;\r\n    uint256 private _totalSupply;\r\n\r\n    uint8 _initialized = 0;\r\n\r\n    // Exchanger data\r\n    uint32 rate_precision = 10000;\r\n    uint16 _coin_counter=1;\r\n\r\n\r\n\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return _permissions[msg.sender] & 1 != 0;\r\n    }\r\n\r\n    function isOperator() public view returns (bool) {\r\n        return _permissions[msg.sender] & 2 != 0;\r\n    }\r\n\r\n    function isOwnerOrOperator() public view returns (bool) {\r\n        return _permissions[msg.sender] & 3 != 0;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Permission: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(isOperator(), \"Permission: caller is not the operator\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrOperator() {\r\n        require(isOwnerOrOperator(), \"Permission: caller is not the owner or operator\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        _permissions[msg.sender] &= 0xFE;\r\n        emit PermissionSet(msg.sender, msg.sender, _permissions[msg.sender]);\r\n    }\r\n\r\n    function _setPermission(address _to, uint8 _permission) internal {\r\n        _permissions[_to] = _permission;\r\n        emit PermissionSet(msg.sender, _to, _permission);\r\n\r\n    }\r\n\r\n    function setPermission(address _to, uint8 _permission) public onlyOwner {\r\n        _setPermission(_to, _permission);\r\n    }\r\n \r\n    // CRC \r\n    function name() public view returns(string memory){\r\n        require(_initialized > 0, \"Not initialized\");\r\n        return \"CRC Stable Coin\";\r\n    }\r\n\r\n    function symbol() public view returns(string memory){\r\n        require(_initialized > 0, \"Not initialized\");\r\n        return \"CRC\";\r\n    }\r\n\r\n    function decimals() public view returns(uint8){\r\n        require(_initialized > 0, \"Not initialized\");\r\n        return 18;\r\n    }\r\n\r\n    function getInitialTime() public view returns(uint256) {\r\n        return INITIAL_TIME;\r\n    }\r\n\r\n    function balanceChange(address account) private view returns (uint256){\r\n        return _balances[account].div(percentPrecision.mul(100)).mul(percentPerMinute).mul( block.timestamp.sub(INITIAL_TIME).div(60) );\r\n    }\r\n\r\n    function totalSupplyChange() private view returns (uint256){\r\n        return _totalSupply.div(percentPrecision.mul(100)).mul(percentPerMinute).mul( block.timestamp.sub(INITIAL_TIME).div(60) );\r\n    }\r\n\r\n\r\n    function equalizedAmount(uint256 amount) public view returns (uint256){\r\n        return amount.div( block.timestamp.sub(INITIAL_TIME).div(60).mul(percentPerMinute).add( percentPrecision.mul(100) )).mul(percentPrecision.mul(100));\r\n    }\r\n\r\n\r\n\r\n    function round(uint256 amount) public pure returns (uint256){\r\n        uint256 rounded = amount.div(10**16).mul(10**16);\r\n        if(amount.sub(rounded) > 99 * 10**14){\r\n            rounded += 10**16;\r\n        }\r\n        return rounded;\r\n    }\r\n\r\n    // ERC20\r\n\r\n    function balanceOf(address account) public view returns (uint256){\r\n        return round(_balances[account].add(balanceChange(account)));\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256){\r\n        return _totalSupply.add(totalSupplyChange());\r\n    }\r\n\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        uint256 commission = amount.mul(transfer_fee).div(10000);\r\n        _transfer(msg.sender, recipient, amount.sub(commission));\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        uint256 commission = amount.mul(transfer_fee).div(10000);\r\n        _transfer(sender, recipient, amount.sub(commission));\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n    \r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        uint256 token_amount = equalizedAmount(amount);\r\n        _balances[sender] = _balances[sender].sub(token_amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(token_amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        uint256 token_amount = equalizedAmount(amount);\r\n        _totalSupply = _totalSupply.add(token_amount);\r\n        _balances[account] = _balances[account].add(token_amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        uint256 token_amount = equalizedAmount(amount);\r\n        _balances[account] = _balances[account].sub(token_amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(token_amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n \r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        uint256 token_amount = equalizedAmount(amount);\r\n        _burn(account, token_amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    // Exchanger\r\n\r\n\r\n    function buyref(uint16 coin_id, uint256 amount, address referral) public returns (bool) {\r\n        require(_coins[coin_id].status & 1 != 0, \"Coin in not active\");\r\n        uint256 coin_amount = amount;\r\n        if(amount == 0){\r\n            coin_amount = IERC20(_coins[coin_id].token).allowance(msg.sender, address(this));\r\n        }\r\n        require(coin_amount > 0, \"No funds avaialble\");\r\n        IERC20(_coins[coin_id].token).safeTransferFrom(msg.sender, address(this), coin_amount);\r\n        uint256 current_token_amount = getBuyCoinAmountByID(coin_id, coin_amount);\r\n        _mint(msg.sender, current_token_amount);\r\n        if( referral != address(0) && referral_fee > 0 && balanceOf(referral) >= referral_deposit ){\r\n            if( referrals[msg.sender] == address(0) ){\r\n                referrals[msg.sender] = referral;\r\n            }\r\n            _mint(referral, current_token_amount.mul(coinGetSpread(coin_id)).div(20000));\r\n        }else{\r\n            if( referrals[msg.sender] != address(0) && referral_fee > 0 && balanceOf(referrals[msg.sender]) >= referral_deposit ){\r\n                _mint(referrals[msg.sender], current_token_amount.mul(coinGetSpread(coin_id)).div(referral_fee));\r\n            }\r\n        }\r\n        emit Buy(msg.sender, current_token_amount, coin_id, coin_amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function buy(uint16 coin_id, uint256 amount) public returns (bool) {\r\n        require(_coins[coin_id].status & 1 != 0, \"Coin in not active\");\r\n        uint256 coin_amount = amount;\r\n        if(amount == 0){\r\n            coin_amount = IERC20(_coins[coin_id].token).allowance(msg.sender, address(this));\r\n        }\r\n        require(coin_amount > 0, \"No funds avaialble\");\r\n        IERC20(_coins[coin_id].token).safeTransferFrom(msg.sender, address(this), coin_amount);\r\n        uint256 current_token_amount = getBuyCoinAmountByID(coin_id, coin_amount);\r\n        _mint(msg.sender, current_token_amount);\r\n        if( referrals[msg.sender] != address(0) && referral_fee > 0 && balanceOf(referrals[msg.sender]) >= referral_deposit ){\r\n                _mint(referrals[msg.sender], current_token_amount.mul(coinGetSpread(coin_id)).div(referral_fee));\r\n        }\r\n        emit Buy(msg.sender, current_token_amount, coin_id, coin_amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function sell(uint16 coin_id, uint256 amount) public returns (bool) {\r\n        require(_coins[coin_id].status & 2 != 0, \"Coin in not active\");\r\n        _burn(msg.sender, amount);\r\n        uint256 coin_amount = getSellTokenAmountByID(coin_id, amount);\r\n        IERC20(_coins[coin_id].token).safeTransfer(msg.sender, coin_amount);\r\n        emit Sell(msg.sender, amount, coin_id, coin_amount);\r\n        return true;\r\n    }\r\n\r\n    function setTransferFee(uint32 _transfer_fee) public onlyOwner returns(bool){\r\n        transfer_fee = _transfer_fee;\r\n        return true;\r\n    }\r\n\r\n    function setReferralFee(uint32 _referral_fee) public onlyOwner returns(bool){\r\n        referral_fee = _referral_fee;\r\n        return true;\r\n    }\r\n\r\n    function setReferralDeposit(uint32 _referral_deposit) public onlyOwner returns(bool){\r\n        referral_deposit = _referral_deposit;\r\n        return true;\r\n    }\r\n\r\n\r\n    function addCoin(address _token, string memory _name, string memory _symbol, uint8 _decimals) public onlyOwner returns(bool){\r\n        _coins[_coin_counter] = Coin(_token, _name, _symbol, _decimals, 1*rate_precision, 0, 0, 9000, 11000, 1000);\r\n        _coin_index[_token] = _coin_counter;\r\n        _coin_counter += 1;\r\n    }\r\n\r\n    function fetchCoin(address _token) public onlyOwner returns(bool){\r\n        string memory _name = IERC20(_token).name();\r\n        string memory _symbol = IERC20(_token).symbol();\r\n        uint8 _decimals = IERC20(_token).decimals();\r\n\r\n        _coins[_coin_counter] = Coin(_token, _name, _symbol,  _decimals, 1 * rate_precision, 0, 0, 9000, 11000, 1000);\r\n        _coin_index[_token] = _coin_counter;\r\n        _coin_counter += 1;\r\n\r\n    }\r\n\r\n\r\n    function setStatusByID(uint16 coin_id, uint8 status) public onlyOwner returns(bool){\r\n        _coins[coin_id].status = status;\r\n        return true;\r\n    }\r\n\r\n    function setRateLimitsByID(uint16 coin_id, uint32 min_rate, uint32 max_rate, uint32 max_spread) public onlyOwner returns(bool){\r\n        require(min_rate <= max_rate, \"Invalid rate\");\r\n        _coins[coin_id].min_rate = min_rate;\r\n        _coins[coin_id].max_rate = max_rate;\r\n        _coins[coin_id].max_spread = max_spread;\r\n        if( _coins[coin_id].rate < min_rate  ){\r\n            _coins[coin_id].rate = min_rate;\r\n        }\r\n        if( _coins[coin_id].rate > max_rate  ){\r\n            _coins[coin_id].rate = max_rate;\r\n        }\r\n        if( _coins[coin_id].spread > max_spread  ){\r\n            _coins[coin_id].spread = max_spread;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function setRateByID(uint16 coin_id, uint32 rate) public onlyOwnerOrOperator returns(bool){\r\n        require(rate >= _coins[coin_id].min_rate && rate <= _coins[coin_id].max_rate, \"Rate out of limits\");\r\n        _coins[coin_id].rate = rate;\r\n        return true;\r\n    }\r\n\r\n    function setSpreadByID(uint16 coin_id, uint32 spread) public onlyOwnerOrOperator returns(bool){\r\n        require(spread <= _coins[coin_id].max_spread, \"Spread out of limits\");\r\n        _coins[coin_id].spread = spread;\r\n        return true;\r\n    }\r\n\r\n    function transferCoinByID(uint16 coin_id, address to, uint256 amount) public onlyOwner returns(bool){\r\n        IERC20(_coins[coin_id].token).safeTransfer(to, amount);\r\n        return true;\r\n    }\r\n\r\n    function balanceOfCoin(uint16 coin_id) public view returns(uint256){\r\n        return IERC20(_coins[coin_id].token).balanceOf(address(this));\r\n    }\r\n\r\n    function coinCounter() public view returns(uint16){\r\n        return _coin_counter;\r\n    }\r\n\r\n    function coin(uint16 index) public view returns(string memory coinName, string memory coinSymbol, uint8 coinDecimals){\r\n        return (_coins[index].name, _coins[index].symbol, _coins[index].decimals);\r\n    }\r\n\r\n    function coinRate(uint16 index) public view returns(uint32 rate, uint32 spread){\r\n        return (_coins[index].rate, _coins[index].spread);\r\n    }\r\n\r\n    function coinRateLimits(uint16 index) public view returns(uint32 min_rate,uint32 max_rate, uint32 max_spread){\r\n        return (_coins[index].min_rate,_coins[index].max_rate,_coins[index].max_spread);\r\n    }\r\n\r\n\r\n    function coinGetRate(uint16 index) public view returns(uint32){\r\n        return _coins[index].rate;\r\n    }\r\n\r\n    function coinGetSpread(uint16 index) public view returns(uint32){\r\n        return _coins[index].spread;\r\n    }\r\n\r\n    function coinGetStatus(uint16 index) public view returns(uint8){\r\n        return _coins[index].status;\r\n    }\r\n\r\n    function coinData(uint16 index) public view returns(address coinAddress, uint8 coinStatus){\r\n        return (_coins[index].token, _coins[index].status);\r\n    }\r\n\r\n    function normalizeCoinAmount(uint256 amount, uint8 coin_decimals ) internal pure returns (uint256){\r\n        if( coin_decimals > 18 ){\r\n            return amount.div(uint256(10) ** (coin_decimals-18));\r\n        }\r\n        return amount.mul(uint256(10) ** (18-coin_decimals));\r\n    }\r\n\r\n    function normalizeTokenAmount(uint256 amount, uint8 coin_decimals ) internal pure returns (uint256){\r\n        if( coin_decimals >= 18 ){\r\n            return amount.mul(uint256(10) ** (coin_decimals-18));\r\n        }\r\n        return amount.div(uint256(10) ** (18-coin_decimals));\r\n    }\r\n\r\n        function getSellTokenAmountByID(uint16 coin_id, uint256 amount) public view returns(uint256){\r\n        return normalizeTokenAmount(amount.div(_coins[coin_id].rate.add(_coins[coin_id].spread)).mul(rate_precision), _coins[coin_id].decimals);\r\n    }\r\n\r\n    function getBuyTokenAmountByID(uint16 coin_id, uint256 amount) public view returns(uint256){\r\n        return normalizeTokenAmount(amount.div(_coins[coin_id].rate.sub(_coins[coin_id].spread)).mul(rate_precision), _coins[coin_id].decimals);\r\n    }\r\n\r\n    function getSellCoinAmountByID(uint16 coin_id, uint256 amount) public view returns(uint256){\r\n        return normalizeCoinAmount(amount.mul(_coins[coin_id].rate.add(_coins[coin_id].spread)).div(rate_precision), _coins[coin_id].decimals);\r\n    }\r\n\r\n    function getBuyCoinAmountByID(uint16 coin_id, uint256 amount) public view returns(uint256){\r\n        return normalizeCoinAmount(amount.mul(_coins[coin_id].rate.sub(_coins[coin_id].spread)).div(rate_precision), _coins[coin_id].decimals);\r\n    }\r\n\r\n    function getBuyTokenAmount(address coin_address, uint256 amount) public view returns(uint256){\r\n        return getBuyTokenAmountByID(_coin_index[coin_address], amount);\r\n    }\r\n    function getSellTokenAmount(address coin_address, uint256 amount) public view returns(uint256){\r\n        return getSellTokenAmountByID(_coin_index[coin_address], amount);\r\n    }\r\n\r\n    function getBuyCoinAmount(address coin_address, uint256 amount) public view returns(uint256){\r\n        return getBuyCoinAmountByID(_coin_index[coin_address], amount);\r\n    }\r\n    function getSellCoinAmount(address coin_address, uint256 amount) public view returns(uint256){\r\n        return getSellCoinAmountByID(_coin_index[coin_address], amount);\r\n    }\r\n\r\n    // Initialization \r\n\r\n    function initialize() public returns(bool){\r\n        require(_initialized == 0, \"Already initialized\");\r\n        _initialized = 1;\r\n        rounding = 2;\r\n        INITIAL_SUPPLY = 1000 * 10**18;\r\n        INITIAL_TIME = block.timestamp.sub(365*24*60*60);\r\n        percentPrecision = 10 ** 12;\r\n        percentPerMinute = 36 * percentPrecision / (365 * 24 * 60);\r\n        transfer_fee = 10;\r\n        referral_fee = 20000;\r\n        _setPermission(msg.sender, 3);\r\n        _mint(msg.sender, INITIAL_SUPPLY);\r\n\r\n        rate_precision = 10000;\r\n        _coin_counter = 1;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"coin_id\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coin_amount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"permission\",\"type\":\"uint8\"}],\"name\":\"PermissionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"coin_id\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coin_amount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"addCoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"}],\"name\":\"balanceOfCoin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"buyref\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"coin\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"coinName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"coinSymbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"coinDecimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinCounter\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"coinData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"coinStatus\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"coinGetRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"coinGetSpread\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"coinGetStatus\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"coinRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"rate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"spread\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"coinRateLimits\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"min_rate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"max_rate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"max_spread\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"equalizedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"fetchCoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coin_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyCoinAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyCoinAmountByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coin_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyTokenAmountByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitialTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coin_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSellCoinAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSellCoinAmountByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coin_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSellTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSellTokenAmountByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwnerOrOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rounding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_permission\",\"type\":\"uint8\"}],\"name\":\"setPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"rate\",\"type\":\"uint32\"}],\"name\":\"setRateByID\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"min_rate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"max_rate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"max_spread\",\"type\":\"uint32\"}],\"name\":\"setRateLimitsByID\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_referral_deposit\",\"type\":\"uint32\"}],\"name\":\"setReferralDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_referral_fee\",\"type\":\"uint32\"}],\"name\":\"setReferralFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"spread\",\"type\":\"uint32\"}],\"name\":\"setSpreadByID\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"setStatusByID\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_transfer_fee\",\"type\":\"uint32\"}],\"name\":\"setTransferFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"coin_id\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferCoinByID\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CRC","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://a868c28a25512cafcb671a4d67c287eea4394bd6ca602e11a785c838bb00bb53"}]}