{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *         __  .__                                          .__       ___.    \r\n *   _____/  |_|  |__   ___________  ____   ____       ____ |  |  __ _\\_ |__  \r\n * _/ __ \\   __\\  |  \\_/ __ \\_  __ \\/  _ \\ /    \\    _/ ___\\|  | |  |  \\ __ \\ \r\n * \\  ___/|  | |   Y  \\  ___/|  | \\(  <_> )   |  \\   \\  \\___|  |_|  |  / \\_\\ \\\r\n *  \\___  >__| |___|  /\\___  >__|   \\____/|___|  / /\\ \\___  >____/____/|___  /\r\n *      \\/          \\/     \\/                  \\/  \\/     \\/               \\/ \r\n *\r\n * https://etheron.club\r\n**/\r\n\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract Etheron {\r\n    uint public currentUserID;\r\n\r\n    mapping (uint => User) public users;\r\n    mapping (address => uint) public userWallets;\r\n    uint[10] public levelBase;\r\n    uint[9] public regBase;\r\n    address public token_contract;\r\n\r\n    struct User {\r\n        bool exists;\r\n        address wallet;\r\n        uint referrer;\r\n        mapping (uint => uint) uplines;\r\n        mapping (uint => uint[]) referrals;\r\n        mapping (uint => uint) levelExpiry;\r\n    }\r\n\r\n    event RegisterUserEvent(address indexed user, address indexed referrer, uint time);\r\n    event BuyLevelEvent(address indexed user, uint indexed level, uint time);\r\n    event TransferEvent(address indexed recipient, address indexed sender, uint indexed amount, uint time, uint recipientID, uint senderID, bool superprofit);\r\n    event LostProfitEvent(address indexed recipient, address indexed sender, uint indexed amount, uint time, uint senderID);\r\n\r\n    constructor(address _owner, address _token) public {\r\n\r\n      currentUserID++;\r\n      levelBase = [0.5 ether, 1 ether, 2 ether, 4 ether, 5 ether, 6 ether, 7 ether, 8 ether, 9 ether, 10 ether];\r\n      regBase = [0.6 ether, 1.8 ether, 4.1 ether, 8.5 ether, 17 ether, 33.6 ether, 66.3 ether, 131.1 ether, 260 ether];\r\n\r\n      users[currentUserID] =  User({ exists: true, wallet: _owner, referrer: 1});\r\n      userWallets[_owner] = currentUserID;\r\n      token_contract = _token;\r\n\r\n      for (uint i = 0; i < 90; i++) {\r\n        users[currentUserID].levelExpiry[i] = 1 << 37;\r\n      }\r\n      \r\n      for (uint i = 1; i < 10; i++) {\r\n          users[currentUserID].uplines[i] = 1;\r\n          users[currentUserID].referrals[i] = new uint[](0);\r\n      }\r\n    }\r\n\r\n    function () external payable {\r\n        if (userWallets[msg.sender] == 0) {\r\n            require(msg.value == 0.6 ether, 'Wrong amount');\r\n            uint[9] memory tmp;\r\n            registerUser(userWallets[bytesToAddress(msg.data)], 0, tmp);\r\n        } else {\r\n            buyLevel(0);\r\n        }\r\n    }\r\n\r\n    function registerUser(uint _referrer, uint _rounds, uint[9] memory _uplines) public payable {\r\n        require(_referrer > 0 && _referrer <= currentUserID, 'Invalid referrer ID');\r\n        require(_rounds < 9);\r\n        require(msg.value == regBase[_rounds], 'Wrong amount');\r\n        require(userWallets[msg.sender] == 0, 'User already registered');\r\n\r\n        currentUserID++;\r\n        users[currentUserID] = User({ exists: true, wallet: msg.sender, referrer: _referrer });\r\n        userWallets[msg.sender] = currentUserID;\r\n\r\n        for (uint i = 0 ; i <= _rounds; i++ ) {\r\n            levelUp(i * 10, 1, i + 1, currentUserID, _uplines[i]);\r\n        } \r\n        emit RegisterUserEvent(msg.sender, users[_referrer].wallet, now);\r\n    }\r\n\r\n    function buyLevel(uint _upline) public payable {\r\n        uint userID = userWallets[msg.sender];\r\n        require (userID > 0, 'User not registered');\r\n        (uint round, uint level, uint levelID) = getLevel(msg.value);\r\n        \r\n        if (level == 1 && round > 1) {\r\n            bool prev = false;\r\n            for (uint l = levelID - 10; l < levelID; l++) {\r\n                if (users[userID].levelExpiry[l] >= now) {\r\n                    prev = true;\r\n                    break;\r\n                }\r\n                require(prev == true, 'Previous round not active');\r\n            }\r\n        } else {\r\n            for (uint l = level - 1; l > 0; l--) {\r\n                require(users[userID].levelExpiry[levelID - level + l] >= now, 'Previous level not active');\r\n            }\r\n        }\r\n\r\n        levelUp(levelID, level, round, userID, _upline);\r\n\r\n        if (level == 4 && round < 9 && users[userID].levelExpiry[levelID + 7] <= now) levelUp(levelID + 7, 1, round + 1, userID, _upline);\r\n\r\n        if (address(this).balance > 0) msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    function levelUp(uint _levelid, uint _level, uint _round, uint _userid, uint _upline) internal {\r\n\r\n        uint duration = 30 days * _round + 90 days;\r\n        IERC20 token = IERC20(token_contract);\r\n        uint eron = token.balanceOf(msg.sender);\r\n\r\n        if (users[_userid].levelExpiry[_levelid] == 0 || (users[_userid].levelExpiry[_levelid] < now && eron >= _round)) {\r\n            users[_userid].levelExpiry[_levelid] = now + duration;\r\n        } else {\r\n            users[_userid].levelExpiry[_levelid] += duration;\r\n        }\r\n        \r\n        if (_level == 1 && users[_userid].uplines[_round] == 0) {\r\n            if (_upline == 0) _upline = users[_userid].referrer;\r\n            if (_round > 1) _upline = findUplineUp(_upline, _round);\r\n            _upline = findUplineDown(_upline, _round);\r\n            users[_userid].uplines[_round] = _upline;\r\n            users[_upline].referrals[_round].push(_userid);\r\n        }\r\n\r\n        payForLevel(_levelid, _userid, _level, _round, false);\r\n        emit BuyLevelEvent(msg.sender, _levelid, now);\r\n    }\r\n\r\n    function payForLevel(uint _levelid, uint _userid, uint _height, uint _round, bool _superprofit) internal {\r\n      uint referrer = getUserUpline(_userid, _height, _round);\r\n      uint amount = lvlAmount(_levelid);\r\n\r\n      if (users[referrer].levelExpiry[_levelid] < now) {\r\n        emit LostProfitEvent(users[referrer].wallet, msg.sender, amount, now, userWallets[msg.sender]);\r\n        payForLevel(_levelid, referrer, _height, _round, true);\r\n        return;\r\n      }\r\n\r\n      if (address(uint160(users[referrer].wallet)).send(amount)) {\r\n        emit TransferEvent(users[referrer].wallet, msg.sender, amount, now, referrer, userWallets[msg.sender], _superprofit);\r\n      }\r\n    }\r\n\r\n    function getUserUpline(uint _user, uint _height, uint _round) public view returns (uint) {\r\n        while (_height > 0) {\r\n            _user = users[_user].uplines[_round];\r\n            _height--;\r\n        }\r\n        return _user;\r\n    }\r\n\r\n    function findUplineUp(uint _user, uint _round) public view returns (uint) {\r\n        while (users[_user].uplines[_round] == 0) {\r\n            _user = users[_user].uplines[1];\r\n        }\r\n        return _user;\r\n    }\r\n\r\n    function findUplineDown(uint _user, uint _round) public view returns (uint) {\r\n      if (users[_user].referrals[_round].length < 2) {\r\n        return _user;\r\n      }\r\n\r\n      uint[1024] memory referrals;\r\n      referrals[0] = users[_user].referrals[_round][0];\r\n      referrals[1] = users[_user].referrals[_round][1];\r\n\r\n      uint referrer;\r\n\r\n      for (uint i = 0; i < 1024; i++) {\r\n        if (users[referrals[i]].referrals[_round].length < 2) {\r\n          referrer = referrals[i];\r\n          break;\r\n        }\r\n\r\n        if (i >= 512) {\r\n          continue;\r\n        }\r\n\r\n        referrals[(i+1)*2] = users[referrals[i]].referrals[_round][0];\r\n        referrals[(i+1)*2+1] = users[referrals[i]].referrals[_round][1];\r\n      }\r\n\r\n      require(referrer != 0, 'Referrer not found');\r\n      return referrer;\r\n    }\r\n\r\n\r\n    function getLevel(uint _amount) public view returns(uint, uint, uint) {\r\n\r\n        if (_amount == 0.6 ether) return (1, 1, 0);\r\n        uint level = 0;\r\n        uint tmp = _amount % 1 ether;\r\n        uint round = tmp / 0.1 ether;\r\n        require(round != 0, 'Wrong amount');\r\n\r\n        tmp = (_amount - tmp) / (2 ** (round - 1));\r\n\r\n        for (uint i = 1; i <= 10; i++) {\r\n            if (tmp == levelBase[i - 1]) {\r\n                    level = i;\r\n                    break;\r\n            }\r\n        }\r\n        require(level > 0, 'Wrong amount');\r\n\r\n        uint levelID = (round - 1) * 10 + level - 1;\r\n        \r\n        return (round, level, levelID);\r\n    }\r\n\r\n    function lvlAmount (uint _levelID) public view returns(uint) {\r\n        uint level = _levelID % 10;\r\n        uint round = (_levelID - level) / 10;\r\n        uint tmp = levelBase[level] * (2 ** round);\r\n\r\n        if (level == 3 && round < 8) return (tmp - (2 ** round) * 1 ether - 0.1 ether);\r\n        return (tmp  + (0.1 ether * (round + 1)));\r\n    }\r\n\r\n    function getReferralTree(uint _user, uint _treeLevel, uint _round) external view returns (uint[] memory, uint[] memory, uint) {\r\n\r\n        uint tmp = 2 ** (_treeLevel + 1) - 2;\r\n        uint[] memory ids = new uint[](tmp);\r\n        uint[] memory lvl = new uint[](tmp);\r\n\r\n        ids[0] = (users[_user].referrals[_round].length > 0)? users[_user].referrals[_round][0]: 0;\r\n        ids[1] = (users[_user].referrals[_round].length > 1)? users[_user].referrals[_round][1]: 0;\r\n        lvl[0] = getMaxLevel(ids[0], _round);\r\n        lvl[1] = getMaxLevel(ids[1], _round);\r\n\r\n        for (uint i = 0; i < (2 ** _treeLevel - 2); i++) {\r\n            tmp = i * 2 + 2;\r\n            ids[tmp] = (users[ids[i]].referrals[_round].length > 0)? users[ids[i]].referrals[_round][0]: 0;\r\n            ids[tmp + 1] = (users[ids[i]].referrals[_round].length > 1)? users[ids[i]].referrals[_round][1]: 0;\r\n            lvl[tmp] = getMaxLevel(ids[tmp], _round);\r\n            lvl[tmp + 1] = getMaxLevel(ids[tmp + 1], _round);\r\n        }\r\n        \r\n        uint curMax = getMaxLevel(_user, _round);\r\n\r\n        return(ids, lvl, curMax);\r\n    }\r\n\r\n    function getMaxLevel(uint _user, uint _round) private view returns (uint){\r\n        uint max = 0;\r\n        if (_user == 0) return 0;\r\n        if (!users[_user].exists) return 0;\r\n        for (uint i = 1; i <= 10; i++) {\r\n            if (users[_user].levelExpiry[_round * 10 - i] > now) {\r\n                max = 11 - i;\r\n                break;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n    \r\n    function getUplines(uint _user, uint _round) public view returns (uint[10] memory uplines, address[10] memory uplinesWallets) {\r\n        for(uint i = 0; i < 10; i++) {\r\n            _user = users[_user].uplines[_round];\r\n            uplines[i] = _user;\r\n            uplinesWallets[i] = users[_user].wallet;\r\n        }\r\n    }\r\n\r\n    function getUserLevels(uint _user) external view returns (uint[90] memory levels) {\r\n        for (uint i = 0; i < 90; i++) {\r\n            levels[i] = users[_user].levelExpiry[i];\r\n        }\r\n    }\r\n\r\n    function bytesToAddress(bytes memory _addr) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(_addr, 20))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"regBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referrer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rounds\",\"type\":\"uint256\"},{\"internalType\":\"uint256[9]\",\"name\":\"_uplines\",\"type\":\"uint256[9]\"}],\"name\":\"registerUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"findUplineUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userWallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"}],\"name\":\"getUserLevels\",\"outputs\":[{\"internalType\":\"uint256[90]\",\"name\":\"levels\",\"type\":\"uint256[90]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentUserID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_height\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getUserUpline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_levelID\",\"type\":\"uint256\"}],\"name\":\"lvlAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"findUplineDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getUplines\",\"outputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"uplines\",\"type\":\"uint256[10]\"},{\"internalType\":\"address[10]\",\"name\":\"uplinesWallets\",\"type\":\"address[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_upline\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_user\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treeLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getReferralTree\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"RegisterUserEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"BuyLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recipientID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"senderID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"superprofit\",\"type\":\"bool\"}],\"name\":\"TransferEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"senderID\",\"type\":\"uint256\"}],\"name\":\"LostProfitEvent\",\"type\":\"event\"}]","ContractName":"Etheron","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000be799ef5157da8988d0a18f62b542808b4aafe54000000000000000000000000eff65630a7bcc8b6271c5c2ac199d017940756f3","Library":"","LicenseType":"None","SwarmSource":"bzzr://4cd30828e99690af8ab483409811a5b46c785e7333dfbce9ef143a10653eb3ca"}]}