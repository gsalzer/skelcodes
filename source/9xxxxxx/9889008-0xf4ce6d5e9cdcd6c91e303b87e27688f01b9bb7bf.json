{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary LibMathSigned {\r\n    int256 private constant _WAD = 10**18;\r\n    int256 private constant _INT256_MIN = -2**255;\r\n\r\n    function WAD() internal pure returns (int256) {\r\n        return _WAD;\r\n    }\r\n\r\n    // additive inverse\r\n    function neg(int256 a) internal pure returns (int256) {\r\n        return sub(int256(0), a);\r\n    }\r\n\r\n    /**\r\n     * @dev wmultiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(!(a == -1 && b == _INT256_MIN), \"wmultiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"wmultiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer wdivision of two signed integers truncating the quotient, reverts on wdivision by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"wdivision by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"wdivision overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function wmul(int256 x, int256 y) internal pure returns (int256 z) {\r\n        z = roundHalfUp(mul(x, y), _WAD) / _WAD;\r\n    }\r\n\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wdiv(int256 x, int256 y) internal pure returns (int256 z) {\r\n        if (y < 0) {\r\n            y = -y;\r\n            x = -x;\r\n        }\r\n        z = roundHalfUp(mul(x, _WAD), y) / y;\r\n    }\r\n\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wfrac(int256 x, int256 y, int256 z) internal pure returns (int256 r) {\r\n        int256 t = mul(x, y);\r\n        if (z < 0) {\r\n            z = -z;\r\n            t = -t;\r\n        }\r\n        r = roundHalfUp(t, z) / z;\r\n    }\r\n\r\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    // quotient and remainder\r\n    function pwdiv(int256 x, int256 y) internal pure returns (int256 z, int256 m) {\r\n        z = wdiv(x, y);\r\n        m = sub(wmul(y, z), x);\r\n    }\r\n\r\n    function toUint256(int256 x) internal pure returns (uint256) {\r\n        require(x >= 0, \"int overflow\");\r\n        return uint256(x);\r\n    }\r\n\r\n    // x ^ n\r\n    // NOTE: n is a normal integer, do not shift 18 decimals\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wpowi(int256 x, int256 n) internal pure returns (int256 z) {\r\n        z = n % 2 != 0 ? x : _WAD;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = wmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = wmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    uint8 internal constant fixed_digits = 18;\r\n    int256 internal constant fixed_1 = 1000000000000000000;\r\n    int256 internal constant fixed_e = 2718281828459045235;\r\n    uint8 internal constant longer_digits = 36;\r\n    int256 internal constant longer_fixed_log_e_1_5 = 405465108108164381978013115464349137;\r\n    int256 internal constant longer_fixed_1 = 1000000000000000000000000000000000000;\r\n    int256 internal constant longer_fixed_log_e_10 = 2302585092994045684017991454684364208;\r\n\r\n    // ROUND_HALF_UP rule helper. 0.5 ≈ 1, 0.4 ≈ 0, -0.5 ≈ -1, -0.4 ≈ 0\r\n    function roundHalfUp(int256 x, int256 y) internal pure returns (int256) {\r\n        require(y > 0, \"roundHalfUp only supports y > 0\");\r\n        if (x >= 0) {\r\n            return add(x, y / 2);\r\n        }\r\n        return sub(x, y / 2);\r\n    }\r\n\r\n    // function roundFloor(int256 x, int256 y) internal pure returns (int256) {\r\n    //     require(y > 0, \"roundHalfUp only supports y > 0\");\r\n    //     if (x >= 0 || x % _WAD == 0) {\r\n    //         return x;\r\n    //     }\r\n    //     return sub(x, y);\r\n    // }\r\n\r\n    // function roundCeil(int256 x, int256 y) internal pure returns (int256) {\r\n    //     require(y > 0, \"roundHalfUp only supports y > 0\");\r\n    //     if (x <= 0 || x % _WAD == 0) {\r\n    //         return x;\r\n    //     }\r\n    //     return add(x, y);\r\n    // }\r\n\r\n    // Log(e, x)\r\n    // solium-disable-next-line security/no-assign-params\r\n    function wln(int256 x) internal pure returns (int256) {\r\n        require(x > 0, \"logE of negative number\");\r\n        require(x <= 10000000000000000000000000000000000000000, \"logE only accepts v <= 1e22 * 1e18\"); // in order to prevent using safe-math\r\n        int256 r = 0;\r\n        uint8 extra_digits = longer_digits - fixed_digits;\r\n        int256 t = int256(uint256(10)**uint256(extra_digits));\r\n\r\n        while (x <= fixed_1 / 10) {\r\n            x = x * 10;\r\n            r -= longer_fixed_log_e_10;\r\n        }\r\n        while (x >= 10 * fixed_1) {\r\n            x = x / 10;\r\n            r += longer_fixed_log_e_10;\r\n        }\r\n        while (x < fixed_1) {\r\n            x = wmul(x, fixed_e);\r\n            r -= longer_fixed_1;\r\n        }\r\n        while (x > fixed_e) {\r\n            x = wdiv(x, fixed_e);\r\n            r += longer_fixed_1;\r\n        }\r\n        if (x == fixed_1) {\r\n            return roundHalfUp(r, t) / t;\r\n        }\r\n        if (x == fixed_e) {\r\n            return fixed_1 + roundHalfUp(r, t) / t;\r\n        }\r\n        x *= t;\r\n\r\n        //               x^2   x^3   x^4\r\n        // Ln(1+x) = x - --- + --- - --- + ...\r\n        //                2     3     4\r\n        // when -1 < x < 1, O(x^n) < ε => when n = 36, 0 < x < 0.316\r\n        //\r\n        //                    2    x           2    x          2    x\r\n        // Ln(a+x) = Ln(a) + ---(------)^1  + ---(------)^3 + ---(------)^5 + ...\r\n        //                    1   2a+x         3   2a+x        5   2a+x\r\n        //\r\n        // Let x = v - a\r\n        //                  2   v-a         2   v-a        2   v-a\r\n        // Ln(v) = Ln(a) + ---(-----)^1  + ---(-----)^3 + ---(-----)^5 + ...\r\n        //                  1   v+a         3   v+a        5   v+a\r\n        // when n = 36, 1 < v < 3.423\r\n        r = r + longer_fixed_log_e_1_5;\r\n        int256 a1_5 = (3 * longer_fixed_1) / 2;\r\n        int256 m = (longer_fixed_1 * (x - a1_5)) / (x + a1_5);\r\n        r = r + 2 * m;\r\n        int256 m2 = (m * m) / longer_fixed_1;\r\n        uint8 i = 3;\r\n        while (true) {\r\n            m = (m * m2) / longer_fixed_1;\r\n            r = r + (2 * m) / int256(i);\r\n            i += 2;\r\n            if (i >= 3 + 2 * fixed_digits) {\r\n                break;\r\n            }\r\n        }\r\n        return roundHalfUp(r, t) / t;\r\n    }\r\n\r\n    // Log(b, x)\r\n    function logBase(int256 base, int256 x) internal pure returns (int256) {\r\n        return wdiv(wln(x), wln(base));\r\n    }\r\n\r\n    function ceil(int256 x, int256 m) internal pure returns (int256) {\r\n        require(x >= 0, \"ceil need x >= 0\");\r\n        require(m > 0, \"ceil need m > 0\");\r\n        return (sub(add(x, m), 1) / m) * m;\r\n    }\r\n}\r\n\r\nlibrary LibMathUnsigned {\r\n    uint256 private constant _WAD = 10**18;\r\n    uint256 private constant _UINT256_MAX = 2**255 - 1;\r\n\r\n    function WAD() internal pure returns (uint256) {\r\n        return _WAD;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"Unaddition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"Unsubtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"Unmultiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"Undivision by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), _WAD / 2) / _WAD;\r\n    }\r\n\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, _WAD), y / 2) / y;\r\n    }\r\n\r\n    function wfrac(uint256 x, uint256 y, uint256 z) internal pure returns (uint256 r) {\r\n        r = mul(x, y) / z;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    // quotient and remainder\r\n    function pwdiv(uint256 x, uint256 y) internal pure returns (uint256 z, uint256 m) {\r\n        z = wdiv(x, y);\r\n        m = sub(wmul(y, z), x);\r\n    }\r\n\r\n    function toInt256(uint256 x) internal pure returns (int256) {\r\n        require(x <= _UINT256_MAX, \"uint256 overflow\");\r\n        return int256(x);\r\n    }\r\n\r\n    function mod(uint256 x, uint256 m) internal pure returns (uint256) {\r\n        require(m != 0, \"mod by zero\");\r\n        return x % m;\r\n    }\r\n\r\n    function ceil(uint256 x, uint256 m) internal pure returns (uint256) {\r\n        require(m > 0, \"ceil need m > 0\");\r\n        return (sub(add(x, m), 1) / m) * m;\r\n    }\r\n}\r\n\r\nlibrary LibEIP712 {\r\n    string internal constant DOMAIN_NAME = \"Mai Protocol\";\r\n\r\n    struct OrderSignature {\r\n        bytes32 config;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    /**\r\n     * Hash of the EIP712 Domain Separator Schema\r\n     */\r\n    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\"EIP712Domain(string name)\"));\r\n\r\n    bytes32 private constant DOMAIN_SEPARATOR = keccak256(\r\n        abi.encodePacked(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(DOMAIN_NAME)))\r\n    );\r\n\r\n    /**\r\n     * Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\r\n     *\r\n     * @param eip712hash The EIP712 hash struct.\r\n     * @return EIP712 hash applied to this EIP712 Domain.\r\n     */\r\n    function hashEIP712Message(bytes32 eip712hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, eip712hash));\r\n    }\r\n}\r\n\r\nlibrary LibSignature {\r\n    enum SignatureMethod {ETH_SIGN, EIP712}\r\n\r\n    struct OrderSignature {\r\n        bytes32 config;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    /**\r\n     * Validate a signature given a hash calculated from the order data, the signer, and the\r\n     * signature data passed in with the order.\r\n     *\r\n     * This function will revert the transaction if the signature method is invalid.\r\n     *\r\n     * @param signature The signature data passed along with the order to validate against\r\n     * @param hash Hash bytes calculated by taking the EIP712 hash of the passed order data\r\n     * @param signerAddress The address of the signer\r\n     * @return True if the calculated signature matches the order signature data, false otherwise.\r\n     */\r\n    function isValidSignature(OrderSignature memory signature, bytes32 hash, address signerAddress)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint8 method = uint8(signature.config[1]);\r\n        address recovered;\r\n        uint8 v = uint8(signature.config[0]);\r\n\r\n        if (method == uint8(SignatureMethod.ETH_SIGN)) {\r\n            recovered = ecrecover(\r\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),\r\n                v,\r\n                signature.r,\r\n                signature.s\r\n            );\r\n        } else if (method == uint8(SignatureMethod.EIP712)) {\r\n            recovered = ecrecover(hash, v, signature.r, signature.s);\r\n        } else {\r\n            revert(\"invalid sign method\");\r\n        }\r\n\r\n        return signerAddress == recovered;\r\n    }\r\n}\r\n\r\nlibrary LibOrder {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n\r\n    bytes32 public constant EIP712_ORDER_TYPE = keccak256(\r\n        abi.encodePacked(\r\n            \"Order(address trader,address broker,address perpetual,uint256 amount,uint256 price,bytes32 data)\"\r\n        )\r\n    );\r\n\r\n    int256 public constant FEE_RATE_BASE = 100000;\r\n    uint256 public constant ONE = 1e18;\r\n\r\n    struct Order {\r\n        address trader;\r\n        address broker;\r\n        address perpetual;\r\n        uint256 amount;\r\n        uint256 price;\r\n        /**\r\n         * Data contains the following values packed into 32 bytes\r\n         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\r\n         * ║                    │ length(bytes)   desc                                      ║\r\n         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\r\n         * ║ version            │ 1               order version                             ║\r\n         * ║ side               │ 1               0: buy (long), 1: sell (short)            ║\r\n         * ║ isMarketOrder      │ 1               0: limitOrder, 1: marketOrder             ║\r\n         * ║ expiredAt          │ 5               order expiration time in seconds          ║\r\n         * ║ asMakerFeeRate     │ 2               maker fee rate (base 100,000)             ║\r\n         * ║ asTakerFeeRate     │ 2               taker fee rate (base 100,000)             ║\r\n         * ║ (d) makerRebateRate│ 2               rebate rate for maker (base 100)          ║\r\n         * ║ salt               │ 8               salt                                      ║\r\n         * ║ isMakerOnly        │ 1               is maker only                             ║\r\n         * ║ isInversed         │ 1               is inversed contract                      ║\r\n         * ║                    │ 8               reserved                                  ║\r\n         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\r\n         */\r\n        bytes32 data;\r\n    }\r\n\r\n    struct OrderParam {\r\n        address trader;\r\n        uint256 amount;\r\n        uint256 price;\r\n        bytes32 data;\r\n        LibSignature.OrderSignature signature;\r\n    }\r\n\r\n    function getOrderHash(OrderParam memory orderParam, address perpetual, address broker)\r\n        internal\r\n        pure\r\n        returns (bytes32 orderHash)\r\n    {\r\n        Order memory order = getOrder(orderParam, perpetual, broker);\r\n        orderHash = LibEIP712.hashEIP712Message(hashOrder(order));\r\n        return orderHash;\r\n    }\r\n\r\n    function getOrderHash(Order memory order) internal pure returns (bytes32 orderHash) {\r\n        orderHash = LibEIP712.hashEIP712Message(hashOrder(order));\r\n        return orderHash;\r\n    }\r\n\r\n    function getOrder(OrderParam memory orderParam, address perpetual, address broker)\r\n        internal\r\n        pure\r\n        returns (LibOrder.Order memory order)\r\n    {\r\n        order.trader = orderParam.trader;\r\n        order.broker = broker;\r\n        order.perpetual = perpetual;\r\n        order.amount = orderParam.amount;\r\n        order.price = orderParam.price;\r\n        order.data = orderParam.data;\r\n    }\r\n\r\n    function hashOrder(Order memory order) internal pure returns (bytes32 result) {\r\n        bytes32 orderType = EIP712_ORDER_TYPE;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let start := sub(order, 32)\r\n            let tmp := mload(start)\r\n            mstore(start, orderType)\r\n            result := keccak256(start, 224)\r\n            mstore(start, tmp)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getOrderVersion(OrderParam memory orderParam) internal pure returns (uint256) {\r\n        return uint256(uint8(bytes1(orderParam.data)));\r\n    }\r\n\r\n    function getExpiredAt(OrderParam memory orderParam) internal pure returns (uint256) {\r\n        return uint256(uint40(bytes5(orderParam.data << (8 * 3))));\r\n    }\r\n\r\n    function isSell(OrderParam memory orderParam) internal pure returns (bool) {\r\n        bool sell = uint8(orderParam.data[1]) == 1;\r\n        return isInversed(orderParam) ? !sell : sell;\r\n    }\r\n\r\n    function getPrice(OrderParam memory orderParam) internal pure returns (uint256) {\r\n        return isInversed(orderParam) ? ONE.wdiv(orderParam.price) : orderParam.price;\r\n    }\r\n\r\n    function isMarketOrder(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return uint8(orderParam.data[2]) == 1;\r\n    }\r\n\r\n    function isMarketBuy(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return !isSell(orderParam) && isMarketOrder(orderParam);\r\n    }\r\n\r\n    function isMakerOnly(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return uint8(orderParam.data[22]) == 1;\r\n    }\r\n\r\n    function isInversed(OrderParam memory orderParam) internal pure returns (bool) {\r\n        return uint8(orderParam.data[23]) == 1;\r\n    }\r\n\r\n    function side(OrderParam memory orderParam) internal pure returns (LibTypes.Side) {\r\n        return isSell(orderParam) ? LibTypes.Side.SHORT : LibTypes.Side.LONG;\r\n    }\r\n\r\n    function makerFeeRate(OrderParam memory orderParam) internal pure returns (int256) {\r\n        return int256(int16(bytes2(orderParam.data << (8 * 8)))).mul(LibMathSigned.WAD()).div(FEE_RATE_BASE);\r\n    }\r\n\r\n    function takerFeeRate(OrderParam memory orderParam) internal pure returns (int256) {\r\n        return int256(int16(bytes2(orderParam.data << (8 * 10)))).mul(LibMathSigned.WAD()).div(FEE_RATE_BASE);\r\n    }\r\n}\r\n\r\nlibrary LibTypes {\r\n    enum Side {FLAT, SHORT, LONG}\r\n\r\n    enum Status {NORMAL, SETTLING, SETTLED}\r\n\r\n    function counterSide(Side side) internal pure returns (Side) {\r\n        if (side == Side.LONG) {\r\n            return Side.SHORT;\r\n        } else if (side == Side.SHORT) {\r\n            return Side.LONG;\r\n        }\r\n        return side;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////\r\n    // Perpetual\r\n    //////////////////////////////////////////////////////////////////////////\r\n    struct PerpGovernanceConfig {\r\n        uint256 initialMarginRate;\r\n        uint256 maintenanceMarginRate;\r\n        uint256 liquidationPenaltyRate;\r\n        uint256 penaltyFundRate;\r\n        int256 takerDevFeeRate;\r\n        int256 makerDevFeeRate;\r\n        uint256 lotSize;\r\n        uint256 tradingLotSize;\r\n    }\r\n\r\n    // CollateralAccount represents cash account of user\r\n    struct CollateralAccount {\r\n        // currernt deposited erc20 token amount, representing in decimals 18\r\n        int256 balance;\r\n        // the amount of withdrawal applied by user\r\n        // which allowed to withdraw in the future but not available in trading\r\n        int256 appliedBalance;\r\n        // applied balance will be appled only when the block height below is reached\r\n        uint256 appliedHeight;\r\n    }\r\n\r\n    struct PositionAccount {\r\n        LibTypes.Side side;\r\n        uint256 size;\r\n        uint256 entryValue;\r\n        int256 entrySocialLoss;\r\n        int256 entryFundingLoss;\r\n    }\r\n\r\n    struct BrokerRecord {\r\n        address broker;\r\n        uint256 appliedHeight;\r\n    }\r\n\r\n    struct Broker {\r\n        BrokerRecord previous;\r\n        BrokerRecord current;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////\r\n    // AMM\r\n    //////////////////////////////////////////////////////////////////////////\r\n    struct AMMGovernanceConfig {\r\n        uint256 poolFeeRate;\r\n        uint256 poolDevFeeRate;\r\n        int256 emaAlpha;\r\n        uint256 updatePremiumPrize;\r\n        int256 markPremiumLimit;\r\n        int256 fundingDampener;\r\n    }\r\n\r\n    struct FundingState {\r\n        uint256 lastFundingTime;\r\n        int256 lastPremium;\r\n        int256 lastEMAPremium;\r\n        uint256 lastIndexPrice;\r\n        int256 accumulatedFundingPerContract;\r\n    }\r\n}\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(msg.sender), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\ncontract WhitelistedRole is WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(msg.sender);\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\ncontract AMMGovernance is WhitelistedRole {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n\r\n    LibTypes.AMMGovernanceConfig internal governance;\r\n\r\n    // auto-set when calling setGovernanceParameter\r\n    int256 public emaAlpha2; // 1 - emaAlpha\r\n    int256 public emaAlpha2Ln; // ln(emaAlpha2)\r\n\r\n    event UpdateGovernanceParameter(bytes32 indexed key, int256 value);\r\n\r\n    function setGovernanceParameter(bytes32 key, int256 value) public onlyWhitelistAdmin {\r\n        if (key == \"poolFeeRate\") {\r\n            governance.poolFeeRate = value.toUint256();\r\n        } else if (key == \"poolDevFeeRate\") {\r\n            governance.poolDevFeeRate = value.toUint256();\r\n        } else if (key == \"emaAlpha\") {\r\n            require(value > 0, \"alpha should be > 0\");\r\n            governance.emaAlpha = value;\r\n            emaAlpha2 = 10**18 - governance.emaAlpha;\r\n            emaAlpha2Ln = emaAlpha2.wln();\r\n        } else if (key == \"updatePremiumPrize\") {\r\n            governance.updatePremiumPrize = value.toUint256();\r\n        } else if (key == \"markPremiumLimit\") {\r\n            governance.markPremiumLimit = value;\r\n        } else if (key == \"fundingDampener\") {\r\n            governance.fundingDampener = value;\r\n        } else {\r\n            revert(\"key not exists\");\r\n        }\r\n        emit UpdateGovernanceParameter(key, value);\r\n    }\r\n\r\n    function getGovernance() public view returns (LibTypes.AMMGovernanceConfig memory) {\r\n        return governance;\r\n    }\r\n}\r\n\r\ninterface IPriceFeeder {\r\n    function price() external view returns (uint256 lastPrice, uint256 lastTimestamp);\r\n}\r\n\r\ninterface IPerpetualProxy {\r\n    // a gas-optimized version of position*\r\n    struct PoolAccount {\r\n        uint256 positionSize;\r\n        uint256 positionEntryValue;\r\n        int256 cashBalance;\r\n        int256 socialLossPerContract;\r\n        int256 positionEntrySocialLoss;\r\n        int256 positionEntryFundingLoss;\r\n    }\r\n\r\n    function self() external view returns (address);\r\n\r\n    function perpetual() external view returns (address);\r\n\r\n    function devAddress() external view returns (address);\r\n\r\n    function currentBroker(address guy) external view returns (address);\r\n\r\n    function markPrice() external returns (uint256);\r\n\r\n    function settlementPrice() external view returns (uint256);\r\n\r\n    function availableMargin(address guy) external returns (int256);\r\n\r\n    function getPoolAccount() external view returns (PoolAccount memory pool);\r\n\r\n    function cashBalance() external view returns (int256);\r\n\r\n    function positionSize() external view returns (uint256);\r\n\r\n    function positionSide() external view returns (LibTypes.Side);\r\n\r\n    function positionEntryValue() external view returns (uint256);\r\n\r\n    function positionEntrySocialLoss() external view returns (int256);\r\n\r\n    function positionEntryFundingLoss() external view returns (int256);\r\n\r\n    // function isEmergency() external view returns (bool);\r\n\r\n    // function isGlobalSettled() external view returns (bool);\r\n\r\n    function status() external view returns (LibTypes.Status);\r\n\r\n    function socialLossPerContract(LibTypes.Side side) external view returns (int256);\r\n\r\n    function transferBalanceIn(address from, uint256 amount) external;\r\n\r\n    function transferBalanceOut(address to, uint256 amount) external;\r\n\r\n    function transferBalanceTo(address from, address to, uint256 amount) external;\r\n\r\n    function trade(address guy, LibTypes.Side side, uint256 price, uint256 amount) external returns (uint256);\r\n\r\n    function setBrokerFor(address guy, address broker) external;\r\n\r\n    function depositFor(address guy, uint256 amount) external;\r\n\r\n    function depositEtherFor(address guy) external payable;\r\n\r\n    function withdrawFor(address payable guy, uint256 amount) external;\r\n\r\n    function isSafe(address guy) external returns (bool);\r\n\r\n    function isSafeWithPrice(address guy, uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function isProxySafe() external returns (bool);\r\n\r\n    function isProxySafeWithPrice(uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function isIMSafe(address guy) external returns (bool);\r\n\r\n    function isIMSafeWithPrice(address guy, uint256 currentMarkPrice) external returns (bool);\r\n\r\n    function lotSize() external view returns (uint256);\r\n\r\n    function tradingLotSize() external view returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\ncontract MinterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () internal {\r\n        _addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\ncontract ERC20Mintable is ERC20, MinterRole {\r\n    /**\r\n     * @dev See `ERC20._mint`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `MinterRole`.\r\n     */\r\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\r\n        _mint(account, amount);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ERC20Burnable is ERC20 {\r\n    /**\r\n     * @dev Destoys `amount` tokens from the caller.\r\n     *\r\n     * See `ERC20._burn`.\r\n     */\r\n    function burn(uint256 amount) public {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See `ERC20._burnFrom`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public {\r\n        _burnFrom(account, amount);\r\n    }\r\n}\r\n\r\ncontract ShareToken is ERC20Mintable {\r\n    uint256 public decimals;\r\n    string public name;\r\n    string public symbol;\r\n\r\n    constructor(string memory _name, string memory _symbol, uint256 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function burn(address account, uint256 amount) public onlyMinter {\r\n        _burn(account, amount);\r\n    }\r\n}\r\n\r\ncontract AMM is AMMGovernance {\r\n    using LibMathSigned for int256;\r\n    using LibMathUnsigned for uint256;\r\n\r\n    uint256 private constant ONE_WAD_U = 10**18;\r\n    int256 private constant ONE_WAD_S = 10**18;\r\n\r\n    // interfaces\r\n    ShareToken private shareToken;\r\n    IPerpetualProxy public perpetualProxy;\r\n    IPriceFeeder public priceFeeder;\r\n\r\n    // funding\r\n    LibTypes.FundingState internal fundingState;\r\n\r\n    event CreateAMM();\r\n    event UpdateFundingRate(LibTypes.FundingState fundingState);\r\n\r\n    modifier onlyBroker() {\r\n        require(perpetualProxy.currentBroker(msg.sender) == authorizedBroker(), \"invalid broker\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _perpetualProxy, address _priceFeeder, address _shareToken) public {\r\n        priceFeeder = IPriceFeeder(_priceFeeder);\r\n        perpetualProxy = IPerpetualProxy(_perpetualProxy);\r\n        shareToken = ShareToken(_shareToken);\r\n\r\n        emit CreateAMM();\r\n    }\r\n\r\n    // view functions\r\n    function authorizedBroker() internal view returns (address) {\r\n        return address(perpetualProxy);\r\n    }\r\n\r\n    function shareTokenAddress() public view returns (address) {\r\n        return address(shareToken);\r\n    }\r\n\r\n    function indexPrice() public view returns (uint256 price, uint256 timestamp) {\r\n        (price, timestamp) = priceFeeder.price();\r\n        require(price != 0, \"dangerous index price\");\r\n    }\r\n\r\n    function positionSize() public view returns (uint256) {\r\n        return perpetualProxy.positionSize();\r\n    }\r\n\r\n    // note: last* functions (lastFundingState, lastAvailableMargin, lastFairPrice, etc.) are calculated based on\r\n    //       the on-chain fundingState. current* functions are calculated based on the current timestamp\r\n\r\n    function lastFundingState() public view returns (LibTypes.FundingState memory) {\r\n        return fundingState;\r\n    }\r\n\r\n    function lastAvailableMargin() internal view returns (uint256) {\r\n        IPerpetualProxy.PoolAccount memory pool = perpetualProxy.getPoolAccount();\r\n        return availableMarginFromPoolAccount(pool);\r\n    }\r\n\r\n    function lastFairPrice() internal view returns (uint256) {\r\n        IPerpetualProxy.PoolAccount memory pool = perpetualProxy.getPoolAccount();\r\n        return fairPriceFromPoolAccount(pool);\r\n    }\r\n\r\n    function lastPremium() internal view returns (int256) {\r\n        IPerpetualProxy.PoolAccount memory pool = perpetualProxy.getPoolAccount();\r\n        return premiumFromPoolAccount(pool);\r\n    }\r\n\r\n    function lastEMAPremium() internal view returns (int256) {\r\n        return fundingState.lastEMAPremium;\r\n    }\r\n\r\n    function lastMarkPrice() internal view returns (uint256) {\r\n        int256 index = fundingState.lastIndexPrice.toInt256();\r\n        int256 limit = index.wmul(governance.markPremiumLimit);\r\n        int256 p = index.add(lastEMAPremium());\r\n        p = p.min(index.add(limit));\r\n        p = p.max(index.sub(limit));\r\n        return p.max(0).toUint256();\r\n    }\r\n\r\n    function lastPremiumRate() internal view returns (int256) {\r\n        int256 index = fundingState.lastIndexPrice.toInt256();\r\n        int256 rate = lastMarkPrice().toInt256();\r\n        rate = rate.sub(index).wdiv(index);\r\n        return rate;\r\n    }\r\n\r\n    function lastFundingRate() public view returns (int256) {\r\n        int256 rate = lastPremiumRate();\r\n        return rate.max(governance.fundingDampener).add(rate.min(-governance.fundingDampener));\r\n    }\r\n\r\n    // Public functions\r\n    // note: current* functions (currentFundingState, currentAvailableMargin, currentFairPrice, etc.) are calculated based on\r\n    //       the current timestamp. current* functions are calculated based on the on-chain fundingState\r\n\r\n    function currentFundingState() public returns (LibTypes.FundingState memory) {\r\n        funding();\r\n        return fundingState;\r\n    }\r\n\r\n    function currentAvailableMargin() public returns (uint256) {\r\n        funding();\r\n        return lastAvailableMargin();\r\n    }\r\n\r\n    function currentFairPrice() public returns (uint256) {\r\n        funding();\r\n        return lastFairPrice();\r\n    }\r\n\r\n    function currentPremium() public returns (int256) {\r\n        funding();\r\n        return lastPremium();\r\n    }\r\n\r\n    function currentMarkPrice() public returns (uint256) {\r\n        funding();\r\n        return lastMarkPrice();\r\n    }\r\n\r\n    function currentPremiumRate() public returns (int256) {\r\n        funding();\r\n        return lastPremiumRate();\r\n    }\r\n\r\n    function currentFundingRate() public returns (int256) {\r\n        funding();\r\n        return lastFundingRate();\r\n    }\r\n\r\n    function currentAccumulatedFundingPerContract() public returns (int256) {\r\n        funding();\r\n        return fundingState.accumulatedFundingPerContract;\r\n    }\r\n\r\n    function createPool(uint256 amount) public {\r\n        require(perpetualProxy.status() == LibTypes.Status.NORMAL, \"wrong perpetual status\");\r\n        require(positionSize() == 0, \"pool not empty\");\r\n        require(amount.mod(perpetualProxy.lotSize()) == 0, \"invalid lot size\");\r\n\r\n        address trader = msg.sender;\r\n        uint256 blockTime = getBlockTimestamp();\r\n        uint256 newIndexPrice;\r\n        uint256 newIndexTimestamp;\r\n        (newIndexPrice, newIndexTimestamp) = indexPrice();\r\n\r\n        initFunding(newIndexPrice, blockTime);\r\n        perpetualProxy.transferBalanceIn(trader, newIndexPrice.wmul(amount).mul(2));\r\n        uint256 opened = perpetualProxy.trade(trader, LibTypes.Side.SHORT, newIndexPrice, amount);\r\n        mintShareTokenTo(trader, amount);\r\n\r\n        forceFunding(); // x, y changed, so fair price changed. we need funding now\r\n        mustSafe(trader, opened);\r\n    }\r\n\r\n    function getBuyPrice(uint256 amount) internal returns (uint256 price) {\r\n        uint256 x;\r\n        uint256 y;\r\n        (x, y) = currentXY();\r\n        require(y != 0 && x != 0, \"empty pool\");\r\n        return x.wdiv(y.sub(amount));\r\n    }\r\n\r\n    function buyFrom(address trader, uint256 amount, uint256 limitPrice, uint256 deadline) private returns (uint256) {\r\n        require(perpetualProxy.status() == LibTypes.Status.NORMAL, \"wrong perpetual status\");\r\n        require(amount.mod(perpetualProxy.tradingLotSize()) == 0, \"invalid trading lot size\");\r\n\r\n        uint256 price = getBuyPrice(amount);\r\n        require(limitPrice >= price, \"price limited\");\r\n        require(getBlockTimestamp() <= deadline, \"deadline exceeded\");\r\n        uint256 opened = perpetualProxy.trade(trader, LibTypes.Side.LONG, price, amount);\r\n\r\n        uint256 value = price.wmul(amount);\r\n        uint256 fee = value.wmul(governance.poolFeeRate);\r\n        uint256 devFee = value.wmul(governance.poolDevFeeRate);\r\n        address devAddress = perpetualProxy.devAddress();\r\n\r\n        perpetualProxy.transferBalanceIn(trader, fee);\r\n        perpetualProxy.transferBalanceTo(trader, devAddress, devFee);\r\n\r\n        forceFunding(); // x, y changed, so fair price changed. we need funding now\r\n        mustSafe(trader, opened);\r\n        return opened;\r\n    }\r\n\r\n    function buyFromWhitelisted(address trader, uint256 amount, uint256 limitPrice, uint256 deadline)\r\n        public\r\n        onlyWhitelisted\r\n        returns (uint256)\r\n    {\r\n        return buyFrom(trader, amount, limitPrice, deadline);\r\n    }\r\n\r\n    function buy(uint256 amount, uint256 limitPrice, uint256 deadline) public onlyBroker returns (uint256) {\r\n        return buyFrom(msg.sender, amount, limitPrice, deadline);\r\n    }\r\n\r\n    function getSellPrice(uint256 amount) internal returns (uint256 price) {\r\n        uint256 x;\r\n        uint256 y;\r\n        (x, y) = currentXY();\r\n        require(y != 0 && x != 0, \"empty pool\");\r\n        return x.wdiv(y.add(amount));\r\n    }\r\n\r\n    function sellFrom(address trader, uint256 amount, uint256 limitPrice, uint256 deadline) private returns (uint256) {\r\n        require(perpetualProxy.status() == LibTypes.Status.NORMAL, \"wrong perpetual status\");\r\n        require(amount.mod(perpetualProxy.tradingLotSize()) == 0, \"invalid trading lot size\");\r\n\r\n        uint256 price = getSellPrice(amount);\r\n        require(limitPrice <= price, \"price limited\");\r\n        require(getBlockTimestamp() <= deadline, \"deadline exceeded\");\r\n        uint256 opened = perpetualProxy.trade(trader, LibTypes.Side.SHORT, price, amount);\r\n\r\n        uint256 value = price.wmul(amount);\r\n        uint256 fee = value.wmul(governance.poolFeeRate);\r\n        uint256 devFee = value.wmul(governance.poolDevFeeRate);\r\n        address devAddress = perpetualProxy.devAddress();\r\n        perpetualProxy.transferBalanceIn(trader, fee);\r\n        perpetualProxy.transferBalanceTo(trader, devAddress, devFee);\r\n\r\n        forceFunding(); // x, y changed, so fair price changed. we need funding now\r\n        mustSafe(trader, opened);\r\n        return opened;\r\n    }\r\n\r\n    function sellFromWhitelisted(address trader, uint256 amount, uint256 limitPrice, uint256 deadline)\r\n        public\r\n        onlyWhitelisted\r\n        returns (uint256)\r\n    {\r\n        return sellFrom(trader, amount, limitPrice, deadline);\r\n    }\r\n\r\n    function sell(uint256 amount, uint256 limitPrice, uint256 deadline) public onlyBroker returns (uint256) {\r\n        return sellFrom(msg.sender, amount, limitPrice, deadline);\r\n    }\r\n\r\n    // sell amount, pay 2 * amount * price collateral\r\n    function addLiquidity(uint256 amount) public onlyBroker {\r\n        require(perpetualProxy.status() == LibTypes.Status.NORMAL, \"wrong perpetual status\");\r\n        require(amount.mod(perpetualProxy.lotSize()) == 0, \"invalid lot size\");\r\n\r\n        uint256 oldAvailableMargin;\r\n        uint256 oldPoolPositionSize;\r\n        (oldAvailableMargin, oldPoolPositionSize) = currentXY();\r\n        require(oldPoolPositionSize != 0 && oldAvailableMargin != 0, \"empty pool\");\r\n\r\n        address trader = msg.sender;\r\n        uint256 price = oldAvailableMargin.wdiv(oldPoolPositionSize);\r\n\r\n        uint256 collateralAmount = amount.wmul(price).mul(2);\r\n        perpetualProxy.transferBalanceIn(trader, collateralAmount);\r\n        uint256 opened = perpetualProxy.trade(trader, LibTypes.Side.SHORT, price, amount);\r\n\r\n        mintShareTokenTo(trader, shareToken.totalSupply().wmul(amount).wdiv(oldPoolPositionSize));\r\n\r\n        forceFunding(); // x, y changed, so fair price changed. we need funding now\r\n        mustSafe(trader, opened);\r\n    }\r\n\r\n    function removeLiquidity(uint256 shareAmount) public onlyBroker {\r\n        require(perpetualProxy.status() == LibTypes.Status.NORMAL, \"wrong perpetual status\");\r\n\r\n        address trader = msg.sender;\r\n        uint256 oldAvailableMargin;\r\n        uint256 oldPoolPositionSize;\r\n        (oldAvailableMargin, oldPoolPositionSize) = currentXY();\r\n        require(oldPoolPositionSize != 0 && oldAvailableMargin != 0, \"empty pool\");\r\n        require(shareToken.balanceOf(msg.sender) >= shareAmount, \"shareBalance limited\");\r\n        uint256 price = oldAvailableMargin.wdiv(oldPoolPositionSize);\r\n        uint256 amount = shareAmount.wmul(oldPoolPositionSize).wdiv(shareToken.totalSupply());\r\n        amount = amount.sub(amount.mod(perpetualProxy.lotSize()));\r\n\r\n        perpetualProxy.transferBalanceOut(trader, price.wmul(amount).mul(2));\r\n        burnShareTokenFrom(trader, shareAmount);\r\n        uint256 opened = perpetualProxy.trade(trader, LibTypes.Side.LONG, price, amount);\r\n\r\n        forceFunding(); // x, y changed, so fair price changed. we need funding now\r\n        mustSafe(trader, opened);\r\n    }\r\n\r\n    function settleShare() public {\r\n        require(perpetualProxy.status() == LibTypes.Status.SETTLED, \"wrong perpetual status\");\r\n\r\n        address trader = msg.sender;\r\n        IPerpetualProxy.PoolAccount memory pool = perpetualProxy.getPoolAccount();\r\n        uint256 total = availableMarginFromPoolAccount(pool);\r\n        uint256 shareAmount = shareToken.balanceOf(trader);\r\n        uint256 balance = shareAmount.wmul(total).wdiv(shareToken.totalSupply());\r\n        perpetualProxy.transferBalanceOut(trader, balance);\r\n        burnShareTokenFrom(trader, shareAmount);\r\n    }\r\n\r\n    // this is a composite function of perp.setBroker + perp.deposit + amm.buy\r\n    // composite functions accept amount = 0\r\n    function depositAndBuy(uint256 depositAmount, uint256 tradeAmount, uint256 limitPrice, uint256 deadline) public {\r\n        perpetualProxy.setBrokerFor(msg.sender, authorizedBroker());\r\n        if (depositAmount > 0) {\r\n            perpetualProxy.depositFor(msg.sender, depositAmount);\r\n        }\r\n        if (tradeAmount > 0) {\r\n            buy(tradeAmount, limitPrice, deadline);\r\n        }\r\n    }\r\n\r\n    // this is a composite function of perp.setBroker + perp.depositEther + amm.buy\r\n    // composite functions accept amount = 0\r\n    function depositEtherAndBuy(uint256 tradeAmount, uint256 limitPrice, uint256 deadline) public payable {\r\n        perpetualProxy.setBrokerFor(msg.sender, authorizedBroker());\r\n        if (msg.value > 0) {\r\n            perpetualProxy.depositEtherFor.value(msg.value)(msg.sender);\r\n        }\r\n        if (tradeAmount > 0) {\r\n            buy(tradeAmount, limitPrice, deadline);\r\n        }\r\n    }\r\n\r\n    // this is a composite function of perp.setBroker + perp.deposit + amm.sell\r\n    // composite functions accept amount = 0\r\n    function depositAndSell(uint256 depositAmount, uint256 tradeAmount, uint256 limitPrice, uint256 deadline) public {\r\n        perpetualProxy.setBrokerFor(msg.sender, authorizedBroker());\r\n        if (depositAmount > 0) {\r\n            perpetualProxy.depositFor(msg.sender, depositAmount);\r\n        }\r\n        if (tradeAmount > 0) {\r\n            sell(tradeAmount, limitPrice, deadline);\r\n        }\r\n    }\r\n\r\n    // this is a composite function of perp.setBroker + perp.depositEther + amm.sell\r\n    // composite functions accept amount = 0\r\n    function depositEtherAndSell(uint256 tradeAmount, uint256 limitPrice, uint256 deadline) public payable {\r\n        perpetualProxy.setBrokerFor(msg.sender, authorizedBroker());\r\n        if (msg.value > 0) {\r\n            perpetualProxy.depositEtherFor.value(msg.value)(msg.sender);\r\n        }\r\n        if (tradeAmount > 0) {\r\n            sell(tradeAmount, limitPrice, deadline);\r\n        }\r\n    }\r\n\r\n    // this is a composite function of perp.setBroker + amm.buy + perp.withdraw\r\n    // composite functions accept amount = 0\r\n    function buyAndWithdraw(uint256 tradeAmount, uint256 limitPrice, uint256 deadline, uint256 withdrawAmount) public {\r\n        perpetualProxy.setBrokerFor(msg.sender, authorizedBroker());\r\n        if (tradeAmount > 0) {\r\n            buy(tradeAmount, limitPrice, deadline);\r\n        }\r\n        if (withdrawAmount > 0) {\r\n            perpetualProxy.withdrawFor(msg.sender, withdrawAmount);\r\n        }\r\n    }\r\n\r\n    // this is a composite function of perp.setBroker + amm.sell + perp.withdraw\r\n    // composite functions accept amount = 0\r\n    function sellAndWithdraw(uint256 tradeAmount, uint256 limitPrice, uint256 deadline, uint256 withdrawAmount) public {\r\n        perpetualProxy.setBrokerFor(msg.sender, authorizedBroker());\r\n        if (tradeAmount > 0) {\r\n            sell(tradeAmount, limitPrice, deadline);\r\n        }\r\n        if (withdrawAmount > 0) {\r\n            perpetualProxy.withdrawFor(msg.sender, withdrawAmount);\r\n        }\r\n    }\r\n\r\n    // this is a composite function of perp.deposit + perp.setBroker + amm.addLiquidity\r\n    // composite functions accept amount = 0\r\n    function depositAndAddLiquidity(uint256 depositAmount, uint256 amount) public {\r\n        perpetualProxy.setBrokerFor(msg.sender, authorizedBroker());\r\n        if (depositAmount > 0) {\r\n            perpetualProxy.depositFor(msg.sender, depositAmount);\r\n        }\r\n        if (amount > 0) {\r\n            addLiquidity(amount);\r\n        }\r\n    }\r\n\r\n    // this is a composite function of perp.deposit + perp.setBroker + amm.addLiquidity\r\n    // composite functions accept amount = 0\r\n    function depositEtherAndAddLiquidity(uint256 amount) public payable {\r\n        perpetualProxy.setBrokerFor(msg.sender, authorizedBroker());\r\n        if (msg.value > 0) {\r\n            perpetualProxy.depositEtherFor.value(msg.value)(msg.sender);\r\n        }\r\n        if (amount > 0) {\r\n            addLiquidity(amount);\r\n        }\r\n    }\r\n\r\n    function updateIndex() public {\r\n        uint256 oldIndexPrice = fundingState.lastIndexPrice;\r\n        forceFunding();\r\n        address devAddress = perpetualProxy.devAddress();\r\n        if (oldIndexPrice != fundingState.lastIndexPrice) {\r\n            perpetualProxy.transferBalanceTo(devAddress, msg.sender, governance.updatePremiumPrize);\r\n            require(perpetualProxy.isSafe(devAddress), \"dev unsafe\");\r\n        }\r\n    }\r\n\r\n    function initFunding(uint256 newIndexPrice, uint256 blockTime) private {\r\n        require(fundingState.lastFundingTime == 0, \"initalready initialized\");\r\n        fundingState.lastFundingTime = blockTime;\r\n        fundingState.lastIndexPrice = newIndexPrice;\r\n        fundingState.lastPremium = 0;\r\n        fundingState.lastEMAPremium = 0;\r\n    }\r\n\r\n    // changing conditions for funding:\r\n    // condition 1: time\r\n    // condition 2: indexPrice\r\n    // condition 3: fairPrice - hand over to forceFunding\r\n    function funding() public {\r\n        uint256 blockTime = getBlockTimestamp();\r\n        uint256 newIndexPrice;\r\n        uint256 newIndexTimestamp;\r\n        (newIndexPrice, newIndexTimestamp) = indexPrice();\r\n        if (\r\n            blockTime != fundingState.lastFundingTime || // condition 1\r\n            newIndexPrice != fundingState.lastIndexPrice || // condition 2, especially when updateIndex and buy/sell are in the same block\r\n            newIndexTimestamp > fundingState.lastFundingTime // condition 2\r\n        ) {\r\n            forceFunding(blockTime, newIndexPrice, newIndexTimestamp);\r\n        }\r\n    }\r\n\r\n    // Internal helpers\r\n\r\n    // in order to mock the block.timestamp\r\n    function getBlockTimestamp() internal view returns (uint256) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp;\r\n    }\r\n\r\n    // a gas-optimized version of currentAvailableMargin() + positionSize(). almost all formulas require these two\r\n    function currentXY() internal returns (uint256 x, uint256 y) {\r\n        funding();\r\n        IPerpetualProxy.PoolAccount memory pool = perpetualProxy.getPoolAccount();\r\n        x = availableMarginFromPoolAccount(pool);\r\n        y = pool.positionSize;\r\n    }\r\n\r\n    // a gas-optimized version of lastAvailableMargin()\r\n    function availableMarginFromPoolAccount(IPerpetualProxy.PoolAccount memory pool) internal view returns (uint256) {\r\n        int256 available = pool.cashBalance;\r\n        available = available.sub(pool.positionEntryValue.toInt256());\r\n        available = available.sub(\r\n            pool.socialLossPerContract.wmul(pool.positionSize.toInt256()).sub(pool.positionEntrySocialLoss)\r\n        );\r\n        available = available.sub(\r\n            fundingState.accumulatedFundingPerContract.wmul(pool.positionSize.toInt256()).sub(\r\n                pool.positionEntryFundingLoss\r\n            )\r\n        );\r\n        return available.max(0).toUint256();\r\n    }\r\n\r\n    // a gas-optimized version of lastFairPrice\r\n    function fairPriceFromPoolAccount(IPerpetualProxy.PoolAccount memory pool) internal view returns (uint256) {\r\n        uint256 y = pool.positionSize;\r\n        require(y > 0, \"funding initialization required\");\r\n        uint256 x = availableMarginFromPoolAccount(pool);\r\n        return x.wdiv(y);\r\n    }\r\n\r\n    // a gas-optimized version of lastPremium\r\n    function premiumFromPoolAccount(IPerpetualProxy.PoolAccount memory pool) internal view returns (int256) {\r\n        int256 p = fairPriceFromPoolAccount(pool).toInt256();\r\n        p = p.sub(fundingState.lastIndexPrice.toInt256());\r\n        return p;\r\n    }\r\n\r\n    function mustSafe(address trader, uint256 opened) internal {\r\n        // perpetual.markPrice is a little different from ours\r\n        uint256 perpetualMarkPrice = perpetualProxy.markPrice();\r\n        if (opened > 0) {\r\n            require(perpetualProxy.isIMSafeWithPrice(trader, perpetualMarkPrice), \"im unsafe\");\r\n        }\r\n        require(perpetualProxy.isSafeWithPrice(trader, perpetualMarkPrice), \"sender unsafe\");\r\n        require(perpetualProxy.isProxySafeWithPrice(perpetualMarkPrice), \"amm unsafe\");\r\n    }\r\n\r\n    function mintShareTokenTo(address guy, uint256 amount) internal {\r\n        shareToken.mint(guy, amount);\r\n    }\r\n\r\n    function burnShareTokenFrom(address guy, uint256 amount) internal {\r\n        shareToken.burn(guy, amount);\r\n    }\r\n\r\n    function forceFunding() internal {\r\n        uint256 blockTime = getBlockTimestamp();\r\n        uint256 newIndexPrice;\r\n        uint256 newIndexTimestamp;\r\n        (newIndexPrice, newIndexTimestamp) = indexPrice();\r\n        forceFunding(blockTime, newIndexPrice, newIndexTimestamp);\r\n    }\r\n\r\n    function forceFunding(uint256 blockTime, uint256 newIndexPrice, uint256 newIndexTimestamp) internal {\r\n        if (fundingState.lastFundingTime == 0) {\r\n            // funding initialization required. but in this case, it's safe to just do nothing and return\r\n            return;\r\n        }\r\n        IPerpetualProxy.PoolAccount memory pool = perpetualProxy.getPoolAccount();\r\n        if (pool.positionSize == 0) {\r\n            // empty pool. it's safe to just do nothing and return\r\n            return;\r\n        }\r\n\r\n        if (newIndexTimestamp > fundingState.lastFundingTime) {\r\n            // the 1st update\r\n            nextStateWithTimespan(pool, newIndexPrice, newIndexTimestamp);\r\n        }\r\n        // the 2nd update;\r\n        nextStateWithTimespan(pool, newIndexPrice, blockTime);\r\n\r\n        emit UpdateFundingRate(fundingState);\r\n    }\r\n\r\n    function nextStateWithTimespan(IPerpetualProxy.PoolAccount memory pool, uint256 newIndexPrice, uint256 endTimestamp)\r\n        private\r\n    {\r\n        require(fundingState.lastFundingTime != 0, \"funding initialization required\");\r\n        require(endTimestamp >= fundingState.lastFundingTime, \"we can't go back in time\");\r\n\r\n        // update ema\r\n        if (fundingState.lastFundingTime != endTimestamp) {\r\n            int256 timeDelta = endTimestamp.sub(fundingState.lastFundingTime).toInt256();\r\n            int256 acc;\r\n            (fundingState.lastEMAPremium, acc) = getAccumulatedFunding(\r\n                timeDelta,\r\n                fundingState.lastEMAPremium,\r\n                fundingState.lastPremium,\r\n                fundingState.lastIndexPrice.toInt256() // ema is according to the old index\r\n            );\r\n            fundingState.accumulatedFundingPerContract = fundingState.accumulatedFundingPerContract.add(\r\n                acc.div(8 * 3600)\r\n            ); // ema is according to the old index\r\n            fundingState.lastFundingTime = endTimestamp;\r\n        }\r\n\r\n        // always update\r\n        fundingState.lastIndexPrice = newIndexPrice; // should update before premium()\r\n        fundingState.lastPremium = premiumFromPoolAccount(pool);\r\n    }\r\n\r\n    // solve t in emaPremium == y equation\r\n    function timeOnFundingCurve(\r\n        int256 y,\r\n        int256 v0, // lastEMAPremium\r\n        int256 _lastPremium\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            int256 t // normal int, not WAD\r\n        )\r\n    {\r\n        require(y != _lastPremium, \"no solution 1 on funding curve\");\r\n        t = y.sub(_lastPremium);\r\n        t = t.wdiv(v0.sub(_lastPremium));\r\n        require(t > 0, \"no solution 2 on funding curve\");\r\n        require(t < ONE_WAD_S, \"no solution 3 on funding curve\");\r\n        t = t.wln();\r\n        t = t.wdiv(emaAlpha2Ln);\r\n        t = t.ceil(ONE_WAD_S) / ONE_WAD_S;\r\n    }\r\n\r\n    // sum emaPremium curve between [x, y)\r\n    function integrateOnFundingCurve(\r\n        int256 x, // normal int, not WAD\r\n        int256 y, // normal int, not WAD\r\n        int256 v0, // lastEMAPremium\r\n        int256 _lastPremium\r\n    ) internal view returns (int256 r) {\r\n        require(x <= y, \"integrate reversed\");\r\n        r = v0.sub(_lastPremium);\r\n        r = r.wmul(emaAlpha2.wpowi(x).sub(emaAlpha2.wpowi(y)));\r\n        r = r.wdiv(governance.emaAlpha);\r\n        r = r.add(_lastPremium.mul(y.sub(x)));\r\n    }\r\n\r\n    struct AccumulatedFundingCalculator {\r\n        int256 vLimit;\r\n        int256 vDampener;\r\n        int256 t1; // normal int, not WAD\r\n        int256 t2; // normal int, not WAD\r\n        int256 t3; // normal int, not WAD\r\n        int256 t4; // normal int, not WAD\r\n    }\r\n\r\n    function getAccumulatedFunding(\r\n        int256 n, // time span. normal int, not WAD\r\n        int256 v0, // lastEMAPremium\r\n        int256 _lastPremium,\r\n        int256 _lastIndexPrice\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            int256 vt, // new LastEMAPremium\r\n            int256 acc\r\n        )\r\n    {\r\n        require(n > 0, \"we can't go back in time\");\r\n        AccumulatedFundingCalculator memory ctx;\r\n        vt = v0.sub(_lastPremium);\r\n        vt = vt.wmul(emaAlpha2.wpowi(n));\r\n        vt = vt.add(_lastPremium);\r\n        ctx.vLimit = governance.markPremiumLimit.wmul(_lastIndexPrice);\r\n        ctx.vDampener = governance.fundingDampener.wmul(_lastIndexPrice);\r\n        if (v0 <= -ctx.vLimit) {\r\n            // part A\r\n            if (vt <= -ctx.vLimit) {\r\n                acc = (-ctx.vLimit).add(ctx.vDampener).mul(n);\r\n            } else if (vt <= -ctx.vDampener) {\r\n                ctx.t1 = timeOnFundingCurve(-ctx.vLimit, v0, _lastPremium);\r\n                acc = (-ctx.vLimit).mul(ctx.t1);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t1, n, v0, _lastPremium));\r\n                acc = acc.add(ctx.vDampener.mul(n));\r\n            } else if (vt <= ctx.vDampener) {\r\n                ctx.t1 = timeOnFundingCurve(-ctx.vLimit, v0, _lastPremium);\r\n                ctx.t2 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                acc = (-ctx.vLimit).mul(ctx.t1);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t1, ctx.t2, v0, _lastPremium));\r\n                acc = acc.add(ctx.vDampener.mul(ctx.t2));\r\n            } else if (vt <= ctx.vLimit) {\r\n                ctx.t1 = timeOnFundingCurve(-ctx.vLimit, v0, _lastPremium);\r\n                ctx.t2 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                ctx.t3 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                acc = (-ctx.vLimit).mul(ctx.t1);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t1, ctx.t2, v0, _lastPremium));\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t3, n, v0, _lastPremium));\r\n                acc = acc.add(ctx.vDampener.mul(ctx.t2.sub(n).add(ctx.t3)));\r\n            } else {\r\n                ctx.t1 = timeOnFundingCurve(-ctx.vLimit, v0, _lastPremium);\r\n                ctx.t2 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                ctx.t3 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                ctx.t4 = timeOnFundingCurve(ctx.vLimit, v0, _lastPremium);\r\n                acc = (-ctx.vLimit).mul(ctx.t1);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t1, ctx.t2, v0, _lastPremium));\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t3, ctx.t4, v0, _lastPremium));\r\n                acc = acc.add(ctx.vLimit.mul(n.sub(ctx.t4)));\r\n                acc = acc.add(ctx.vDampener.mul(ctx.t2.sub(n).add(ctx.t3)));\r\n            }\r\n        } else if (v0 <= -ctx.vDampener) {\r\n            // part B\r\n            if (vt <= -ctx.vLimit) {\r\n                ctx.t4 = timeOnFundingCurve(-ctx.vLimit, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(0, ctx.t4, v0, _lastPremium);\r\n                acc = acc.add((-ctx.vLimit).mul(n.sub(ctx.t4)));\r\n                acc = acc.add(ctx.vDampener.mul(n));\r\n            } else if (vt <= -ctx.vDampener) {\r\n                acc = integrateOnFundingCurve(0, n, v0, _lastPremium);\r\n                acc = acc.add(ctx.vDampener.mul(n));\r\n            } else if (vt <= ctx.vDampener) {\r\n                ctx.t2 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(0, ctx.t2, v0, _lastPremium);\r\n                acc = acc.add(ctx.vDampener.mul(ctx.t2));\r\n            } else if (vt <= ctx.vLimit) {\r\n                ctx.t2 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                ctx.t3 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(0, ctx.t2, v0, _lastPremium);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t3, n, v0, _lastPremium));\r\n                acc = acc.add(ctx.vDampener.mul(ctx.t2.sub(n).add(ctx.t3)));\r\n            } else {\r\n                ctx.t2 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                ctx.t3 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                ctx.t4 = timeOnFundingCurve(ctx.vLimit, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(0, ctx.t2, v0, _lastPremium);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t3, ctx.t4, v0, _lastPremium));\r\n                acc = acc.add(ctx.vLimit.mul(n.sub(ctx.t4)));\r\n                acc = acc.add(ctx.vDampener.mul(ctx.t2.sub(n).add(ctx.t3)));\r\n            }\r\n        } else if (v0 <= ctx.vDampener) {\r\n            // part C\r\n            if (vt <= -ctx.vLimit) {\r\n                ctx.t3 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                ctx.t4 = timeOnFundingCurve(-ctx.vLimit, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(ctx.t3, ctx.t4, v0, _lastPremium);\r\n                acc = acc.add((-ctx.vLimit).mul(n.sub(ctx.t4)));\r\n                acc = acc.add(ctx.vDampener.mul(n.sub(ctx.t3)));\r\n            } else if (vt <= -ctx.vDampener) {\r\n                ctx.t3 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(ctx.t3, n, v0, _lastPremium);\r\n                acc = acc.add(ctx.vDampener.mul(n.sub(ctx.t3)));\r\n            } else if (vt <= ctx.vDampener) {\r\n                acc = 0;\r\n            } else if (vt <= ctx.vLimit) {\r\n                ctx.t3 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(ctx.t3, n, v0, _lastPremium);\r\n                acc = acc.sub(ctx.vDampener.mul(n.sub(ctx.t3)));\r\n            } else {\r\n                ctx.t3 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                ctx.t4 = timeOnFundingCurve(ctx.vLimit, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(ctx.t3, ctx.t4, v0, _lastPremium);\r\n                acc = acc.add(ctx.vLimit.mul(n.sub(ctx.t4)));\r\n                acc = acc.sub(ctx.vDampener.mul(n.sub(ctx.t3)));\r\n            }\r\n        } else if (v0 <= ctx.vLimit) {\r\n            // part D\r\n            if (vt <= -ctx.vLimit) {\r\n                ctx.t2 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                ctx.t3 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                ctx.t4 = timeOnFundingCurve(-ctx.vLimit, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(0, ctx.t2, v0, _lastPremium);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t3, ctx.t4, v0, _lastPremium));\r\n                acc = acc.add((-ctx.vLimit).mul(n.sub(ctx.t4)));\r\n                acc = acc.add(ctx.vDampener.mul(n.sub(ctx.t3).sub(ctx.t2)));\r\n            } else if (vt <= -ctx.vDampener) {\r\n                ctx.t2 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                ctx.t3 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(0, ctx.t2, v0, _lastPremium);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t3, n, v0, _lastPremium));\r\n                acc = acc.add(ctx.vDampener.mul(n.sub(ctx.t3).sub(ctx.t2)));\r\n            } else if (vt <= ctx.vDampener) {\r\n                ctx.t2 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(0, ctx.t2, v0, _lastPremium);\r\n                acc = acc.sub(ctx.vDampener.mul(ctx.t2));\r\n            } else if (vt <= ctx.vLimit) {\r\n                acc = integrateOnFundingCurve(0, n, v0, _lastPremium);\r\n                acc = acc.sub(ctx.vDampener.mul(n));\r\n            } else {\r\n                ctx.t4 = timeOnFundingCurve(ctx.vLimit, v0, _lastPremium);\r\n                acc = integrateOnFundingCurve(0, ctx.t4, v0, _lastPremium);\r\n                acc = acc.add(ctx.vLimit.mul(n.sub(ctx.t4)));\r\n                acc = acc.sub(ctx.vDampener.mul(n));\r\n            }\r\n        } else {\r\n            // part E\r\n            if (vt <= -ctx.vLimit) {\r\n                ctx.t1 = timeOnFundingCurve(ctx.vLimit, v0, _lastPremium);\r\n                ctx.t2 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                ctx.t3 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                ctx.t4 = timeOnFundingCurve(-ctx.vLimit, v0, _lastPremium);\r\n                acc = ctx.vLimit.mul(ctx.t1);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t1, ctx.t2, v0, _lastPremium));\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t3, ctx.t4, v0, _lastPremium));\r\n                acc = acc.add((-ctx.vLimit).mul(n.sub(ctx.t4)));\r\n                acc = acc.add(ctx.vDampener.mul(n.sub(ctx.t3).sub(ctx.t2)));\r\n            } else if (vt <= -ctx.vDampener) {\r\n                ctx.t1 = timeOnFundingCurve(ctx.vLimit, v0, _lastPremium);\r\n                ctx.t2 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                ctx.t3 = timeOnFundingCurve(-ctx.vDampener, v0, _lastPremium);\r\n                acc = ctx.vLimit.mul(ctx.t1);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t1, ctx.t2, v0, _lastPremium));\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t3, n, v0, _lastPremium));\r\n                acc = acc.add(ctx.vDampener.mul(n.sub(ctx.t3).sub(ctx.t2)));\r\n            } else if (vt <= ctx.vDampener) {\r\n                ctx.t1 = timeOnFundingCurve(ctx.vLimit, v0, _lastPremium);\r\n                ctx.t2 = timeOnFundingCurve(ctx.vDampener, v0, _lastPremium);\r\n                acc = ctx.vLimit.mul(ctx.t1);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t1, ctx.t2, v0, _lastPremium));\r\n                acc = acc.add(ctx.vDampener.mul(-ctx.t2));\r\n            } else if (vt <= ctx.vLimit) {\r\n                ctx.t1 = timeOnFundingCurve(ctx.vLimit, v0, _lastPremium);\r\n                acc = ctx.vLimit.mul(ctx.t1);\r\n                acc = acc.add(integrateOnFundingCurve(ctx.t1, n, v0, _lastPremium));\r\n                acc = acc.sub(ctx.vDampener.mul(n));\r\n            } else {\r\n                acc = ctx.vLimit.sub(ctx.vDampener).mul(n);\r\n            }\r\n        }\r\n    } // getAccumulatedFunding\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositAndAddLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastFundingState\",\"outputs\":[{\"components\":[{\"name\":\"lastFundingTime\",\"type\":\"uint256\"},{\"name\":\"lastPremium\",\"type\":\"int256\"},{\"name\":\"lastEMAPremium\",\"type\":\"int256\"},{\"name\":\"lastIndexPrice\",\"type\":\"uint256\"},{\"name\":\"accumulatedFundingPerContract\",\"type\":\"int256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"indexPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceFeeder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGovernance\",\"outputs\":[{\"components\":[{\"name\":\"poolFeeRate\",\"type\":\"uint256\"},{\"name\":\"poolDevFeeRate\",\"type\":\"uint256\"},{\"name\":\"emaAlpha\",\"type\":\"int256\"},{\"name\":\"updatePremiumPrize\",\"type\":\"uint256\"},{\"name\":\"markPremiumLimit\",\"type\":\"int256\"},{\"name\":\"fundingDampener\",\"type\":\"int256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"currentAvailableMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"currentFundingRate\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emaAlpha2\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"perpetualProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastFundingRate\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"currentPremiumRate\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"sellFromWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emaAlpha2Ln\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"currentPremium\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"positionSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"currentAccumulatedFundingPerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"shareAmount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"buyFromWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"buyAndWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"setGovernanceParameter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"currentFairPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"depositEtherAndSell\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"sellAndWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"depositAndBuy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"depositEtherAndBuy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositEtherAndAddLiquidity\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"funding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"currentMarkPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"depositAndSell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"currentFundingState\",\"outputs\":[{\"components\":[{\"name\":\"lastFundingTime\",\"type\":\"uint256\"},{\"name\":\"lastPremium\",\"type\":\"int256\"},{\"name\":\"lastEMAPremium\",\"type\":\"int256\"},{\"name\":\"lastIndexPrice\",\"type\":\"uint256\"},{\"name\":\"accumulatedFundingPerContract\",\"type\":\"int256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_perpetualProxy\",\"type\":\"address\"},{\"name\":\"_priceFeeder\",\"type\":\"address\"},{\"name\":\"_shareToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CreateAMM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"name\":\"lastFundingTime\",\"type\":\"uint256\"},{\"name\":\"lastPremium\",\"type\":\"int256\"},{\"name\":\"lastEMAPremium\",\"type\":\"int256\"},{\"name\":\"lastIndexPrice\",\"type\":\"uint256\"},{\"name\":\"accumulatedFundingPerContract\",\"type\":\"int256\"}],\"indexed\":false,\"name\":\"fundingState\",\"type\":\"tuple\"}],\"name\":\"UpdateFundingRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"UpdateGovernanceParameter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"}]","ContractName":"AMM","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"000000000000000000000000da9f6fb1ef188e081cfbea74ec820a3718e91f21000000000000000000000000133906776302d10a2005ec2ed0c92ab6f2cbd9030000000000000000000000006d5b330523017e2d4ec36ff973a49a440ab763ef","Library":"","LicenseType":"None","SwarmSource":"bzzr://8d006add17b0797e789e02d79c90ebfa78b31d434a6ed39bbd56741832a49518"}]}