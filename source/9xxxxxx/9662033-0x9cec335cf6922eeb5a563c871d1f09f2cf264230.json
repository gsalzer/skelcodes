{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.1;\r\n\r\ncontract NIOXToken {\r\n    uint256 public peopleCount = 0;\r\n    \r\n    mapping(address => Person ) public people;\r\n    \r\n    uint256 constant stage11 = 1584016200; // ---- Thursday, March 12, 2020 6:00:00 PM GMT+05:30\r\n    uint256 constant stage12 = 1591964999; // ---- Friday, June 12, 2020 5:59:59 PM GMT+05:30\r\n    uint256 constant stage21 = 1591965000; // ---- Friday, June 12, 2020 6:00:00 PM GMT+05:30\r\n    uint256 constant stage22 = 1597235399; // ---- Wednesday, August 12, 2020 5:59:59 PM GMT+05:30\r\n    uint256 constant stage31 = 1597235400; // ---- Wednesday, August 12, 2020 6:00:00 PM GMT+05:30\r\n    uint256 constant stage32 = 1599913799; // ---- Saturday, September 12, 2020 5:59:59 PM GMT+05:30\r\n    \r\n   uint256 constant oneyear = 31556926; // 31556926 secs = 1 YEAR\r\n    \r\n    \r\n    uint256 constant sixmonth = 15778458; // 6 month\r\n\r\n    \r\n    uint256 constant addAddressLastDate = 1588163399;// Wednesday, April 29, 2020 5:59:59 PM GMT+05:30\r\n    \r\n   uint256 constant minStakeAmt = 3000000000;\r\n\r\n    \r\n    // Status of user's address that he has withdrew NIOX or staked or haven't decided yet\r\n    enum userState {Withdraw, Staked, NotDecided}\r\n    \r\n    // Status of user's address after claiming their tokens\r\n    enum withdrawState {NotWithdraw, PartiallyWithdraw, FullyWithdraw}\r\n    \r\n    //users remaining claimed tokens\r\n    enum remainToken {stage0, stage1, stage2, stage3, stage4}\r\n    \r\n    // Token name\r\n    string public constant name = \"Autonio\";\r\n\r\n    // Token symbol\r\n    string public constant symbol = \"NIOX\";\r\n\r\n\t// Token decimals\r\n    uint8 public constant decimals = 4;\r\n    \r\n    // Contract owner will be your Link account\r\n    address public owner;\r\n\r\n    address public treasury;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    mapping (address => uint256) private balances;\r\n\r\n    event Approval(address indexed tokenholder, address indexed spender, uint256 value);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event AddedNewUser(address indexed, uint _value);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }   \r\n\r\n    modifier checkUser() {\r\n        require(msg.sender == people[msg.sender]._address);\r\n        _;\r\n    }\r\n\r\n    struct Person {\r\n        uint _id;\r\n        address _address;\r\n        uint256 _value;\r\n        uint256 _txHashAddress;\r\n        userState _userState;\r\n        withdrawState _withdrawState;\r\n        remainToken _remainToken;\r\n        uint256 _blocktimestamp;\r\n        uint256 _userStateBlocktimestamp;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n\r\n        // Add your wallet address here which will contain your total token supply\r\n        treasury = owner;\r\n\r\n        // Set your total token supply (default 1000)\r\n        totalSupply = 3000000000000;\r\n\r\n        balances[treasury] = totalSupply;\r\n        emit Transfer(address(0), treasury, totalSupply);\r\n    }\r\n\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    function allowance(address _tokenholder, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_tokenholder][_spender];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(_spender != address(0));\r\n        require(_spender != msg.sender);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _tokenholder) public view returns (uint256 balance) {\r\n        return balances[_tokenholder];\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\r\n        require(_spender != address(0));\r\n        require(_spender != msg.sender);\r\n\r\n        if (allowed[msg.sender][_spender] <= _subtractedValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = allowed[msg.sender][_spender] - _subtractedValue;\r\n        }\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\r\n        require(_spender != address(0));\r\n        require(_spender != msg.sender);\r\n        require(allowed[msg.sender][_spender] <= allowed[msg.sender][_spender] + _addedValue);\r\n\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != msg.sender);\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(balances[msg.sender] - _value <= balances[msg.sender]);\r\n        require(balances[_to] <= balances[_to] + _value);\r\n        require(_value <= transferableTokens(msg.sender));\r\n\r\n        balances[msg.sender] = balances[msg.sender] - _value;\r\n        balances[_to] = balances[_to] + _value;\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_from != address(0));\r\n        require(_from != address(this));\r\n        require(_to != _from);\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_value <= transferableTokens(_from));\r\n        require(allowed[_from][msg.sender] - _value <= allowed[_from][msg.sender]);\r\n        require(balances[_from] - _value <= balances[_from]);\r\n        require(balances[_to] <= balances[_to] + _value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\r\n        balances[_from] = balances[_from] - _value;\r\n        balances[_to] = balances[_to] + _value;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public {\r\n        require(msg.sender == owner);\r\n        require(_newOwner != address(0));\r\n        require(_newOwner != address(this));\r\n        require(_newOwner != owner);\r\n\r\n        address previousOwner = owner;\r\n        owner = _newOwner;\r\n\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function transferableTokens(address holder) public view returns (uint256) {\r\n        return balanceOf(holder);\r\n    }\r\n    \r\n    function addAddress(address _useraddress, uint256 _value, uint256 _txHashAddress, userState _userState, withdrawState _withdrawState, remainToken _remainToken) public onlyOwner {\r\n        \r\n        require(people[_useraddress]._address != _useraddress);\r\n        require(block.timestamp <= addAddressLastDate);\r\n        \r\n        incrementCount();\r\n        people[_useraddress] = Person(peopleCount, _useraddress, _value, _txHashAddress, _userState, _withdrawState, _remainToken, block.timestamp, 0);\r\n    }\r\n    \r\n    function incrementCount() internal {\r\n        peopleCount += 1;\r\n    }\r\n    \r\n    function getRemainTokenCount(address  _address) public view returns (uint256 tokens) {\r\n        \r\n        require(_address == people[_address]._address);\r\n        \r\n        if(people[_address]._remainToken == remainToken.stage0) {\r\n            \r\n            return people[_address]._value;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage1) {\r\n            \r\n            return people[_address]._value / 100 * 50;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage2) {\r\n            \r\n            return people[_address]._value / 100 * 30;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage3) {\r\n            \r\n            return people[_address]._value / 100 * 20;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage4) {\r\n            \r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    function getWithdrawTokenCount(address  _address) public view returns (uint256 tokens) {\r\n        \r\n        require(_address == people[_address]._address);\r\n        \r\n        if(people[_address]._remainToken == remainToken.stage0) {\r\n            \r\n            return 0;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage1) {\r\n            \r\n            return people[_address]._value / 100 * 50;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage2) {\r\n            \r\n            return people[_address]._value / 100 * 70;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage3) {\r\n            \r\n            return people[_address]._value / 100 * 80;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage4) {\r\n            \r\n            return people[_address]._value;\r\n        }\r\n    }\r\n    \r\n    function getUserState(address _address) public view returns (userState){\r\n        \r\n        require(_address == people[_address]._address);\r\n        \r\n        return people[_address]._userState;\r\n    }\r\n    \r\n    function withdrawOrStake(userState _userStates) public returns (bool) {\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.NotDecided);\r\n        require(people[msg.sender]._userStateBlocktimestamp == 0);\r\n        \r\n        if(people[msg.sender]._userState == userState.NotDecided && _userStates == userState.Withdraw){\r\n            people[msg.sender]._userState = userState.Withdraw;\r\n            people[msg.sender]._userStateBlocktimestamp = block.timestamp;\r\n            return true;\r\n        }\r\n        else if(people[msg.sender]._userState == userState.NotDecided && _userStates == userState.Staked && people[msg.sender]._value >= minStakeAmt ){\r\n            people[msg.sender]._userState = userState.Staked;\r\n            people[msg.sender]._userStateBlocktimestamp = block.timestamp;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n        \r\n    }\r\n    \r\n    function changeStakeToWithdraw() public checkUser returns (bool) {\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.Staked);\r\n        require(people[msg.sender]._userStateBlocktimestamp != 0);\r\n        require(block.timestamp >= (people[msg.sender]._userStateBlocktimestamp + sixmonth));\r\n        \r\n        if(people[msg.sender]._userState == userState.Staked){\r\n            people[msg.sender]._userState = userState.Withdraw;\r\n            // people[msg.sender]._blocktimestamp = block.timestamp;\r\n            return true;\r\n        }\r\n        \r\n    }\r\n    \r\n    function withdrawToken() public checkUser returns (bool){\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.Withdraw);\r\n        require(people[msg.sender]._userStateBlocktimestamp != 0);\r\n        require(people[msg.sender]._withdrawState == withdrawState.NotWithdraw);\r\n        require(people[msg.sender]._remainToken == remainToken.stage0);\r\n        \r\n        if (block.timestamp >= stage11 && block.timestamp <= stage12 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 50; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage1;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > stage21 && block.timestamp <= stage22 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 70; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage2;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > stage31 && block.timestamp <= stage32 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 80; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage3;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > stage32){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function withdrawRemainPenaltyToken() public checkUser returns (bool){\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.Withdraw);\r\n        require(people[msg.sender]._withdrawState == withdrawState.PartiallyWithdraw);\r\n        require(block.timestamp >= people[msg.sender]._blocktimestamp + oneyear);\r\n        \r\n        if (people[msg.sender]._remainToken == remainToken.stage1){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 50; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            \r\n            return true;\r\n        }\r\n        else if (people[msg.sender]._remainToken == remainToken.stage2){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 30; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            \r\n            return true;\r\n        }\r\n        else if (people[msg.sender]._remainToken == remainToken.stage3){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 20; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            \r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function remainPenaltyClaimDate(address  _address) public view returns (uint256 date) {\r\n        \r\n         require(_address == people[_address]._address);\r\n         require(people[_address]._withdrawState == withdrawState.PartiallyWithdraw);\r\n         require(people[_address]._userState == userState.Withdraw);\r\n         \r\n         return people[_address]._blocktimestamp + oneyear;\r\n        \r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"people\",\"outputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_txHashAddress\",\"type\":\"uint256\"},{\"name\":\"_userState\",\"type\":\"uint8\"},{\"name\":\"_withdrawState\",\"type\":\"uint8\"},{\"name\":\"_remainToken\",\"type\":\"uint8\"},{\"name\":\"_blocktimestamp\",\"type\":\"uint256\"},{\"name\":\"_userStateBlocktimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peopleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userStates\",\"type\":\"uint8\"}],\"name\":\"withdrawOrStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainPenaltyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getWithdrawTokenCount\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeStakeToWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenholder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"transferableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRemainTokenCount\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"remainPenaltyClaimDate\",\"outputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_useraddress\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_txHashAddress\",\"type\":\"uint256\"},{\"name\":\"_userState\",\"type\":\"uint8\"},{\"name\":\"_withdrawState\",\"type\":\"uint8\"},{\"name\":\"_remainToken\",\"type\":\"uint8\"}],\"name\":\"addAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenholder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenholder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"AddedNewUser\",\"type\":\"event\"}]","ContractName":"NIOXToken","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://5d3bd789741e2b038f42f9b4fc20fd7a5a4dd62e17d7c96a8fc6e0bc4471180f"}]}