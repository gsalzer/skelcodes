{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n\r\n  Source code of Opium Protocol\r\n  Web https://opium.network\r\n  Telegram https://t.me/opium_network\r\n  Twitter https://twitter.com/opium_network\r\n\r\n */\r\n\r\n// File: LICENSE\r\n\r\n/**\r\n\r\nThe software and documentation available in this repository (the \"Software\") is protected by copyright law and accessible pursuant to the license set forth below. Copyright © 2020 Blockeys BV. All rights reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person or organization obtaining the Software (the “Licensee”) to privately study, review, and analyze the Software. Licensee shall not use the Software for any other purpose. Licensee shall not modify, transfer, assign, share, or sub-license the Software or any derivative works of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: contracts/Lib/LibDerivative.sol\r\n\r\npragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @title Opium.Lib.LibDerivative contract should be inherited by contracts that use Derivative structure and calculate derivativeHash\r\ncontract LibDerivative {\r\n    // Opium derivative structure (ticker) definition\r\n    struct Derivative {\r\n        // Margin parameter for syntheticId\r\n        uint256 margin;\r\n        // Maturity of derivative\r\n        uint256 endTime;\r\n        // Additional parameters for syntheticId\r\n        uint256[] params;\r\n        // oracleId of derivative\r\n        address oracleId;\r\n        // Margin token address of derivative\r\n        address token;\r\n        // syntheticId of derivative\r\n        address syntheticId;\r\n    }\r\n\r\n    /// @notice Calculates hash of provided Derivative\r\n    /// @param _derivative Derivative Instance of derivative to hash\r\n    /// @return derivativeHash bytes32 Derivative hash\r\n    function getDerivativeHash(Derivative memory _derivative) public pure returns (bytes32 derivativeHash) {\r\n        derivativeHash = keccak256(abi.encodePacked(\r\n            _derivative.margin,\r\n            _derivative.endTime,\r\n            _derivative.params,\r\n            _derivative.oracleId,\r\n            _derivative.token,\r\n            _derivative.syntheticId\r\n        ));\r\n    }\r\n}\r\n\r\n// File: contracts/Lib/LibCommission.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title Opium.Lib.LibCommission contract defines constants for Opium commissions\r\ncontract LibCommission {\r\n    // Represents 100% base for commissions calculation\r\n    uint256 constant public COMMISSION_BASE = 10000;\r\n\r\n    // Represents 100% base for Opium commission\r\n    uint256 constant public OPIUM_COMMISSION_BASE = 10;\r\n\r\n    // Represents which part of `syntheticId` author commissions goes to opium\r\n    uint256 constant public OPIUM_COMMISSION_PART = 1;\r\n}\r\n\r\n// File: contracts/Errors/SyntheticAggregatorErrors.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract SyntheticAggregatorErrors {\r\n    string constant internal ERROR_SYNTHETIC_AGGREGATOR_DERIVATIVE_HASH_NOT_MATCH = \"SYNTHETIC_AGGREGATOR:DERIVATIVE_HASH_NOT_MATCH\";\r\n    string constant internal ERROR_SYNTHETIC_AGGREGATOR_WRONG_MARGIN = \"SYNTHETIC_AGGREGATOR:WRONG_MARGIN\";\r\n    string constant internal ERROR_SYNTHETIC_AGGREGATOR_COMMISSION_TOO_BIG = \"SYNTHETIC_AGGREGATOR:COMMISSION_TOO_BIG\";\r\n}\r\n\r\n// File: contracts/Interface/IOracleId.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title Opium.Interface.IOracleId contract is an interface that every oracleId should implement\r\ninterface IOracleId {\r\n    /// @notice Requests data from `oracleId` one time\r\n    /// @param timestamp uint256 Timestamp at which data are needed\r\n    function fetchData(uint256 timestamp) external payable;\r\n\r\n    /// @notice Requests data from `oracleId` multiple times\r\n    /// @param timestamp uint256 Timestamp at which data are needed for the first time\r\n    /// @param period uint256 Period in seconds between multiple timestamps\r\n    /// @param times uint256 How many timestamps are requested\r\n    function recursivelyFetchData(uint256 timestamp, uint256 period, uint256 times) external payable;\r\n\r\n    /// @notice Requests and returns price in ETH for one request. This function could be called as `view` function. Oraclize API for price calculations restricts making this function as view.\r\n    /// @return fetchPrice uint256 Price of one data request in ETH\r\n    function calculateFetchPrice() external returns (uint256 fetchPrice);\r\n\r\n    // Event with oracleId metadata JSON string (for DIB.ONE derivative explorer)\r\n    event MetadataSet(string metadata);\r\n}\r\n\r\n// File: contracts/Interface/IDerivativeLogic.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title Opium.Interface.IDerivativeLogic contract is an interface that every syntheticId should implement\r\ncontract IDerivativeLogic is LibDerivative {\r\n    /// @notice Validates ticker\r\n    /// @param _derivative Derivative Instance of derivative to validate\r\n    /// @return Returns boolean whether ticker is valid\r\n    function validateInput(Derivative memory _derivative) public view returns (bool);\r\n\r\n    /// @notice Calculates margin required for derivative creation\r\n    /// @param _derivative Derivative Instance of derivative\r\n    /// @return buyerMargin uint256 Margin needed from buyer (LONG position)\r\n    /// @return sellerMargin uint256 Margin needed from seller (SHORT position)\r\n    function getMargin(Derivative memory _derivative) public view returns (uint256 buyerMargin, uint256 sellerMargin);\r\n\r\n    /// @notice Calculates payout for derivative execution\r\n    /// @param _derivative Derivative Instance of derivative\r\n    /// @param _result uint256 Data retrieved from oracleId on the maturity\r\n    /// @return buyerPayout uint256 Payout in ratio for buyer (LONG position holder)\r\n    /// @return sellerPayout uint256 Payout in ratio for seller (SHORT position holder)\r\n    function getExecutionPayout(Derivative memory _derivative, uint256 _result)\tpublic view returns (uint256 buyerPayout, uint256 sellerPayout);\r\n\r\n    /// @notice Returns syntheticId author address for Opium commissions\r\n    /// @return authorAddress address The address of syntheticId address\r\n    function getAuthorAddress() public view returns (address authorAddress);\r\n\r\n    /// @notice Returns syntheticId author commission in base of COMMISSION_BASE\r\n    /// @return commission uint256 Author commission\r\n    function getAuthorCommission() public view returns (uint256 commission);\r\n\r\n    /// @notice Returns whether thirdparty could execute on derivative's owner's behalf\r\n    /// @param _derivativeOwner address Derivative owner address\r\n    /// @return Returns boolean whether _derivativeOwner allowed third party execution\r\n    function thirdpartyExecutionAllowed(address _derivativeOwner) public view returns (bool);\r\n\r\n    /// @notice Returns whether syntheticId implements pool logic\r\n    /// @return Returns whether syntheticId implements pool logic\r\n    function isPool() public view returns (bool);\r\n\r\n    /// @notice Sets whether thirds parties are allowed or not to execute derivative's on msg.sender's behalf\r\n    /// @param _allow bool Flag for execution allowance\r\n    function allowThirdpartyExecution(bool _allow) public;\r\n\r\n    // Event with syntheticId metadata JSON string (for DIB.ONE derivative explorer)\r\n    event MetadataSet(string metadata);\r\n}\r\n\r\n// File: contracts/SyntheticAggregator.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @notice Opium.SyntheticAggregator contract initialized, identifies and caches syntheticId sensitive data\r\ncontract SyntheticAggregator is SyntheticAggregatorErrors, LibDerivative, LibCommission, ReentrancyGuard {\r\n    // Emitted when new ticker is initialized\r\n    event Create(Derivative derivative, bytes32 derivativeHash);\r\n\r\n    // Enum for types of syntheticId\r\n    // Invalid - syntheticId is not initialized yet\r\n    // NotPool - syntheticId with p2p logic\r\n    // Pool - syntheticId with pooled logic\r\n    enum SyntheticTypes { Invalid, NotPool, Pool }\r\n\r\n    // Cache of buyer margin by ticker\r\n    // buyerMarginByHash[derivativeHash] = buyerMargin\r\n    mapping (bytes32 => uint256) public buyerMarginByHash;\r\n\r\n    // Cache of seller margin by ticker\r\n    // sellerMarginByHash[derivativeHash] = sellerMargin\r\n    mapping (bytes32 => uint256) public sellerMarginByHash;\r\n\r\n    // Cache of type by ticker\r\n    // typeByHash[derivativeHash] = type\r\n    mapping (bytes32 => SyntheticTypes) public typeByHash;\r\n\r\n    // Cache of commission by ticker\r\n    // commissionByHash[derivativeHash] = commission\r\n    mapping (bytes32 => uint256) public commissionByHash;\r\n\r\n    // Cache of author addresses by ticker\r\n    // authorAddressByHash[derivativeHash] = authorAddress\r\n    mapping (bytes32 => address) public authorAddressByHash;\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @notice Initializes ticker, if was not initialized and returns `syntheticId` author commission from cache\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return commission uint256 Synthetic author commission\r\n    function getAuthorCommission(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 commission) {\r\n        // Initialize derivative if wasn't initialized before\r\n        _initDerivative(_derivativeHash, _derivative);\r\n        commission = commissionByHash[_derivativeHash];\r\n    }\r\n\r\n    /// @notice Initializes ticker, if was not initialized and returns `syntheticId` author address from cache\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return authorAddress address Synthetic author address\r\n    function getAuthorAddress(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (address authorAddress) {\r\n        // Initialize derivative if wasn't initialized before\r\n        _initDerivative(_derivativeHash, _derivative);\r\n        authorAddress = authorAddressByHash[_derivativeHash];\r\n    }\r\n\r\n    /// @notice Initializes ticker, if was not initialized and returns buyer and seller margin from cache\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return buyerMargin uint256 Margin of buyer\r\n    /// @return sellerMargin uint256 Margin of seller\r\n    function getMargin(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 buyerMargin, uint256 sellerMargin) {\r\n        // If it's a pool, just return margin from syntheticId contract\r\n        if (_isPool(_derivativeHash, _derivative)) {\r\n            return IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative);\r\n        }\r\n\r\n        // Initialize derivative if wasn't initialized before\r\n        _initDerivative(_derivativeHash, _derivative);\r\n\r\n        // Check if margins for _derivativeHash were already cached\r\n        buyerMargin = buyerMarginByHash[_derivativeHash];\r\n        sellerMargin = sellerMarginByHash[_derivativeHash];\r\n    }\r\n\r\n    /// @notice Checks whether `syntheticId` implements pooled logic\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return result bool Returns whether synthetic implements pooled logic\r\n    function isPool(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (bool result) {\r\n        result = _isPool(_derivativeHash, _derivative);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @notice Initializes ticker, if was not initialized and returns whether `syntheticId` implements pooled logic\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    /// @return result bool Returns whether synthetic implements pooled logic\r\n    function _isPool(bytes32 _derivativeHash, Derivative memory _derivative) private returns (bool result) {\r\n        // Initialize derivative if wasn't initialized before\r\n        _initDerivative(_derivativeHash, _derivative);\r\n        result = typeByHash[_derivativeHash] == SyntheticTypes.Pool;\r\n    }\r\n\r\n    /// @notice Initializes ticker: caches syntheticId type, margin, author address and commission\r\n    /// @param _derivativeHash bytes32 Hash of derivative\r\n    /// @param _derivative Derivative Derivative itself\r\n    function _initDerivative(bytes32 _derivativeHash, Derivative memory _derivative) private {\r\n        // Check if type for _derivativeHash was already cached\r\n        SyntheticTypes syntheticType = typeByHash[_derivativeHash];\r\n\r\n        // Type could not be Invalid, thus this condition says us that type was not cached before\r\n        if (syntheticType != SyntheticTypes.Invalid) {\r\n            return;\r\n        }\r\n\r\n        // For security reasons we calculate hash of provided _derivative\r\n        bytes32 derivativeHash = getDerivativeHash(_derivative);\r\n        require(derivativeHash == _derivativeHash, ERROR_SYNTHETIC_AGGREGATOR_DERIVATIVE_HASH_NOT_MATCH);\r\n\r\n        // POOL\r\n        // Get isPool from SyntheticId\r\n        bool result = IDerivativeLogic(_derivative.syntheticId).isPool();\r\n        // Cache type returned from synthetic\r\n        typeByHash[derivativeHash] = result ? SyntheticTypes.Pool : SyntheticTypes.NotPool;\r\n\r\n        // MARGIN\r\n        // Get margin from SyntheticId\r\n        (uint256 buyerMargin, uint256 sellerMargin) = IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative);\r\n        // We are not allowing both margins to be equal to 0\r\n        require(buyerMargin != 0 || sellerMargin != 0, ERROR_SYNTHETIC_AGGREGATOR_WRONG_MARGIN);\r\n        // Cache margins returned from synthetic\r\n        buyerMarginByHash[derivativeHash] = buyerMargin;\r\n        sellerMarginByHash[derivativeHash] = sellerMargin;\r\n\r\n        // AUTHOR ADDRESS\r\n        // Cache author address returned from synthetic\r\n        authorAddressByHash[derivativeHash] = IDerivativeLogic(_derivative.syntheticId).getAuthorAddress();\r\n\r\n        // AUTHOR COMMISSION\r\n        // Get commission from syntheticId\r\n        uint256 commission = IDerivativeLogic(_derivative.syntheticId).getAuthorCommission();\r\n        // Check if commission is not set > 100%\r\n        require(commission <= COMMISSION_BASE, ERROR_SYNTHETIC_AGGREGATOR_COMMISSION_TOO_BIG);\r\n        // Cache commission\r\n        commissionByHash[derivativeHash] = commission;\r\n\r\n        // If we are here, this basically means this ticker was not used before, so we emit an event for Dapps developers about new ticker (derivative) and it's hash\r\n        emit Create(_derivative, derivativeHash);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"derivative\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"derivativeHash\",\"type\":\"bytes32\"}],\"name\":\"Create\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSION_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPIUM_COMMISSION_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPIUM_COMMISSION_PART\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"authorAddressByHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"buyerMarginByHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commissionByHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_derivativeHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"getAuthorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"authorAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_derivativeHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"getAuthorCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"getDerivativeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"derivativeHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_derivativeHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"getMargin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyerMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerMargin\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_derivativeHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"isPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"sellerMarginByHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"typeByHash\",\"outputs\":[{\"internalType\":\"enum SyntheticAggregator.SyntheticTypes\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SyntheticAggregator","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://a025095cd0b5077493eee6ff2dfcce3064aa992d8f02c15d811f1df7178b8c48"}]}