{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\n\r\ncontract Context {\r\n    \r\n    \r\n    constructor () internal { }\r\n    \r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n        \r\n        \r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        \r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        \r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    \r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    \r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    \r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     \r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    \r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            \r\n            \r\n            tempBytes := mload(0x40)\r\n\r\n            \r\n            \r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            \r\n            \r\n            \r\n            let mc := add(tempBytes, 0x20)\r\n            \r\n            \r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                \r\n                \r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                \r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                \r\n                \r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            \r\n            \r\n            \r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            \r\n            \r\n            mc := end\r\n            \r\n            \r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            mstore(0x40, and(\r\n                add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                not(31) \r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            \r\n            \r\n            \r\n            let fslot := sload(_preBytes_slot)\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            \r\n            \r\n            \r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                \r\n                \r\n                \r\n                sstore(\r\n                    _preBytes_slot,\r\n                    \r\n                    \r\n                    add(\r\n                        \r\n                        \r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    \r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    \r\n                                    exp(0x100, sub(32, mlength))\r\n                        ),\r\n                        \r\n                        \r\n                        exp(0x100, sub(32, newlength))\r\n                        ),\r\n                        \r\n                        \r\n                        mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                \r\n                \r\n                \r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                \r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                    ),\r\n                    and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                \r\n                mstore(0x0, _preBytes_slot)\r\n                \r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                \r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                \r\n                \r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory) {\r\n        require(_bytes.length >= (_start + _length), \"Slice out of bounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                \r\n                \r\n                tempBytes := mload(0x40)\r\n\r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                let lengthmod := and(_length, 31)\r\n\r\n                \r\n                \r\n                \r\n                \r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    \r\n                    \r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                \r\n                \r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            \r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20), \"Address conversion out of bounds.\");\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32), \"Uint conversion out of bounds.\");\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            \r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                \r\n                \r\n                \r\n                \r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                    \r\n                    \r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    \r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        \r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                \r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            \r\n            let fslot := sload(_preBytes_slot)\r\n            \r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            \r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                \r\n                \r\n                \r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        \r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            \r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        \r\n                        \r\n                        \r\n                        \r\n                        let cb := 1\r\n\r\n                        \r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        \r\n                        \r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                \r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                \r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(_source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(_source, 32))\r\n        }\r\n    }\r\n}\r\n\r\nlibrary BTCUtils {\r\n    using BytesLib for bytes;\r\n    using SafeMath for uint256;\r\n\r\n    \r\n    uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\r\n\r\n    uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  \r\n    uint256 public constant RETARGET_PERIOD_BLOCKS = 2016;  \r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    function determineVarIntDataLength(bytes memory _flag) internal pure returns (uint8) {\r\n        if (uint8(_flag[0]) == 0xff) {\r\n            return 8;  \r\n        }\r\n        if (uint8(_flag[0]) == 0xfe) {\r\n            return 4;  \r\n        }\r\n        if (uint8(_flag[0]) == 0xfd) {\r\n            return 2;  \r\n        }\r\n\r\n        return 0;  \r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function reverseEndianness(bytes memory _b) internal pure returns (bytes memory) {\r\n        bytes memory _newValue = new bytes(_b.length);\r\n\r\n        for (uint i = 0; i < _b.length; i++) {\r\n            _newValue[_b.length - i - 1] = _b[i];\r\n        }\r\n\r\n        return _newValue;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function bytesToUint(bytes memory _b) internal pure returns (uint256) {\r\n        uint256 _number;\r\n\r\n        for (uint i = 0; i < _b.length; i++) {\r\n            _number = _number + uint8(_b[i]) * (2 ** (8 * (_b.length - (i + 1))));\r\n        }\r\n\r\n        return _number;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function lastBytes(bytes memory _b, uint256 _num) internal pure returns (bytes memory) {\r\n        uint256 _start = _b.length.sub(_num);\r\n\r\n        return _b.slice(_start, _num);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hash160(bytes memory _b) internal pure returns (bytes memory) {\r\n        return abi.encodePacked(ripemd160(abi.encodePacked(sha256(_b))));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hash256(bytes memory _b) internal pure returns (bytes32) {\r\n        return abi.encodePacked(sha256(abi.encodePacked(sha256(_b)))).toBytes32();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function extractInputAtIndex(bytes memory _vin, uint8 _index) internal pure returns (bytes memory) {\r\n        uint256 _len;\r\n        bytes memory _remaining;\r\n\r\n        uint256 _offset = 1;\r\n\r\n        for (uint8 _i = 0; _i < _index; _i ++) {\r\n            _remaining = _vin.slice(_offset, _vin.length - _offset);\r\n            _len = determineInputLength(_remaining);\r\n            _offset = _offset + _len;\r\n        }\r\n\r\n        _remaining = _vin.slice(_offset, _vin.length - _offset);\r\n        _len = determineInputLength(_remaining);\r\n        return _vin.slice(_offset, _len);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function isLegacyInput(bytes memory _input) internal pure returns (bool) {\r\n        return keccak256(_input.slice(36, 1)) != keccak256(hex\"00\");\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function determineInputLength(bytes memory _input) internal pure returns (uint256) {\r\n        uint8 _varIntDataLen;\r\n        uint256 _scriptSigLen;\r\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\r\n        return 36 + 1 + _varIntDataLen + _scriptSigLen + 4;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractSequenceLELegacy(bytes memory _input) internal pure returns (bytes memory) {\r\n        uint8 _varIntDataLen;\r\n        uint256 _scriptSigLen;\r\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\r\n        return _input.slice(36 + 1 + _varIntDataLen + _scriptSigLen, 4);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractSequenceLegacy(bytes memory _input) internal pure returns (uint32) {\r\n        bytes memory _leSeqence = extractSequenceLELegacy(_input);\r\n        bytes memory _beSequence = reverseEndianness(_leSeqence);\r\n        return uint32(bytesToUint(_beSequence));\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    function extractScriptSig(bytes memory _input) internal pure returns (bytes memory) {\r\n        uint8 _varIntDataLen;\r\n        uint256 _scriptSigLen;\r\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\r\n        return _input.slice(36, 1 + _varIntDataLen + _scriptSigLen);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractScriptSigLen(bytes memory _input) internal pure returns (uint8, uint256) {\r\n        bytes memory _varIntTag = _input.slice(36, 1);\r\n        uint8 _varIntDataLen = determineVarIntDataLength(_varIntTag);\r\n        uint256 _len;\r\n        if (_varIntDataLen == 0) {\r\n            _len = uint8(_varIntTag[0]);\r\n        } else {\r\n            _len = bytesToUint(reverseEndianness(_input.slice(36 + 1, _varIntDataLen)));\r\n        }\r\n        return (_varIntDataLen, _len);\r\n    }\r\n\r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractSequenceLEWitness(bytes memory _input) internal pure returns (bytes memory) {\r\n        return _input.slice(37, 4);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractSequenceWitness(bytes memory _input) internal pure returns (uint32) {\r\n        bytes memory _leSeqence = extractSequenceLEWitness(_input);\r\n        bytes memory _inputeSequence = reverseEndianness(_leSeqence);\r\n        return uint32(bytesToUint(_inputeSequence));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractOutpoint(bytes memory _input) internal pure returns (bytes memory) {\r\n        return _input.slice(0, 36);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractInputTxIdLE(bytes memory _input) internal pure returns (bytes32) {\r\n        return _input.slice(0, 32).toBytes32();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractInputTxId(bytes memory _input) internal pure returns (bytes32) {\r\n        bytes memory _leId = abi.encodePacked(extractInputTxIdLE(_input));\r\n        bytes memory _beId = reverseEndianness(_leId);\r\n        return _beId.toBytes32();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTxIndexLE(bytes memory _input) internal pure returns (bytes memory) {\r\n        return _input.slice(32, 4);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTxIndex(bytes memory _input) internal pure returns (uint32) {\r\n        bytes memory _leIndex = extractTxIndexLE(_input);\r\n        bytes memory _beIndex = reverseEndianness(_leIndex);\r\n        return uint32(bytesToUint(_beIndex));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    function determineOutputLength(bytes memory _output) internal pure returns (uint256) {\r\n        uint8 _len = uint8(_output.slice(8, 1)[0]);\r\n        require(_len < 0xfd, \"Multi-byte VarInts not supported\");\r\n\r\n        return _len + 8 + 1; \r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function extractOutputAtIndex(bytes memory _vout, uint8 _index) internal pure returns (bytes memory) {\r\n        uint256 _len;\r\n        bytes memory _remaining;\r\n\r\n        uint256 _offset = 1;\r\n\r\n        for (uint8 _i = 0; _i < _index; _i ++) {\r\n            _remaining = _vout.slice(_offset, _vout.length - _offset);\r\n            _len = determineOutputLength(_remaining);\r\n            _offset = _offset + _len;\r\n        }\r\n\r\n        _remaining = _vout.slice(_offset, _vout.length - _offset);\r\n        _len = determineOutputLength(_remaining);\r\n        return _vout.slice(_offset, _len);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractOutputScriptLen(bytes memory _output) internal pure returns (bytes memory) {\r\n        return _output.slice(8, 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractValueLE(bytes memory _output) internal pure returns (bytes memory) {\r\n        return _output.slice(0, 8);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractValue(bytes memory _output) internal pure returns (uint64) {\r\n        bytes memory _leValue = extractValueLE(_output);\r\n        bytes memory _beValue = reverseEndianness(_leValue);\r\n        return uint64(bytesToUint(_beValue));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractOpReturnData(bytes memory _output) internal pure returns (bytes memory) {\r\n        if (keccak256(_output.slice(9, 1)) != keccak256(hex\"6a\")) {\r\n            return hex\"\";\r\n        }\r\n        bytes memory _dataLen = _output.slice(10, 1);\r\n        return _output.slice(11, bytesToUint(_dataLen));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractHash(bytes memory _output) internal pure returns (bytes memory) {\r\n        if (uint8(_output.slice(9, 1)[0]) == 0) {\r\n            uint256 _len = uint8(extractOutputScriptLen(_output)[0]) - 2;\r\n            \r\n            if (uint8(_output.slice(10, 1)[0]) != uint8(_len)) {\r\n                return hex\"\";\r\n            }\r\n            return _output.slice(11, _len);\r\n        } else {\r\n            bytes32 _tag = keccak256(_output.slice(8, 3));\r\n            \r\n            if (_tag == keccak256(hex\"1976a9\")) {\r\n                \r\n                if (uint8(_output.slice(11, 1)[0]) != 0x14 ||\r\n                    keccak256(_output.slice(_output.length - 2, 2)) != keccak256(hex\"88ac\")) {\r\n                    return hex\"\";\r\n                }\r\n                return _output.slice(12, 20);\r\n            \r\n            } else if (_tag == keccak256(hex\"17a914\")) {\r\n                \r\n                if (uint8(_output.slice(_output.length - 1, 1)[0]) != 0x87) {\r\n                    return hex\"\";\r\n                }\r\n                return _output.slice(11, 20);\r\n            }\r\n        }\r\n        return hex\"\";  \r\n    }\r\n\r\n    \r\n    \r\n    \r\n\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function validateVin(bytes memory _vin) internal pure returns (bool) {\r\n        uint256 _offset = 1;\r\n        uint8 _nIns = uint8(_vin.slice(0, 1)[0]);\r\n\r\n        \r\n        if (_nIns >= 0xfd || _nIns == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint8 i = 0; i < _nIns; i++) {\r\n            \r\n            \r\n            _offset += determineInputLength(_vin.slice(_offset, _vin.length - _offset));\r\n\r\n            \r\n            if (_offset > _vin.length) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        \r\n        return _offset == _vin.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function validateVout(bytes memory _vout) internal pure returns (bool) {\r\n        uint256 _offset = 1;\r\n        uint8 _nOuts = uint8(_vout.slice(0, 1)[0]);\r\n\r\n        \r\n        if (_nOuts >= 0xfd || _nOuts == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint8 i = 0; i < _nOuts; i++) {\r\n            \r\n            \r\n            _offset += determineOutputLength(_vout.slice(_offset, _vout.length - _offset));\r\n\r\n            \r\n            if (_offset > _vout.length) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        \r\n        return _offset == _vout.length;\r\n    }\r\n\r\n\r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractMerkleRootLE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return _header.slice(36, 32);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractMerkleRootBE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return reverseEndianness(extractMerkleRootLE(_header));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTarget(bytes memory _header) internal pure returns (uint256) {\r\n        bytes memory _m = _header.slice(72, 3);\r\n        uint8 _e = uint8(_header[75]);\r\n        uint256 _mantissa = bytesToUint(reverseEndianness(_m));\r\n        uint _exponent = _e - 3;\r\n\r\n        return _mantissa * (256 ** _exponent);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function calculateDifficulty(uint256 _target) internal pure returns (uint256) {\r\n        \r\n        return DIFF1_TARGET.div(_target);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractPrevBlockLE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return _header.slice(4, 32);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractPrevBlockBE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return reverseEndianness(extractPrevBlockLE(_header));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTimestampLE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return _header.slice(68, 4);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTimestamp(bytes memory _header) internal pure returns (uint32) {\r\n        return uint32(bytesToUint(reverseEndianness(extractTimestampLE(_header))));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractDifficulty(bytes memory _header) internal pure returns (uint256) {\r\n        return calculateDifficulty(extractTarget(_header));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function _hash256MerkleStep(bytes memory _a, bytes memory _b) internal pure returns (bytes32) {\r\n        return hash256(abi.encodePacked(_a, _b));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function verifyHash256Merkle(bytes memory _proof, uint _index) internal pure returns (bool) {\r\n        \r\n        if (_proof.length % 32 != 0) {\r\n            return false;\r\n        }\r\n\r\n        \r\n        if (_proof.length == 32) {\r\n            return true;\r\n        }\r\n\r\n        \r\n        if (_proof.length == 64) {\r\n            return false;\r\n        }\r\n\r\n        uint _idx = _index;\r\n        bytes32 _root = _proof.slice(_proof.length - 32, 32).toBytes32();\r\n        bytes32 _current = _proof.slice(0, 32).toBytes32();\r\n\r\n        for (uint i = 1; i < (_proof.length.div(32)) - 1; i++) {\r\n            if (_idx % 2 == 1) {\r\n                _current = _hash256MerkleStep(_proof.slice(i * 32, 32), abi.encodePacked(_current));\r\n            } else {\r\n                _current = _hash256MerkleStep(abi.encodePacked(_current), _proof.slice(i * 32, 32));\r\n            }\r\n            _idx = _idx >> 1;\r\n        }\r\n        return _current == _root;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function retargetAlgorithm(\r\n        uint256 _previousTarget,\r\n        uint256 _firstTimestamp,\r\n        uint256 _secondTimestamp\r\n    ) internal pure returns (uint256) {\r\n        uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\r\n\r\n        \r\n        if (_elapsedTime < RETARGET_PERIOD.div(4)) {\r\n            _elapsedTime = RETARGET_PERIOD.div(4);\r\n        }\r\n        if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\r\n            _elapsedTime = RETARGET_PERIOD.mul(4);\r\n        }\r\n\r\n        \r\n\r\n        uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\r\n        return _adjusted.div(RETARGET_PERIOD).mul(65536);\r\n    }\r\n}\r\n\r\ninterface FundsInterface {\r\n    function lender(bytes32) external view returns (address);\r\n    function custom(bytes32) external view returns (bool);\r\n    function deposit(bytes32, uint256) external;\r\n    function decreaseTotalBorrow(uint256) external;\r\n    function calcGlobalInterest() external;\r\n}\r\n\r\ninterface SalesInterface {\r\n    function saleIndexByLoan(bytes32, uint256) external returns(bytes32);\r\n    function settlementExpiration(bytes32) external view returns (uint256);\r\n    function accepted(bytes32) external view returns (bool);\r\n    function next(bytes32) external view returns (uint256);\r\n    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\r\n}\r\n\r\ninterface CollateralInterface {\r\n    function onDemandSpv() external view returns(address);\r\n    function collateral(bytes32 loan) external view returns (uint256);\r\n    function refundableCollateral(bytes32 loan) external view returns (uint256);\r\n    function seizableCollateral(bytes32 loan) external view returns (uint256);\r\n    function temporaryRefundableCollateral(bytes32 loan) external view returns (uint256);\r\n    function temporarySeizableCollateral(bytes32 loan) external view returns (uint256);\r\n    function setCollateral(bytes32 loan, uint256 refundableCollateral_, uint256 seizableCollateral_) external;\r\n    function requestSpv(bytes32 loan) external;\r\n    function cancelSpv(bytes32 loan) external;\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant COL  = 10 ** 8;\r\n    uint constant WAD  = 10 ** 18;\r\n    uint constant RAY  = 10 ** 27;\r\n\r\n    function cmul(uint x, uint y) public pure returns (uint z) {\r\n        z = add(mul(x, y), COL / 2) / COL;\r\n    }\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function cdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, COL), y / 2) / y;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Medianizer {\r\n    function peek() external view returns (bytes32, bool);\r\n    function read() external returns (bytes32);\r\n    function poke() external;\r\n    function poke(bytes32) external;\r\n    function fund (uint256 amount, ERC20 token) external;\r\n}\r\n\r\ncontract Loans is DSMath {\r\n    FundsInterface funds;\r\n    Medianizer med;\r\n    SalesInterface sales;\r\n    CollateralInterface col;\r\n\r\n    uint256 public constant APPROVE_EXP_THRESHOLD = 2 hours;    \r\n    uint256 public constant ACCEPT_EXP_THRESHOLD = 2 days;      \r\n    uint256 public constant LIQUIDATION_EXP_THRESHOLD = 7 days; \r\n    uint256 public constant SEIZURE_EXP_THRESHOLD = 2 days;     \r\n    uint256 public constant LIQUIDATION_DISCOUNT = 930000000000000000; \r\n    uint256 public constant MAX_NUM_LIQUIDATIONS = 3; \r\n    uint256 public constant MAX_UINT_256 = 2**256-1;\r\n\r\n    mapping (bytes32 => Loan)                     public loans;\r\n    mapping (bytes32 => PubKeys)                  public pubKeys;             \r\n    mapping (bytes32 => SecretHashes)             public secretHashes;        \r\n    mapping (bytes32 => Bools)                    public bools;               \r\n    mapping (bytes32 => bytes32)                  public fundIndex;           \r\n    mapping (bytes32 => uint256)                  public repayments;          \r\n    mapping (address => bytes32[])                public borrowerLoans;\r\n    mapping (address => bytes32[])                public lenderLoans;\r\n    mapping (address => mapping(uint256 => bool)) public addressToTimestamp;\r\n    uint256                                       public loanIndex;           \r\n\r\n    ERC20 public token; \r\n    uint256 public decimals;\r\n\r\n    address deployer;\r\n\r\n    \r\n    struct Loan {\r\n        address borrower;\r\n        address lender;\r\n        address arbiter;\r\n        uint256 createdAt;\r\n        uint256 loanExpiration;\r\n        uint256 requestTimestamp;\r\n        uint256 closedTimestamp;\r\n        uint256 principal;\r\n        uint256 interest;\r\n        uint256 penalty;\r\n        uint256 fee;\r\n        uint256 liquidationRatio;\r\n    }\r\n\r\n    \r\n    struct PubKeys {\r\n        bytes   borrowerPubKey;\r\n        bytes   lenderPubKey;\r\n        bytes   arbiterPubKey;\r\n    }\r\n\r\n    \r\n    struct SecretHashes {\r\n        bytes32    secretHashA1;\r\n        bytes32[3] secretHashAs;\r\n        bytes32    secretHashB1;\r\n        bytes32[3] secretHashBs;\r\n        bytes32    secretHashC1;\r\n        bytes32[3] secretHashCs;\r\n        bytes32    withdrawSecret;\r\n        bytes32    acceptSecret;\r\n        bool       set;\r\n    }\r\n\r\n    \r\n    struct Bools {\r\n        bool funded;\r\n        bool approved;\r\n        bool withdrawn;\r\n        bool sale;\r\n        bool paid;\r\n        bool off;\r\n    }\r\n\r\n    event Create(bytes32 loan);\r\n\r\n    event SetSecretHashes(bytes32 loan);\r\n\r\n    event FundLoan(bytes32 loan);\r\n\r\n    event Approve(bytes32 loan);\r\n\r\n    event Withdraw(bytes32 loan, bytes32 secretA1);\r\n\r\n    event Repay(bytes32 loan, uint256 amount);\r\n\r\n    event Refund(bytes32 loan);\r\n\r\n    event Cancel(bytes32 loan, bytes32 secret);\r\n\r\n    event Accept(bytes32 loan, bytes32 secret);\r\n\r\n    event Liquidate(bytes32 loan, bytes32 secretHash, bytes20 pubKeyHash);\r\n\r\n    \r\n    function borrower(bytes32 loan) external view returns (address) {\r\n        return loans[loan].borrower;\r\n    }\r\n\r\n    \r\n    function lender(bytes32 loan) external view returns (address) {\r\n        return loans[loan].lender;\r\n    }\r\n\r\n    \r\n    function arbiter(bytes32 loan) external view returns (address) {\r\n        return loans[loan].arbiter;\r\n    }\r\n\r\n    \r\n    function approveExpiration(bytes32 loan) public view returns (uint256) { \r\n        return add(loans[loan].createdAt, APPROVE_EXP_THRESHOLD);\r\n    }\r\n\r\n    \r\n    function acceptExpiration(bytes32 loan) public view returns (uint256) { \r\n        return add(loans[loan].loanExpiration, ACCEPT_EXP_THRESHOLD);\r\n    }\r\n\r\n    \r\n    function liquidationExpiration(bytes32 loan) public view returns (uint256) { \r\n        return add(loans[loan].loanExpiration, LIQUIDATION_EXP_THRESHOLD);\r\n    }\r\n\r\n    \r\n    function seizureExpiration(bytes32 loan) public view returns (uint256) {\r\n        return add(liquidationExpiration(loan), SEIZURE_EXP_THRESHOLD);\r\n    }\r\n\r\n    \r\n    function principal(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].principal;\r\n    }\r\n\r\n    \r\n    function interest(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].interest;\r\n    }\r\n\r\n    \r\n    function fee(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].fee;\r\n    }\r\n\r\n    \r\n    function penalty(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].penalty;\r\n    }\r\n\r\n    \r\n    function collateral(bytes32 loan) public view returns (uint256) {\r\n        return col.collateral(loan);\r\n    }\r\n\r\n    \r\n    function refundableCollateral(bytes32 loan) external view returns (uint256) {\r\n        return col.refundableCollateral(loan);\r\n    }\r\n\r\n    \r\n    function seizableCollateral(bytes32 loan) external view returns (uint256) {\r\n        return col.seizableCollateral(loan);\r\n    }\r\n\r\n    \r\n    function temporaryRefundableCollateral(bytes32 loan) external view returns (uint256) {\r\n        return col.temporaryRefundableCollateral(loan);\r\n    }\r\n\r\n    \r\n    function temporarySeizableCollateral(bytes32 loan) external view returns (uint256) {\r\n        return col.temporarySeizableCollateral(loan);\r\n    }\r\n\r\n    \r\n    function repaid(bytes32 loan) public view returns (uint256) { \r\n        return repayments[loan];\r\n    }\r\n\r\n    \r\n    function liquidationRatio(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].liquidationRatio;\r\n    }\r\n\r\n    \r\n    function owedToLender(bytes32 loan) public view returns (uint256) { \r\n        return add(principal(loan), interest(loan));\r\n    }\r\n\r\n    \r\n    function owedForLoan(bytes32 loan) public view returns (uint256) { \r\n        return add(owedToLender(loan), fee(loan));\r\n    }\r\n\r\n    \r\n    function owedForLiquidation(bytes32 loan) external view returns (uint256) { \r\n        return add(owedForLoan(loan), penalty(loan));\r\n    }\r\n\r\n    \r\n    function owing(bytes32 loan) external view returns (uint256) {\r\n        return sub(owedForLoan(loan), repaid(loan));\r\n    }\r\n\r\n    \r\n    function funded(bytes32 loan) external view returns (bool) {\r\n        return bools[loan].funded;\r\n    }\r\n\r\n    \r\n    function approved(bytes32 loan) external view returns (bool) {\r\n        return bools[loan].approved;\r\n    }\r\n\r\n    \r\n    function withdrawn(bytes32 loan) external view returns (bool) {\r\n        return bools[loan].withdrawn;\r\n    }\r\n\r\n    \r\n    function sale(bytes32 loan) public view returns (bool) {\r\n        return bools[loan].sale;\r\n    }\r\n\r\n    \r\n    function paid(bytes32 loan) external view returns (bool) {\r\n        return bools[loan].paid;\r\n    }\r\n\r\n    \r\n    function off(bytes32 loan) public view returns (bool) {\r\n        return bools[loan].off;\r\n    }\r\n\r\n    \r\n    function dmul(uint x) public view returns (uint256) {\r\n        return mul(x, (10 ** sub(18, decimals)));\r\n    }\r\n\r\n    \r\n    function ddiv(uint x) public view returns (uint256) {\r\n        return div(x, (10 ** sub(18, decimals)));\r\n    }\r\n\r\n    \r\n    function borrowerLoanCount(address borrower_) external view returns (uint256) {\r\n        return borrowerLoans[borrower_].length;\r\n    }\r\n\r\n    \r\n    function lenderLoanCount(address lender_) external view returns (uint256) {\r\n        return lenderLoans[lender_].length;\r\n    }\r\n\r\n    \r\n    function minSeizableCollateral(bytes32 loan) public view returns (uint256) {\r\n        (bytes32 val, bool set) = med.peek();\r\n        require(set, \"Loans.minSeizableCollateral: Medianizer must be set\");\r\n        uint256 price = uint(val);\r\n        return div(wdiv(dmul(sub(owedForLoan(loan), repaid(loan))), price), div(WAD, COL));\r\n    }\r\n\r\n    \r\n    function collateralValue(bytes32 loan) public view returns (uint256) {\r\n        (bytes32 val, bool set) = med.peek();\r\n        require(set, \"Loans.collateralValue: Medianizer must be set\");\r\n        uint256 price = uint(val);\r\n        return cmul(price, collateral(loan));\r\n    }\r\n\r\n    \r\n    function minCollateralValue(bytes32 loan) public view returns (uint256) {\r\n        return rmul(dmul(sub(owedForLoan(loan), repaid(loan))), liquidationRatio(loan));\r\n    }\r\n\r\n    \r\n    function discountCollateralValue(bytes32 loan) public view returns (uint256) {\r\n        return wmul(collateralValue(loan), LIQUIDATION_DISCOUNT);\r\n    }\r\n\r\n    \r\n    function safe(bytes32 loan) public view returns (bool) {\r\n        return collateralValue(loan) >= minCollateralValue(loan);\r\n    }\r\n\r\n    \r\n    constructor (FundsInterface funds_, Medianizer med_, ERC20 token_, uint256 decimals_) public {\r\n        require(address(funds_) != address(0), \"Funds address must be non-zero\");\r\n        require(address(med_) != address(0), \"Medianizer address must be non-zero\");\r\n        require(address(token_) != address(0), \"Token address must be non-zero\");\r\n\r\n        deployer = msg.sender;\r\n        funds = funds_;\r\n        med = med_;\r\n        token = token_;\r\n        decimals = decimals_;\r\n        require(token.approve(address(funds), MAX_UINT_256), \"Token approve failed\");\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n    function setSales(SalesInterface sales_) external {\r\n        require(msg.sender == deployer, \"Loans.setSales: Only the deployer can perform this\");\r\n        require(address(sales) == address(0), \"Loans.setSales: The Sales address has already been set\");\r\n        require(address(sales_) != address(0), \"Loans.setSales: Sales address must be non-zero\");\r\n        sales = sales_;\r\n    }\r\n\r\n    \r\n    function setCollateral(CollateralInterface col_) external {\r\n        require(msg.sender == deployer, \"Loans.setCollateral: Only the deployer can perform this\");\r\n        require(address(col) == address(0), \"Loans.setCollateral: The Collateral address has already been set\");\r\n        require(address(col_) != address(0), \"Loans.setCollateral: Collateral address must be non-zero\");\r\n        col = col_;\r\n    }\r\n    \r\n\r\n    \r\n    function create(\r\n        uint256             loanExpiration_,\r\n        address[3] calldata usrs_,\r\n        uint256[7] calldata vals_,\r\n        bytes32             fund\r\n    ) external returns (bytes32 loan) {\r\n        if (fund != bytes32(0)) {\r\n            require(funds.lender(fund) == usrs_[1], \"Loans.create: Lender of Fund not in args\");\r\n        }\r\n        require(!addressToTimestamp[usrs_[0]][vals_[6]], \"Loans.create: Duplicate request timestamps are not allowed\");\r\n        require(loanExpiration_ > now, \"Loans.create: loanExpiration must be greater than `now`\");\r\n        require(usrs_[0] != address(0) && usrs_[1] != address(0), \"Loans.create: Borrower and Lender address must be non-zero\");\r\n        require(vals_[0] != 0 && vals_[4] != 0, \"Loans.create: Principal and Collateral must be non-zero\");\r\n        require(vals_[5] != 0 && vals_[6] != 0, \"Loans.create: Liquidation ratio and Request timestamp must be non-zero\");\r\n\r\n        loanIndex = add(loanIndex, 1);\r\n        loan = bytes32(loanIndex);\r\n        loans[loan].createdAt = now;\r\n        loans[loan].loanExpiration = loanExpiration_;\r\n        loans[loan].borrower = usrs_[0];\r\n        loans[loan].lender = usrs_[1];\r\n        loans[loan].arbiter = usrs_[2];\r\n        loans[loan].principal = vals_[0];\r\n        loans[loan].interest = vals_[1];\r\n        loans[loan].penalty = vals_[2];\r\n        loans[loan].fee = vals_[3];\r\n        uint256 minSeizableCol = minSeizableCollateral(loan);\r\n        col.setCollateral(loan, sub(vals_[4], minSeizableCol), minSeizableCol);\r\n        loans[loan].liquidationRatio = vals_[5];\r\n        loans[loan].requestTimestamp = vals_[6];\r\n        fundIndex[loan] = fund;\r\n        secretHashes[loan].set = false;\r\n        borrowerLoans[usrs_[0]].push(bytes32(loanIndex));\r\n        lenderLoans[usrs_[1]].push(bytes32(loanIndex));\r\n        addressToTimestamp[usrs_[0]][vals_[6]] = true;\r\n\r\n        emit Create(loan);\r\n    }\r\n\r\n    \r\n    function setSecretHashes(\r\n        bytes32             loan,\r\n        bytes32[4] calldata borrowerSecretHashes,\r\n        bytes32[4] calldata lenderSecretHashes,\r\n        bytes32[4] calldata arbiterSecretHashes,\r\n        bytes      calldata borrowerPubKey_,\r\n        bytes      calldata lenderPubKey_,\r\n        bytes      calldata arbiterPubKey_\r\n    ) external {\r\n        require(!secretHashes[loan].set, \"Loans.setSecretHashes: Secret hashes must not already be set\");\r\n        require(\r\n            msg.sender == loans[loan].borrower || msg.sender == loans[loan].lender || msg.sender == address(funds),\r\n            \"Loans.setSecretHashes: msg.sender must be Borrower, Lender or Funds Address\"\r\n        );\r\n        secretHashes[loan].secretHashA1 = borrowerSecretHashes[0];\r\n        secretHashes[loan].secretHashAs = [ borrowerSecretHashes[1], borrowerSecretHashes[2], borrowerSecretHashes[3] ];\r\n        secretHashes[loan].secretHashB1 = lenderSecretHashes[0];\r\n        secretHashes[loan].secretHashBs = [ lenderSecretHashes[1], lenderSecretHashes[2], lenderSecretHashes[3] ];\r\n        secretHashes[loan].secretHashC1 = arbiterSecretHashes[0];\r\n        secretHashes[loan].secretHashCs = [ arbiterSecretHashes[1], arbiterSecretHashes[2], arbiterSecretHashes[3] ];\r\n        pubKeys[loan].borrowerPubKey = borrowerPubKey_;\r\n        pubKeys[loan].lenderPubKey = lenderPubKey_;\r\n        pubKeys[loan].arbiterPubKey = arbiterPubKey_;\r\n        secretHashes[loan].set = true;\r\n    }\r\n\r\n    \r\n    function fund(bytes32 loan) external {\r\n        require(secretHashes[loan].set, \"Loans.fund: Secret hashes must be set\");\r\n        require(bools[loan].funded == false, \"Loans.fund: Loan is already funded\");\r\n        bools[loan].funded = true;\r\n        require(token.transferFrom(msg.sender, address(this), principal(loan)), \"Loans.fund: Failed to transfer tokens\");\r\n\r\n        emit FundLoan(loan);\r\n    }\r\n\r\n    \r\n    function approve(bytes32 loan) external { \r\n    \trequire(bools[loan].funded == true, \"Loans.approve: Loan must be funded\");\r\n    \trequire(loans[loan].lender == msg.sender, \"Loans.approve: Only the lender can approve the loan\");\r\n        require(now <= approveExpiration(loan), \"Loans.approve: Loan is past the approve deadline\");\r\n    \tbools[loan].approved = true;\r\n\r\n        emit Approve(loan);\r\n    }\r\n\r\n    \r\n    function withdraw(bytes32 loan, bytes32 secretA1) external {\r\n        require(!off(loan), \"Loans.withdraw: Loan cannot be inactive\");\r\n        require(bools[loan].funded == true, \"Loans.withdraw: Loan must be funded\");\r\n        require(bools[loan].approved == true, \"Loans.withdraw: Loan must be approved\");\r\n        require(bools[loan].withdrawn == false, \"Loans.withdraw: Loan principal has already been withdrawn\");\r\n        require(sha256(abi.encodePacked(secretA1)) == secretHashes[loan].secretHashA1, \"Loans.withdraw: Secret does not match\");\r\n        bools[loan].withdrawn = true;\r\n        require(token.transfer(loans[loan].borrower, principal(loan)), \"Loans.withdraw: Failed to transfer tokens\");\r\n\r\n        secretHashes[loan].withdrawSecret = secretA1;\r\n        if (address(col.onDemandSpv()) != address(0)) {col.requestSpv(loan);}\r\n\r\n        emit Withdraw(loan, secretA1);\r\n    }\r\n\r\n    \r\n    function repay(bytes32 loan, uint256 amount) external {\r\n        require(!off(loan), \"Loans.repay: Loan cannot be inactive\");\r\n        require(!sale(loan), \"Loans.repay: Loan cannot be undergoing a liquidation\");\r\n        require(bools[loan].withdrawn == true, \"Loans.repay: Loan principal must be withdrawn\");\r\n        require(now <= loans[loan].loanExpiration, \"Loans.repay: Loan cannot have expired\");\r\n        require(add(amount, repaid(loan)) <= owedForLoan(loan), \"Loans.repay: Cannot repay more than the owed amount\");\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"Loans.repay: Failed to transfer tokens\");\r\n        repayments[loan] = add(amount, repayments[loan]);\r\n        if (repaid(loan) == owedForLoan(loan)) {\r\n            bools[loan].paid = true;\r\n            if (address(col.onDemandSpv()) != address(0)) {col.cancelSpv(loan);}\r\n        }\r\n\r\n        emit Repay(loan, amount);\r\n    }\r\n\r\n    \r\n    function refund(bytes32 loan) external {\r\n        require(!off(loan), \"Loans.refund: Loan cannot be inactive\");\r\n        require(!sale(loan), \"Loans.refund: Loan cannot be undergoing a liquidation\");\r\n        require(now > acceptExpiration(loan), \"Loans.refund: Cannot request refund until after acceptExpiration\");\r\n        require(bools[loan].paid == true, \"Loans.refund: The loan must be repaid\");\r\n        require(msg.sender == loans[loan].borrower, \"Loans.refund: Only the borrower can request a refund\");\r\n        bools[loan].off = true;\r\n        loans[loan].closedTimestamp = now;\r\n        if (funds.custom(fundIndex[loan]) == false) {\r\n            funds.decreaseTotalBorrow(loans[loan].principal);\r\n            funds.calcGlobalInterest();\r\n        }\r\n        require(token.transfer(loans[loan].borrower, owedForLoan(loan)), \"Loans.refund: Failed to transfer tokens\");\r\n\r\n        emit Refund(loan);\r\n    }\r\n\r\n    \r\n    function cancel(bytes32 loan, bytes32 secret) external {\r\n        accept(loan, secret);\r\n\r\n        emit Cancel(loan, secret);\r\n    }\r\n\r\n    \r\n    function cancel(bytes32 loan) external {\r\n        require(!off(loan), \"Loans.cancel: Loan must not be inactive\");\r\n        require(bools[loan].withdrawn == false, \"Loans.cancel: Loan principal must not be withdrawn\");\r\n        require(now >= seizureExpiration(loan), \"Loans.cancel: Seizure deadline has not been reached\");\r\n        require(bools[loan].sale == false, \"Loans.cancel: Loan must not be undergoing liquidation\");\r\n        close(loan);\r\n\r\n        emit Cancel(loan, bytes32(0));\r\n    }\r\n\r\n    \r\n    function accept(bytes32 loan, bytes32 secret) public {\r\n        require(!off(loan), \"Loans.accept: Loan must not be inactive\");\r\n        require(bools[loan].withdrawn == false || bools[loan].paid == true, \"Loans.accept: Loan must be either not withdrawn or repaid\");\r\n        require(msg.sender == loans[loan].lender || msg.sender == loans[loan].arbiter, \"Loans.accept: msg.sender must be lender or arbiter\");\r\n        require(now <= acceptExpiration(loan), \"Loans.accept: Acceptance deadline has past\");\r\n        require(bools[loan].sale == false, \"Loans.accept: Loan must not be going under liquidation\");\r\n        require(\r\n            sha256(abi.encodePacked(secret)) == secretHashes[loan].secretHashB1 || sha256(abi.encodePacked(secret)) == secretHashes[loan].secretHashC1,\r\n            \"Loans.accept: Invalid secret\"\r\n        );\r\n        secretHashes[loan].acceptSecret = secret;\r\n        close(loan);\r\n\r\n        emit Accept(loan, secret);\r\n    }\r\n\r\n    \r\n    function close(bytes32 loan) private {\r\n        bools[loan].off = true;\r\n        loans[loan].closedTimestamp = now;\r\n        \r\n        if (bools[loan].withdrawn == false) {\r\n            if (fundIndex[loan] == bytes32(0)) {\r\n                require(token.transfer(loans[loan].lender, loans[loan].principal), \"Loans.close: Failed to transfer principal to Lender\");\r\n            } else {\r\n                if (funds.custom(fundIndex[loan]) == false) {\r\n                    funds.decreaseTotalBorrow(loans[loan].principal);\r\n                }\r\n                funds.deposit(fundIndex[loan], loans[loan].principal);\r\n            }\r\n        }\r\n        \r\n        else {\r\n            if (fundIndex[loan] == bytes32(0)) {\r\n                require(token.transfer(loans[loan].lender, owedToLender(loan)), \"Loans.close: Failed to transfer owedToLender to Lender\");\r\n            } else {\r\n                if (funds.custom(fundIndex[loan]) == false) {\r\n                    funds.decreaseTotalBorrow(loans[loan].principal);\r\n                }\r\n                funds.deposit(fundIndex[loan], owedToLender(loan));\r\n            }\r\n            require(token.transfer(loans[loan].arbiter, fee(loan)), \"Loans.close: Failed to transfer fee to Arbiter\");\r\n        }\r\n    }\r\n\r\n    \r\n    function liquidate(bytes32 loan, bytes32 secretHash, bytes20 pubKeyHash) external returns (bytes32 sale_) {\r\n        require(!off(loan), \"Loans.liquidate: Loan must not be inactive\");\r\n        require(bools[loan].withdrawn == true, \"Loans.liquidate: Loan principal must be withdrawn\");\r\n        require(msg.sender != loans[loan].borrower && msg.sender != loans[loan].lender, \"Loans.liquidate: Liquidator must be a third-party\");\r\n        require(secretHash != bytes32(0) && pubKeyHash != bytes20(0), \"Loans.liquidate: secretHash and pubKeyHash must be non-zero\");\r\n        \r\n        if (sales.next(loan) == 0) {\r\n            \r\n            if (now > loans[loan].loanExpiration) {\r\n                require(bools[loan].paid == false, \"Loans.liquidate: loan must not have already been repaid\");\r\n            } else {\r\n                require(!safe(loan), \"Loans.liquidate: collateralization must be below min-collateralization ratio\");\r\n            }\r\n            \r\n            if (funds.custom(fundIndex[loan]) == false) {\r\n                funds.decreaseTotalBorrow(loans[loan].principal);\r\n                funds.calcGlobalInterest();\r\n            }\r\n        } else {\r\n            \r\n            require(sales.next(loan) < MAX_NUM_LIQUIDATIONS, \"Loans.liquidate: Max number of liquidations reached\");\r\n            require(!sales.accepted(sales.saleIndexByLoan(loan, sales.next(loan) - 1)), \"Loans.liquidate: Previous liquidation already accepted\");\r\n            require(\r\n                now > sales.settlementExpiration(sales.saleIndexByLoan(loan, sales.next(loan) - 1)),\r\n                \"Loans.liquidate: Previous liquidation settlement expiration hasn't expired\"\r\n            );\r\n        }\r\n        require(token.balanceOf(msg.sender) >= ddiv(discountCollateralValue(loan)), \"Loans.liquidate: insufficient balance to liquidate\");\r\n        require(token.transferFrom(msg.sender, address(sales), ddiv(discountCollateralValue(loan))), \"Loans.liquidate: Token transfer failed\");\r\n        SecretHashes storage h = secretHashes[loan];\r\n        uint256 i = sales.next(loan);\r\n        \r\n        sale_ = sales.create(\r\n            loan, loans[loan].borrower, loans[loan].lender, loans[loan].arbiter, msg.sender,\r\n            h.secretHashAs[i], h.secretHashBs[i], h.secretHashCs[i], secretHash, pubKeyHash\r\n        );\r\n        if (bools[loan].sale == false) {\r\n            bools[loan].sale = true;\r\n            require(token.transfer(address(sales), repaid(loan)), \"Loans.liquidate: Token transfer to Sales contract failed\");\r\n        }\r\n        \r\n        if (address(col.onDemandSpv()) != address(0)) {col.cancelSpv(loan);}\r\n\r\n        emit Liquidate(loan, secretHash, pubKeyHash);\r\n    }\r\n}\r\n\r\ncontract Sales is DSMath {\r\n    FundsInterface funds;\r\n    Loans loans;\r\n    Medianizer med;\r\n\r\n    uint256 public constant SWAP_EXP = 2 hours;       \r\n    uint256 public constant SETTLEMENT_EXP = 4 hours; \r\n    uint256 public constant MAX_NUM_LIQUIDATIONS = 3; \r\n    uint256 public constant MAX_UINT_256 = 2**256-1;\r\n\r\n    address public deployer; \r\n\r\n    mapping (bytes32 => Sale)       public sales;        \r\n    mapping (bytes32 => Sig)        public borrowerSigs; \r\n    mapping (bytes32 => Sig)        public lenderSigs;   \r\n    mapping (bytes32 => Sig)        public arbiterSigs;  \r\n    mapping (bytes32 => SecretHash) public secretHashes; \r\n    uint256                         public saleIndex;    \r\n\r\n    mapping (bytes32 => bytes32[])  public saleIndexByLoan; \r\n\r\n    mapping(bytes32 => bool) revealed;\r\n\r\n    ERC20 public token;\r\n\r\n    \r\n    struct Sale {\r\n        bytes32    loanIndex;\r\n        uint256    discountBuy;\r\n        address    liquidator;\r\n        address    borrower;\r\n        address    lender;\r\n        address    arbiter;\r\n        uint256    createdAt;\r\n        bytes20    pubKeyHash;\r\n        bool       set;\r\n        bool       accepted;\r\n        bool       off;\r\n    }\r\n\r\n    \r\n    struct Sig {\r\n        bytes refundableSig;\r\n        bytes seizableSig;\r\n    }\r\n\r\n    \r\n    struct SecretHash {\r\n        bytes32 secretHashA; \r\n        bytes32 secretA;     \r\n        bytes32 secretHashB; \r\n        bytes32 secretB;     \r\n        bytes32 secretHashC; \r\n        bytes32 secretC;     \r\n        bytes32 secretHashD; \r\n        bytes32 secretD;     \r\n    }\r\n\r\n    event Create(bytes32 sale);\r\n\r\n    event ProvideSig(bytes32 sale);\r\n\r\n    event ProvideSecret(bytes32 sale, bytes32 secret_);\r\n\r\n    event Accept(bytes32 sale);\r\n\r\n    event Refund(bytes32 sale);\r\n\r\n    \r\n    function discountBuy(bytes32 sale) external view returns (uint256) {\r\n        return sales[sale].discountBuy;\r\n    }\r\n\r\n    \r\n    function swapExpiration(bytes32 sale) external view returns (uint256) {\r\n        return sales[sale].createdAt + SWAP_EXP;\r\n    }\r\n\r\n    \r\n    function settlementExpiration(bytes32 sale) public view returns (uint256) {\r\n        return sales[sale].createdAt + SETTLEMENT_EXP;\r\n    }\r\n\r\n    \r\n    function accepted(bytes32 sale) public view returns (bool) {\r\n        return sales[sale].accepted;\r\n    }\r\n\r\n    \r\n    function off(bytes32 sale) public view returns (bool) {\r\n        return sales[sale].off;\r\n    }\r\n\r\n    \r\n    constructor (Loans loans_, FundsInterface funds_, Medianizer med_, ERC20 token_) public {\r\n        require(address(loans_) != address(0), \"Loans address must be non-zero\");\r\n        require(address(funds_) != address(0), \"Funds address must be non-zero\");\r\n        require(address(med_) != address(0), \"Medianizer address must be non-zero\");\r\n        require(address(token_) != address(0), \"Token address must be non-zero\");\r\n    \tdeployer = address(loans_);\r\n        loans = loans_;\r\n        funds = funds_;\r\n        med = med_;\r\n        token = token_;\r\n        require(token.approve(address(funds), MAX_UINT_256), \"Token approve failed\");\r\n    }\r\n\r\n    \r\n    function next(bytes32 loan) public view returns (uint256) {\r\n    \treturn saleIndexByLoan[loan].length;\r\n    }\r\n\r\n    \r\n    function create(\r\n        bytes32 loanIndex,\r\n        address borrower,\r\n        address lender,\r\n        address arbiter,\r\n        address liquidator,\r\n        bytes32 secretHashA,\r\n        bytes32 secretHashB,\r\n        bytes32 secretHashC,\r\n        bytes32 secretHashD,\r\n        bytes20 pubKeyHash\r\n        ) external returns(bytes32 sale) {\r\n        require(msg.sender == address(loans), \"Sales.create: Only the Loans contract can create a Sale\");\r\n        saleIndex = add(saleIndex, 1);\r\n        sale = bytes32(saleIndex);\r\n        sales[sale].loanIndex = loanIndex;\r\n        sales[sale].borrower = borrower;\r\n        sales[sale].lender = lender;\r\n        sales[sale].arbiter = arbiter;\r\n        sales[sale].liquidator = liquidator;\r\n        sales[sale].createdAt = now;\r\n        sales[sale].pubKeyHash = pubKeyHash;\r\n        sales[sale].discountBuy = loans.ddiv(loans.discountCollateralValue(loanIndex));\r\n        sales[sale].set = true;\r\n        secretHashes[sale].secretHashA = secretHashA;\r\n        secretHashes[sale].secretHashB = secretHashB;\r\n        secretHashes[sale].secretHashC = secretHashC;\r\n        secretHashes[sale].secretHashD = secretHashD;\r\n        saleIndexByLoan[loanIndex].push(sale);\r\n\r\n        emit Create(sale);\r\n   }\r\n\r\n    \r\n    function provideSig(\r\n        bytes32        sale,\r\n        bytes calldata refundableSig,\r\n        bytes calldata seizableSig\r\n    ) external {\r\n        require(sales[sale].set, \"Sales.provideSig: Sale must be set\");\r\n        require(now < settlementExpiration(sale), \"Sales.provideSig: Cannot provide signature after settlement expiration\");\r\n        require(BytesLib.toBytes32(refundableSig) != bytes32(0), \"Sales.provideSig: refundableSig must be non-zero\");\r\n        require(BytesLib.toBytes32(seizableSig) != bytes32(0), \"Sales.provideSig: seizableSig must be non-zero\");\r\n        if (msg.sender == sales[sale].borrower) {\r\n            borrowerSigs[sale].refundableSig = refundableSig;\r\n            borrowerSigs[sale].seizableSig = seizableSig;\r\n        } else if (msg.sender == sales[sale].lender) {\r\n            lenderSigs[sale].refundableSig = refundableSig;\r\n            lenderSigs[sale].seizableSig = seizableSig;\r\n        } else if (msg.sender == sales[sale].arbiter) {\r\n            arbiterSigs[sale].refundableSig = refundableSig;\r\n            arbiterSigs[sale].seizableSig = seizableSig;\r\n        } else {\r\n            revert(\"Loans.provideSig: Must be called by Borrower, Lender or Arbiter\");\r\n        }\r\n\r\n        emit ProvideSig(sale);\r\n    }\r\n\r\n    \r\n    function provideSecret(bytes32 sale, bytes32 secret_) public {\r\n        require(sales[sale].set, \"Sales.provideSecret: Sale must be set\");\r\n        bytes32 secretHash = sha256(abi.encodePacked(secret_));\r\n        revealed[secretHash] = true;\r\n        if (secretHash == secretHashes[sale].secretHashA) {secretHashes[sale].secretA = secret_;}\r\n        if (secretHash == secretHashes[sale].secretHashB) {secretHashes[sale].secretB = secret_;}\r\n        if (secretHash == secretHashes[sale].secretHashC) {secretHashes[sale].secretC = secret_;}\r\n        if (secretHash == secretHashes[sale].secretHashD) {secretHashes[sale].secretD = secret_;}\r\n\r\n        emit ProvideSecret(sale, secret_);\r\n    }\r\n\r\n    \r\n    function hasSecrets(bytes32 sale) public view returns (bool) {\r\n        uint8 numCorrectSecrets = 0;\r\n        if (revealed[secretHashes[sale].secretHashA]) {numCorrectSecrets += 1;}\r\n        if (revealed[secretHashes[sale].secretHashB]) {numCorrectSecrets += 1;}\r\n        if (revealed[secretHashes[sale].secretHashC]) {numCorrectSecrets += 1;}\r\n        return (numCorrectSecrets >= 2);\r\n    }\r\n\r\n    \r\n    function accept(bytes32 sale) public {\r\n        require(!accepted(sale), \"Sales.accept: Sale must not already be accepted\");\r\n        require(!off(sale), \"Sales.accept: Sale must not already be off\");\r\n        require(hasSecrets(sale), \"Sales.accept: Secrets need to have already been revealed\");\r\n        require(revealed[secretHashes[sale].secretHashD], \"Sales.accept: Secret D must have already been revealed\");\r\n        sales[sale].accepted = true;\r\n\r\n        \r\n        uint256 available = add(sales[sale].discountBuy, loans.repaid(sales[sale].loanIndex));\r\n\r\n        \r\n        if (sales[sale].arbiter != address(0) && available >= loans.fee(sales[sale].loanIndex)) {\r\n            require(token.transfer(sales[sale].arbiter, loans.fee(sales[sale].loanIndex)), \"Sales.accept: Token transfer of fee to Arbiter failed\");\r\n            available = sub(available, loans.fee(sales[sale].loanIndex));\r\n        }\r\n\r\n        \r\n        uint256 amount = min(available, loans.owedToLender(sales[sale].loanIndex));\r\n\r\n        \r\n        if (loans.fundIndex(sales[sale].loanIndex) == bytes32(0)) {\r\n            require(token.transfer(sales[sale].lender, amount), \"Sales.accept: Token transfer of amount left to Lender failed\");\r\n        } else {\r\n            funds.deposit(loans.fundIndex(sales[sale].loanIndex), amount);\r\n        }\r\n\r\n        \r\n        available = sub(available, amount);\r\n\r\n        \r\n        if (available >= loans.penalty(sales[sale].loanIndex)) {\r\n            require(token.approve(address(med), loans.penalty(sales[sale].loanIndex)), \"Sales.accept: Token transfer of penalty to Medianizer failed\");\r\n            med.fund(loans.penalty(sales[sale].loanIndex), token);\r\n            available = sub(available, loans.penalty(sales[sale].loanIndex));\r\n        } else if (available > 0) {\r\n            require(token.approve(address(med), available), \"Sales.accept: Token transfer of tokens available to Medianizer failed\");\r\n            med.fund(available, token);\r\n            available = 0;\r\n        }\r\n\r\n        \r\n        if (available > 0) {\r\n            require(token.transfer(sales[sale].borrower, available), \"Sales.accept: Token transfer of tokens available to Borrower failed\");\r\n        }\r\n\r\n        emit Accept(sale);\r\n    }\r\n\r\n     \r\n    function provideSecretsAndAccept(bytes32 sale, bytes32[3] calldata secrets_) external {\r\n        provideSecret(sale, secrets_[0]);\r\n        provideSecret(sale, secrets_[1]);\r\n        provideSecret(sale, secrets_[2]);\r\n        accept(sale);\r\n    }\r\n\r\n    \r\n    function refund(bytes32 sale) external {\r\n        require(!accepted(sale), \"Sales.refund: Sale must not be accepted\");\r\n        require(!off(sale), \"Sales.refund: Sale must not be off\");\r\n        require(now > settlementExpiration(sale), \"Sales.refund: Can only refund after settlement expiration\");\r\n        require(sales[sale].discountBuy > 0, \"Sales.refund: Discount Buy amount must be non-zero\");\r\n        sales[sale].off = true;\r\n        require(token.transfer(sales[sale].liquidator, sales[sale].discountBuy), \"Sales.refund: Token transfer to Liquidator failed\");\r\n        if (next(sales[sale].loanIndex) == MAX_NUM_LIQUIDATIONS) {\r\n            require(token.transfer(sales[sale].borrower, loans.repaid(sales[sale].loanIndex)), \"Sales.refund: Token transfer to Borrower failed\");\r\n        }\r\n\r\n        emit Refund(sale);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MAX_NUM_LIQUIDATIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"loan\",\"type\":\"bytes32\"}],\"name\":\"next\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"sales\",\"outputs\":[{\"name\":\"loanIndex\",\"type\":\"bytes32\"},{\"name\":\"discountBuy\",\"type\":\"uint256\"},{\"name\":\"liquidator\",\"type\":\"address\"},{\"name\":\"borrower\",\"type\":\"address\"},{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"arbiter\",\"type\":\"address\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"pubKeyHash\",\"type\":\"bytes20\"},{\"name\":\"set\",\"type\":\"bool\"},{\"name\":\"accepted\",\"type\":\"bool\"},{\"name\":\"off\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"loanIndex\",\"type\":\"bytes32\"},{\"name\":\"borrower\",\"type\":\"address\"},{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"arbiter\",\"type\":\"address\"},{\"name\":\"liquidator\",\"type\":\"address\"},{\"name\":\"secretHashA\",\"type\":\"bytes32\"},{\"name\":\"secretHashB\",\"type\":\"bytes32\"},{\"name\":\"secretHashC\",\"type\":\"bytes32\"},{\"name\":\"secretHashD\",\"type\":\"bytes32\"},{\"name\":\"pubKeyHash\",\"type\":\"bytes20\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"saleIndexByLoan\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"hasSecrets\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SETTLEMENT_EXP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"},{\"name\":\"secret_\",\"type\":\"bytes32\"}],\"name\":\"provideSecret\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_UINT_256\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"off\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"},{\"name\":\"secrets_\",\"type\":\"bytes32[3]\"}],\"name\":\"provideSecretsAndAccept\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"discountBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"swapExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"arbiterSigs\",\"outputs\":[{\"name\":\"refundableSig\",\"type\":\"bytes\"},{\"name\":\"seizableSig\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"accepted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"settlementExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"},{\"name\":\"refundableSig\",\"type\":\"bytes\"},{\"name\":\"seizableSig\",\"type\":\"bytes\"}],\"name\":\"provideSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lenderSigs\",\"outputs\":[{\"name\":\"refundableSig\",\"type\":\"bytes\"},{\"name\":\"seizableSig\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"secretHashes\",\"outputs\":[{\"name\":\"secretHashA\",\"type\":\"bytes32\"},{\"name\":\"secretA\",\"type\":\"bytes32\"},{\"name\":\"secretHashB\",\"type\":\"bytes32\"},{\"name\":\"secretB\",\"type\":\"bytes32\"},{\"name\":\"secretHashC\",\"type\":\"bytes32\"},{\"name\":\"secretC\",\"type\":\"bytes32\"},{\"name\":\"secretHashD\",\"type\":\"bytes32\"},{\"name\":\"secretD\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"borrowerSigs\",\"outputs\":[{\"name\":\"refundableSig\",\"type\":\"bytes\"},{\"name\":\"seizableSig\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SWAP_EXP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"accept\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"cmul\",\"outputs\":[{\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"loans_\",\"type\":\"address\"},{\"name\":\"funds_\",\"type\":\"address\"},{\"name\":\"med_\",\"type\":\"address\"},{\"name\":\"token_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"ProvideSig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sale\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"secret_\",\"type\":\"bytes32\"}],\"name\":\"ProvideSecret\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"Accept\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"Sales","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000defdccaa8177f54eb5aeaab28cbedc21a47e8bf000000000000000000000000077e8df7f436fdb8d6d3554de02526c39104f7b04000000000000000000000000bc32048d9be3a3c3b626c44d296cefaaa400c7970000000000000000000000006b175474e89094c44da98b954eedeac495271d0f","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://7d2fc801d5c3892288aae9882c8721acae492d3ce2b48d89d3fe1de75c6f088e"}]}