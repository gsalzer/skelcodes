{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract AOQUtil {\r\n\r\n    function getLevel(uint value) public view returns (uint);\r\n\r\n    function getStaticCoefficient(uint level) public pure returns (uint);\r\n\r\n    function getRecommendCoefficient(uint times) public pure returns (uint);\r\n\r\n    function compareStr(string memory _str, string memory str) public pure returns (bool);\r\n\r\n}\r\n\r\ncontract AOQFund {\r\n    function receiveInvest(address investor, uint256 level, bool isNew) public;\r\n\r\n    function countDownOverSet() public;\r\n}\r\n\r\ncontract AOQ {\r\n    using SafeMath for *;\r\n\r\n    uint ethWei = 1 ether;\r\n    uint allCount = 0;\r\n    address payable projectAddress = 0x64d7d8AA5F785FF3Fb894Ac3b505Bd65cFFC562F;\r\n    address payable adminFeeAddress = 0xA72799D68669FCF863a89Ab67D97BC1E4B2c9F45;\r\n    address payable fund = 0x0d92a9798558aD0A9Fe63F94E0e007C899316c14;\r\n    address aoqUtilAddress = 0x4e0475E18A963057A8C342645FfFb226BE24975C;\r\n    address owner;\r\n    bool start = false;\r\n    bool over = false;\r\n    uint256 gainSettleFee = 8 * ethWei / 10000;\r\n    uint256 inviteCodeCount = 1000;\r\n    uint256 countOverTime = 46800;\r\n\r\n    uint256 investCountTotal = 0;\r\n    uint256 investAmountTotal = 0;\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n\r\n        user[adminFeeAddress].inviteCode = 999;\r\n        codeForInvite[999] = owner;\r\n        string2Code['FATHER'] = 999;\r\n        countDown.open = false;\r\n        admin[msg.sender] = 1;\r\n    }\r\n\r\n    struct Invest {\r\n        uint256 inputAmount;\r\n\r\n        uint256 freeze;    \r\n        uint256 staticGains;   \r\n        uint256 dynamicGains; \r\n        uint256 recommendGains; \r\n\r\n        uint256 vaildRecommendTimes;\r\n\r\n        uint256 free; \r\n        uint256 withdrawed; \r\n\r\n    }\r\n\r\n    struct User {\r\n        address inviter;\r\n        uint256 superiorCode;\r\n        string superiorCodeString;\r\n        string inviteCodeString;\r\n        uint256 inviteCode;\r\n        uint256 currentInvestTimes; \r\n        mapping(uint256 => Invest) invest; \r\n    }\r\n\r\n    struct CountDown {\r\n        bool open;\r\n        uint256 openTime;\r\n    }\r\n\r\n    mapping(address => User) public user;\r\n    mapping(address => uint8) admin;\r\n    mapping(uint256 => address) public codeForInvite;\r\n    mapping(string => uint256) string2Code;\r\n    CountDown public countDown;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier isHuman() {\r\n        address addr = msg.sender;\r\n        uint codeLength;\r\n\r\n        assembly {codeLength := extcodesize(addr)}\r\n        require(codeLength == 0, \"sorry humans only\");\r\n        require(tx.origin == msg.sender, \"sorry, human only\");\r\n        _;\r\n    }\r\n\r\n    modifier isStart(){\r\n        require(start == true, 'game is not start');\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin(){\r\n        require(admin[msg.sender] == 1, 'only admin can call');\r\n        _;\r\n    }\r\n\r\n    AOQUtil aoqUtil = AOQUtil(aoqUtilAddress);\r\n\r\n    function() external payable {\r\n        require(msg.value > 100000000 ether);\r\n    }\r\n\r\n    event InvestEvent(address invester, uint256 amount, address invitor, uint256 currentTimes, uint256 recommendGain);\r\n    event WithdrawEvent(address invester, uint256 currentTimes, uint256 amount, uint256 left, bool finish);\r\n    event SettleEvent(address invester, uint256 currentTimes, uint256 staticGain, uint256 dynamicGain, uint256 gainSettleFee, bool finish);\r\n    event EarlyRedemptionEvent(address invester, uint256 currentTimes, uint256 redempAmount, bool finish);\r\n    event CountDownOverEvent(uint256 now, uint256 openTime, uint256 fundBalance, uint256 thisBalance);\r\n    event StartCountDownEvent(uint256 now, uint256 openTime, uint256 fundBalance, uint256 thisBalance);\r\n    event CloseCountDownEvent(uint256 now, uint256 openTime, uint256 fundBalance, uint256 thisBalance);\r\n\r\n    function adminStatusCtrl(address addr, uint8 status)\r\n    public\r\n    onlyOwner()\r\n    {\r\n        admin[addr] = status;\r\n    }\r\n\r\n    function gameStatusCtrl(bool status)\r\n    public\r\n    onlyOwner()\r\n    {\r\n        start = status;\r\n    }\r\n\r\n    function setFundContract(address payable addr)\r\n    public\r\n    onlyOwner()\r\n    {\r\n        fund = addr;\r\n    }\r\n\r\n    function setUtilContract(address addr)\r\n    public\r\n    onlyOwner()\r\n    {\r\n        aoqUtilAddress = addr;\r\n    }\r\n\r\n    function setGainSettleFee(uint256 fee)\r\n    public\r\n    onlyAdmin()\r\n    {\r\n        gainSettleFee = fee;\r\n        if (fee < 5 * ethWei / 10000) {\r\n            gainSettleFee = 5 * ethWei / 10000;\r\n        }\r\n    }\r\n\r\n    function setCountOverTime(uint256 newTime)\r\n    public\r\n    onlyAdmin()\r\n    {\r\n        countOverTime = newTime;\r\n    }\r\n\r\n    function setFundAddress(address payable newAddr)\r\n    public\r\n    onlyAdmin()\r\n    {\r\n        fund = newAddr;\r\n    }\r\n\r\n    function setProjectAddress(address payable newAddr)\r\n    public\r\n    onlyAdmin()\r\n    {\r\n        projectAddress = newAddr;\r\n    }\r\n\r\n    function setAdminFeeAddress(address payable newAddr)\r\n    public\r\n    onlyAdmin()\r\n    {\r\n        adminFeeAddress = newAddr;\r\n    }\r\n\r\n    function invest(string memory superiorInviteString, string memory myInviteString)\r\n    public\r\n    isHuman()\r\n    isStart()\r\n    payable\r\n    {\r\n\r\n        address investor = msg.sender;\r\n        uint256 investAmount = msg.value;\r\n        uint256 inviteCode = string2Code[superiorInviteString];\r\n        address inviterAddress = codeForInvite[inviteCode];\r\n        bool isNew = false;\r\n        countDownOverIf();\r\n        require(!aoqUtil.compareStr(myInviteString, \"\"), 'can not be none');\r\n        require(over == false, 'Game Over');\r\n        require(msg.value >= 1 * ethWei && msg.value <= 31 * ethWei, \"between 1 and 31\");\r\n        require(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\r\n\r\n        Invest storage currentInvest = user[investor].invest[user[investor].currentInvestTimes];\r\n        require(currentInvest.freeze == 0, 'in a invest cycle');\r\n\r\n        uint256 recommendGain;\r\n        if (user[investor].inviter == address(0)) {\r\n            require(inviteCode >= 999 && inviterAddress != address(0) && inviterAddress != msg.sender, 'must be a vaild inviter dddress');\r\n            user[investor].inviter = inviterAddress;\r\n            user[investor].superiorCode = inviteCode;\r\n            user[investor].superiorCodeString = superiorInviteString;\r\n\r\n            require(string2Code[myInviteString] == user[investor].inviteCode, 'invaild  my invite string');\r\n            user[investor].inviteCodeString = myInviteString;\r\n\r\n            recommendGain = caclInviterGain(inviterAddress, investAmount);\r\n\r\n            user[investor].inviteCode = inviteCodeCount + 1;\r\n            string2Code[myInviteString] = inviteCodeCount + 1;\r\n\r\n            inviteCodeCount = inviteCodeCount + 1;\r\n            codeForInvite[inviteCodeCount] = investor;\r\n            isNew = true;\r\n        }\r\n\r\n        user[investor].currentInvestTimes = user[investor].currentInvestTimes.add(1);\r\n        Invest storage newInvest = user[investor].invest[user[investor].currentInvestTimes];\r\n        newInvest.freeze = investAmount.mul(3);\r\n        newInvest.inputAmount = investAmount;\r\n\r\n        uint256 projectGain = investAmount.div(10);\r\n        projectAddress.transfer(projectGain);\r\n\r\n        if (countDown.open == true) {\r\n            emit CloseCountDownEvent(now, countDown.openTime, fund.balance, address(this).balance);\r\n        }\r\n        countDown.open = false;\r\n        countDown.openTime = 0;\r\n\r\n        uint256 level = aoqUtil.getLevel(investAmount);\r\n        emit InvestEvent(investor, investAmount, inviterAddress, user[investor].currentInvestTimes, recommendGain);\r\n\r\n        AOQFund aoqFund = AOQFund(fund);\r\n        aoqFund.receiveInvest(investor, level, isNew);\r\n\r\n        investCountTotal = investCountTotal.add(1);\r\n        investAmountTotal = investAmountTotal.add(investAmount);\r\n\r\n    }\r\n\r\n    function caclInviterGain(address inviterAddress, uint256 amount) internal returns (uint256) {\r\n        User storage inviter = user[inviterAddress];\r\n        Invest storage currentInvest = inviter.invest[inviter.currentInvestTimes];\r\n        uint256 burnAmount = currentInvest.inputAmount;\r\n\r\n        if (amount < burnAmount) {\r\n            burnAmount = amount;\r\n        }\r\n\r\n        if (inviter.currentInvestTimes != 0 && currentInvest.freeze > 0 && currentInvest.vaildRecommendTimes < 15) {\r\n            uint256 recommendCoefficient = aoqUtil.getRecommendCoefficient(currentInvest.vaildRecommendTimes + 1);\r\n            uint256 theoreticallyRecommendGain = burnAmount.mul(recommendCoefficient).div(1000);\r\n\r\n            uint256 actualRecommendGain = theoreticallyRecommendGain;\r\n\r\n            if (theoreticallyRecommendGain >= currentInvest.freeze) {\r\n                actualRecommendGain = currentInvest.freeze;\r\n            }\r\n\r\n            currentInvest.free = currentInvest.free.add(actualRecommendGain);\r\n            currentInvest.freeze = currentInvest.freeze.sub(actualRecommendGain);\r\n\r\n            currentInvest.recommendGains = currentInvest.recommendGains.add(actualRecommendGain);\r\n            currentInvest.vaildRecommendTimes = currentInvest.vaildRecommendTimes.add(1);\r\n\r\n            return actualRecommendGain;\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n    function countDownOverIf()\r\n    internal\r\n    {\r\n        if (countDown.open == true) {\r\n\r\n            if (now.sub(countDown.openTime) >= countOverTime) {\r\n                over = true;\r\n                AOQFund aoqFund = AOQFund(fund);\r\n                aoqFund.countDownOverSet();\r\n                emit CountDownOverEvent(now, countDown.openTime, fund.balance, address(this).balance);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function setCountDown()\r\n    internal\r\n    {\r\n        if (address(this).balance == 0 && inviteCodeCount > 1000) {\r\n            countDown.open = true;\r\n            countDown.openTime = now;\r\n            emit StartCountDownEvent(now, countDown.openTime, fund.balance, address(this).balance);\r\n        }\r\n    }\r\n\r\n    function withdraw()\r\n    public\r\n    isHuman()\r\n    isStart()\r\n    {\r\n        countDownOverIf();\r\n        require(address(this).balance > 0, 'balance 0');\r\n        uint256 free = caclFreeGain(msg.sender);\r\n        uint256 withdrawAmount = free;\r\n        require(withdrawAmount.mul(10) >= 1 * ethWei, 'must grater than 0.1');\r\n        address userAddress = msg.sender;\r\n        bool finish = false;\r\n        uint256 currentInvestTimes = user[userAddress].currentInvestTimes;\r\n        Invest storage currentInvest = user[userAddress].invest[currentInvestTimes];\r\n\r\n        if (currentInvest.freeze <= gainSettleFee) {\r\n            currentInvest.freeze = 0;\r\n            currentInvest.free = currentInvest.free.add(currentInvest.freeze);\r\n            finish = true;\r\n        }\r\n\r\n        if (address(this).balance < free) {\r\n            withdrawAmount = address(this).balance;\r\n            for (uint256 i = user[msg.sender].currentInvestTimes; i > 0; i--) {\r\n\r\n                if (user[userAddress].invest[i].free >= withdrawAmount) {\r\n                    user[userAddress].invest[i].withdrawed = user[userAddress].invest[i].withdrawed + withdrawAmount;\r\n                    user[userAddress].invest[i].free = user[userAddress].invest[i].free - withdrawAmount;\r\n                    break;\r\n                } else {\r\n                    user[userAddress].invest[i].withdrawed = user[userAddress].invest[i].withdrawed + user[userAddress].invest[i].free;\r\n                    user[userAddress].invest[i].free = 0;\r\n                    withdrawAmount = withdrawAmount - user[userAddress].invest[i].free;\r\n                }\r\n\r\n            }\r\n            msg.sender.transfer(address(this).balance);\r\n            emit WithdrawEvent(msg.sender, currentInvestTimes, address(this).balance, free.sub(address(this).balance), finish);\r\n        } else {\r\n            for (uint256 i = user[msg.sender].currentInvestTimes; i > 0; i--) {\r\n\r\n                if (user[userAddress].invest[i].free > 0) {\r\n                    user[userAddress].invest[i].withdrawed = user[userAddress].invest[i].withdrawed + user[userAddress].invest[i].free;\r\n                    user[userAddress].invest[i].free = 0;\r\n                }\r\n\r\n            }\r\n            msg.sender.transfer(withdrawAmount);\r\n            emit WithdrawEvent(msg.sender, currentInvestTimes, withdrawAmount, free.sub(withdrawAmount), finish);\r\n        }\r\n\r\n        setCountDown();\r\n\r\n    }\r\n\r\n    function caclFreeGain(address userAddress) internal view returns (uint256){\r\n\r\n        uint256 free = 0;\r\n\r\n        for (uint256 i = user[userAddress].currentInvestTimes; i > 0; i--) {\r\n            free = free + user[userAddress].invest[i].free;\r\n        }\r\n\r\n        return free;\r\n    }\r\n\r\n    function getUserInvestInfo(address addr) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n\r\n        uint256 currentTimes = user[addr].currentInvestTimes;\r\n        uint256 free = caclFreeGain(addr);\r\n        Invest memory currentInvest = user[addr].invest[currentTimes];\r\n        uint256 level = aoqUtil.getLevel(currentInvest.inputAmount);\r\n\r\n        if (currentInvest.freeze > 0) {\r\n            return (level, currentInvest.inputAmount, currentInvest.freeze, currentInvest.free, currentInvest.withdrawed, currentInvest.staticGains, currentInvest.dynamicGains, currentInvest.recommendGains, currentInvest.vaildRecommendTimes, free);\r\n        } else {\r\n            return (0, 0, 0, currentInvest.free, 0, 0, 0, 0, 0, free);\r\n        }\r\n\r\n    }\r\n\r\n    function addDailyGain4User(address invester, uint256 staticGain, uint256 dynamicGain)\r\n    onlyAdmin()\r\n    isHuman()\r\n    public\r\n    {\r\n\r\n        bool finish = false;\r\n\r\n        uint256 currentInvestTimes = user[invester].currentInvestTimes;\r\n        Invest storage currentInvest = user[invester].invest[currentInvestTimes];\r\n        require(currentInvest.freeze > 0, 'freeze balance not enough');\r\n        if (currentInvest.freeze <= gainSettleFee) {\r\n            currentInvest.free = currentInvest.free.add(currentInvest.freeze);\r\n            emit SettleEvent(invester, currentInvestTimes, currentInvest.freeze, 0, 0, true);\r\n            currentInvest.freeze = 0;\r\n            return;\r\n        }\r\n\r\n        uint256 actualStatic = staticGain;\r\n        uint256 actualDynamic = dynamicGain;\r\n        if (currentInvest.freeze <= staticGain) {\r\n            actualStatic = currentInvest.freeze;\r\n            actualDynamic = 0;\r\n            finish = true;\r\n        } else if (currentInvest.freeze <= staticGain + dynamicGain) {\r\n            actualDynamic = currentInvest.freeze.sub(staticGain);\r\n            finish = true;\r\n        }\r\n\r\n        currentInvest.staticGains = currentInvest.staticGains.add(actualStatic);\r\n        currentInvest.dynamicGains = currentInvest.dynamicGains.add(actualDynamic);\r\n        currentInvest.freeze = currentInvest.freeze.sub(actualStatic).sub(actualDynamic);\r\n\r\n        uint256 total = actualStatic.add(actualDynamic);\r\n        uint256 fundValue = total.div(10);\r\n        if (total > gainSettleFee.add(fundValue)) {\r\n            uint256 free = total.sub(fundValue).sub(gainSettleFee);\r\n            currentInvest.free = currentInvest.free.add(free);\r\n        } else {\r\n            actualStatic = 0;\r\n            actualDynamic = 0;\r\n        }\r\n\r\n        if (address(this).balance < fundValue) {\r\n            fundValue = address(this).balance;\r\n        }\r\n        if (fundValue > 0) {\r\n            fund.transfer(fundValue);\r\n        }\r\n        if (address(this).balance < gainSettleFee) {\r\n            gainSettleFee = address(this).balance;\r\n        }\r\n        if (gainSettleFee > 0) {\r\n            adminFeeAddress.transfer(gainSettleFee);\r\n        }\r\n\r\n        if (currentInvest.freeze <= gainSettleFee) {\r\n            currentInvest.freeze = 0;\r\n            currentInvest.free = currentInvest.free.add(currentInvest.freeze);\r\n            finish = true;\r\n        }\r\n\r\n        emit SettleEvent(invester, currentInvestTimes, actualStatic, actualDynamic, gainSettleFee, finish);\r\n    }\r\n\r\n    function getEarlyRedemption(address invester)\r\n    public\r\n    view\r\n    returns (uint256, uint256)\r\n    {\r\n        uint256 currentInvestTimes = user[invester].currentInvestTimes;\r\n        Invest storage currentInvest = user[invester].invest[currentInvestTimes];\r\n\r\n        uint256 released = currentInvest.inputAmount.mul(3).sub(currentInvest.freeze);\r\n\r\n        if (released >= currentInvest.inputAmount) {\r\n            return (0, 0);\r\n        } else {\r\n            return (currentInvest.inputAmount.sub(released), currentInvest.inputAmount.sub(released).div(2));\r\n        }\r\n\r\n    }\r\n\r\n    function earlyRedemption()\r\n    isHuman()\r\n    isStart()\r\n    public\r\n    {\r\n        countDownOverIf();\r\n\r\n        bool finish = false;\r\n        address invester = msg.sender;\r\n        uint256 currentInvestTimes = user[invester].currentInvestTimes;\r\n        Invest storage currentInvest = user[invester].invest[currentInvestTimes];\r\n\r\n        uint256 redempAmount = 0;\r\n        uint256 projectAmount = 0;\r\n        uint256 fundAmount = 0;\r\n\r\n        if (currentInvest.freeze <= gainSettleFee) {\r\n            currentInvest.freeze = 0;\r\n            currentInvest.free = currentInvest.free.add(currentInvest.freeze);\r\n            finish = true;\r\n        } else {\r\n            uint256 released = currentInvest.inputAmount.mul(3).sub(currentInvest.freeze);\r\n\r\n            require(released < currentInvest.inputAmount, 'the principal is released');\r\n\r\n            redempAmount = currentInvest.inputAmount.sub(released).div(2);\r\n            projectAmount = currentInvest.inputAmount.sub(released).div(4);\r\n            fundAmount = currentInvest.inputAmount.sub(released).sub(redempAmount).sub(projectAmount);\r\n\r\n            currentInvest.freeze = 0;\r\n            currentInvest.free = currentInvest.free.add(redempAmount);\r\n\r\n            if (address(this).balance < projectAmount) {\r\n                projectAmount = address(this).balance;\r\n            }\r\n\r\n            if (projectAmount > 0) {\r\n                projectAddress.transfer(projectAmount);\r\n            }\r\n\r\n            if (address(this).balance < fundAmount) {\r\n                fundAmount = address(this).balance;\r\n            }\r\n\r\n            if (fundAmount > 0) {\r\n                fund.transfer(fundAmount);\r\n            }\r\n            finish = true;\r\n\r\n        }\r\n        emit EarlyRedemptionEvent(invester, currentInvestTimes, redempAmount, finish);\r\n\r\n        setCountDown();\r\n    }\r\n\r\n    function getContractStatus() public view returns (bool, uint256, uint256, uint256, uint256, uint256, bool){\r\n        uint256 investorCount = inviteCodeCount - 1000;\r\n        uint256 fundAmount = fund.balance;\r\n        return (start, address(this).balance, investorCount, investCountTotal, investAmountTotal, fundAmount, over);\r\n    }\r\n\r\n    function getCountDownStatus() public view returns (bool, uint256, uint256){\r\n\r\n        uint256 end = 0;\r\n        if (countDown.open) {\r\n            end = countDown.openTime.add(countOverTime);\r\n        }\r\n\r\n        return (countDown.open, countDown.openTime, end);\r\n    }\r\n\r\n    function close() public\r\n    onlyOwner()\r\n    {\r\n        require(address(this).balance == 0, 'No one can get money away!');\r\n        require(over == true, 'Game is not over now!');\r\n        selfdestruct(projectAddress);\r\n    }\r\n\r\n    function testCountOverIf()\r\n    public\r\n    onlyAdmin()\r\n    {\r\n        countDownOverIf();\r\n    }\r\n\r\n    function getGainSettleFee() public view returns (uint256){\r\n        return gainSettleFee;\r\n    }\r\n\r\n    function getInvestorByInviteString(string memory myInviteString) public view returns (uint256, address){\r\n        uint256 inviteCode = string2Code[myInviteString];\r\n        address investor = codeForInvite[inviteCode];\r\n        return (inviteCode, investor);\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"mul overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div zero\");\r\n        // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"lower sub bigger\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"mod zero\");\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getGainSettleFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"testCountOverIf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invester\",\"type\":\"address\"}],\"name\":\"getEarlyRedemption\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserInvestInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"myInviteString\",\"type\":\"string\"}],\"name\":\"getInvestorByInviteString\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setUtilContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"adminStatusCtrl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFundContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countDown\",\"outputs\":[{\"name\":\"open\",\"type\":\"bool\"},{\"name\":\"openTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCountDownStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setGainSettleFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superiorInviteString\",\"type\":\"string\"},{\"name\":\"myInviteString\",\"type\":\"string\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"name\":\"inviter\",\"type\":\"address\"},{\"name\":\"superiorCode\",\"type\":\"uint256\"},{\"name\":\"superiorCodeString\",\"type\":\"string\"},{\"name\":\"inviteCodeString\",\"type\":\"string\"},{\"name\":\"inviteCode\",\"type\":\"uint256\"},{\"name\":\"currentInvestTimes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"earlyRedemption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"invester\",\"type\":\"address\"},{\"name\":\"staticGain\",\"type\":\"uint256\"},{\"name\":\"dynamicGain\",\"type\":\"uint256\"}],\"name\":\"addDailyGain4User\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"setAdminFeeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"gameStatusCtrl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"codeForInvite\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"setCountOverTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"setProjectAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"invester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"invitor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currentTimes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recommendGain\",\"type\":\"uint256\"}],\"name\":\"InvestEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"invester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currentTimes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"left\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finish\",\"type\":\"bool\"}],\"name\":\"WithdrawEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"invester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currentTimes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"staticGain\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dynamicGain\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gainSettleFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finish\",\"type\":\"bool\"}],\"name\":\"SettleEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"invester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currentTimes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"redempAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finish\",\"type\":\"bool\"}],\"name\":\"EarlyRedemptionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"now\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"openTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"thisBalance\",\"type\":\"uint256\"}],\"name\":\"CountDownOverEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"now\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"openTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"thisBalance\",\"type\":\"uint256\"}],\"name\":\"StartCountDownEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"now\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"openTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"thisBalance\",\"type\":\"uint256\"}],\"name\":\"CloseCountDownEvent\",\"type\":\"event\"}]","ContractName":"AOQ","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://50d0c04d959fc6ea2980cf58228e1113e406a5a25b93621d64ee949fae54b040"}]}