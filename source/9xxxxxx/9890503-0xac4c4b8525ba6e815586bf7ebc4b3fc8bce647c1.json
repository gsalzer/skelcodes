{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.1 <0.6.0;\r\n\r\ninterface RecommendSmallTeamInterface {\r\n\r\n        function API_AppendAchievement( address owner, uint value ) external;\r\n\r\n        function API_DivestmentAchievement( address owner, uint value) external;\r\n\r\n        function AchievementValueOf( address owner ) external view returns (uint);\r\n\r\n        function AchievementDistributionOf( address owner) external view returns (uint totalSum, uint large, uint len, address[] memory addrs, uint[] memory values);\r\n\r\n        function AchievementDynamicValue( address owner) external view returns ( uint );\r\n\r\n        function GetIntroducer( address _owner ) external view returns (address);\r\n\r\n        function RecommendList( address _owner, uint256 depth ) external view returns ( address[] memory list, uint256 len );\r\n\r\n        function ShortCodeToAddress( bytes6 shortCode ) external view returns (address);\r\n\r\n        function AddressToShortCode( address _addr ) external view returns (bytes6);\r\n\r\n        function TeamMemberTotal( address _addr ) external view returns (uint256);\r\n\r\n        function RegisterShortCode( bytes6 shortCode ) external;\r\n\r\n        function BindRelation(address _recommer ) external;\r\n\r\n            function BindRelationEx(address _recommer, bytes6 shortCode ) external;\r\n\r\n    function AddressesCount() external view returns (uint);\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\ncontract KState {\r\n\r\n    address private _KDeveloper;\r\n    address internal _KIMPLAddress;\r\n\r\n    address[] _KAuthAddress;\r\n    address payable public _KDefaultReciver;\r\n\r\n    address payable[] public _KContractOwners = [\r\n        address(0x4ad16f3f6B4C1C48C644756979f96bcd0bfa077B)    ];\r\n\r\n    bool public _KContractBroken;\r\n    mapping (address => bool) _KWithdrawabledAddress;\r\n\r\n    constructor() public {\r\n\r\n        _KDeveloper = msg.sender;\r\n\r\n        _KContractOwners.push(msg.sender);\r\n\r\n        _KDefaultReciver = msg.sender;\r\n    }\r\n\r\n    modifier KWhenBroken() {\r\n        require(_KContractBroken); _;\r\n    }\r\n\r\n    modifier KWhenNotBroken() {\r\n        require(!_KContractBroken); _;\r\n    }\r\n\r\n    modifier KOwnerOnly() {\r\n\r\n        bool exist = false;\r\n\r\n        for ( uint i = 0; i < _KContractOwners.length; i++ ) {\r\n            if ( _KContractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function KSetContractBroken(bool broken) external KOwnerOnly {\r\n        _KContractBroken = broken;\r\n    }\r\n\r\n    modifier KDAODefense() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \"DAO_Warning\" );\r\n        _;\r\n    }\r\n\r\n    modifier KAPIMethod() {\r\n\r\n        bool exist = false;\r\n\r\n        for (uint i = 0; i < _KAuthAddress.length; i++) {\r\n            if ( _KAuthAddress[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function KAuthAddresses() external view returns (address[] memory authAddr) {\r\n        return _KAuthAddress;\r\n    }\r\n\r\n    function KAddAuthAddress(address _addr) external KOwnerOnly {\r\n        _KAuthAddress.push(_addr);\r\n    }\r\n\r\n    modifier KDeveloperOnly {\r\n        require(msg.sender == _KDeveloper); _;\r\n    }\r\n\r\n    function KSetImplAddress(address impl) external KDeveloperOnly {\r\n        _KIMPLAddress = impl;\r\n    }\r\n\r\n    function KGetImplAddress() external view KDeveloperOnly returns (address) {\r\n        return _KIMPLAddress;\r\n    }\r\n\r\n}\r\n\r\ncontract KDoctor is KState {\r\n    modifier write {_;}\r\n}\r\n\r\ncontract KContract is KState {\r\n\r\n    modifier write {\r\n\r\n        if ( _KIMPLAddress != address(0x0) ) {\r\n\r\n            (, bytes memory ret) = address(_KIMPLAddress).delegatecall(msg.data);\r\n\r\n            assembly {\r\n                return( add(ret, 0x20), mload(ret) )\r\n            }\r\n\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https:     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\npragma solidity >=0.4.22 <0.7.0;\r\n\r\nlibrary Times {\r\n\r\n    function Now() public view returns (uint) {\r\n                return now;\r\n    }\r\n\r\n    function OneDay() public pure returns (uint256) {\r\n        return 1 days;\r\n    }\r\n\r\n    function OneMonth() public pure returns (uint256) {\r\n        return 30 * OneDay();\r\n    }\r\n\r\n        function TodayZeroGMT8() public view returns (uint256) {\r\n        return Now() / OneDay() * OneDay();\r\n    }\r\n\r\n    function DayZeroGMT8(uint gmtTime) public pure returns (uint256) {\r\n                return gmtTime / OneDay() * OneDay();\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\n\r\nlibrary ValueQueue {\r\n\r\n    struct Queue {\r\n\r\n        uint40[] times;\r\n\r\n        mapping(uint40 => uint144) stateMapping;\r\n    }\r\n\r\n    function LastTime( Queue storage self ) internal view returns ( uint40 ) {\r\n\r\n        if ( self.times.length <= 0 ) {\r\n            return 0;\r\n        }\r\n\r\n        return uint40(self.times[self.times.length - 1]);\r\n    }\r\n\r\n    function Last( Queue storage self ) internal view returns ( uint ) {\r\n        return uint(self.stateMapping[uint40(LastTime(self))]);\r\n    }\r\n\r\n    function Add( Queue storage self, uint amount ) internal {\r\n\r\n        uint40 nowDayTime = uint40(Times.TodayZeroGMT8());\r\n\r\n        if ( LastTime(self) != nowDayTime ) {\r\n\r\n            self.stateMapping[ nowDayTime ] = self.stateMapping[ uint40(LastTime(self)) ];\r\n\r\n            self.times.push( nowDayTime );\r\n        }\r\n\r\n        self.stateMapping[ uint40(LastTime(self)) ] += uint144(amount);\r\n    }\r\n\r\n    function Set( Queue storage self, uint amount) internal {\r\n\r\n        uint40 nowDayTime = uint40(Times.TodayZeroGMT8());\r\n\r\n        if ( LastTime(self) != nowDayTime ) {\r\n\r\n            self.stateMapping[ nowDayTime ] = self.stateMapping[ LastTime(self) ];\r\n\r\n            self.times.push( nowDayTime );\r\n        }\r\n\r\n        self.stateMapping[ LastTime(self) ] = uint144(amount);\r\n    }\r\n\r\n    function Sub( Queue storage self, uint256 amount ) internal {\r\n\r\n        require( self.stateMapping[ LastTime(self) ] >= amount );\r\n\r\n        uint40 nowDayTime = uint40(Times.TodayZeroGMT8());\r\n\r\n        if ( LastTime(self) != nowDayTime ) {\r\n\r\n            self.stateMapping[ nowDayTime ] = self.stateMapping[ LastTime(self) ];\r\n\r\n            self.times.push( nowDayTime );\r\n        }\r\n\r\n        self.stateMapping[ LastTime(self) ] -= uint144(amount);\r\n    }\r\n\r\n    function Nearest(Queue storage self, uint time ) internal view returns ( uint ) {\r\n\r\n        uint dayzeroTime = Times.DayZeroGMT8(time);\r\n\r\n        require( dayzeroTime > 0 );\r\n\r\n        for ( int i = int(self.times.length) - 1; i >= 0; i-- ) {\r\n\r\n            if ( self.times[uint(i)] <= dayzeroTime ) {\r\n                return self.stateMapping[self.times[uint(i)]];\r\n            }\r\n\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function NearestAtDeadLine(Queue storage self, uint time, uint deadLineTime ) internal view returns ( uint ) {\r\n\r\n        uint dayzeroTime = Times.DayZeroGMT8(time);\r\n\r\n        if ( dayzeroTime <= deadLineTime ) {\r\n            return 0;\r\n        }\r\n\r\n        require( dayzeroTime > 0 );\r\n\r\n        for ( int i = int(self.times.length) - 1; i >= 0; i-- ) {\r\n\r\n            if ( self.times[uint(i)] < dayzeroTime ) {\r\n                return self.stateMapping[self.times[uint(i)]];\r\n            }\r\n\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\n\r\n\r\nlibrary DepositedPool {\r\n\r\n    using ValueQueue for ValueQueue.Queue;\r\n\r\n    event LogDepositedChanged(address indexed owner, int amount, uint time);\r\n\r\n    struct MainDB {\r\n        uint relaseTime;\r\n        mapping(address => ValueQueue.Queue) depositMapping;\r\n    }\r\n\r\n    function Init(MainDB storage self) internal {\r\n        self.relaseTime = Times.TodayZeroGMT8();\r\n    }\r\n\r\n    function DepositedAmount(MainDB storage self, address owner, uint nearestTime) internal view returns (uint) {\r\n        return self.depositMapping[owner].NearestAtDeadLine(nearestTime, self.relaseTime);\r\n    }\r\n\r\n    function LatestAmount(MainDB storage self, address owner) internal view returns (uint) {\r\n        return self.depositMapping[owner].Last();\r\n    }\r\n\r\n    function DepositedSubDelegate(MainDB storage self, address owner, uint256 amount) internal {\r\n\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        self.depositMapping[owner].Sub( amount );\r\n\r\n        emit LogDepositedChanged(owner, int(amount), Times.Now());\r\n    }\r\n\r\n    function DepositedAddDelegate(MainDB storage self, address owner, uint256 amount) internal {\r\n\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        self.depositMapping[owner].Add( amount );\r\n\r\n        emit LogDepositedChanged(owner, -int(amount), Times.Now());\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\n\r\nlibrary Distribution {\r\n\r\n    struct MainDB {\r\n\r\n        uint relaseTime;\r\n\r\n                uint SectionSpace;\r\n        uint SectionSpaceMaxLimit;\r\n\r\n                mapping(uint => uint) sectionDistributionMapping;\r\n\r\n                        mapping(uint => uint) calculationValues;\r\n\r\n                mapping(uint => uint32[]) distributionEverDays;\r\n\r\n        uint count;\r\n    }\r\n\r\n    function Init(MainDB storage self) internal {\r\n\r\n        self.relaseTime = Times.TodayZeroGMT8();\r\n\r\n                self.SectionSpace = 100 ether;\r\n        self.SectionSpaceMaxLimit = 20000 ether;\r\n    }\r\n\r\n    function DepositChangeDelegate(MainDB storage self, uint oldAmount, uint newAmount) internal {\r\n\r\n                if ( oldAmount >= self.SectionSpaceMaxLimit && newAmount >= self.SectionSpaceMaxLimit ) {\r\n            return ;\r\n        }\r\n\r\n                if ( oldAmount > 0 ) {\r\n\r\n            uint spaceIdx;\r\n\r\n            if ( oldAmount >= self.SectionSpaceMaxLimit ) {\r\n                spaceIdx = self.SectionSpaceMaxLimit / self.SectionSpace;\r\n\r\n            } else {\r\n                spaceIdx = oldAmount / self.SectionSpace;\r\n            }\r\n\r\n            if ( spaceIdx > 0 ) {\r\n                --self.sectionDistributionMapping[spaceIdx];\r\n            }\r\n        }\r\n\r\n                if ( newAmount > 0 )  {\r\n\r\n            uint spaceIdx;\r\n\r\n            if ( newAmount >= self.SectionSpaceMaxLimit ) {\r\n                spaceIdx = self.SectionSpaceMaxLimit / self.SectionSpace;\r\n\r\n            } else {\r\n                spaceIdx = newAmount / self.SectionSpace;\r\n            }\r\n\r\n            if ( spaceIdx > 0 ) {\r\n                ++self.sectionDistributionMapping[spaceIdx];\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function DistributionInfo(MainDB storage self, uint offset, uint size)\r\n    internal view\r\n    returns (\r\n        uint len,\r\n        uint[] memory spaceIdxs,\r\n        uint[] memory spaceSums\r\n    ) {\r\n        len = size;\r\n        spaceIdxs = new uint[](len);\r\n        spaceSums = new uint[](len);\r\n\r\n        for ( (uint i, uint s) = (0, offset); s < offset + len; (s++, i++) ) {\r\n\r\n            spaceIdxs[i] = s;\r\n\r\n            spaceSums[i] = self.sectionDistributionMapping[s];\r\n        }\r\n\r\n    }\r\n\r\n    function UpdateCalculationValue( MainDB storage self ) internal {\r\n\r\n        uint targetDay = Times.TodayZeroGMT8() + Times.OneDay();\r\n\r\n        if ( self.calculationValues[targetDay] == 0 && targetDay > self.relaseTime ) {\r\n\r\n            uint orderID = 1;\r\n            uint ret = 0;\r\n            uint len = (self.SectionSpaceMaxLimit / self.SectionSpace) + 1;\r\n            uint32[] memory tempDsitribution = new uint32[](len);\r\n\r\n                        tempDsitribution[0] = uint32(self.sectionDistributionMapping[0]);\r\n\r\n            for ( uint i = 1; i < len; i++ ) {\r\n\r\n                if ( self.sectionDistributionMapping[i] > 0 ) {\r\n\r\n                    tempDsitribution[i] = uint32(orderID);\r\n\r\n                    ret += orderID * self.sectionDistributionMapping[i];\r\n\r\n                    orderID += self.sectionDistributionMapping[i];\r\n                }\r\n\r\n            }\r\n\r\n            self.distributionEverDays[ targetDay ] = tempDsitribution;\r\n            self.calculationValues[ targetDay ] = ret;\r\n        }\r\n\r\n    }\r\n\r\n    function CalculationValueAtDay( MainDB storage self, uint nearestTime) internal view returns (uint) {\r\n\r\n        uint targetDay = Times.DayZeroGMT8(nearestTime);\r\n\r\n        if ( targetDay <= self.relaseTime ) {\r\n            return 0;\r\n        }\r\n\r\n        return self.calculationValues[targetDay];\r\n    }\r\n\r\n    function CalculationQuickValueAtDay( MainDB storage self, uint nearestTime, uint epaceIndex) internal view returns (uint) {\r\n\r\n                uint targetDay = Times.DayZeroGMT8(nearestTime);\r\n\r\n        if ( self.distributionEverDays[targetDay].length != 0  ) {\r\n            return self.distributionEverDays[targetDay][epaceIndex];\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory c) {\r\n\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n\r\n        while (i != 0){\r\n            bstr[k--] = byte( uint8(48 + i % 10) );\r\n            i /= 10;\r\n        }\r\n        c = string(bstr);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\r\n\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n\r\n        string memory ret = new string(_ba.length + _bb.length + 1);\r\n\r\n        bytes memory bret = bytes(ret);\r\n\r\n        uint k = 0;\r\n\r\n        for (uint i = 0; i < _ba.length; i++){\r\n            bret[k++] = _ba[i];\r\n        }\r\n\r\n        bret[k++] = '/';\r\n\r\n        for (uint i = 0; i < _bb.length; i++) {\r\n            bret[k++] = _bb[i];\r\n        }\r\n\r\n        return string(ret);\r\n   }\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\n\r\nlibrary RelaseCalculator {\r\n\r\n    struct MainDB {\r\n\r\n                uint relaseTime;\r\n\r\n                uint relaseMonthCount;\r\n\r\n                uint currentBoundsAmount;\r\n\r\n                uint relaseAmountEverMonth;\r\n\r\n                uint latestCalculatorTimes;\r\n    }\r\n\r\n    function Init(MainDB storage self) internal {\r\n\r\n        self.relaseTime = Times.TodayZeroGMT8();\r\n        self.currentBoundsAmount = 10000000 ether;\r\n        self.relaseAmountEverMonth = 1000000 ether;\r\n        self.relaseMonthCount = 0;\r\n        self.latestCalculatorTimes = Times.TodayZeroGMT8();\r\n\r\n    }\r\n\r\n        function P(uint mc) internal pure returns (uint) {\r\n\r\n                if ( mc < 7 ) { return 10; }\r\n\r\n                else if ( mc >= 7 && mc < 19 ) { return 8;}\r\n\r\n                else if ( mc >= 19 && mc < 43) { return 5;}\r\n\r\n                else if ( mc >= 43 && mc < 80) { return 3;}\r\n\r\n                else { return 2; }\r\n\r\n    }\r\n\r\n        function IsExpirationBounds(MainDB storage self) internal view returns (bool) {\r\n                return Times.TodayZeroGMT8() - self.latestCalculatorTimes <= Times.OneMonth();\r\n    }\r\n\r\n        function CurrentRelaseAmountMonth(MainDB storage self) internal view returns (uint) {\r\n        return self.relaseAmountEverMonth;\r\n    }\r\n\r\n        function CurrentRelaseAmountDay(MainDB storage self) internal view returns (uint) {\r\n        return self.relaseAmountEverMonth / ( Times.OneMonth() / Times.OneDay() );\r\n    }\r\n\r\n    function UpdateBounds(MainDB storage self) internal {\r\n\r\n        if ( IsExpirationBounds(self) ) {\r\n\r\n                        uint relaseMonthCount = (Times.TodayZeroGMT8() - self.relaseTime) / Times.OneMonth();\r\n\r\n            for ( uint i = self.relaseMonthCount; i < relaseMonthCount; i++ ) {\r\n\r\n                                self.currentBoundsAmount = self.currentBoundsAmount + self.relaseAmountEverMonth;\r\n\r\n                                self.relaseAmountEverMonth = self.currentBoundsAmount * P(i+1) / 100;\r\n            }\r\n\r\n                        self.latestCalculatorTimes = Times.TodayZeroGMT8();\r\n            self.relaseMonthCount = relaseMonthCount;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary StaticRelaseManager {\r\n\r\n    using DepositedPool for DepositedPool.MainDB;\r\n    using Distribution for Distribution.MainDB;\r\n    using RelaseCalculator for RelaseCalculator.MainDB;\r\n\r\n    struct MainDB {\r\n\r\n                mapping(address => uint) latestWithdrawTimes;\r\n\r\n        ERC20Interface erc20Inc;\r\n\r\n        address assertPool;\r\n    }\r\n\r\n    function Init(MainDB storage self, ERC20Interface erc20, address assertPool) internal {\r\n        self.erc20Inc = erc20;\r\n        self.assertPool = assertPool;\r\n    }\r\n\r\n        function initFirstDepositedTime(MainDB storage self, address owner ) internal {\r\n\r\n        if ( self.latestWithdrawTimes[owner] == 0 ) {\r\n            self.latestWithdrawTimes[owner] = Times.TodayZeroGMT8();\r\n        }\r\n    }\r\n\r\n        event LogStaticRelaseDay( address indexed owner, uint indexed dayTime, uint profix );\r\n\r\n        function WithdrawCurrentRealseProfix(\r\n        MainDB storage self,\r\n        DepositedPool.MainDB storage depositPool,\r\n        Distribution.MainDB storage distribution,\r\n        RelaseCalculator.MainDB storage relaser,\r\n        address owner,\r\n                        uint endTime\r\n    ) internal {\r\n\r\n        (\r\n            uint sum,\r\n            uint len,\r\n            uint[] memory dayTimes,\r\n            uint[] memory profixs\r\n\r\n        ) = CurrentRelaseProfix(\r\n\r\n            self, depositPool,\r\n            distribution,\r\n            relaser,\r\n            owner,\r\n            endTime\r\n\r\n        );\r\n\r\n                require( sum > 0, \"NoProfix\" );\r\n\r\n                self.erc20Inc.transferFrom( self.assertPool, owner, sum );\r\n\r\n                for (uint i = 0; i < len; i++) {\r\n            emit LogStaticRelaseDay( owner, dayTimes[i], profixs[i] );\r\n        }\r\n\r\n                self.latestWithdrawTimes[owner] += len * Times.OneDay();\r\n    }\r\n\r\n        function CurrentRelaseProfix(\r\n        MainDB storage self,\r\n        DepositedPool.MainDB storage depositPool,\r\n        Distribution.MainDB storage distribution,\r\n        RelaseCalculator.MainDB storage relaser,\r\n        address owner,\r\n                        uint endTime\r\n    )\r\n    internal view returns (\r\n        uint sum,\r\n        uint len,\r\n        uint[] memory dayTimes,\r\n        uint[] memory profixs\r\n    ) {\r\n\r\n        uint ltime = self.latestWithdrawTimes[owner];\r\n\r\n                if ( Times.DayZeroGMT8(endTime) - Times.OneDay() < ltime ) {\r\n\r\n            sum = 0;\r\n            len = 0;\r\n            dayTimes = new uint[](0);\r\n            profixs = new uint[](0);\r\n\r\n            return (sum, len, dayTimes, profixs);\r\n        }\r\n\r\n        len = (Times.DayZeroGMT8(endTime) - Times.OneDay() - ltime) / Times.OneDay();\r\n\r\n        dayTimes = new uint[](len);\r\n        profixs = new uint[](len);\r\n\r\n                for ( uint i = 0; i < len; i++) {\r\n\r\n            ltime += Times.OneDay();\r\n\r\n                        dayTimes[i] = ltime;\r\n\r\n                        profixs[i] = ProfixHandle( depositPool, distribution, relaser, owner, dayTimes[i] );\r\n\r\n                        sum += profixs[i];\r\n        }\r\n    }\r\n\r\n    function ProfixHandle (\r\n        DepositedPool.MainDB storage depositPool,\r\n        Distribution.MainDB storage distribution,\r\n        RelaseCalculator.MainDB storage relaser,\r\n        address owner,\r\n        uint dayZero\r\n    )\r\n    internal view returns (uint) {\r\n\r\n                uint ps = distribution.CalculationValueAtDay(dayZero + Times.OneDay());\r\n        if ( ps == 0 ) {\r\n            return 0;\r\n        }\r\n\r\n                uint dayDeposit = depositPool.DepositedAmount( owner, dayZero );\r\n\r\n                uint spaceIdx;\r\n        if ( dayDeposit >= distribution.SectionSpaceMaxLimit ) {\r\n            spaceIdx = distribution.SectionSpaceMaxLimit / distribution.SectionSpace;\r\n        } else {\r\n            spaceIdx = dayDeposit / distribution.SectionSpace;\r\n        }\r\n\r\n        if ( spaceIdx == 0 ) {\r\n            return 0;\r\n        }\r\n\r\n                uint qvalue = distribution.CalculationQuickValueAtDay(dayZero + Times.OneDay(), spaceIdx);\r\n        return relaser.CurrentRelaseAmountDay() / 2 * (qvalue * 1 ether / ps) / 1 ether;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory c) {\r\n\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n\r\n        while (i != 0){\r\n            bstr[k--] = byte( uint8(48 + i % 10) );\r\n            i /= 10;\r\n        }\r\n        c = string(bstr);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\r\n\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n\r\n        string memory ret = new string(_ba.length + _bb.length + 1);\r\n\r\n        bytes memory bret = bytes(ret);\r\n\r\n        uint k = 0;\r\n\r\n        for (uint i = 0; i < _ba.length; i++){\r\n            bret[k++] = _ba[i];\r\n        }\r\n\r\n        bret[k++] = '/';\r\n\r\n        for (uint i = 0; i < _bb.length; i++) {\r\n            bret[k++] = _bb[i];\r\n        }\r\n\r\n        return string(ret);\r\n   }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary DynamicRelaseManager {\r\n\r\n    using ValueQueue for ValueQueue.Queue;\r\n    using RelaseCalculator for RelaseCalculator.MainDB;\r\n\r\n    struct MainDB {\r\n\r\n                mapping(address => ValueQueue.Queue) addressValuesMapping;\r\n\r\n                mapping(address => uint) latestWithdrawTimes;\r\n\r\n                uint currentSumValue;\r\n\r\n                ValueQueue.Queue totalSumValues;\r\n\r\n                RecommendSmallTeamInterface rcmInc;\r\n\r\n        ERC20Interface erc20Inc;\r\n\r\n        address assertPool;\r\n    }\r\n\r\n        event LogDynamicRelaseDay( address indexed owner, uint indexed dayTime, uint profix );\r\n\r\n    function Init(MainDB storage self, RecommendSmallTeamInterface rcm, ERC20Interface erc20, address assertPool) internal {\r\n        self.rcmInc = rcm;\r\n        self.erc20Inc = erc20;\r\n        self.assertPool = assertPool;\r\n    }\r\n\r\n        function initFirstDepositedTime( MainDB storage self, address owner ) internal {\r\n        if ( self.latestWithdrawTimes[owner] == 0 ) {\r\n            self.latestWithdrawTimes[owner] = Times.TodayZeroGMT8();\r\n        }\r\n    }\r\n\r\n        function UpdateDynamicTotalSum(MainDB storage self) internal {\r\n        if ( self.totalSumValues.Nearest( Times.TodayZeroGMT8() ) == 0 ) {\r\n            self.totalSumValues.Set(self.currentSumValue);\r\n        }\r\n    }\r\n\r\n        function UpdateOwnerDynmicValue(MainDB storage self, address owner, uint d)\r\n    internal {\r\n\r\n                address parent = self.rcmInc.GetIntroducer(owner);\r\n        if ( parent == address(0x0) || parent == address(0xdead) ) {\r\n            return ;\r\n        }\r\n\r\n                        uint origin_p = self.addressValuesMapping[parent].Nearest(Times.Now());\r\n\r\n                uint new_p = self.rcmInc.AchievementDynamicValue(parent);\r\n\r\n                uint tvalue = self.currentSumValue;\r\n\r\n        for (\r\n            uint16 depth = 0;\r\n            (parent != address(0x0) && parent != address(0xdead)) && (depth < d || d == 0);\r\n            (parent = self.rcmInc.GetIntroducer(parent), depth++)\r\n        ) {\r\n                        if ( new_p > origin_p ) {\r\n\r\n                                tvalue += (new_p - origin_p);\r\n\r\n                                self.addressValuesMapping[parent].Add( new_p - origin_p );\r\n\r\n            } else if ( new_p < origin_p && tvalue > (origin_p - new_p)) {\r\n\r\n                tvalue -= (origin_p - new_p);\r\n\r\n                                self.addressValuesMapping[parent].Sub( origin_p - new_p );\r\n\r\n            }\r\n        }\r\n\r\n                self.totalSumValues.Set(tvalue);\r\n        self.currentSumValue = tvalue;\r\n    }\r\n\r\n        function DynamicValueOf(MainDB storage self, address owner, uint nearestTime)\r\n    internal view\r\n    returns (uint) {\r\n        return self.addressValuesMapping[owner].Nearest(nearestTime);\r\n    }\r\n\r\n    function DynamicTotalValueOf(MainDB storage self, uint nearestTime)\r\n    internal view\r\n    returns (uint) {\r\n        return self.totalSumValues.Nearest(nearestTime);\r\n    }\r\n\r\n    function ProfixHandle(\r\n        MainDB storage self,\r\n        RelaseCalculator.MainDB storage relaser,\r\n        address owner,\r\n        uint nearestTime )\r\n    internal view\r\n    returns (uint) {\r\n\r\n                uint owner_p = self.addressValuesMapping[owner].Nearest(nearestTime);\r\n\r\n                uint all_p = self.totalSumValues.Nearest(nearestTime);\r\n\r\n        if ( all_p == 0 ) {\r\n            return 0;\r\n        }\r\n\r\n        return relaser.CurrentRelaseAmountDay() / 2 * (owner_p * 1 ether / all_p) / 1 ether;\r\n    }\r\n\r\n        function CurrentRelaseProfix(\r\n        MainDB storage self,\r\n        RelaseCalculator.MainDB storage relaser,\r\n        address owner,\r\n        uint endTime\r\n    )\r\n    internal view returns (\r\n        uint sum,\r\n        uint len,\r\n        uint[] memory dayTimes,\r\n        uint[] memory profixs\r\n    ) {\r\n\r\n                uint ltime = self.latestWithdrawTimes[owner];\r\n\r\n                if ( Times.DayZeroGMT8(endTime) - Times.OneDay() < ltime ) {\r\n\r\n            sum = 0;\r\n            len = 0;\r\n            dayTimes = new uint[](0);\r\n            profixs = new uint[](0);\r\n\r\n            return (sum, len, dayTimes, profixs);\r\n        }\r\n\r\n        len = (Times.DayZeroGMT8(endTime) - ltime) / Times.OneDay();\r\n\r\n        dayTimes = new uint[](len);\r\n        profixs = new uint[](len);\r\n\r\n        for (uint i = 0; i < len; i++) {\r\n\r\n            ltime += Times.OneDay();\r\n\r\n                        dayTimes[i] = ltime;\r\n\r\n                        profixs[i] = ProfixHandle( self, relaser, owner, dayTimes[i] );\r\n\r\n                        sum += profixs[i];\r\n        }\r\n    }\r\n\r\n\r\n        function WithdrawCurrentRealseProfix(\r\n        MainDB storage self,\r\n        RelaseCalculator.MainDB storage relaser,\r\n        address owner,\r\n        uint endTime\r\n    ) internal {\r\n\r\n        (\r\n            uint sum,\r\n            uint len,\r\n            uint[] memory dayTimes,\r\n            uint[] memory profixs\r\n\r\n        ) = CurrentRelaseProfix(\r\n\r\n            self,\r\n            relaser,\r\n            owner,\r\n            endTime\r\n\r\n        );\r\n\r\n                require( sum > 0, \"NoProfix\" );\r\n\r\n                self.erc20Inc.transferFrom( self.assertPool, owner, sum );\r\n\r\n                for (uint i = 0; i < len; i++) {\r\n            emit LogDynamicRelaseDay( owner, dayTimes[i], profixs[i]);\r\n        }\r\n\r\n                self.latestWithdrawTimes[owner] += len * Times.OneDay();\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory c) {\r\n\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n\r\n        while (i != 0){\r\n            bstr[k--] = byte( uint8(48 + i % 10) );\r\n            i /= 10;\r\n        }\r\n        c = string(bstr);\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\n\r\n\r\ncontract RelasePool is KContract {\r\n\r\n    ERC20Interface public _erc20Inc;\r\n\r\n    constructor(ERC20Interface erc20) public {\r\n        _erc20Inc = erc20;\r\n    }\r\n\r\n    function ApproveToMainContract(address spender, uint amount) external write KDeveloperOnly {\r\n        _erc20Inc.approve( spender, amount );\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DepositToken is KContract {\r\n\r\n    using RelaseCalculator for RelaseCalculator.MainDB;\r\n    RelaseCalculator.MainDB public _relaser;\r\n\r\n    using StaticRelaseManager for StaticRelaseManager.MainDB;\r\n    StaticRelaseManager.MainDB public _staticRelaser;\r\n\r\n    using DepositedPool for DepositedPool.MainDB;\r\n    DepositedPool.MainDB _depositedPool;\r\n\r\n    using Distribution for Distribution.MainDB;\r\n    Distribution.MainDB _distribution;\r\n\r\n    using DynamicRelaseManager for DynamicRelaseManager.MainDB;\r\n    DynamicRelaseManager.MainDB _dynamicRelaser;\r\n\r\n    event LogRelaseDay( address indexed owner, uint indexed dayTime, uint profix);\r\n\r\n            uint16 public SD = 0;\r\n\r\n        RecommendSmallTeamInterface public _rcmInc;\r\n\r\n        RelasePool public _assertPool;\r\n\r\n        ERC20Interface public _erc20Inc;\r\n\r\n    uint _depositedLimit = 100 ether;\r\n\r\n    constructor(ERC20Interface erc20, RelasePool pool, RecommendSmallTeamInterface rcm) public {\r\n\r\n        _assertPool = pool;\r\n        _erc20Inc = erc20;\r\n        _rcmInc = rcm;\r\n\r\n        _distribution.Init();\r\n        _relaser.Init();\r\n\r\n        _staticRelaser.Init(erc20, address(pool) );\r\n        _dynamicRelaser.Init(rcm, erc20, address(pool) );\r\n        _depositedPool.Init();\r\n\r\n                _KContractBroken = true;\r\n    }\r\n\r\n        function DepositAppend(uint amount) external write KWhenNotBroken {\r\n\r\n                require( amount >= _depositedLimit, \"LessMinLimit\" );\r\n\r\n                UpdateContractState();\r\n\r\n                require( _rcmInc.GetIntroducer(msg.sender) != address(0x0), \"NoIntroducer\" );\r\n\r\n                require( amount > 0 && _erc20Inc.transferFrom( msg.sender, address(this), amount ) );\r\n\r\n        uint oldAmount = _depositedPool.LatestAmount(msg.sender);\r\n\r\n        _depositedPool.DepositedAddDelegate(msg.sender, amount);\r\n\r\n        uint newAmount = _depositedPool.LatestAmount(msg.sender);\r\n\r\n        _distribution.DepositChangeDelegate(oldAmount, newAmount);\r\n\r\n                _staticRelaser.initFirstDepositedTime(msg.sender);\r\n        _dynamicRelaser.initFirstDepositedTime(msg.sender);\r\n\r\n                _rcmInc.API_AppendAchievement(msg.sender, amount);\r\n\r\n                _dynamicRelaser.UpdateOwnerDynmicValue(msg.sender, SD);\r\n    }\r\n\r\n        function DepositDivestment(uint amount) external write KWhenNotBroken {\r\n\r\n        UpdateContractState();\r\n\r\n        require(amount > 0);\r\n\r\n                uint oldAmount = _depositedPool.LatestAmount(msg.sender);\r\n\r\n                _depositedPool.DepositedSubDelegate(msg.sender, amount);\r\n\r\n        uint newAmount = _depositedPool.LatestAmount(msg.sender);\r\n\r\n        _distribution.DepositChangeDelegate(oldAmount, newAmount);\r\n\r\n                _erc20Inc.transfer( msg.sender, amount );\r\n\r\n                _rcmInc.API_DivestmentAchievement(msg.sender, amount);\r\n\r\n                _dynamicRelaser.UpdateOwnerDynmicValue(msg.sender, SD);\r\n\r\n    }\r\n\r\n        function UpdateContractState() public write {\r\n\r\n                _relaser.UpdateBounds();\r\n\r\n                _dynamicRelaser.UpdateDynamicTotalSum();\r\n\r\n                _distribution.UpdateCalculationValue();\r\n\r\n    }\r\n\r\n        function CurrentRelaseProfixStatic(address owner, uint latestTime) external view\r\n    returns (\r\n        uint sum,\r\n        uint len,\r\n        uint[] memory dayTimes,\r\n        uint[] memory profixs\r\n    ) {\r\n        uint endTime = latestTime;\r\n        if ( endTime == 0 ) {\r\n            endTime = Times.Now();\r\n        }\r\n        return _staticRelaser.CurrentRelaseProfix( _depositedPool, _distribution, _relaser, owner, endTime );\r\n    }\r\n\r\n        function CurrentRelaseProfixDynamic(address owner, uint latestTime) external view\r\n    returns (\r\n        uint sum,\r\n        uint len,\r\n        uint[] memory dayTimes,\r\n        uint[] memory profixs\r\n    ) {\r\n        uint endTime = latestTime;\r\n        if ( endTime == 0 ) {\r\n            endTime = Times.Now();\r\n        }\r\n\r\n        return _dynamicRelaser.CurrentRelaseProfix( _relaser, owner, endTime );\r\n    }\r\n\r\n        function WithdrawProfix(uint latestTime) external write KWhenNotBroken {\r\n\r\n        uint endTime = latestTime;\r\n        if ( endTime == 0 ) {\r\n            endTime = Times.Now();\r\n        }\r\n\r\n        _dynamicRelaser.UpdateOwnerDynmicValue(msg.sender, SD);\r\n\r\n        (uint st,,,) = _staticRelaser.CurrentRelaseProfix( _depositedPool, _distribution, _relaser, msg.sender, endTime );\r\n        (uint dy,,,) = _dynamicRelaser.CurrentRelaseProfix( _relaser, msg.sender, endTime );\r\n        emit LogRelaseDay( msg.sender, Times.DayZeroGMT8(endTime), st+dy );\r\n\r\n        if ( st > 0 )  {\r\n            _staticRelaser.WithdrawCurrentRealseProfix( _depositedPool, _distribution, _relaser, msg.sender, endTime );\r\n        }\r\n\r\n        if (dy > 0 ) {\r\n            _dynamicRelaser.WithdrawCurrentRealseProfix( _relaser, msg.sender, endTime );\r\n        }\r\n    }\r\n\r\n    function WithdrawProfix_Dynamic(uint latestTime) public write KWhenNotBroken {\r\n        uint endTime = latestTime;\r\n        if ( endTime == 0 ) {\r\n            endTime = Times.Now();\r\n        }\r\n        _dynamicRelaser.UpdateOwnerDynmicValue(msg.sender, SD);\r\n        _dynamicRelaser.WithdrawCurrentRealseProfix( _relaser, msg.sender, endTime );\r\n    }\r\n\r\n        function WithdrawProfix_Static(uint latestTime) public write KWhenNotBroken {\r\n        uint endTime = latestTime;\r\n        if ( endTime == 0 ) {\r\n            endTime = Times.Now();\r\n        }\r\n        _dynamicRelaser.UpdateOwnerDynmicValue(msg.sender, SD);\r\n        _staticRelaser.WithdrawCurrentRealseProfix( _depositedPool, _distribution, _relaser, msg.sender, endTime );\r\n    }\r\n\r\n        function DepositDistributionInfo(uint offset, uint size) external view\r\n    returns (\r\n        uint maxlimit,\r\n        uint spaceBase,\r\n        uint len,\r\n        uint[] memory spaceIdxs,\r\n        uint[] memory spaceSums\r\n    ) {\r\n        maxlimit = _distribution.SectionSpaceMaxLimit;\r\n        spaceBase = _distribution.SectionSpace;\r\n        (len, spaceIdxs, spaceSums) = _distribution.DistributionInfo(offset, size);\r\n    }\r\n\r\n\r\n        function RelaseInfomations() external view returns (\r\n                uint poolBalance,\r\n                uint todayRelase,\r\n                uint staticValue,\r\n                uint dynamicValue,\r\n                uint addresses,\r\n                uint relasedAmount\r\n    ) {\r\n        poolBalance = _erc20Inc.balanceOf(address(_assertPool));\r\n        todayRelase = _relaser.CurrentRelaseAmountDay();\r\n        staticValue = _distribution.CalculationValueAtDay(Times.Now());\r\n        dynamicValue = _dynamicRelaser.currentSumValue;\r\n        addresses = _rcmInc.AddressesCount();\r\n        relasedAmount = _relaser.currentBoundsAmount;\r\n    }\r\n\r\n    function DepositedInfo(address owner, uint latestTime) external view returns (\r\n        bytes6 shortCode,\r\n        uint depositedAmount,\r\n        uint staticValue,\r\n        uint dynamicValue\r\n    ) {\r\n        uint nearestTime = Times.DayZeroGMT8(latestTime);\r\n        if ( nearestTime == 0 ) {\r\n            nearestTime = Times.TodayZeroGMT8();\r\n        }\r\n\r\n        shortCode = _rcmInc.AddressToShortCode(owner);\r\n        depositedAmount = _depositedPool.LatestAmount(owner);\r\n        dynamicValue = _dynamicRelaser.DynamicValueOf(owner, nearestTime);\r\n\r\n                        uint spaceIdx;\r\n        if ( depositedAmount >= _distribution.SectionSpaceMaxLimit ) {\r\n            spaceIdx = _distribution.SectionSpaceMaxLimit / _distribution.SectionSpace;\r\n        } else {\r\n            spaceIdx = depositedAmount / _distribution.SectionSpace;\r\n        }\r\n\r\n                if ( spaceIdx == 0 ) {\r\n            staticValue =  0;\r\n        } else {\r\n            staticValue = _distribution.CalculationQuickValueAtDay(nearestTime, spaceIdx);\r\n        }\r\n\r\n    }\r\n\r\n    function WithdrawMyDepostied() external write KWhenBroken returns (uint) {\r\n\r\n        if ( _KWithdrawabledAddress[msg.sender] ) {\r\n\r\n            return 0;\r\n\r\n        } else {\r\n\r\n            _KWithdrawabledAddress[msg.sender] = true;\r\n\r\n            uint r = _depositedPool.LatestAmount(msg.sender);\r\n\r\n            require( _erc20Inc.transferFrom(address(this), msg.sender, r) );\r\n\r\n            return r;\r\n        }\r\n    }\r\n\r\n        function Owner_SetSP(uint16 sd) external write KOwnerOnly {\r\n        SD = sd;\r\n    }\r\n\r\n    function Owner_SetDepostMinLimit(uint minlimit) external write KOwnerOnly {\r\n        _depositedLimit = minlimit;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"_relaser\",\"outputs\":[{\"name\":\"relaseTime\",\"type\":\"uint256\"},{\"name\":\"relaseMonthCount\",\"type\":\"uint256\"},{\"name\":\"currentBoundsAmount\",\"type\":\"uint256\"},{\"name\":\"relaseAmountEverMonth\",\"type\":\"uint256\"},{\"name\":\"latestCalculatorTimes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_erc20Inc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_rcmInc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_KContractBroken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"broken\",\"type\":\"bool\"}],\"name\":\"KSetContractBroken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"latestTime\",\"type\":\"uint256\"}],\"name\":\"CurrentRelaseProfixDynamic\",\"outputs\":[{\"name\":\"sum\",\"type\":\"uint256\"},{\"name\":\"len\",\"type\":\"uint256\"},{\"name\":\"dayTimes\",\"type\":\"uint256[]\"},{\"name\":\"profixs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"latestTime\",\"type\":\"uint256\"}],\"name\":\"WithdrawProfix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RelaseInfomations\",\"outputs\":[{\"name\":\"poolBalance\",\"type\":\"uint256\"},{\"name\":\"todayRelase\",\"type\":\"uint256\"},{\"name\":\"staticValue\",\"type\":\"uint256\"},{\"name\":\"dynamicValue\",\"type\":\"uint256\"},{\"name\":\"addresses\",\"type\":\"uint256\"},{\"name\":\"relasedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_assertPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"KAddAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_staticRelaser\",\"outputs\":[{\"name\":\"erc20Inc\",\"type\":\"address\"},{\"name\":\"assertPool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"latestTime\",\"type\":\"uint256\"}],\"name\":\"WithdrawProfix_Dynamic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositAppend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sd\",\"type\":\"uint16\"}],\"name\":\"Owner_SetSP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"UpdateContractState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_KContractOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minlimit\",\"type\":\"uint256\"}],\"name\":\"Owner_SetDepostMinLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"offset\",\"type\":\"uint256\"},{\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"DepositDistributionInfo\",\"outputs\":[{\"name\":\"maxlimit\",\"type\":\"uint256\"},{\"name\":\"spaceBase\",\"type\":\"uint256\"},{\"name\":\"len\",\"type\":\"uint256\"},{\"name\":\"spaceIdxs\",\"type\":\"uint256[]\"},{\"name\":\"spaceSums\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositDivestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KGetImplAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"KSetImplAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_KDefaultReciver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"latestTime\",\"type\":\"uint256\"}],\"name\":\"DepositedInfo\",\"outputs\":[{\"name\":\"shortCode\",\"type\":\"bytes6\"},{\"name\":\"depositedAmount\",\"type\":\"uint256\"},{\"name\":\"staticValue\",\"type\":\"uint256\"},{\"name\":\"dynamicValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawMyDepostied\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"latestTime\",\"type\":\"uint256\"}],\"name\":\"CurrentRelaseProfixStatic\",\"outputs\":[{\"name\":\"sum\",\"type\":\"uint256\"},{\"name\":\"len\",\"type\":\"uint256\"},{\"name\":\"dayTimes\",\"type\":\"uint256[]\"},{\"name\":\"profixs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KAuthAddresses\",\"outputs\":[{\"name\":\"authAddr\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"latestTime\",\"type\":\"uint256\"}],\"name\":\"WithdrawProfix_Static\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"erc20\",\"type\":\"address\"},{\"name\":\"pool\",\"type\":\"address\"},{\"name\":\"rcm\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dayTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"profix\",\"type\":\"uint256\"}],\"name\":\"LogRelaseDay\",\"type\":\"event\"}]","ContractName":"DepositToken","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000091c4b0cfc5eac8b8c5fd953ae9fbc707b520a7d60000000000000000000000007efe32bb58a0f322a1f8f650002fd4e88c290e4a000000000000000000000000d3c8dc421d3cfbd446ff9faf8145144df1f04f9b","Library":"Times:f048225ecefbb6e14be0aea9d4473416300b681e","LicenseType":"MIT","SwarmSource":"bzzr://26af6b652274ff20ace41ba0070a0e7c51dcd266334a32ff737bd29287c7c317"}]}