{"status":"1","message":"OK","result":[{"SourceCode":"/// matching_market.sol\r\n\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.12;\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC20Events {\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n}\r\n\r\ncontract ERC20 is ERC20Events {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address guy) public view returns (uint);\r\n    function allowance(address src, address guy) public view returns (uint);\r\n\r\n    function approve(address guy, uint wad) public returns (bool);\r\n    function transfer(address dst, uint wad) public returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint wad\r\n    ) public returns (bool);\r\n}\r\n\r\ncontract EventfulMarket {\r\n    event LogItemUpdate(uint id);\r\n    event LogTrade(uint pay_amt, address indexed pay_gem,\r\n                   uint buy_amt, address indexed buy_gem);\r\n\r\n    event LogMake(\r\n        bytes32  indexed  id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        ERC20             pay_gem,\r\n        ERC20             buy_gem,\r\n        uint128           pay_amt,\r\n        uint128           buy_amt,\r\n        uint64            timestamp\r\n    );\r\n\r\n    event LogBump(\r\n        bytes32  indexed  id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        ERC20             pay_gem,\r\n        ERC20             buy_gem,\r\n        uint128           pay_amt,\r\n        uint128           buy_amt,\r\n        uint64            timestamp\r\n    );\r\n\r\n    event LogTake(\r\n        bytes32           id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        ERC20             pay_gem,\r\n        ERC20             buy_gem,\r\n        address  indexed  taker,\r\n        uint128           take_amt,\r\n        uint128           give_amt,\r\n        uint64            timestamp\r\n    );\r\n\r\n    event LogKill(\r\n        bytes32  indexed  id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        ERC20             pay_gem,\r\n        ERC20             buy_gem,\r\n        uint128           pay_amt,\r\n        uint128           buy_amt,\r\n        uint64            timestamp\r\n    );\r\n}\r\n\r\ncontract SimpleMarket is EventfulMarket, DSMath {\r\n\r\n    uint public last_offer_id;\r\n\r\n    mapping (uint => OfferInfo) public offers;\r\n\r\n    bool locked;\r\n\r\n    struct OfferInfo {\r\n        uint     pay_amt;\r\n        ERC20    pay_gem;\r\n        uint     buy_amt;\r\n        ERC20    buy_gem;\r\n        address  owner;\r\n        uint64   timestamp;\r\n    }\r\n\r\n    modifier can_buy(uint id) {\r\n        require(isActive(id));\r\n        _;\r\n    }\r\n\r\n    modifier can_cancel(uint id) {\r\n        require(isActive(id));\r\n        require(getOwner(id) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _;\r\n    }\r\n\r\n    modifier synchronized {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function isActive(uint id) public view returns (bool active) {\r\n        return offers[id].timestamp > 0;\r\n    }\r\n\r\n    function getOwner(uint id) public view returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n\r\n    function getOffer(uint id) public view returns (uint, ERC20, uint, ERC20) {\r\n      OfferInfo memory offer = offers[id];\r\n      return (offer.pay_amt, offer.pay_gem,\r\n              offer.buy_amt, offer.buy_gem);\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    function bump(bytes32 id_)\r\n        public\r\n        can_buy(uint256(id_))\r\n    {\r\n        uint256 id = uint256(id_);\r\n        emit LogBump(\r\n            id_,\r\n            keccak256(abi.encodePacked(offers[id].pay_gem, offers[id].buy_gem)),\r\n            offers[id].owner,\r\n            offers[id].pay_gem,\r\n            offers[id].buy_gem,\r\n            uint128(offers[id].pay_amt),\r\n            uint128(offers[id].buy_amt),\r\n            offers[id].timestamp\r\n        );\r\n    }\r\n\r\n    // Accept given `quantity` of an offer. Transfers funds from caller to\r\n    // offer maker, and from market to caller.\r\n    function buy(uint id, uint quantity)\r\n        public\r\n        can_buy(id)\r\n        synchronized\r\n        returns (bool)\r\n    {\r\n        OfferInfo memory offer = offers[id];\r\n        uint spend = mul(quantity, offer.buy_amt) / offer.pay_amt;\r\n\r\n        require(uint128(spend) == spend);\r\n        require(uint128(quantity) == quantity);\r\n\r\n        // For backwards semantic compatibility.\r\n        if (quantity == 0 || spend == 0 ||\r\n            quantity > offer.pay_amt || spend > offer.buy_amt)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        offers[id].pay_amt = sub(offer.pay_amt, quantity);\r\n        offers[id].buy_amt = sub(offer.buy_amt, spend);\r\n        require( offer.buy_gem.transferFrom(msg.sender, offer.owner, spend) );\r\n        require( offer.pay_gem.transfer(msg.sender, quantity) );\r\n\r\n        emit LogItemUpdate(id);\r\n        emit LogTake(\r\n            bytes32(id),\r\n            keccak256(abi.encodePacked(offer.pay_gem, offer.buy_gem)),\r\n            offer.owner,\r\n            offer.pay_gem,\r\n            offer.buy_gem,\r\n            msg.sender,\r\n            uint128(quantity),\r\n            uint128(spend),\r\n            uint64(now)\r\n        );\r\n        emit LogTrade(quantity, address(offer.pay_gem), spend, address(offer.buy_gem));\r\n\r\n        if (offers[id].pay_amt == 0) {\r\n          delete offers[id];\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel(uint id)\r\n        public\r\n        can_cancel(id)\r\n        synchronized\r\n        returns (bool success)\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        require( offer.pay_gem.transfer(offer.owner, offer.pay_amt) );\r\n\r\n        emit LogItemUpdate(id);\r\n        emit LogKill(\r\n            bytes32(id),\r\n            keccak256(abi.encodePacked(offer.pay_gem, offer.buy_gem)),\r\n            offer.owner,\r\n            offer.pay_gem,\r\n            offer.buy_gem,\r\n            uint128(offer.pay_amt),\r\n            uint128(offer.buy_amt),\r\n            uint64(now)\r\n        );\r\n\r\n        success = true;\r\n    }\r\n\r\n    function kill(bytes32 id)\r\n        public\r\n    {\r\n        require(cancel(uint256(id)));\r\n    }\r\n\r\n    function make(\r\n        ERC20    pay_gem,\r\n        ERC20    buy_gem,\r\n        uint128  pay_amt,\r\n        uint128  buy_amt\r\n    )\r\n        public\r\n        returns (bytes32 id)\r\n    {\r\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer(uint pay_amt, ERC20 pay_gem, uint buy_amt, ERC20 buy_gem)\r\n        public\r\n        can_offer\r\n        synchronized\r\n        returns (uint id)\r\n    {\r\n        require(uint128(pay_amt) == pay_amt);\r\n        require(uint128(buy_amt) == buy_amt);\r\n        require(pay_amt > 0);\r\n        require(pay_gem != ERC20(0x0));\r\n        require(buy_amt > 0);\r\n        require(buy_gem != ERC20(0x0));\r\n        require(pay_gem != buy_gem);\r\n\r\n        OfferInfo memory info;\r\n        info.pay_amt = pay_amt;\r\n        info.pay_gem = pay_gem;\r\n        info.buy_amt = buy_amt;\r\n        info.buy_gem = buy_gem;\r\n        info.owner = msg.sender;\r\n        info.timestamp = uint64(now);\r\n        id = _next_id();\r\n        offers[id] = info;\r\n\r\n        require( pay_gem.transferFrom(msg.sender, address(this), pay_amt) );\r\n\r\n        emit LogItemUpdate(id);\r\n        emit LogMake(\r\n            bytes32(id),\r\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\r\n            msg.sender,\r\n            pay_gem,\r\n            buy_gem,\r\n            uint128(pay_amt),\r\n            uint128(buy_amt),\r\n            uint64(now)\r\n        );\r\n    }\r\n\r\n    function take(bytes32 id, uint128 maxTakeAmount)\r\n        public\r\n    {\r\n        require(buy(uint256(id), maxTakeAmount));\r\n    }\r\n\r\n    function _next_id()\r\n        internal\r\n        returns (uint)\r\n    {\r\n        last_offer_id++; return last_offer_id;\r\n    }\r\n}\r\n\r\n// Simple Market with a market lifetime. When the close_time has been reached,\r\n// offers can only be cancelled (offer and buy will throw).\r\n\r\ncontract ExpiringMarket is DSAuth, SimpleMarket {\r\n    uint64 public close_time;\r\n    bool public stopped;\r\n\r\n    // after close_time has been reached, no new offers are allowed\r\n    modifier can_offer {\r\n        require(!isClosed());\r\n        _;\r\n    }\r\n\r\n    // after close, no new buys are allowed\r\n    modifier can_buy(uint id) {\r\n        require(isActive(id));\r\n        require(!isClosed());\r\n        _;\r\n    }\r\n\r\n    // after close, anyone can cancel an offer\r\n    modifier can_cancel(uint id) {\r\n        require(isActive(id));\r\n        require((msg.sender == getOwner(id)) || isClosed());\r\n        _;\r\n    }\r\n\r\n    constructor(uint64 _close_time)\r\n        public\r\n    {\r\n        close_time = _close_time;\r\n    }\r\n\r\n    function isClosed() public view returns (bool closed) {\r\n        return stopped || getTime() > close_time;\r\n    }\r\n\r\n    function getTime() public view returns (uint64) {\r\n        return uint64(now);\r\n    }\r\n\r\n    function stop() public auth {\r\n        stopped = true;\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract MatchingEvents {\r\n    event LogBuyEnabled(bool isEnabled);\r\n    event LogMinSell(address pay_gem, uint min_amount);\r\n    event LogMatchingEnabled(bool isEnabled);\r\n    event LogUnsortedOffer(uint id);\r\n    event LogSortedOffer(uint id);\r\n    event LogInsert(address keeper, uint id);\r\n    event LogDelete(address keeper, uint id);\r\n}\r\n\r\ncontract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote {\r\n    bool public buyEnabled = true;      //buy enabled\r\n    bool public matchingEnabled = true; //true: enable matching,\r\n                                         //false: revert to expiring market\r\n    struct sortInfo {\r\n        uint next;  //points to id of next higher offer\r\n        uint prev;  //points to id of previous lower offer\r\n        uint delb;  //the blocknumber where this entry was marked for delete\r\n    }\r\n    mapping(uint => sortInfo) public _rank;                     //doubly linked lists of sorted offer ids\r\n    mapping(address => mapping(address => uint)) public _best;  //id of the highest offer for a token pair\r\n    mapping(address => mapping(address => uint)) public _span;  //number of offers stored for token pair in sorted orderbook\r\n    mapping(address => uint) public _dust;                      //minimum sell amount for a token to avoid dust offers\r\n    mapping(uint => uint) public _near;         //next unsorted offer id\r\n    uint _head;                                 //first unsorted offer id\r\n    uint public dustId;                         // id of the latest offer marked as dust\r\n\r\n\r\n    constructor(uint64 close_time) ExpiringMarket(close_time) public {\r\n    }\r\n\r\n    // After close, anyone can cancel an offer\r\n    modifier can_cancel(uint id) {\r\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\r\n        require(\r\n            isClosed() || msg.sender == getOwner(id) || id == dustId,\r\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    function make(\r\n        ERC20    pay_gem,\r\n        ERC20    buy_gem,\r\n        uint128  pay_amt,\r\n        uint128  buy_amt\r\n    )\r\n        public\r\n        returns (bytes32)\r\n    {\r\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\r\n    }\r\n\r\n    function take(bytes32 id, uint128 maxTakeAmount) public {\r\n        require(buy(uint256(id), maxTakeAmount));\r\n    }\r\n\r\n    function kill(bytes32 id) public {\r\n        require(cancel(uint256(id)));\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    //\r\n    // If matching is enabled:\r\n    //     * creates new offer without putting it in\r\n    //       the sorted list.\r\n    //     * available to authorized contracts only!\r\n    //     * keepers should call insert(id,pos)\r\n    //       to put offer in the sorted list.\r\n    //\r\n    // If matching is disabled:\r\n    //     * calls expiring market's offer().\r\n    //     * available to everyone without authorization.\r\n    //     * no sorting is done.\r\n    //\r\n    function offer(\r\n        uint pay_amt,    //maker (ask) sell how much\r\n        ERC20 pay_gem,   //maker (ask) sell which token\r\n        uint buy_amt,    //taker (ask) buy how much\r\n        ERC20 buy_gem    //taker (ask) buy which token\r\n    )\r\n        public\r\n        returns (uint)\r\n    {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        function (uint256,ERC20,uint256,ERC20) returns (uint256) fn = matchingEnabled ? _offeru : super.offer;\r\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer(\r\n        uint pay_amt,    //maker (ask) sell how much\r\n        ERC20 pay_gem,   //maker (ask) sell which token\r\n        uint buy_amt,    //maker (ask) buy how much\r\n        ERC20 buy_gem,   //maker (ask) buy which token\r\n        uint pos         //position to insert offer, 0 should be used if unknown\r\n    )\r\n        public\r\n        can_offer\r\n        returns (uint)\r\n    {\r\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\r\n    }\r\n\r\n    function offer(\r\n        uint pay_amt,    //maker (ask) sell how much\r\n        ERC20 pay_gem,   //maker (ask) sell which token\r\n        uint buy_amt,    //maker (ask) buy how much\r\n        ERC20 buy_gem,   //maker (ask) buy which token\r\n        uint pos,        //position to insert offer, 0 should be used if unknown\r\n        bool rounding    //match \"close enough\" orders?\r\n    )\r\n        public\r\n        can_offer\r\n        returns (uint)\r\n    {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        require(_dust[address(pay_gem)] <= pay_amt);\r\n\r\n        if (matchingEnabled) {\r\n          return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, rounding);\r\n        }\r\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\r\n    }\r\n\r\n    //Transfers funds from caller to offer maker, and from market to caller.\r\n    function buy(uint id, uint amount)\r\n        public\r\n        can_buy(id)\r\n        returns (bool)\r\n    {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        function (uint256,uint256) returns (bool) fn = matchingEnabled ? _buys : super.buy;\r\n        return fn(id, amount);\r\n    }\r\n\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel(uint id)\r\n        public\r\n        can_cancel(id)\r\n        returns (bool success)\r\n    {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        if (matchingEnabled) {\r\n            if (isOfferSorted(id)) {\r\n                require(_unsort(id));\r\n            } else {\r\n                require(_hide(id));\r\n            }\r\n        }\r\n        return super.cancel(id);    //delete the offer.\r\n    }\r\n\r\n    //insert offer into the sorted list\r\n    //keepers need to use this function\r\n    function insert(\r\n        uint id,   //maker (ask) id\r\n        uint pos   //position to insert into\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        require(!isOfferSorted(id));    //make sure offers[id] is not yet sorted\r\n        require(isActive(id));          //make sure offers[id] is active\r\n\r\n        _hide(id);                      //remove offer from unsorted offers list\r\n        _sort(id, pos);                 //put offer into the sorted offers list\r\n        emit LogInsert(msg.sender, id);\r\n        return true;\r\n    }\r\n\r\n    //deletes _rank [id]\r\n    //  Function should be called by keepers.\r\n    function del_rank(uint id)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        require(!isActive(id) && _rank[id].delb != 0 && _rank[id].delb < block.number - 10);\r\n        delete _rank[id];\r\n        emit LogDelete(msg.sender, id);\r\n        return true;\r\n    }\r\n\r\n    //set the minimum sell amount for a token\r\n    //    Function is used to avoid \"dust offers\" that have\r\n    //    very small amount of tokens to sell, and it would\r\n    //    cost more gas to accept the offer, than the value\r\n    //    of tokens received.\r\n    function setMinSell(\r\n        ERC20 pay_gem,     //token to assign minimum sell amount to\r\n        uint dust          //maker (ask) minimum sell amount\r\n    )\r\n        public\r\n        auth\r\n        note\r\n        returns (bool)\r\n    {\r\n        _dust[address(pay_gem)] = dust;\r\n        emit LogMinSell(address(pay_gem), dust);\r\n        return true;\r\n    }\r\n\r\n    //returns the minimum sell amount for an offer\r\n    function getMinSell(\r\n        ERC20 pay_gem      //token for which minimum sell amount is queried\r\n    )\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return _dust[address(pay_gem)];\r\n    }\r\n\r\n    //set buy functionality enabled/disabled\r\n    function setBuyEnabled(bool buyEnabled_) public auth returns (bool) {\r\n        buyEnabled = buyEnabled_;\r\n        emit LogBuyEnabled(buyEnabled);\r\n        return true;\r\n    }\r\n\r\n    //set matching enabled/disabled\r\n    //    If matchingEnabled true(default), then inserted offers are matched.\r\n    //    Except the ones inserted by contracts, because those end up\r\n    //    in the unsorted list of offers, that must be later sorted by\r\n    //    keepers using insert().\r\n    //    If matchingEnabled is false then MatchingMarket is reverted to ExpiringMarket,\r\n    //    and matching is not done, and sorted lists are disabled.\r\n    function setMatchingEnabled(bool matchingEnabled_) public auth returns (bool) {\r\n        matchingEnabled = matchingEnabled_;\r\n        emit LogMatchingEnabled(matchingEnabled);\r\n        return true;\r\n    }\r\n\r\n    //return the best offer for a token pair\r\n    //      the best offer is the lowest one if it's an ask,\r\n    //      and highest one if it's a bid offer\r\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem) public view returns(uint) {\r\n        return _best[address(sell_gem)][address(buy_gem)];\r\n    }\r\n\r\n    //return the next worse offer in the sorted list\r\n    //      the worse offer is the higher one if its an ask,\r\n    //      a lower one if its a bid offer,\r\n    //      and in both cases the newer one if they're equal.\r\n    function getWorseOffer(uint id) public view returns(uint) {\r\n        return _rank[id].prev;\r\n    }\r\n\r\n    //return the next better offer in the sorted list\r\n    //      the better offer is in the lower priced one if its an ask,\r\n    //      the next higher priced one if its a bid offer\r\n    //      and in both cases the older one if they're equal.\r\n    function getBetterOffer(uint id) public view returns(uint) {\r\n\r\n        return _rank[id].next;\r\n    }\r\n\r\n    //return the amount of better offers for a token pair\r\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem) public view returns(uint) {\r\n        return _span[address(sell_gem)][address(buy_gem)];\r\n    }\r\n\r\n    //get the first unsorted offer that was inserted by a contract\r\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\r\n    //      Their offers get put in the unsorted list of offers.\r\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\r\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\r\n    function getFirstUnsortedOffer() public view returns(uint) {\r\n        return _head;\r\n    }\r\n\r\n    //get the next unsorted offer\r\n    //      Can be used to cycle through all the unsorted offers.\r\n    function getNextUnsortedOffer(uint id) public view returns(uint) {\r\n        return _near[id];\r\n    }\r\n\r\n    function isOfferSorted(uint id) public view returns(bool) {\r\n        return _rank[id].next != 0\r\n               || _rank[id].prev != 0\r\n               || _best[address(offers[id].pay_gem)][address(offers[id].buy_gem)] == id;\r\n    }\r\n\r\n    function sellAllAmount(ERC20 pay_gem, uint pay_amt, ERC20 buy_gem, uint min_fill_amount)\r\n        public\r\n        returns (uint fill_amt)\r\n    {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        uint offerId;\r\n        while (pay_amt > 0) {                           //while there is amount to sell\r\n            offerId = getBestOffer(buy_gem, pay_gem);   //Get the best offer for the token pair\r\n            require(offerId != 0);                      //Fails if there are not more offers\r\n\r\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\r\n            if (pay_amt * 1 ether < wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) {\r\n                break;                                  //We consider that all amount is sold\r\n            }\r\n            if (pay_amt >= offers[offerId].buy_amt) {                       //If amount to sell is higher or equal than current offer amount to buy\r\n                fill_amt = add(fill_amt, offers[offerId].pay_amt);          //Add amount bought to acumulator\r\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt);            //Decrease amount to sell\r\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt));   //We take the whole offer\r\n            } else { // if lower\r\n                uint256 baux = rmul(pay_amt * 10 ** 9, rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) / 10 ** 9;\r\n                fill_amt = add(fill_amt, baux);         //Add amount bought to acumulator\r\n                take(bytes32(offerId), uint128(baux));  //We take the portion of the offer that we need\r\n                pay_amt = 0;                            //All amount is sold\r\n            }\r\n        }\r\n        require(fill_amt >= min_fill_amount);\r\n    }\r\n\r\n    function buyAllAmount(ERC20 buy_gem, uint buy_amt, ERC20 pay_gem, uint max_fill_amount)\r\n        public\r\n        returns (uint fill_amt)\r\n    {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        uint offerId;\r\n        while (buy_amt > 0) {                           //Meanwhile there is amount to buy\r\n            offerId = getBestOffer(buy_gem, pay_gem);   //Get the best offer for the token pair\r\n            require(offerId != 0);\r\n\r\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\r\n            if (buy_amt * 1 ether < wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) {\r\n                break;                                  //We consider that all amount is sold\r\n            }\r\n            if (buy_amt >= offers[offerId].pay_amt) {                       //If amount to buy is higher or equal than current offer amount to sell\r\n                fill_amt = add(fill_amt, offers[offerId].buy_amt);          //Add amount sold to acumulator\r\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt);            //Decrease amount to buy\r\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt));   //We take the whole offer\r\n            } else {                                                        //if lower\r\n                fill_amt = add(fill_amt, rmul(buy_amt * 10 ** 9, rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) / 10 ** 9); //Add amount sold to acumulator\r\n                take(bytes32(offerId), uint128(buy_amt));                   //We take the portion of the offer that we need\r\n                buy_amt = 0;                                                //All amount is bought\r\n            }\r\n        }\r\n        require(fill_amt <= max_fill_amount);\r\n    }\r\n\r\n    function getBuyAmount(ERC20 buy_gem, ERC20 pay_gem, uint pay_amt) public view returns (uint fill_amt) {\r\n        uint256 offerId = getBestOffer(buy_gem, pay_gem);           //Get best offer for the token pair\r\n        while (pay_amt > offers[offerId].buy_amt) {\r\n            fill_amt = add(fill_amt, offers[offerId].pay_amt);  //Add amount to buy accumulator\r\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt);    //Decrease amount to pay\r\n            if (pay_amt > 0) {                                  //If we still need more offers\r\n                offerId = getWorseOffer(offerId);               //We look for the next best offer\r\n                require(offerId != 0);                          //Fails if there are not enough offers to complete\r\n            }\r\n        }\r\n        fill_amt = add(fill_amt, rmul(pay_amt * 10 ** 9, rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) / 10 ** 9); //Add proportional amount of last offer to buy accumulator\r\n    }\r\n\r\n    function getPayAmount(ERC20 pay_gem, ERC20 buy_gem, uint buy_amt) public view returns (uint fill_amt) {\r\n        uint256 offerId = getBestOffer(buy_gem, pay_gem);           //Get best offer for the token pair\r\n        while (buy_amt > offers[offerId].pay_amt) {\r\n            fill_amt = add(fill_amt, offers[offerId].buy_amt);  //Add amount to pay accumulator\r\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt);    //Decrease amount to buy\r\n            if (buy_amt > 0) {                                  //If we still need more offers\r\n                offerId = getWorseOffer(offerId);               //We look for the next best offer\r\n                require(offerId != 0);                          //Fails if there are not enough offers to complete\r\n            }\r\n        }\r\n        fill_amt = add(fill_amt, rmul(buy_amt * 10 ** 9, rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) / 10 ** 9); //Add proportional amount of last offer to pay accumulator\r\n    }\r\n\r\n    // ---- Internal Functions ---- //\r\n\r\n    function _buys(uint id, uint amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(buyEnabled);\r\n        if (amount == offers[id].pay_amt) {\r\n            if (isOfferSorted(id)) {\r\n                //offers[id] must be removed from sorted list because all of it is bought\r\n                _unsort(id);\r\n            }else{\r\n                _hide(id);\r\n            }\r\n        }\r\n        require(super.buy(id, amount));\r\n        // If offer has become dust during buy, we cancel it\r\n        if (isActive(id) && offers[id].pay_amt < _dust[address(offers[id].pay_gem)]) {\r\n            dustId = id; //enable current msg.sender to call cancel(id)\r\n            cancel(id);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //find the id of the next higher offer after offers[id]\r\n    function _find(uint id)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        require( id > 0 );\r\n\r\n        address buy_gem = address(offers[id].buy_gem);\r\n        address pay_gem = address(offers[id].pay_gem);\r\n        uint top = _best[pay_gem][buy_gem];\r\n        uint old_top = 0;\r\n\r\n        // Find the larger-than-id order whose successor is less-than-id.\r\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\r\n            old_top = top;\r\n            top = _rank[top].prev;\r\n        }\r\n        return old_top;\r\n    }\r\n\r\n    //find the id of the next higher offer after offers[id]\r\n    function _findpos(uint id, uint pos)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        require(id > 0);\r\n\r\n        // Look for an active order.\r\n        while (pos != 0 && !isActive(pos)) {\r\n            pos = _rank[pos].prev;\r\n        }\r\n\r\n        if (pos == 0) {\r\n            //if we got to the end of list without a single active offer\r\n            return _find(id);\r\n\r\n        } else {\r\n            // if we did find a nearby active offer\r\n            // Walk the order book down from there...\r\n            if(_isPricedLtOrEq(id, pos)) {\r\n                uint old_pos;\r\n\r\n                // Guaranteed to run at least once because of\r\n                // the prior if statements.\r\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\r\n                    old_pos = pos;\r\n                    pos = _rank[pos].prev;\r\n                }\r\n                return old_pos;\r\n\r\n            // ...or walk it up.\r\n            } else {\r\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\r\n                    pos = _rank[pos].next;\r\n                }\r\n                return pos;\r\n            }\r\n        }\r\n    }\r\n\r\n    //return true if offers[low] priced less than or equal to offers[high]\r\n    function _isPricedLtOrEq(\r\n        uint low,   //lower priced offer's id\r\n        uint high   //higher priced offer's id\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return mul(offers[low].buy_amt, offers[high].pay_amt)\r\n          >= mul(offers[high].buy_amt, offers[low].pay_amt);\r\n    }\r\n\r\n    //these variables are global only because of solidity local variable limit\r\n\r\n    //match offers with taker offer, and execute token transactions\r\n    function _matcho(\r\n        uint t_pay_amt,    //taker sell how much\r\n        ERC20 t_pay_gem,   //taker sell which token\r\n        uint t_buy_amt,    //taker buy how much\r\n        ERC20 t_buy_gem,   //taker buy which token\r\n        uint pos,          //position id\r\n        bool rounding      //match \"close enough\" orders?\r\n    )\r\n        internal\r\n        returns (uint id)\r\n    {\r\n        uint best_maker_id;    //highest maker id\r\n        uint t_buy_amt_old;    //taker buy how much saved\r\n        uint m_buy_amt;        //maker offer wants to buy this much token\r\n        uint m_pay_amt;        //maker offer wants to sell this much token\r\n\r\n        // there is at least one offer stored for token pair\r\n        while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\r\n            best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\r\n            m_buy_amt = offers[best_maker_id].buy_amt;\r\n            m_pay_amt = offers[best_maker_id].pay_amt;\r\n\r\n            // Ugly hack to work around rounding errors. Based on the idea that\r\n            // the furthest the amounts can stray from their \"true\" values is 1.\r\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\r\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\r\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\r\n            // c * d > a * b + a + b + c + d, we write...\r\n            if (mul(m_buy_amt, t_buy_amt) > mul(t_pay_amt, m_pay_amt) +\r\n                (rounding ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt : 0))\r\n            {\r\n                break;\r\n            }\r\n            // ^ The `rounding` parameter is a compromise borne of a couple days\r\n            // of discussion.\r\n            buy(best_maker_id, min(m_pay_amt, t_buy_amt));\r\n            t_buy_amt_old = t_buy_amt;\r\n            t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\r\n            t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\r\n\r\n            if (t_pay_amt == 0 || t_buy_amt == 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (t_buy_amt > 0 && t_pay_amt > 0 && t_pay_amt >= _dust[address(t_pay_gem)]) {\r\n            //new offer should be created\r\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\r\n            //insert offer into the sorted list\r\n            _sort(id, pos);\r\n        }\r\n    }\r\n\r\n    // Make a new offer without putting it in the sorted list.\r\n    // Takes funds from the caller into market escrow.\r\n    // ****Available to authorized contracts only!**********\r\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\r\n    function _offeru(\r\n        uint pay_amt,      //maker (ask) sell how much\r\n        ERC20 pay_gem,     //maker (ask) sell which token\r\n        uint buy_amt,      //maker (ask) buy how much\r\n        ERC20 buy_gem      //maker (ask) buy which token\r\n    )\r\n        internal\r\n        returns (uint id)\r\n    {\r\n        require(_dust[address(pay_gem)] <= pay_amt);\r\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\r\n        _near[id] = _head;\r\n        _head = id;\r\n        emit LogUnsortedOffer(id);\r\n    }\r\n\r\n    //put offer into the sorted list\r\n    function _sort(\r\n        uint id,    //maker (ask) id\r\n        uint pos    //position to insert into\r\n    )\r\n        internal\r\n    {\r\n        require(isActive(id));\r\n\r\n        ERC20 buy_gem = offers[id].buy_gem;\r\n        ERC20 pay_gem = offers[id].pay_gem;\r\n        uint prev_id;                                      //maker (ask) id\r\n\r\n        pos = pos == 0 || offers[pos].pay_gem != pay_gem || offers[pos].buy_gem != buy_gem || !isOfferSorted(pos)\r\n        ?\r\n            _find(id)\r\n        :\r\n            _findpos(id, pos);\r\n\r\n        if (pos != 0) {                                    //offers[id] is not the highest offer\r\n            //requirement below is satisfied by statements above\r\n            //require(_isPricedLtOrEq(id, pos));\r\n            prev_id = _rank[pos].prev;\r\n            _rank[pos].prev = id;\r\n            _rank[id].next = pos;\r\n        } else {                                           //offers[id] is the highest offer\r\n            prev_id = _best[address(pay_gem)][address(buy_gem)];\r\n            _best[address(pay_gem)][address(buy_gem)] = id;\r\n        }\r\n\r\n        if (prev_id != 0) {                               //if lower offer does exist\r\n            //requirement below is satisfied by statements above\r\n            //require(!_isPricedLtOrEq(id, prev_id));\r\n            _rank[prev_id].next = id;\r\n            _rank[id].prev = prev_id;\r\n        }\r\n\r\n        _span[address(pay_gem)][address(buy_gem)]++;\r\n        emit LogSortedOffer(id);\r\n    }\r\n\r\n    // Remove offer from the sorted list (does not cancel offer)\r\n    function _unsort(\r\n        uint id    //id of maker (ask) offer to remove from sorted list\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        address buy_gem = address(offers[id].buy_gem);\r\n        address pay_gem = address(offers[id].pay_gem);\r\n        require(_span[pay_gem][buy_gem] > 0);\r\n\r\n        require(_rank[id].delb == 0 &&                    //assert id is in the sorted list\r\n                 isOfferSorted(id));\r\n\r\n        if (id != _best[pay_gem][buy_gem]) {              // offers[id] is not the highest offer\r\n            require(_rank[_rank[id].next].prev == id);\r\n            _rank[_rank[id].next].prev = _rank[id].prev;\r\n        } else {                                          //offers[id] is the highest offer\r\n            _best[pay_gem][buy_gem] = _rank[id].prev;\r\n        }\r\n\r\n        if (_rank[id].prev != 0) {                        //offers[id] is not the lowest offer\r\n            require(_rank[_rank[id].prev].next == id);\r\n            _rank[_rank[id].prev].next = _rank[id].next;\r\n        }\r\n\r\n        _span[pay_gem][buy_gem]--;\r\n        _rank[id].delb = block.number;                    //mark _rank[id] for deletion\r\n        return true;\r\n    }\r\n\r\n    //Hide offer from the unsorted order book (does not cancel offer)\r\n    function _hide(\r\n        uint id     //id of maker offer to remove from unsorted list\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint uid = _head;               //id of an offer in unsorted offers list\r\n        uint pre = uid;                 //id of previous offer in unsorted offers list\r\n\r\n        require(!isOfferSorted(id));    //make sure offer id is not in sorted offers list\r\n\r\n        if (_head == id) {              //check if offer is first offer in unsorted offers list\r\n            _head = _near[id];          //set head to new first unsorted offer\r\n            _near[id] = 0;              //delete order from unsorted order list\r\n            return true;\r\n        }\r\n        while (uid > 0 && uid != id) {  //find offer in unsorted order list\r\n            pre = uid;\r\n            uid = _near[uid];\r\n        }\r\n        if (uid != id) {                //did not find offer id in unsorted offers list\r\n            return false;\r\n        }\r\n        _near[pre] = _near[id];         //set previous unsorted offer to point to offer after offer id\r\n        _near[id] = 0;                  //delete order from unsorted order list\r\n        return true;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"close_time\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"pay_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"buy_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogBump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"LogBuyEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogDelete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogInsert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogItemUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"pay_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"buy_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogKill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"pay_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"buy_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogMake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"LogMatchingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"min_amount\",\"type\":\"uint256\"}],\"name\":\"LogMinSell\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogSortedOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"take_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"give_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogTake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buy_gem\",\"type\":\"address\"}],\"name\":\"LogTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogUnsortedOffer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_best\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_dust\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_near\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_rank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"next\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delb\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_span\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract DSAuthority\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id_\",\"type\":\"bytes32\"}],\"name\":\"bump\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"max_fill_amount\",\"type\":\"uint256\"}],\"name\":\"buyAllAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fill_amt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"close_time\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"del_rank\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dustId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"sell_gem\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"}],\"name\":\"getBestOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetterOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pay_amt\",\"type\":\"uint256\"}],\"name\":\"getBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fill_amt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstUnsortedOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"}],\"name\":\"getMinSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getNextUnsortedOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"sell_gem\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"}],\"name\":\"getOfferCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amt\",\"type\":\"uint256\"}],\"name\":\"getPayAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fill_amt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getWorseOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"insert\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isOfferSorted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_offer_id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"pay_amt\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"buy_amt\",\"type\":\"uint128\"}],\"name\":\"make\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"matchingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"offer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"rounding\",\"type\":\"bool\"}],\"name\":\"offer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"}],\"name\":\"offer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"buy_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"min_fill_amount\",\"type\":\"uint256\"}],\"name\":\"sellAllAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fill_amt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract DSAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"buyEnabled_\",\"type\":\"bool\"}],\"name\":\"setBuyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"matchingEnabled_\",\"type\":\"bool\"}],\"name\":\"setMatchingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"pay_gem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dust\",\"type\":\"uint256\"}],\"name\":\"setMinSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"maxTakeAmount\",\"type\":\"uint128\"}],\"name\":\"take\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MatchingMarket","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000601be1c0","Library":"","LicenseType":"None","SwarmSource":"bzzr://5b0c151f0af00c06b5e7e444003a6a00e95e2e416fe2b80a78015489ce8f2d80"}]}