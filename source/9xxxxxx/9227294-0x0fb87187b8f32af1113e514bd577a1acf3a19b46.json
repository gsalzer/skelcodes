{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\ncontract HEX {\r\n    function xfLobbyEnter(address referrerAddr)\r\n    external\r\n    payable;\r\n\r\n    function xfLobbyExit(uint256 enterDay, uint256 count)\r\n    external;\r\n\r\n    function xfLobbyPendingDays(address memberAddr)\r\n    external\r\n    view\r\n    returns (uint256[2] memory words);\r\n\r\n    function balanceOf (address account)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n    function transfer (address recipient, uint256 amount)\r\n    external\r\n    returns (bool);\r\n\r\n    function currentDay ()\r\n    external\r\n    view\r\n    returns (uint256);\r\n}\r\n\r\ncontract Router {\r\n\r\n    struct CustomerState {\r\n        uint16 nextPendingDay;\r\n        mapping(uint256 => uint256) contributionByDay;\r\n    }\r\n\r\n    struct LobbyContributionState {\r\n        uint256 totalValue;\r\n        uint256 heartsReceived;\r\n    }\r\n\r\n    struct ContractStateCache {\r\n        uint256 currentDay;\r\n        uint256 nextPendingDay;\r\n    }\r\n\r\n    event LobbyJoined(\r\n        uint40 timestamp,\r\n        uint16 day,\r\n        uint256 amount,\r\n        address indexed customer,\r\n        address indexed affiliate\r\n    );\r\n\r\n    event LobbyLeft(\r\n        uint40 timestamp,\r\n        uint16 day,\r\n        uint256 hearts\r\n    );\r\n\r\n    event MissedLobby(\r\n        uint40 timestamp,\r\n        uint16 day\r\n    );\r\n\r\n    // from HEX\r\n    uint16 private constant LAUNCH_PHASE_DAYS = 350;\r\n    uint16 private constant LAUNCH_PHASE_END_DAY = 351;\r\n    uint256 private constant XF_LOBBY_DAY_WORDS = (LAUNCH_PHASE_END_DAY + 255) >> 8;\r\n\r\n    // constants & mappings we need\r\n    HEX private constant hx = HEX(0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39);\r\n    address private constant DEFAULT_OPERATOR = 0xD30BC4859A79852157211E6db19dE159673a67E2;\r\n    address private operatorOne;\r\n    address private operatorTwo;\r\n    address private operatorThree;\r\n    address private constant splitter = 0x292A6FE731314557f08F7D598eADaa1988018833;\r\n    uint256 private contractNextPendingDay;\r\n    uint256 public HEX_LAUNCH_TIME = 1575331200;\r\n    mapping(address => uint8) private registeredAffiliates;\r\n    mapping(uint256 => LobbyContributionState) private totalValueByDay;\r\n    mapping(address => CustomerState) private customerData;\r\n\r\n    modifier operatorOnly() {\r\n        require(msg.sender == operatorOne ||\r\n                msg.sender == operatorTwo ||\r\n                msg.sender == operatorThree,\r\n                 \"This operation is only allowed to be performed by the contract operator\");\r\n        _;\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        operatorOne = DEFAULT_OPERATOR;\r\n        operatorTwo = DEFAULT_OPERATOR;\r\n        operatorThree = DEFAULT_OPERATOR;\r\n        contractNextPendingDay = _getHexContractDay(); // today is the next day to resolve\r\n    }\r\n\r\n    function enterLobby(address customer, address affiliate)\r\n    public\r\n    payable\r\n    {\r\n      bool isAffiliate = false;\r\n        if(affiliate != address(0) && registeredAffiliates[msg.sender] > 0){\r\n            // real affiliate, use them for ref\r\n            isAffiliate = true;\r\n            uint256 half = msg.value / 2;\r\n            hx.xfLobbyEnter.value(half)(affiliate);\r\n            hx.xfLobbyEnter.value(msg.value - half)(splitter);\r\n        } else {\r\n            hx.xfLobbyEnter.value(msg.value)(splitter);\r\n        }\r\n\r\n        // record customer contribution\r\n        uint256 currentDay = _getHexContractDay();\r\n        totalValueByDay[currentDay].totalValue += msg.value;\r\n        customerData[customer].contributionByDay[currentDay] += msg.value;\r\n        if(customerData[customer].nextPendingDay == 0){\r\n            // new user\r\n            customerData[customer].nextPendingDay = uint16(currentDay);\r\n        }\r\n\r\n        if(isAffiliate){\r\n          emit LobbyJoined(\r\n              uint40(block.timestamp),\r\n              uint16(currentDay),\r\n              msg.value,\r\n              customer,\r\n              affiliate\r\n          );\r\n        } else {\r\n          //if the splitter is used as referral, set the zero address as affiliate\r\n          emit LobbyJoined(\r\n              uint40(block.timestamp),\r\n              uint16(currentDay),\r\n              msg.value,\r\n              customer,\r\n              address(0)\r\n          );\r\n        }\r\n\r\n    }\r\n\r\n    function exitLobbiesBeforeDay(address customer, uint256 day)\r\n    public\r\n    {\r\n        ContractStateCache memory state = ContractStateCache(_getHexContractDay(), contractNextPendingDay);\r\n        uint256 _day = day > 0 ? day : state.currentDay;\r\n        require(customerData[customer].nextPendingDay < _day,\r\n            \"Customer has no active lobby entries for this time period\");\r\n        _leaveLobbies(state, _day);\r\n        // next pending day was updated as part of leaveLobbies\r\n        contractNextPendingDay = state.nextPendingDay;\r\n        _distributeShare(customer, _day);\r\n    }\r\n\r\n    function updateOperatorOne(address newOperator)\r\n    public\r\n    {\r\n        require(msg.sender == operatorOne, \"Operator may only update themself\");\r\n        require(newOperator != address(0),\"New operator must be a non-zero address\");\r\n        operatorOne = newOperator;\r\n    }\r\n\r\n    function updateOperatorTwo(address newOperator)\r\n    public\r\n    {\r\n        require(msg.sender == operatorTwo, \"Operator may only update themself\");\r\n        require(newOperator != address(0),\"New operator must be a non-zero address\");\r\n        operatorTwo = newOperator;\r\n    }\r\n\r\n    function updateOperatorThree(address newOperator)\r\n    public\r\n    {\r\n        require(msg.sender == operatorThree, \"Operator may only update themself\");\r\n        require(newOperator != address(0),\"New operator must be a non-zero address\");\r\n        operatorThree = newOperator;\r\n    }\r\n\r\n    function registerAffiliate(address affiliateContract)\r\n    public\r\n    operatorOnly\r\n    {\r\n        require(registeredAffiliates[affiliateContract] == 0, \"Affiliate contract is already registered\");\r\n        registeredAffiliates[affiliateContract] = 1;\r\n    }\r\n\r\n    function verifyAffiliate(address affiliateContract)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return registeredAffiliates[affiliateContract] > 0;\r\n    }\r\n\r\n    function ()\r\n    external\r\n    payable\r\n    {\r\n        // If someone just sends eth, get them in a lobby with no affiliate, i.e. splitter\r\n        enterLobby(msg.sender, address(0));\r\n    }\r\n\r\n    function _getHexContractDay()\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(HEX_LAUNCH_TIME < block.timestamp, \"Launch time not before current block\");\r\n        return (block.timestamp - HEX_LAUNCH_TIME) / 1 days;\r\n    }\r\n\r\n    function _leaveLobbies(ContractStateCache memory currentState, uint256 beforeDay)\r\n    private\r\n    {\r\n        uint256 newBalance = hx.balanceOf(address(this));\r\n        uint256 oldBalance;\r\n        if(currentState.nextPendingDay < beforeDay){\r\n            uint256[XF_LOBBY_DAY_WORDS] memory joinedDays = hx.xfLobbyPendingDays(address(this));\r\n            while(currentState.nextPendingDay < beforeDay){\r\n                if( (joinedDays[currentState.nextPendingDay >> 8] & (1 << (currentState.nextPendingDay & 255))) >>\r\n                    (currentState.nextPendingDay & 255) == 1){\r\n                    hx.xfLobbyExit(currentState.nextPendingDay, 0);\r\n                    oldBalance = newBalance;\r\n                    newBalance = hx.balanceOf(address(this));\r\n                    totalValueByDay[currentState.nextPendingDay].heartsReceived = newBalance - oldBalance;\r\n                    require(totalValueByDay[currentState.nextPendingDay].heartsReceived > 0, \"Hearts received for a lobby is 0\");\r\n                    emit LobbyLeft(uint40(block.timestamp),\r\n                        uint16(currentState.nextPendingDay),\r\n                        totalValueByDay[currentState.nextPendingDay].heartsReceived);\r\n                } else {\r\n                    emit MissedLobby(uint40(block.timestamp),\r\n                     uint16(currentState.nextPendingDay));\r\n                }\r\n                currentState.nextPendingDay++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _distributeShare(address customer, uint256 endDay)\r\n    private\r\n    returns (uint256)\r\n    {\r\n        uint256 totalShare = 0;\r\n        CustomerState storage user = customerData[customer];\r\n        uint256 nextDay = user.nextPendingDay;\r\n        if(nextDay > 0 && nextDay < endDay){\r\n            while(nextDay < endDay){\r\n                if(totalValueByDay[nextDay].totalValue > 0 && totalValueByDay[nextDay].heartsReceived > 0){\r\n                    require(totalValueByDay[nextDay].heartsReceived > 0, \"Hearts received must be > 0, leave lobby for day\");\r\n                    totalShare += user.contributionByDay[nextDay] *\r\n                        totalValueByDay[nextDay].heartsReceived /\r\n                        totalValueByDay[nextDay].totalValue;\r\n                }\r\n                nextDay++;\r\n            }\r\n            if(totalShare > 0){\r\n                require(hx.transfer(customer, totalShare), strConcat(\"Failed to transfer \",uint2str(totalShare),\", insufficient balance\"));\r\n            }\r\n        }\r\n        if(nextDay != user.nextPendingDay){\r\n            user.nextPendingDay = uint16(nextDay);\r\n        }\r\n\r\n        return totalShare;\r\n    }\r\n\r\n    function uint2str(uint i)\r\n    internal\r\n    pure returns (string memory _uintAsString)\r\n    {\r\n        uint _i = i;\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c\r\n    , string memory _d, string memory _e)\r\n    private\r\n    pure\r\n    returns (string memory){\r\n    bytes memory _ba = bytes(_a);\r\n    bytes memory _bb = bytes(_b);\r\n    bytes memory _bc = bytes(_c);\r\n    bytes memory _bd = bytes(_d);\r\n    bytes memory _be = bytes(_e);\r\n    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n    bytes memory babcde = bytes(abcde);\r\n    uint k = 0;\r\n    for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n    for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n    for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n    for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n    for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n    return string(babcde);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d)\r\n    private\r\n    pure\r\n    returns (string memory) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c)\r\n    private\r\n    pure\r\n    returns (string memory) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b)\r\n    private\r\n    pure\r\n    returns (string memory) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n}\r\n\r\ncontract Affiliate {\r\n\r\n    Router private router = Router(0xFa6e6DA7b352Ef0775e03f27756D3654cd68d53b);\r\n\r\n    address private affiliateAddr;\r\n\r\n    constructor(address affiliate)\r\n    public\r\n    {\r\n        affiliateAddr = affiliate;\r\n    }\r\n\r\n    function enterLobby()\r\n    public\r\n    payable\r\n    {\r\n        router.enterLobby.value(msg.value)(msg.sender, affiliateAddr);\r\n    }\r\n\r\n    // in theory this could exit on behalf of a customer by taking an address... not sure if that's good\r\n    function exitLobbies()\r\n    public\r\n    {\r\n        router.exitLobbiesBeforeDay(msg.sender, 0);\r\n    }\r\n\r\n    function ()\r\n    external\r\n    payable\r\n    {\r\n        //if the transaction value is 0, exit lobbies instead\r\n        if(msg.value > 0)\r\n        {\r\n          enterLobby();\r\n        }\r\n          else\r\n        {\r\n          router.exitLobbiesBeforeDay(msg.sender, 0);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"enterLobby\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exitLobbies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Affiliate","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d30bc4859a79852157211e6db19de159673a67e2","Library":"","LicenseType":"None","SwarmSource":"bzzr://92d4f4b8d2879c6ea721e8a8c3c37364755a6726b1138c542b7ee3c06802add1"}]}