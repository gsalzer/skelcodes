{"status":"1","message":"OK","result":[{"SourceCode":"// ╔══╗╔═══╗╔╗╔╗╔═══╗╔════╗╔══╗╔═══╗╔══╗╔╗──╔╗╔═══╗──╔══╗─╔═══╗╔════╗\r\n// ║╔═╝║╔═╗║║║║║║╔═╗║╚═╗╔═╝║╔╗║║╔══╝║╔╗║║║──║║║╔══╝──║╔╗║─║╔══╝╚═╗╔═╝\r\n// ║║──║╚═╝║║╚╝║║╚═╝║──║║──║║║║║║╔═╗║╚╝║║╚╗╔╝║║╚══╗──║╚╝╚╗║╚══╗──║║\r\n// ║║──║╔╗╔╝╚═╗║║╔══╝──║║──║║║║║║╚╗║║╔╗║║╔╗╔╗║║╔══╝──║╔═╗║║╔══╝──║║\r\n// ║╚═╗║║║║──╔╝║║║─────║║──║╚╝║║╚═╝║║║║║║║╚╝║║║╚══╗╔╗║╚═╝║║╚══╗──║║\r\n// ╚══╝╚╝╚╝──╚═╝╚╝─────╚╝──╚══╝╚═══╝╚╝╚╝╚╝──╚╝╚═══╝╚╝╚═══╝╚═══╝──╚╝\r\n\r\n\r\n//By playing platform games you agree that your age is over 21 and you clearly understand that you can lose your coins\r\n//The platform is not responsible for all Ethereum cryptocurrency losses during the game.\r\n//The contract uses the entropy algorithm Signidice\r\n//https://github.com/gluk256/misc/blob/master/rng4ethereum/signidice.md\r\n\r\npragma solidity 0.5.16;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a); \r\n    return a - b; \r\n  } \r\n  \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) { \r\n    uint256 c = a + b; assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract CryptoGames {\r\n    using SafeMath for uint;\r\n    address payable public  owner = 0x333333e25F2176e2e165Aeb1b933cE10Cf315b47;\r\n    address public  CROUPIER_BOB = 0xB0B3336c83A4c86FBd4f804BB8D410B23F181b05;\r\n    uint public minStake = 0.01 ether;\r\n    uint public maxStake = 15 ether;\r\n    uint public constant WIN_COEFFICIENT = 198;\r\n    uint public constant DICE_COEFFICIENT = 600;\r\n    mapping(address => uint) public deposit;\r\n    mapping(address => uint) public withdrawal;\r\n    bool status = true;\r\n\r\n    enum GameState {\r\n        Pending,\r\n        Win,\r\n        Lose,\r\n        Draw\r\n    }\r\n    \r\n    enum Games {\r\n        CoinFlip,\r\n        KNB,\r\n        Dice\r\n    }\r\n\r\n    struct Game {\r\n        Games game_title;\r\n        address payable player;\r\n        uint bet;\r\n        bytes32 seed;\r\n        GameState state;\r\n        uint result;\r\n        bytes choice;\r\n        uint profit;\r\n    }\r\n\r\n    event NewGame(address indexed player, bytes32 seed, uint bet, bytes choice, string  game);\r\n    event DemoGame(address indexed player, bytes32 seed, uint bet, bytes choice, string  game);\r\n    event ConfirmGame(address indexed player, string  game, uint profit, bytes choice, uint game_choice, bytes32 seed, bool status, bool draw,  uint timestamp);\r\n    event Deposit(address indexed from, uint indexed block, uint value, uint time);\r\n    event Withdrawal(address indexed from, uint indexed block, uint value, uint ident,uint time);\r\n    mapping(bytes32 => Game) public listGames;\r\n    \r\n    // Only our croupier and no one else can open the bet\r\n    modifier onlyCroupier() {\r\n        require(msg.sender == CROUPIER_BOB);\r\n        _;\r\n    }\r\n    \r\n    // Check that the rate is between 0.01 - 15 ether\r\n    modifier betInRange() {\r\n        require(minStake <= msg.value && msg.value <= maxStake);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner); _;\r\n    }\r\n    \r\n    modifier isNotContract() {\r\n        uint size;\r\n        address addr = msg.sender;\r\n        assembly { size := extcodesize(addr) }\r\n        require(size == 0 && tx.origin == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    modifier contractIsOn() {\r\n        require(status);\r\n        _;\r\n    }\r\n\r\n    // Game CoinFlip\r\n    // The game of tossing a coin, the coin has 2 sides,\r\n    // an eagle and a tails, which one is up to you to choose\r\n    function game_coin(bytes memory _choice, bytes32 seed) public betInRange payable returns(uint8) {\r\n        string memory game_title = 'CoinFlip';\r\n        uint8 user_choice;\r\n        assembly {user_choice := mload(add(0x1, _choice))}\r\n        require(listGames[seed].bet == 0x0);\r\n        require(_choice.length == 1);\r\n        require(user_choice == 0 || user_choice == 1);\r\n        \r\n        listGames[seed] = Game({\r\n            game_title: Games.CoinFlip,\r\n            player: msg.sender,\r\n            bet: msg.value,\r\n            seed: seed,\r\n            state: GameState.Pending,\r\n            choice: _choice,\r\n            result: 0,\r\n            profit: 0\r\n        });\r\n        emit NewGame(msg.sender, seed, msg.value, _choice, game_title);\r\n        return user_choice;\r\n    }\r\n    \r\n    // Game KNB\r\n    // Game of stone, scissors, paper\r\n    // The stone breaks the scissors, the scissors cut the paper, the paper wraps the stone.\r\n    // Everything is just kk in childhood, it remains only to try to play\r\n    function game_knb(bytes memory _choice, bytes32 seed) public betInRange payable {\r\n        string memory game_title = 'KNB';\r\n        uint8 user_choice;\r\n        assembly {user_choice := mload(add(0x1, _choice))}\r\n        require(listGames[seed].bet == 0x0);\r\n        require(_choice.length == 1);\r\n        //Checking that bids are in the right range\r\n        //1 - stone, 2 - scissors, 3 - paper\r\n        require(user_choice >=1 && user_choice <=3);\r\n        \r\n        listGames[seed] = Game({\r\n            game_title: Games.KNB,\r\n            player: msg.sender,\r\n            bet: msg.value,\r\n            seed: seed,\r\n            state: GameState.Pending,\r\n            choice: _choice,\r\n            result: 0,\r\n            profit: 0\r\n        });\r\n       emit NewGame(msg.sender, seed, msg.value, _choice, game_title);\r\n    }\r\n    \r\n    // Game Dice\r\n    // Playing dice, the player can select up to 5 dice values at a time. The more dice a player chooses, the less his final reward.\r\n    // The reward is calculated according to the formula:  (6 / number of selected cubes) * bet\r\n    function game_dice(bytes memory _choice, bytes32 seed) public betInRange payable {\r\n        string memory game_title = 'Dice';\r\n        require(listGames[seed].bet == 0x0);\r\n        //Checking that bids are in the right range, and no more than 5 cubes are selected\r\n        require(_choice.length >= 1 && _choice.length <= 5);\r\n        \r\n        // for(uint i=0; i< _choice.length; i++){\r\n        //     require(_choice[i] > 0 && _choice[i] < 7);\r\n        // }\r\n        \r\n        listGames[seed] = Game({\r\n            game_title: Games.Dice,\r\n            player: msg.sender,\r\n            bet: msg.value,\r\n            seed: seed,\r\n            state: GameState.Pending,\r\n            choice: _choice,\r\n            result: 0,\r\n            profit: 0\r\n        });\r\n        emit NewGame(msg.sender, seed, msg.value, _choice, game_title);\r\n    }\r\n\r\n    //Casino must sign the resulting value V with its PrivKey, thus producing the digital signature S = sign(PrivKey, V), and send the corresponding TX, containing S.\r\n    //The contract recovers the actual public key (K) from the digital signature S, and verifies that it is equal to the previously published PubKey (K == PubKey).\r\n    //If APK does not match PubKey, it is tantamount to cheating. In this case, the contract simply rejects the transaction.\r\n    //The contract uses S as a seed for the predefined PRNG algorithm (e.g. SHA-3 based), which produces the lucky number (L), e.g. between 1 and 6.\r\n    function confirm(bytes32 seed, uint8 _v, bytes32 _r, bytes32 _s) public onlyCroupier {\r\n        // Checking that it was Uncle Bob who signed the transaction, otherwise we reject the impostor transaction\r\n        require (ecrecover(seed, _v, _r, _s) == CROUPIER_BOB);\r\n        Game storage game = listGames[seed];\r\n        bytes memory choice = game.choice;\r\n        game.result = uint256(_s) % 12;\r\n        uint profit = 0;\r\n        uint8 user_choice;\r\n        //Our algorithms are very simple and understandable even to the average Internet user and do not need additional explanation\r\n        //Coin game algorithm\r\n        if (game.game_title == Games.CoinFlip){\r\n            assembly {user_choice := mload(add(0x1, choice))}\r\n            if(game.result == user_choice){\r\n                profit = game.bet.mul(WIN_COEFFICIENT).div(100);\r\n                game.state = GameState.Win;\r\n                game.profit = profit;\r\n                game.player.transfer(profit);\r\n                emit ConfirmGame(game.player, 'CoinFlip', profit, game.choice, game.result, game.seed, true, false, now);\r\n            }else{\r\n                game.state = GameState.Lose;\r\n                emit ConfirmGame(game.player, 'CoinFlip', 0, game.choice, game.result, game.seed, false, false, now);\r\n            }\r\n        //KNB game algorithm\r\n        }else if(game.game_title == Games.KNB){\r\n            assembly {user_choice := mload(add(0x1, choice))}\r\n            if(game.result != user_choice){\r\n                if (user_choice == 1 && game.result == 2 || user_choice == 2 && game.result == 3 || user_choice == 3 && game.result == 1) {\r\n                    profit = game.bet.mul(WIN_COEFFICIENT).div(100);\r\n                    game.state = GameState.Win;\r\n                    game.profit = profit;\r\n                    game.player.transfer(profit);\r\n                    emit ConfirmGame(game.player, 'KNB', profit, game.choice, game.result, game.seed, true, false, now);\r\n                }else{\r\n                    game.state = GameState.Lose;\r\n                    emit ConfirmGame(game.player, 'KNB', 0, game.choice, game.result, game.seed, false, false, now);\r\n                }\r\n            }else{\r\n                profit = game.bet.sub(0.001 ether);\r\n                game.player.transfer(profit);\r\n                game.state = GameState.Draw;\r\n                emit ConfirmGame(game.player, 'KNB', profit, game.choice, game.result, game.seed, false, true, now);\r\n            }\r\n        //Dice game algorithm\r\n        }else if(game.game_title == Games.Dice){\r\n            uint length = game.choice.length + 1;\r\n            for(uint8 i=1; i< length; i++){\r\n                assembly {user_choice  := mload(add(i, choice))}\r\n                if (user_choice == game.result){\r\n                    profit = game.bet.mul(DICE_COEFFICIENT.div(game.choice.length)).div(100);\r\n                }\r\n            }\r\n            if(profit > 0){\r\n                game.state = GameState.Win;\r\n                game.profit = profit;\r\n                game.player.transfer(profit);\r\n                emit ConfirmGame(game.player, 'Dice', profit, game.choice, game.result, game.seed, true, false, now);\r\n            }else{\r\n                game.state = GameState.Lose;\r\n                emit ConfirmGame(game.player, 'Dice', 0, game.choice, game.result, game.seed, false, false, now);\r\n            }\r\n        }\r\n    }\r\n    // Demo game, 0 ether value. To reduce the cost of the game, we calculate a random result on the server\r\n    function demo_game(string memory game, bytes memory _choice, bytes32 seed, uint bet) public {\r\n        emit DemoGame(msg.sender, seed, bet, _choice, game);\r\n    }\r\n    \r\n    function get_player_choice(bytes32 seed) public view returns(bytes memory) {\r\n        Game storage game = listGames[seed];\r\n        return game.choice;\r\n    }\r\n    \r\n    //The casino has its own expenses for maintaining the servers, paying for them, each signature by our bot Bob costs 0.00135 ether\r\n    //and we honestly believe that the money that players own is ours, everyone can try their luck and play with us\r\n    function pay_royalty (uint _value) onlyOwner public {\r\n        owner.transfer(_value * 1 ether);\r\n    }\r\n    \r\n    //automatic withdrawal using server bot\r\n    function multisend(address payable[] memory dests, uint256[] memory values, uint256[] memory ident) onlyOwner contractIsOn public returns(uint) {\r\n        uint256 i = 0;\r\n        \r\n        while (i < dests.length) {\r\n            uint transfer_value = values[i].sub(values[i].mul(3).div(100));\r\n            dests[i].transfer(transfer_value);\r\n            withdrawal[dests[i]]+=values[i];\r\n            emit Withdrawal(dests[i], block.number, values[i], ident[i], now);\r\n            i += 1;\r\n        }\r\n        return(i);\r\n    }\r\n    \r\n    function startProphylaxy()onlyOwner public {\r\n        status = false;\r\n    }\r\n    \r\n    function stopProphylaxy()onlyOwner public {\r\n        status = true;\r\n    }\r\n    // recharge function for games\r\n    function() external isNotContract contractIsOn betInRange payable {\r\n        deposit[msg.sender]+= msg.value;\r\n        emit Deposit(msg.sender, block.number, msg.value, now);\r\n    }\r\n}\r\n\r\n//P̴̩͖͈̳o̷̡̳̭̞͔̺̩̩w̸̡̡̡̤̹͙͔̜̮̟̺̬̰͔͉͉͎͉̠̝͜ͅe̵̜̤̹ŗ̶̹̞̰̭̹̭̻̤͔͈͓͉ę̵̡͉͚̲̞̘͙̥̳͇͓̭ḑ̷̞̰̯̭͚͎̣͔̜̝̬͜ͅͅ ̵̣̲b̷̢͙͈̣̝̩͔͉͖y̷̢̱̠̙̘̹̟̠̙͖͍̹̦͍ͅ ̵̡̢̠̗͎͍͕̯̹͈͈̬̹c̷̢̪̪͎̺̠̤̮̙̜̞͈̞̝̭̭r̸̥̯̩̩̝̟͉̲̪̣̬̟̮̤̲̜y̵̗̬͓͎̻̱̝̗͕̟͙̯͇̜̤̲͔̭̫͓p̸̢͇͇̠̪t̵̹̳̮͇͜ǫ̸̙̬ͅͅģ̵̹̬͉̫̣͔̝̳̘̰̘̤̮a̸̡͖̮͙̯̬̰̫̫̘͎͎̰͇̹̜̼̥͚͇͉͔͚͓m̸̢̫̙̫̮̪͕̭̟̬̣̟̫̦͙̖ȩ̸̡̧̟̰̯͖̲͍̳͚̘̦͎̙̥̫͎̺̤̮͜ͅ.̴̨̱̲͚b̸͍͔e̶̡̡̡̜̬͓̤̣͍̝͚͖̘͈̱̘̲̠͓͍͙͉̯͍t̵̻̮\r\n//\r\n//","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"game\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"choice\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"game_choice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"draw\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ConfirmGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"choice\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"game\",\"type\":\"string\"}],\"name\":\"DemoGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"choice\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"game\",\"type\":\"string\"}],\"name\":\"NewGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ident\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"CROUPIER_BOB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DICE_COEFFICIENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WIN_COEFFICIENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"game\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_choice\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"demo_game\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_choice\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"game_coin\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_choice\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"game_dice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_choice\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"game_knb\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"get_player_choice\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"listGames\",\"outputs\":[{\"internalType\":\"enum CryptoGames.Games\",\"name\":\"game_title\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"internalType\":\"enum CryptoGames.GameState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"choice\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"dests\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ident\",\"type\":\"uint256[]\"}],\"name\":\"multisend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"pay_royalty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startProphylaxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopProphylaxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CryptoGames","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://ae19df3b7dac8414747b3b4104ff5bc029758ad0334c093e52207020727726c7"}]}