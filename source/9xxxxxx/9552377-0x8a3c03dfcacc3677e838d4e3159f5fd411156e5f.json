{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface IERC20Mintable {\r\n    function mint(address[] _receiver, uint256[] _value, uint256[] _timestamp) external;\r\n}\r\ninterface IERC20ImplUpgradeable {\r\n    function getImplAddress() view external returns(address);\r\n    function getMintBurnAddress() view external returns(address);\r\n    function isImplAddress(address) view external returns(bool);\r\n}\r\ninterface IERC20Burnable {\r\n    function burn(address[] _receiver, uint256[] _value, uint256[] _timestamp) external;\r\n    function burnAll(address[] _receiver) external;\r\n}\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n    event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n    );\r\n\r\n    event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n    );\r\n}\r\n\r\ncontract ContractBase {\r\n    \r\n    Proxy proxy;\r\n\r\n    constructor(address _proxy) public {\r\n        proxy = Proxy(_proxy);\r\n    }\r\n    \r\n}\r\n\r\nlibrary Address {\r\n \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\ncontract AuthModule {\r\n\r\n    address primaryAdmin;\r\n    address primaryIssuer;\r\n    address primaryExchange;\r\n\r\n    event JobshipTransferred(\r\n        string  strType,\r\n        address indexed previousOwner,\r\n        address indexed newOwner,\r\n        address indexed caller\r\n      );\r\n\r\n    constructor(\r\n        address _admin, \r\n        address _issuer, \r\n        address _exchange\r\n    ) \r\n        public \r\n    {\r\n        primaryAdmin = _admin;\r\n        primaryIssuer = _issuer;\r\n        primaryExchange = _exchange;\r\n    }\r\n\r\n    function isAdmin(address _admin) public view returns (bool) {\r\n        return primaryAdmin == _admin;\r\n    }\r\n\r\n    function isIssuer(address _issuer) public view returns (bool) {\r\n        return primaryIssuer == _issuer;\r\n    }\r\n\r\n    function isExchange(address _exchange) public view returns (bool) {\r\n        return primaryExchange == _exchange;\r\n    }\r\n\r\n    function transferIssuer(address _addr) public returns (bool) {\r\n        require (_addr != address(0) && _addr != primaryIssuer, \"_addr invalid\");\r\n        require (isIssuer(msg.sender) || isAdmin(msg.sender), \"only issuer or admin\");\r\n\r\n        emit JobshipTransferred(\"issuer\", primaryIssuer, _addr, msg.sender);\r\n        primaryIssuer = _addr;\r\n        return true;\r\n    }\r\n\r\n    function transferExchange(address _addr) public returns(bool) {\r\n        require (_addr != address(0) && _addr != primaryExchange, \"_addr invalid\");\r\n        require (isExchange(msg.sender) || isAdmin(msg.sender), \"only exchange or admin\");\r\n\r\n        emit JobshipTransferred(\"exchange\", primaryExchange, _addr, msg.sender);\r\n        primaryExchange = _addr;\r\n        return true;\r\n    }\r\n}\r\ncontract Pausable {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused, \"Contract is not paused\");\r\n        _;\r\n    }\r\n\r\n    function _pause() internal whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function _unpause() internal whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Authorization is ContractBase, Pausable{\r\n    \r\n    constructor(address _proxy) public ContractBase(_proxy) {\r\n\r\n    }\r\n\r\n    modifier onlyInside(address _sender) {\r\n        require(proxy.isInsideContract(_sender), \"Can only be called inside\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyIssuer(address _sender) {\r\n        AuthModule auth = AuthModule(proxy.getModule(\"AuthModule\"));\r\n        require(auth.isIssuer(_sender), \"Need to be issuer\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin(address _sender) {\r\n        AuthModule auth = AuthModule(proxy.getModule(\"AuthModule\"));\r\n        require(auth.isAdmin(_sender), \"Need to be admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyExchange(address _sender) {\r\n        AuthModule auth = AuthModule(proxy.getModule(\"AuthModule\"));\r\n        require(auth.isExchange(_sender), \"Need to be exchange\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyIssuerOrExchange(address _sender) {\r\n        AuthModule auth = AuthModule(proxy.getModule(\"AuthModule\"));\r\n        require(auth.isIssuer(_sender) || auth.isExchange(_sender), \"Need to be issuer or exchange\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenModule(address _sender) {\r\n        require(_sender == proxy.getModule(\"TokenModule\"), \"Need to be tokenModule\");\r\n        _;\r\n    }\r\n\r\n    function unpause() public onlyAdmin(msg.sender)  {\r\n        _unpause();\r\n    }\r\n\r\n    function pause() public onlyAdmin(msg.sender) {\r\n        _pause();\r\n    }\r\n\r\n}\r\n\r\nlibrary LibMapAddressBool {\r\n\r\n    struct MapAddressBool {\r\n        mapping(address => MapValue) data;  // do not modify this variable outside\r\n        uint256 length;\r\n    }\r\n\r\n    struct MapValue {\r\n        bool value;\r\n        bool inited;\r\n    }\r\n\r\n    function add(MapAddressBool storage self, address _key, bool _val) public returns (bool newAdded) {\r\n        if(!self.data[_key].inited) {\r\n            self.data[_key].inited = true;\r\n            self.length++;\r\n            newAdded = true;\r\n        }\r\n        self.data[_key].value = _val;\r\n    }\r\n\r\n    function remove(MapAddressBool storage self, address _key) public returns (bool removed) {\r\n        if(self.data[_key].inited) {\r\n            self.data[_key].inited = false;\r\n            // self.data[_key].value = false;  // no need to reset value here\r\n            self.length--;\r\n            removed = true;\r\n        }\r\n    }\r\n\r\n    function contain(MapAddressBool storage self, address _key) public view returns (bool) {\r\n        return self.data[_key].inited;\r\n    }\r\n\r\n    function get(MapAddressBool storage self, address _key) public view returns (bool) {\r\n        if(!self.data[_key].inited)\r\n            return false;\r\n        return self.data[_key].value; \r\n    }\r\n\r\n    // function getLength(AddressBool storage self) public view returns (uint) {\r\n    //     return self.length;\r\n    // }\r\n}\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\nlibrary StringUtils {\r\n    /// @dev Does a byte-by-byte lexicographical comparison of two strings.\r\n    /// @return a negative number if `_a` is smaller, zero if they are equal\r\n    /// and a positive numbe if `_b` is smaller.\r\n    function compare(string _a, string _b) returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n    /// @dev Compares two strings and returns true iff they are equal.\r\n    function equal(string _a, string _b) returns (bool) {\r\n        return compare(_a, _b) == 0;\r\n    }\r\n    /// @dev Finds the index of the first occurrence of _needle in _haystack\r\n    function indexOf(string _haystack, string _needle) returns (int)\r\n    {\r\n    \tbytes memory h = bytes(_haystack);\r\n    \tbytes memory n = bytes(_needle);\r\n    \tif(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n    \t\treturn -1;\r\n    \telse if(h.length > (2**128 -1)) // since we have to be able to return -1 (if the char isn't found or input error), this function must return an \"int\" type with a max length of (2^128 - 1)\r\n    \t\treturn -1;\t\t\t\t\t\t\t\t\t\r\n    \telse\r\n    \t{\r\n    \t\tuint subindex = 0;\r\n    \t\tfor (uint i = 0; i < h.length; i ++)\r\n    \t\t{\r\n    \t\t\tif (h[i] == n[0]) // found the first char of b\r\n    \t\t\t{\r\n    \t\t\t\tsubindex = 1;\r\n    \t\t\t\twhile(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) // search until the chars don't match or until we reach the end of a or b\r\n    \t\t\t\t{\r\n    \t\t\t\t\tsubindex++;\r\n    \t\t\t\t}\t\r\n    \t\t\t\tif(subindex == n.length)\r\n    \t\t\t\t\treturn int(i);\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\treturn -1;\r\n    \t}\t\r\n    }\r\n}\r\n\r\nlibrary ItMapUintAddress\r\n{\r\n    struct MapUintAddress\r\n    {\r\n        mapping(uint => MapValue) data;\r\n        KeyFlag[] keys;\r\n        uint size;\r\n    }\r\n\r\n    struct MapValue { uint keyIndex; address value; }\r\n\r\n    struct KeyFlag { uint key; bool deleted; }\r\n\r\n    function add(MapUintAddress storage self, uint key, address value) public returns (bool replaced)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        self.data[key].value = value;\r\n        if (keyIndex > 0)\r\n            return true;\r\n        else\r\n        {\r\n            self.keys.push(KeyFlag(key, false));\r\n            self.data[key].keyIndex = self.keys.length;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function remove(MapUintAddress storage self, uint key) public returns (bool success)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        if (keyIndex == 0)\r\n            return false;\r\n        delete self.data[key];\r\n        self.keys[keyIndex - 1].deleted = true;\r\n        self.size --;\r\n    }\r\n\r\n    function contain(MapUintAddress storage self, uint key) public view returns (bool)\r\n    {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n\r\n    function startIndex(MapUintAddress storage self) public view returns (uint keyIndex)\r\n    {\r\n        return nextIndex(self, uint(-1));\r\n    }\r\n\r\n    function validIndex(MapUintAddress storage self, uint keyIndex) public view returns (bool)\r\n    {\r\n        return keyIndex < self.keys.length;\r\n    }\r\n\r\n    function nextIndex(MapUintAddress storage self, uint _keyIndex) public view returns (uint)\r\n    {\r\n        uint keyIndex = _keyIndex;\r\n        keyIndex++;\r\n        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)\r\n            keyIndex++;\r\n        return keyIndex;\r\n    }\r\n\r\n    function getByIndex(MapUintAddress storage self, uint keyIndex) public view returns (address value)\r\n    {\r\n        uint key = self.keys[keyIndex].key;\r\n        value = self.data[key].value;\r\n    }\r\n\r\n    function getByKey(MapUintAddress storage self, uint key) public view returns (address value) {\r\n        return self.data[key].value;\r\n    }\r\n}\r\n\r\n\r\ncontract Proxy {\r\n    using Address for address;\r\n\r\n    mapping(string => address) moduleMap;\r\n    mapping(address => bool) insideContracts;   // all internal contract address, used to make sure only called from inside\r\n\r\n    event AddInsideContract(address _contract);\r\n    event AddInsideContracts(address[] _contracts);\r\n    event RemoveInsideContract(address _contract);\r\n    event UpdateModule(string _moduleName, address _preModule, address _newModule);\r\n\r\n    modifier onlyAdmin() {\r\n        AuthModule auth = AuthModule(getModule(\"AuthModule\"));\r\n        require(auth.isAdmin(msg.sender), \"Need be admin\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address authModule) public {\r\n        _updateModule(\"AuthModule\", authModule, true);\r\n    }\r\n\r\n    function addInsideContract(address _contract) public onlyAdmin {\r\n        _addInsideContract(_contract);\r\n    }\r\n\r\n    function _addInsideContract(address _contract) private {\r\n        // require(insideContracts[_contract] == false, \"Inside contract already exists\");\r\n        insideContracts[_contract] = true;\r\n        emit AddInsideContract(_contract);\r\n    }\r\n    \r\n    function addInsideContracts(address[] _contracts) public onlyAdmin {\r\n        for(uint i = 0; i < _contracts.length; i++) {\r\n            // require(insideContracts[_contracts[i]] == false, \"Inside contract already exists\");\r\n            insideContracts[_contracts[i]] = true;\r\n        }\r\n        emit AddInsideContracts(_contracts);\r\n    }\r\n\r\n    function removeInsideContract(address _contract) public onlyAdmin {\r\n        _removeInsideContract(_contract);\r\n    }\r\n\r\n    function _removeInsideContract(address _contract) private {\r\n        delete insideContracts[_contract];\r\n        emit RemoveInsideContract(_contract);\r\n    }\r\n\r\n    // TODO: need to check if the address is a contract\r\n    function isInsideContract(address _contract) public view returns (bool) {\r\n        return _contract.isContract() && insideContracts[_contract] == true;\r\n    }\r\n\r\n    function updateModule(string _moduleName, address _module, bool _insideContract) public onlyAdmin {\r\n        _updateModule(_moduleName, _module, _insideContract);\r\n    }\r\n\r\n    function _updateModule(string _moduleName, address _module, bool _insideContract) private {\r\n        address preModule = moduleMap[_moduleName];\r\n        if(preModule != address(0))\r\n            _removeInsideContract(preModule);\r\n        moduleMap[_moduleName] = _module;\r\n        if(_insideContract && _module != address(0))\r\n            _addInsideContract(_module);\r\n        emit UpdateModule(_moduleName, preModule, _module);\r\n    }\r\n\r\n    function getModule(string _moduleName) public view returns (address) {\r\n        return moduleMap[_moduleName];\r\n    } \r\n    \r\n}\r\n\r\ncontract TokenModule is Authorization {\r\n    \r\n    using ItMapUintAddress for ItMapUintAddress.MapUintAddress;\r\n\r\n    ItMapUintAddress.MapUintAddress tokenMap;\r\n\r\n    event UpdateToken(uint _tag, address _old, address _new);\r\n\r\n    constructor(address _proxy) public Authorization(_proxy) {\r\n       \r\n    }\r\n\r\n    function addToken(uint _tag, address _token) external whenNotPaused onlyAdmin(msg.sender) {\r\n        require(tokenMap.data[_tag].value == address(0), \"Token already exists\");\r\n        tokenMap.add(_tag, _token);\r\n        emit UpdateToken(_tag, address(0), _token);\r\n    }\r\n\r\n    function updateToken(uint _tag, address _token) external whenNotPaused onlyAdmin(msg.sender) {\r\n        require(tokenMap.data[_tag].value != address(0), \"Token not exists\");\r\n        address _old = tokenMap.data[_tag].value;\r\n        tokenMap.add(_tag, _token);\r\n        emit UpdateToken(_tag, _old, _token);\r\n    }\r\n\r\n    function getToken(uint _tag) external view returns (address) {\r\n        return tokenMap.getByKey(_tag);\r\n    }\r\n\r\n    function balanceOf(address _from) external view returns (uint256 sum) {\r\n        for(uint i = tokenMap.startIndex(); tokenMap.validIndex(i); i = tokenMap.nextIndex(i)) {\r\n            IERC20 _token = IERC20(tokenMap.getByIndex(i));\r\n            if(_token != address(0))\r\n                sum += _token.balanceOf(_from);\r\n        }\r\n    }\r\n\r\n    function mint(uint _tokenTag, address[] _investors, uint[] _balances, uint[] _timestamps, bool _originals) external whenNotPaused onlyIssuer(msg.sender) {\r\n        IERC20ImplUpgradeable token = IERC20ImplUpgradeable(tokenMap.getByKey(_tokenTag));\r\n        IERC20Mintable impl = IERC20Mintable(token.getMintBurnAddress());\r\n        require(impl != address(0), \"mint impl require not 0\");\r\n\r\n        impl.mint(_investors, _balances, _timestamps);\r\n\r\n        StorageModule sm = StorageModule(proxy.getModule(\"StorageModule\"));\r\n        sm.initShareholders(_investors, _originals);\r\n    }\r\n\r\n    function burn(uint _tokenTag, address[] _investors, uint256[] _values, uint256[] _timestamps) external whenNotPaused onlyIssuer(msg.sender) {\r\n        IERC20ImplUpgradeable token = IERC20ImplUpgradeable(tokenMap.getByKey(_tokenTag));\r\n        IERC20Burnable impl = IERC20Burnable(token.getMintBurnAddress());\r\n        require(impl != address(0), \"burn impl require not 0\");\r\n        impl.burn(_investors, _values, _timestamps);\r\n    }\r\n\r\n    function burnAll(uint _tokenTag, address[] _investors) external whenNotPaused onlyIssuer(msg.sender) {\r\n        IERC20ImplUpgradeable token = IERC20ImplUpgradeable(tokenMap.getByKey(_tokenTag));\r\n        IERC20Burnable impl = IERC20Burnable(token.getMintBurnAddress());\r\n        require(impl != address(0), \"burn impl require not 0\");\r\n        impl.burnAll(_investors);\r\n    }\r\n\r\n    function getTokenTags() external view returns(uint[] tags){\r\n        tags = new uint[](tokenMap.size);\r\n        uint j = 0;\r\n        for(uint i = tokenMap.startIndex(); tokenMap.validIndex(i); i = tokenMap.nextIndex(i)) {\r\n            tags[j] = tokenMap.keys[i].key;\r\n            ++j;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract StorageModule is Authorization {\r\n\r\n    using SafeMath for uint256;\r\n    using LibMapAddressBool for LibMapAddressBool.MapAddressBool;\r\n    using StringUtils for string;\r\n\r\n    LibMapAddressBool.MapAddressBool shareholders;\r\n    mapping(address => bool) investorWhitelist;\r\n    mapping(address => bool) investorBlacklist;\r\n    mapping(address => InvestorInfo) investorInfo;\r\n    mapping(address => InvestorDocument) investorDocuments;\r\n    mapping(uint => address) usedHashid;\r\n\r\n    mapping(bytes32 => uint256) retailInvestorCounts;\r\n    mapping(bytes32 => mapping(address => uint256)) retailInvestors;\r\n    \r\n    bool public isTXFrozen;\r\n    uint256 public shareholderMaxAmount;\r\n    string[] public allowCountrys;\r\n\r\n    event AddInvestorToWhitelist(address _investor);\r\n    event AddInvestorsToWhitelist(address[] _investors);\r\n    event RemoveInvestorFromWhitelist(address _investor);\r\n    event UpdateBlacklist(address[] _investors, bool _black);\r\n    event SetShareholderMaxAmount(uint _oldValue, uint _newValue);\r\n    event InitShareholders(address[] _shareholders, bool _original);\r\n    event AddShareholder(address _shareholder, uint _balance);\r\n    event RemoveShareholder(address _shareholder, uint _balance);\r\n    // event AddInvestorInfo(address _investor, uint hashid, string _country, bool _kyc, uint _validDate);\r\n    event UpdateInvestorInfo(address _investor, uint hashid, string _country, bool _kyc, uint _validDate, bool _pi);\r\n    // event AddDocument(address _investor, string _url, uint _hash);\r\n    event UpdateDocument(address _investor, string _url, uint _hash);\r\n\r\n    struct Shareholder {\r\n        bool inited;\r\n        bool original;\r\n    }\r\n\r\n    //专业投资者 Pi,合规投资者,前x名合规投资者\r\n    struct InvestorInfo {\r\n        bool inited;\r\n        uint hashid; //是投资者所有资料串在一起的hash值\r\n        string country;//地区\r\n        bool kyc;// 合规投资者认证\r\n        uint validDate;\r\n        bool pi; //is professional, pi和kyc必须要有一个是true\r\n    }\r\n\r\n    struct InvestorDocument {\r\n        string url;\r\n        uint hash;\r\n    }\r\n\r\n    constructor(address _proxy) public Authorization(_proxy) {\r\n        \r\n    }\r\n\r\n    function freezeTX(bool _freeze) public onlyAdmin(msg.sender) whenNotPaused {\r\n        isTXFrozen = _freeze;\r\n    }\r\n\r\n    function addInvestorToWhitelist(address _investor) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\r\n        investorWhitelist[_investor] = true;\r\n        emit AddInvestorToWhitelist(_investor);\r\n    }\r\n\r\n    function addInvestorsToWhitelist(address[] _investors) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\r\n        for(uint i = 0; i < _investors.length; i++) {\r\n            investorWhitelist[_investors[i]] = true;\r\n        }\r\n        emit AddInvestorsToWhitelist(_investors);\r\n    }\r\n\r\n    function updateBlacklist(address[] _investors, bool _black) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\r\n        for(uint i = 0; i < _investors.length; i++) {\r\n            investorBlacklist[_investors[i]] = _black;\r\n        }\r\n        emit UpdateBlacklist(_investors, _black);\r\n    }\r\n\r\n    function removeInvestorFromWhitelist(address _investor) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\r\n        delete investorWhitelist[_investor];\r\n        emit RemoveInvestorFromWhitelist(_investor);\r\n    }\r\n\r\n    function addRetailInvestor(address _investor) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\r\n        bytes32 _country= getInvestorCountry(_investor);\r\n        if(retailInvestors[_country][_investor] != 0)\r\n            return;\r\n        retailInvestors[_country][_investor] = ++retailInvestorCounts[_country];\r\n    }\r\n\r\n    function getRetailInvestorCount(bytes32 _country) external view returns (uint256) {\r\n        return retailInvestorCounts[_country];\r\n    }\r\n\r\n    function getRetailInvestor(address _investor) external view returns (uint256) {\r\n        bytes32 _country= getInvestorCountry(_investor);\r\n        return retailInvestors[_country][_investor];\r\n    }\r\n\r\n    function isInvestorInWhitelist(address _investor) external view returns (bool) {\r\n        return investorWhitelist[_investor];\r\n    }\r\n\r\n    function isInBlacklist(address _investor) external view returns (bool) {\r\n        return investorBlacklist[_investor];\r\n    }\r\n\r\n    function isProfessionalInvestor(address _investor) external view returns (bool) {\r\n        return investorInfo[_investor].pi;\r\n    }\r\n\r\n    function setShareholderMaxAmount(uint256 _shareholderMaxAmount) public onlyIssuer(msg.sender) whenNotPaused {\r\n        uint256 preValue = shareholderMaxAmount;\r\n        shareholderMaxAmount = _shareholderMaxAmount;\r\n        emit SetShareholderMaxAmount(preValue, shareholderMaxAmount);\r\n    }\r\n\r\n    // called after mint\r\n    function initShareholders(address[] _shareholders, bool _original) public onlyInside(msg.sender) whenNotPaused {\r\n        for(uint i = 0; i < _shareholders.length; i++) {\r\n            shareholders.add(_shareholders[i], _original);\r\n        }\r\n        emit InitShareholders(_shareholders, _original);\r\n    }\r\n\r\n    // called after transaction or burn\r\n    function updateShareholders(address _from, address _to) public onlyInside(msg.sender) whenNotPaused {\r\n        TokenModule token = TokenModule(proxy.getModule(\"TokenModule\"));\r\n        uint balanceFrom = token.balanceOf(_from);\r\n        uint balanceTo = token.balanceOf(_to);\r\n        if(balanceFrom == 0)\r\n            removeShareholder(_from, 0);\r\n        // no need to check investors amount here, cause ComplicanceModule will do the job.\r\n        // _to will be 0 while burn\r\n        if(_to != address(0))\r\n            addShareholder(_to, balanceTo); \r\n    }  \r\n\r\n    function addShareholder(address _shareholder, uint _balance) private {\r\n        bool newAdded = shareholders.add(_shareholder, false);\r\n        if(newAdded)\r\n            emit AddShareholder(_shareholder, _balance);\r\n    }\r\n\r\n    function removeShareholder(address _shareholder, uint _balance) private {\r\n        bool removed = shareholders.remove(_shareholder);\r\n        if(removed)\r\n            emit RemoveShareholder(_shareholder, _balance);\r\n    }\r\n\r\n    function shareholderAmount() public view returns (uint256) {\r\n        return shareholders.length;\r\n    }\r\n\r\n    function isShareholder(address _address) public view returns (bool) {\r\n        return shareholders.contain(_address);\r\n    }\r\n    \r\n    function shareholderExceeded(uint amount) public view returns (bool) {\r\n        return shareholders.length + amount > shareholderMaxAmount;\r\n    }\r\n\r\n    function getInvestorCountry(address _address) public view returns (bytes32 result) {\r\n        string memory country = investorInfo[_address].country;\r\n        assembly {\r\n            result := mload(add(country, 32))\r\n        }\r\n    }\r\n\r\n    // function addInvestorInfo(\r\n    //     address _investor, \r\n    //     uint _investorHash,\r\n    //     string _country, \r\n    //     bool _kyc, \r\n    //     uint _validDate\r\n    // ) \r\n    //     external \r\n    //     onlyIssuerOrExchange(msg.sender) \r\n    // {\r\n    //     require(investorInfo[_investor].inited == false, \"Investor already exists\");\r\n    //     investorInfo[_investor] = InvestorInfo(true, _investorHash, _country, _kyc, _validDate);\r\n    //     emit AddInvestorInfo(_investor, _investorHash, _country, _kyc, _validDate);\r\n    // }\r\n\r\n    function updateInvestorInfo(\r\n        address _investor, \r\n        uint _hashid,\r\n        string _country, \r\n        bool _kyc, \r\n        uint _validDate ,\r\n        bool _pi\r\n    ) \r\n        external \r\n        onlyIssuerOrExchange(msg.sender) \r\n        whenNotPaused\r\n        returns(bool)\r\n    {\r\n        // require(investorInfo[_investor].inited == true, \"Investor do not exist\");\r\n        bool temp_pi = true; //temp_pi = _pi; // force set all guys is professional.\r\n        require (_kyc || temp_pi, \"require _kyc or _pi at less one be true\");\r\n        require (isAllowCountry(_country), \"country not allow\");\r\n        require (_hashid != 0);\r\n        require (usedHashid[_hashid] == address(0) || usedHashid[_hashid] == _investor);\r\n        \r\n        //uint oldhashid = investorInfo[_investor].hashid;\r\n        investorInfo[_investor] = InvestorInfo(true, _hashid, _country, _kyc, _validDate, temp_pi);\r\n        usedHashid[_hashid] = _investor;\r\n        //if (oldhashid != _hashid) //\r\n        //    delete usedHashid[oldhashid];\r\n        emit UpdateInvestorInfo(_investor, _hashid, _country, _kyc, _validDate, temp_pi);\r\n        return true;\r\n    }\r\n\r\n    function getInvestorInfo(address _investor) public view returns (uint, string, bool, uint, bool) {\r\n        InvestorInfo storage info = investorInfo[_investor];\r\n        return (info.hashid, info.country, info.kyc, info.validDate, info.pi);\r\n    }\r\n\r\n    // function addDocument(\r\n    //     address _investor, \r\n    //     string _url, \r\n    //     uint _hash\r\n    // ) \r\n    //     external \r\n    //     onlyIssuerOrExchange(msg.sender) \r\n    // {\r\n    //     InvestorDocument storage doc = investorDocuments[_investor];\r\n    //     require(doc.hash == 0, \"Investor document already exists\");\r\n    //     investorDocuments[_investor] = InvestorDocument(_url, _hash);\r\n    //     emit AddDocument(_investor, _url, _hash);\r\n    // }\r\n\r\n    function updateDocument(\r\n        address _investor, \r\n        string _url, \r\n        uint _hash\r\n    ) \r\n        external \r\n        onlyIssuerOrExchange(msg.sender) \r\n        whenNotPaused\r\n    {\r\n        // InvestorDocument storage doc = investorDocuments[_investor];\r\n        // require(doc.hash != 0, \"Investor document do not exists\");\r\n        investorDocuments[_investor] = InvestorDocument(_url, _hash);\r\n        emit UpdateDocument(_investor, _url, _hash);\r\n    }\r\n\r\n    function getDocument(address _investor) external view returns (string, uint) {\r\n        InvestorDocument storage doc = investorDocuments[_investor];\r\n        return (doc.url, doc.hash);\r\n    }\r\n\r\n    function addAllowCountrys(string _country)\r\n        external \r\n        onlyIssuerOrExchange(msg.sender)\r\n        returns (bool)\r\n    {\r\n        bytes memory strmemct = bytes(_country);\r\n        require (strmemct.length > 0, \"country can not empty\");\r\n\r\n        uint aclen = allowCountrys.length;\r\n        uint firstEmptyPlace = aclen;\r\n        for (uint i=0; i < aclen; i++)\r\n        {\r\n            if (allowCountrys[i].equal(_country))\r\n                return false;\r\n            bytes memory strmem = bytes(allowCountrys[i]);\r\n            if (strmem.length == 0 && firstEmptyPlace == aclen)\r\n                firstEmptyPlace = i;\r\n        }\r\n        if (firstEmptyPlace != aclen)\r\n            allowCountrys[firstEmptyPlace] = _country;\r\n        else\r\n            allowCountrys.push(_country);\r\n        return true;\r\n    }\r\n\r\n    function removeAllowCountrys(string _country) \r\n        external\r\n        onlyIssuerOrExchange(msg.sender)\r\n        returns (bool) \r\n    {\r\n        uint aclen = allowCountrys.length;\r\n        for (uint i=0; i < aclen; i++)\r\n        {\r\n            if (allowCountrys[i].equal(_country))\r\n            {\r\n                delete allowCountrys[i];\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isAllowCountry(string _country)\r\n        public\r\n        returns(bool)\r\n    {\r\n        uint aclen = allowCountrys.length;\r\n        for (uint i=0; i < aclen; i++)\r\n        {\r\n            if (allowCountrys[i].equal(_country)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_shareholders\",\"type\":\"address[]\"},{\"name\":\"_original\",\"type\":\"bool\"}],\"name\":\"initShareholders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getInvestorInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"addInvestorToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"updateShareholders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInvestorCountry\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"removeInvestorFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_country\",\"type\":\"string\"}],\"name\":\"removeAllowCountrys\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"shareholderExceeded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeTX\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_shareholderMaxAmount\",\"type\":\"uint256\"}],\"name\":\"setShareholderMaxAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareholderMaxAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_country\",\"type\":\"bytes32\"}],\"name\":\"getRetailInvestorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"}],\"name\":\"addInvestorsToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getRetailInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_url\",\"type\":\"string\"},{\"name\":\"_hash\",\"type\":\"uint256\"}],\"name\":\"updateDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getDocument\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"isProfessionalInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_hashid\",\"type\":\"uint256\"},{\"name\":\"_country\",\"type\":\"string\"},{\"name\":\"_kyc\",\"type\":\"bool\"},{\"name\":\"_validDate\",\"type\":\"uint256\"},{\"name\":\"_pi\",\"type\":\"bool\"}],\"name\":\"updateInvestorInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_country\",\"type\":\"string\"}],\"name\":\"addAllowCountrys\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"isInBlacklist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_country\",\"type\":\"string\"}],\"name\":\"isAllowCountry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"addRetailInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isShareholder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_black\",\"type\":\"bool\"}],\"name\":\"updateBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareholderAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"isInvestorInWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTXFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowCountrys\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"AddInvestorToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investors\",\"type\":\"address[]\"}],\"name\":\"AddInvestorsToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"RemoveInvestorFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investors\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"_black\",\"type\":\"bool\"}],\"name\":\"UpdateBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"SetShareholderMaxAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_shareholders\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"_original\",\"type\":\"bool\"}],\"name\":\"InitShareholders\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_shareholder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"AddShareholder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_shareholder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"RemoveShareholder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hashid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_country\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_kyc\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_validDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_pi\",\"type\":\"bool\"}],\"name\":\"UpdateInvestorInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_url\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_hash\",\"type\":\"uint256\"}],\"name\":\"UpdateDocument\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"StorageModule","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002be753dd5f5400f5ffc896d6cad195b5db56f857","Library":"LibMapAddressBool:ae76c72a142edbcfa2c6047a8d492d0ffb1d2007;StringUtils:a5447e2173db8d2235deb6e3032445fa82b37d78","LicenseType":"None","SwarmSource":"bzzr://a0e572033de95063e9fd4752cd4387c57ef6e8402232e3e4882c33ab6b1f54d9"}]}