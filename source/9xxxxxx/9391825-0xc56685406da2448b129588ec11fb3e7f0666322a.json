{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/ACE/validators/swap/SwapABIEncoder.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * @title SwapABIEncoder\r\n * @author AZTEC\r\n * @dev Library to ABI encode the output of a Swap proof verification\r\n * Don't include this as an internal library. This contract uses a static memory table to cache\r\n * elliptic curve primitives and hashes.\r\n * Calling this internally from another function will lead to memory mutation and undefined behaviour.\r\n * The intended use case is to call this externally via `staticcall`.\r\n * External calls to OptimizedAZTEC can be treated as pure functions as this contract contains no\r\n * storage and makes no external calls (other than to precompiles)\r\n * \r\n * Copyright 2020 Spilsbury Holdings Ltd \r\n *\r\n * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n**/\r\n\r\nlibrary SwapABIEncoder {\r\n\r\n    /**\r\n    * Calldata map\r\n    * 0x04:0x24      = calldata location of proofData byte array - pointer to the proofData.\r\n    * 0x24:0x44      = message sender // sender\r\n    * 0x44:0x64      = h_x     // crs\r\n    * 0x64:0x84      = h_y     // crs\r\n    * 0x84:0xa4      = t2_x0   // crs\r\n    * 0xa4:0xc4      = t2_x1   // crs\r\n    * 0xc4:0xe4      = t2_y0   // crs\r\n    * 0xe4:0x104     = t2_y1   // crs\r\n    * 0x104:0x124    = length of proofData byte array\r\n    * 0x124:0x144    = challenge\r\n    * 0x144:0x164    = offset in byte array to notes\r\n    * 0x164:0x184    = offset in byte array to inputOwners\r\n    * 0x184:0x1a4    = offset in byte array to outputOwners\r\n    * 0x1a4:0x1c4    = offset in byte array to metadata\r\n    **/\r\n\r\n    function encodeAndExit() internal pure {\r\n        assembly {\r\n            // set up initial variables\r\n            let notes := add(0x104, calldataload(0x144))\r\n            let noteOwners := add(0x124, calldataload(0x164)) // // one word after inputOwners = 1st\r\n            let metadataPtr := add(0x144, calldataload(0x184)) // two words after metadata = 1st\r\n\r\n            // First up, we need to do some checks to ensure we have been provided with correct data.\r\n            // We should only have 2 entries inside `bytes metadata` (only 2 output notes in total),\r\n            // and only 4 entries inside `noteOwners` (4 notes in a Swap proof)\r\n            if iszero(and(\r\n                eq(0x02, calldataload(sub(metadataPtr, 0x20))),\r\n                eq(0x04, calldataload(sub(noteOwners, 0x20)))\r\n            )) {\r\n                revert(0x00, 0x00) // no! bad! come back with good inputs!\r\n            }\r\n\r\n            // memory map of `proofOutputs`\r\n            // 0x00 - 0x160  = scratch data for note hash computation\r\n\r\n            // `returndata` starts at 0x160\r\n            // `proofOutputs` starts at 0x180\r\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\r\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\r\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\r\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\r\n            // 0x1e0 - 0x200 = relative memory offset between `v` and start of `proofOutputs[1]`\r\n\r\n            // `proofOutput` - t, starts at 0x200\r\n            // 0x200 - 0x220 = length of `proofOutput`\r\n            // 0x220 - 0x240 = relative offset between `t` and `inputNotes`\r\n            // 0x240 - 0x260 = relative offset between `t` and `outputNotes`\r\n            // 0x260 - 0x280 = `publicOwner`\r\n            // 0x280 - 0x2a0 = `publicValue`\r\n            // 0x2a0 - 0x2c0 = `challenge`\r\n\r\n            // `inputNotes` starts at 0x2c0\r\n            // structure of `inputNotes` and `outputNotes`\r\n            // 0x00 - 0x20 = byte length of notes array\r\n            // 0x20 - 0x40 = number of notes = 1\r\n            // 0x40 - 0x60 = offset to start of input note (0x60)\r\n\r\n            // structure of a `note`\r\n            // 0x00 - 0x20 = size of `note`\r\n            // 0x20 - 0x40 = `owner`\r\n            // 0x40 - 0x60 = `noteHash`\r\n            // 0x60 - 0x80 = size of note `data`\r\n            // 0x80 - 0xa0 = compressed note coordinate `gamma` (part of `data`)\r\n            // 0xa0 - 0xc0 = compressed note coordinate `sigma` (part of `data`)\r\n            // 0xc0 - ???? = remaining note metadata\r\n\r\n            // Note organisation...\r\n            // The Swap proof proves the following:\r\n            //   1. note[0].value == note[2].value\r\n            //   2. note[1].value == note[3].value\r\n            // In other words...\r\n            // note[0] = maker bid note\r\n            // note[1] = maker ask note\r\n            // note[2] = taker ask note\r\n            // note[3] = taker bid note\r\n\r\n            // We therefore have 2 balancing relationships\r\n            // 1. The maker bid note is destroyed and replaced with the taker ask note\r\n            // 2. The taker bid note is destroyed and replaced with the maker ask note\r\n\r\n            // Finally, we can translate this into 2 proofOutputs entries...\r\n            // In the first entry, `inputNotes` = [note[0]] and `outputNotes` = [note[2]]\r\n            // In the second entry, `inputNotes` = [note[3]] and `outputNotes` = [note[1]]\r\n\r\n            // `proofOutputs` must form a monolithic block of memory that we can return.\r\n            // `s` points to the memory location of the start of the current note\r\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\r\n\r\n            // length of proofOutputs is at 0x180\r\n\r\n            // we use memory from 0x00 - 0x140 as scratch memory\r\n\r\n            // return data starts at 0x160. As return data is `bytes proofOutputs`,\r\n            // the first word is the relative offset to the start of `proofOutputs` (i.e. 0x20)\r\n            mstore(0x160, 0x20)\r\n\r\n            /**\r\n            * Encoding of proofOutputs\r\n            * abi encoding of proofOutputs\r\n            * 0x00 : 0x20 = byte length of `proofOutputs` = 0x60 + L1 + L2\r\n            * 0x20 : 0x40 = number of `proofOutputs` entries (2)\r\n            * 0x40 : 0x60 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\r\n            * 0x60 : 0x80 = relative memory offset between `v` and start of `proofOutputs[1]`\r\n            * 0x80 : 0x80 + L1    = start of proofOutputs[0]\r\n            * 0x80 + L1   : 0x80 + L1 + L2 = start of proofOutputs[1]\r\n            **/\r\n\r\n            // 0x180 stores the total size of `bytes proofOutputs`. We don't know that yet, so leave blank\r\n\r\n            // 0x1a0 = number of proof outputs (2)\r\n            mstore(0x1a0, 0x02)                            // number of proofs\r\n\r\n            // 0x1c0 = relative offset to 1st entry (0x80, 4 words)\r\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\r\n\r\n            /**\r\n            * Encoding of proofOutput\r\n            * 0x00 : 0x20 = byte length of `proofOutput` = 0x60 + L1 + L2\r\n            * 0x20 : 0x40 = relative offset to `bytes inputNotes`\r\n            * 0x40 : 0x60 = relative offset to `bytes outputNotes`\r\n            * 0x60 : 0x80 = publicOwner\r\n            * 0x80 : 0xa0 = publicValue\r\n            * 0xa0 : 0xc0 = challenge\r\n            * 0xc0 : 0xc0 + L1 = `bytes inputNotes` (L1 = 0x140 bytes)\r\n            * 0xc0 + L1 : 0xc0 + L1 + L2 = `bytes inputNotes`\r\n            *\r\n            * Start of proofOutput = 0x200\r\n            **/\r\n\r\n            // length of proofOutput is at 0x200. We don't know that yet, so leave blank\r\n\r\n            // relative offset to inputNotes = 0xc0 (6 words)\r\n            mstore(0x220, 0xc0)                            // location of inputNotes\r\n\r\n            // we know that inputNotes has 1 entry, and input notes don't have metadata.\r\n            // So we actually know the complete size of `bytes inputNotes`\r\n            // (it's 0x140 bytes, we'll get to that in a bit)\r\n            // => relative offset to outputNotes = 0x140 + 0xc0 = 0x200\r\n            mstore(0x240, 0x200)                           // location of outputNotes\r\n\r\n            // Swap proof hardcodes `publicOwner` and `publicValue` to 0 (no public tokens)\r\n            mstore(0x260, 0x00)                             // publicOwner\r\n            mstore(0x280, 0x00)                             // publicValue\r\n            mstore(0x2a0, calldataload(0x124))              // challenge\r\n            /**\r\n            * Encoding of inputNotes\r\n            * 0x00 : 0x20 = byte length of `inputNotes` (0x120)\r\n            * 0x20 : 0x40 = number of input notes (0x01)\r\n            * 0x40 : 0x60 = relative offset to 1st input note (0x60)\r\n            * 0x60 : L    = 1st input note data (L = 0xe0)\r\n            *\r\n            * Start of inputNotes = 0x2a0\r\n            * Because we only have 1 note in this array, and that note has no metadata\r\n            * we know that the size of the note is 0xe0 bytes\r\n            * therefore, the size of inputNotes = 0xe0 + 3 words = 0x140 bytes.\r\n            * We store the byte length as 0x120 bytes because the length parameter\r\n            * of a dynamic bytes array does not include itself in the length calculation\r\n            **/\r\n\r\n            // 0x2c0 = length of inputNotes = 0x120\r\n            mstore(0x2c0, 0x120)\r\n\r\n            // 0x2e0 = number of notes (1)\r\n            mstore(0x2e0, 0x01) // 1 input note\r\n\r\n            // 0x300 = relative offset to input note (0x60)\r\n            mstore(0x300, 0x60) // relative offset to note data\r\n\r\n            /**\r\n            * Encoding of input note\r\n            * 0x00 : 0x20 = byte length of note (0xc0)\r\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\r\n            * 0x40 : 0x60 = note owner\r\n            * 0x60 : 0x80 = note hash\r\n            * 0x80 : 0xa0 = note data length (0x40)\r\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\r\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\r\n            *\r\n            * Start of note = 0x320\r\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\r\n            **/\r\n\r\n            // we use memory from 0x00 - 0xa0 as scratch memory to compute note hash\r\n            // Note hash = keccak256(abi.encode(noteType, gammaX, gammaY, sigmaX, sigmaY))\r\n            mstore(0x00, 0x01) // store noteType at 0x01\r\n\r\n            // We want to copy note coordinate data into memory from 0x20 - 0xa0\r\n            // 'notes' points to the start of the notes array\r\n            // i.e. notes + 0x20 will point to the start of the data of the first entry\r\n            // first two entries are \\bar{k} and \\bar{a}, which we wish to skip over\r\n            // input note is notes[0] => we need to point to notes + 0x60\r\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // copy gamma, sigma into 0x20 - 0xa0\r\n\r\n            // 0x320 = length of note (0xc0)\r\n            mstore(0x320, 0xc0)\r\n\r\n            // 0x340 = note type (UXTO type, 0x01)\r\n            mstore(0x340, 0x01) // note type\r\n\r\n            // 0x360 = note owners. We want the 1st entry in `noteOwners` (calldataload(noteOwners))\r\n            mstore(0x360, calldataload(noteOwners)) // note owner\r\n\r\n            // 0x380 = note hash, which is the hash of memory from 0x00 - 0xa0\r\n            mstore(0x380, keccak256(0x00, 0xa0)) // note hash\r\n\r\n            // 0x3a0 = noteData length (0x40, no metadata)\r\n            mstore(0x3a0, 0x40)\r\n\r\n            // We now need to store compressed note coordinates.\r\n            // We store them in compressed form, as this stuff will be emitted as an event and is not required\r\n            // for additional smart contract logic. Compressing reduces the event data size and saves a fair bit of gas\r\n\r\n            // To compress, we determine if the y-coordinate is odd.\r\n            // If it is, we set the 256th bit of the x-coordinate to 'true'.\r\n            // bn128 field elements are only 254 bits long, so we know that we won't override x-coordinate data\r\n            // (we already have the note coords in memory, so we load from memory instead of calldata)\r\n\r\n            // 0x3c0 = gamma\r\n            mstore(\r\n                0x3c0,\r\n                or(\r\n                    mload(0x20), // load x coordinate\r\n                    mul(         // multiply by (y & 1 ? 2^255 : 0)\r\n                        and(mload(0x40), 0x01),\r\n                        0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                )\r\n            )\r\n\r\n            // 0x3e0 = sigma\r\n            mstore(\r\n                0x3e0,\r\n                or(\r\n                    mload(0x60),\r\n                    mul(\r\n                    and(mload(0x80), 0x01),\r\n                    0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                )\r\n            )\r\n\r\n            /**\r\n            * Encoding of output notes\r\n            *\r\n            * abi format is identical to input notes, but now we don't know the total size\r\n            * (because of variable length metadata)\r\n            * 0x00 : 0x20 = byte length of `outputNotes` (0x40 + L)\r\n            * 0x20 : 0x40 = number of output notes (0x01)\r\n            * 0x40 : 0x60 = relative offset to 1st output note (0x60)\r\n            * 0x60 : 0x60 + L    = 1st output note data\r\n            *\r\n            * Start of outputNotes = 0x400\r\n            **/\r\n\r\n            // 0x400 = byte length of output notes. We don't know what this is so leave blank for now\r\n\r\n            // 0x420 = number of output notes (0x01)\r\n            mstore(0x420, 0x01)\r\n\r\n            // 0x440 = relative offset to output note data (0x60)\r\n            mstore(0x440, 0x60)\r\n\r\n            /**\r\n            * Encoding of output note\r\n            * 0x00 : 0x20 = byte length of note (0xc0 + L)\r\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\r\n            * 0x40 : 0x60 = note owner\r\n            * 0x60 : 0x80 = note hash\r\n            * 0x80 : 0xa0 = note data length (0x40 + L)\r\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\r\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\r\n            * 0xe0 : 0xe0 + L = note metadata\r\n            *\r\n            * Start of note = 0x460\r\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\r\n            **/\r\n\r\n            // next, copy note coordinates into memory to compute hash.\r\n            // We already stored the noteType at position 0x00, no need to do that again\r\n            // We need to copy data from notes[2].\r\n            // 1. notes + 0x20 = start of 1st entry data\r\n            // 2. size of a note entry = 0xc0 bytes\r\n            // 3. we want to point to 3rd word in our note entry, to skip over \\bar{k}, \\bar{a}\r\n            //    (i.e. add 0x40 to caldlata pointer)\r\n            // => offset = notes + 0x20 + 0x40 + (0xc0 * 2) = notes + 0x1e0\r\n            // => calldata pointer = notes + 0x1e0\r\n            calldatacopy(0x20, add(notes, 0x1e0), 0x80) // get gamma, sigma\r\n\r\n            // 0x460 = byte length of output note. Leave blank for now\r\n\r\n            // 0x480 = note type (0x01)\r\n            mstore(0x480, 0x01)      // note type\r\n\r\n            // 0x4a0 = note owner. We are accessing `notes[2]`, therefore\r\n            // the note owner = noteOwners[2].\r\n            // i.e. noteOwners + 0x40\r\n            mstore(0x4a0, calldataload(add(noteOwners, 0x40))) // note owner\r\n\r\n            // 0x4c0 = note hash\r\n            mstore(0x4c0, keccak256(0x00, 0xa0))\r\n\r\n            // 0x4e0 = noteData length. To get this, we need to identify our metadata length\r\n            // `metadataPtr` points to the relative offset, in the `metadata` array, to the first metadata entry\r\n            // ABI encoding of the input data should encode 2 metadata entries.\r\n            // => relative offset to this note's metadata = `calldataload(metadataPtr)`\r\n            let metadataIndex := calldataload(metadataPtr)\r\n    \r\n            // To convert this into a calldata offset, we must add the number of bytes of calldata\r\n            // that preceeds the start of the `metadata` array.\r\n\r\n            // `bytes metadata` abi encoding:\r\n            // 0x00 : 0x20 = size of bytes array\r\n            // 0x20 : 0x40 = number of metadata entries (i)\r\n            // 0x40 : 0x40 + (0x20 * j) = relative offsets to each metadata entry\r\n            // 0x40 + (0x20 * j) : ??? = metadata entries\r\n\r\n            // The `metadata` pointer points to the 3rd word (at 0x40), the 1st relative offset\r\n            // Therefore, to compute the calldata offset to the metadata entry,\r\n            // we need to add `metadataPtr - 0x40` to `calldataload(metadataPtr)`.\r\n            // i.e. metadataCalldataPtr = calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\r\n\r\n            // Because each metadata entry is itself a dynamic bytes array, the first word will\r\n            // be the length of the metadata entry. This is what we want, so we directly call\r\n            // `calldataload` on our offset\r\n            let metadataLength := calldataload(add(metadataIndex, sub(metadataPtr, 0x40)))\r\n\r\n            // 0x4e0 = noteData length = 0x40 + metadata length\r\n            mstore(0x4e0, add(0x40, metadataLength))\r\n\r\n            // 0x500 = compressed note coordinate gamma\r\n            mstore(\r\n                0x500,\r\n                or(\r\n                    mload(0x20),\r\n                    mul(\r\n                        and(mload(0x40), 0x01),\r\n                        0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                )\r\n            )\r\n\r\n            // 0x520 = compressed note coordinate sigma\r\n            mstore(\r\n                0x520,\r\n                or(\r\n                    mload(0x60),\r\n                    mul(\r\n                        and(mload(0x80), 0x01),\r\n                        0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                )\r\n            )\r\n\r\n            // To complete `noteData`, we need to copy note metadata into memory (0x540)\r\n            // We know that metadataIndex + metadataPtr - 0x40 points to the start of the metadata entry in calldata.\r\n            // But the first word is the length of the metadata entry, which we don't want.\r\n            // So we need to point to the second word (the byte array data).\r\n            // i.e. we want to start copying at (metadataIndex + metadataPtr - 0x20)\r\n            // and we want to copy `metadataLength` number of bytes.\r\n            calldatacopy(0x540, add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\r\n\r\n            // We now need to work backwards and fill in the parts of `bytes proofOutput` that we left blank,\r\n            // as we now can identify the size of the array\r\n\r\n            // 0x460 points to the size of the output note. The actual size is 0xe0 + metadataLength.\r\n            // So we record 0xc0 + metadataLength\r\n            // (because the 'size' of a byte array does not take into account the word needed to record the size)\r\n            mstore(0x460, add(0xc0, metadataLength))  // update size of note\r\n\r\n            // 0x400 = the size of `bytes outputNotes`.\r\n            // Raw size = 0x140 + metadataLength, so record 0x120 + metadataLength\r\n            mstore(0x400, add(0x120, metadataLength)) // update size of outputNotes\r\n\r\n            // 0x200 = the size of `bytes proofOutput`\r\n            // Raw size = 0x340 + metadataLength, so record 0x340 + metadataLength\r\n            mstore(0x200, add(0x320, metadataLength))\r\n\r\n            // Great! We've now finished writing the 1st proof output.\r\n            // We now need to write the ABI encoding of the 2nd proof output entry.\r\n\r\n            // 0x1e0 points to the relative offset in `bytes proofOutputs` to the second proof entry.\r\n            // This will be equal to the size of the 1st proof, plus the 0x80 preceeding bytes\r\n            // that are used to record `bytes proofOutputs`\r\n            // i.e. relative offset = 0x340 + 0x80 + metadataLength = 0x3c0 + metadataLength\r\n            mstore(0x1e0, add(0x3c0, metadataLength))\r\n\r\n            /**\r\n            * proofOutput[1]\r\n            **/\r\n\r\n            // When writing data into proofOutputs[1], we cannot use an absolute offset as\r\n            // metadataLength is not known at compile time.\r\n            // `proofPtr` points to the start of `proofOutputs[1]`\r\n            let proofPtr := add(0x540, metadataLength)\r\n\r\n            // (proofPtr) = size of proofOutput (leave blank for now)\r\n\r\n            // (proofPtr + 0x20) = offset to inputNotes (0xc0)\r\n            mstore(add(proofPtr, 0x20), 0xc0)\r\n\r\n            // (proofPtr + 0x40) = offset to outputNotes (0x200)\r\n            mstore(add(proofPtr, 0x40), 0x200)\r\n\r\n            // (proofPtr + 0x60) = publicOwner (0)\r\n            mstore(add(proofPtr, 0x60), 0x00) // publicOwner\r\n\r\n            // (proofPtr + 0x80) = publicValue (0)\r\n            mstore(add(proofPtr, 0x80), 0x00) // publicValue\r\n\r\n            // (proofPtr + 0xa0) = challenge\r\n            // we hash the challenge to get the second proof output's challenge - to preserve uniqueness\r\n            mstore(0xe0, calldataload(0x124))\r\n            mstore(add(proofPtr, 0xa0), keccak256(0xe0, 0x20)) // challenge\r\n\r\n            /**\r\n            * proofOutput[1].inputNotes\r\n            *\r\n            * starts at (proofPtr + 0xc0)\r\n            **/\r\n\r\n            // (proofPtr + 0xc0) = byte size of inputNotes (0x120)\r\n            mstore(add(proofPtr, 0xc0), 0x120)\r\n\r\n            // (proofPtr + 0xe0) = number of input notes (0x01)\r\n            mstore(add(proofPtr, 0xe0), 0x01)\r\n\r\n            // (proofPtr + 0x100) = relative offset to input note data (0x60)\r\n            mstore(add(proofPtr, 0x100), 0x60)\r\n\r\n            /**\r\n            * proofOutput[1].inputNotes[0]\r\n            *\r\n            * starts at (proofPtr + 0x120)\r\n            **/\r\n\r\n            // input note = notes[3]\r\n            // => offset = notes + 0x60 + (0xc0 * 3) = notes + 0x2a0\r\n            // copy note data into scratch memory to hash\r\n            calldatacopy(0x20, add(notes, 0x2a0), 0x80)\r\n\r\n            // (proofPtr + 0x120) = byte length of input note (0xc0)\r\n            mstore(add(proofPtr, 0x120), 0xc0) // length of input note\r\n\r\n            // (proofPtr + 0x140) = note type (UXTO type, 0x01)\r\n            mstore(add(proofPtr, 0x140), 0x01) // note type\r\n\r\n            // (proofPtr + 0x160) = note owner = noteOwners[3]\r\n            mstore(add(proofPtr, 0x160), calldataload(add(noteOwners, 0x60))) // note owner\r\n\r\n            // (proofPtr + 0x180) = note hash\r\n            mstore(add(proofPtr, 0x180), keccak256(0x00, 0xa0)) // note hash\r\n\r\n            // (proofPtr + 0x1a0) = noteData length (0x40 bytes)\r\n            mstore(add(proofPtr, 0x1a0), 0x40)\r\n\r\n            // (proofPtr + 0x1c0) = compressed coordinate 'gamma'\r\n            mstore(\r\n                add(proofPtr, 0x1c0),\r\n                or(\r\n                    mload(0x20),\r\n                    mul(\r\n                        and(mload(0x40), 0x01),\r\n                        0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                )\r\n            )\r\n\r\n            // (proofPtr + 0x1e0) = compressed coordinate 'sigma'\r\n            mstore(\r\n                add(proofPtr, 0x1e0),\r\n                or(\r\n                    mload(0x60),\r\n                    mul(\r\n                        and(mload(0x80), 0x01),\r\n                        0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                )\r\n            )\r\n\r\n            /**\r\n            * proofOutput[1].outputNotes\r\n            *\r\n            * starts at (proofPtr + 0x200)\r\n            **/\r\n\r\n            // (proofPtr + 0x200) = byte length of output notes, leave blank for now\r\n\r\n            // (proofPtr + 0x220) = number of output notes (0x01)\r\n            mstore(add(proofPtr, 0x220), 0x01)\r\n\r\n            // (proofPtr + 0x240) = offset to output notes (0x60)\r\n            mstore(add(proofPtr, 0x240), 0x60)\r\n\r\n            /**\r\n            * proofOutput[1].outputNotes[0]\r\n            *\r\n            * starts at (proofPtr + 0x260)\r\n            **/\r\n            // output note = notes[1]\r\n            // => offset = notes + 0x60 + 0xc0 = notes + 0x120\r\n            // copy note data into scratch memory to hash\r\n            calldatacopy(0x20, add(notes, 0x120), 0x80)\r\n\r\n            // (proofPtr + 0x260) = length of note, leave blank for now\r\n\r\n            // (proofPtr + 0x280) = note type (UXTO type, 0x01)\r\n            mstore(add(proofPtr, 0x280), 0x01) // note type\r\n\r\n            // (proofPtr + 0x2a0) = note owner (noteOwners[1])\r\n            mstore(add(proofPtr, 0x2a0), calldataload(add(noteOwners, 0x20)))\r\n\r\n            // (proofPtr + 0x2c0) = note hash\r\n            mstore(add(proofPtr, 0x2c0), keccak256(0x00, 0xa0))\r\n\r\n            // We now need to compute the metadata length. We want to access the 2nd metadata entry,\r\n            // at (metadataPtr + 0x20)\r\n            metadataIndex := calldataload(add(metadataPtr, 0x20))\r\n            metadataLength := calldataload(add(metadataIndex, sub(metadataPtr, 0x40)))\r\n            // (proofPtr + 0x2e0) = noteData length (0x40 + metadataLength)\r\n            mstore(add(proofPtr, 0x2e0), add(0x40, metadataLength))\r\n\r\n            // (proofPtr + 0x300) = compressed coordinate 'gamma'\r\n            mstore(\r\n                add(proofPtr, 0x300),\r\n                or(\r\n                    mload(0x20),\r\n                    mul(\r\n                        and(mload(0x40), 0x01),\r\n                        0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                )\r\n            )\r\n\r\n            // (proofPtr + 0x320) = compressed coordinate 'sigma'\r\n            mstore(\r\n                add(proofPtr, 0x320),\r\n                or(\r\n                    mload(0x60),\r\n                    mul(\r\n                        and(mload(0x80), 0x01),\r\n                        0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                )\r\n            )\r\n\r\n            // (proofPtr + 0x340) = start of note metadata\r\n            calldatacopy(add(proofPtr, 0x340), add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\r\n\r\n            // Next, work backwards and fill in the remaining gaps\r\n            // (proofPtr + 0x260) = proofOutputs[1].outputNotes[0].length (0xc0 + metadataLength)\r\n            mstore(add(proofPtr, 0x260), add(0xc0, metadataLength))\r\n\r\n            // (proofPtr + 0x200) = proofOutputs[1].outputNotes.length (0x120 + metadataLength)\r\n            mstore(add(proofPtr, 0x200), add(0x120, metadataLength))\r\n\r\n            // (proofPtr) = proofOutputs[1].length = (0x320 + metadataLength)\r\n            mstore(proofPtr, add(0x320, metadataLength))\r\n\r\n            // (0x180) = proofOutputs.length\r\n            // We previously stored proofOutputs[0].length at 0x200\r\n            // Total length = combination of\r\n            // 1. proofOutputs[0].length + 0x20 (extra word because of length variable)\r\n            // 2. proofOutputs[1].length + 0x20 (^^)\r\n            // 3. data to record relative offsets (0x20 * number of outputs) = (0x40)\r\n            // 4. data to record number of entries (0x20)\r\n\r\n            // We stored proofOutputs[0].length at 0x200\r\n            // and we know that proofOutputs[1].length = 0x320 + metadataLength\r\n            // => length = mload(0x200) + metadataLength + 0x320 + 0x40 + 0x40 + 0x20\r\n            // => length = mload(0x200) + metadataLength + 0x3c0\r\n            mstore(0x180, add(add(0x3c0, metadataLength), mload(0x200)))\r\n\r\n            // Great, we've done it! Now all that is left is to return from this transaction.\r\n            // Our return data starts at 0x160.\r\n            // Total size of `bytes proofOutpust` = proofOutputs.length + 0x20\r\n            // We need 1 extra word (at 0x160) for the relative offset to get to `bytes proofOutputs`\r\n            // => returndata size = proofOutputs.length + 0x40\r\n            // = mload(0x180) + 0x40\r\n            return(0x160, add(mload(0x180), 0x40)) // *kazoo noises*\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ACE/validators/swap/Swap.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Swap\r\n * @author AZTEC\r\n * @dev Library to validate Swap proofs\r\n * Don't include this as an internal library. This contract uses\r\n * a static memory table to cache elliptic curve primitives and hashes.\r\n * Calling this internally from another function will lead to memory\r\n * mutation and undefined behaviour.\r\n * The intended use case is to call this externally via `staticcall`. External\r\n * calls to OptimizedAZTEC can be treated as pure functions as this contract\r\n * contains no storage and makes no external calls (other than to precompiles)\r\n * \r\n * Copyright 2020 Spilsbury Holdings Ltd \r\n *\r\n * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n**/\r\ncontract Swap {\r\n\r\n    /**\r\n     * @dev Swap will take any transaction sent to it and attempt to validate a zero knowledge proof.\r\n     * If the proof is not valid, the transaction throws.\r\n     * @notice See SwapInterface for how method calls should be constructed.\r\n     * This contract is written in YUL to enable manual memory management and for other efficiency savings.\r\n     **/\r\n    // solhint-disable payable-fallback\r\n    function() external {\r\n        assembly {\r\n\r\n            // We don't check for function signatures, there's only one function that\r\n            // ever gets called: validateSwap()\r\n            // We still assume calldata is offset by 4 bytes so that we can represent\r\n            // this contract through a comp\\atible ABI\r\n            validateSwap()\r\n\r\n            // if we get to here, the proof is valid. We now 'fall through' the assembly block\r\n            // and into JoinSplitABI.validateJoinSplit()\r\n            // reset the free memory pointer because we're touching Solidity code again\r\n            mstore(0x40, 0x60)\r\n            /**\r\n             * New calldata map\r\n             * 0x04:0x24      = calldata location of proofData byte array\r\n             * 0x24:0x44      = message sender // sender\r\n             * 0x44:0x64      = h_x     // crs\r\n             * 0x64:0x84      = h_y     // crs\r\n             * 0x84:0xa4      = t2_x0   // crs\r\n             * 0xa4:0xc4      = t2_x1   // crs\r\n             * 0xa4:0xc4      = t2_x1   // crs\r\n             * 0xc4:0xe4      = t2_y0   // crs\r\n             * 0xe4:0x104     = t2_y1   // crs\r\n             * 0x104:0x124    = length of proofData byte array\r\n             * 0x124:0x144    = challenge\r\n             * 0x144:0x164    = offset in byte array to notes\r\n             * 0x164:0x184    = offset in byte array to inputOwners\r\n             * 0x184:0x1a4    = offset in byte array to outputOwners\r\n             * 0x1a4:0x1c4    = offset in byte array to metadata\r\n             *\r\n             *\r\n             * Note data map (uint[6]) is\r\n             * 0x00:0x20       = Z_p element \\bar{k}_i\r\n             * 0x20:0x40       = Z_p element \\bar{a}_i\r\n             * 0x40:0x80       = G1 element \\gamma_i\r\n             * 0x80:0xc0       = G1 element \\sigma_i\r\n             *\r\n             * We use a hard-coded memory map to reduce gas costs - if this is not called as an\r\n             * external contract then terrible things will happen!\r\n             *\r\n             * 0x00:0x20       = scratch data to store result of keccak256 calls\r\n             * 0x20:0x80       = scratch data to store \\gamma_i and a multiplication scalar\r\n             * 0x80:0xc0       = x-coordinate of generator h\r\n             * 0xc0:0xe0       = y-coordinate of generator h\r\n             * 0xe0:0x100      = scratch data to store a scalar we plan to multiply h by\r\n             * 0x100:0x160     = scratch data to store \\sigma_i and a multiplication scalar\r\n             * 0x160:0x1a0     = stratch data to store result of G1 point additions\r\n             * 0x1a0:0x1c0     = scratch data to store result of \\sigma_i^{-cx_{i-m-1}}\r\n             * 0x220:0x260     = scratch data to store \\gamma_i^{cx_{i-m-1}}\r\n             * 0x2e0:0x300     = msg.sender (contract should be called via delegatecall/staticcall)\r\n             * 0x300:???       = block of memory that contains (\\gamma_i, \\sigma_i)_{i=0}^{n-1}\r\n             *                   concatenated with (B_i)_{i=0}^{n-1}\r\n             **/\r\n            function validateSwap() {\r\n                /*\r\n                ///////////////////////////////////////////  SETUP  //////////////////////////////////////////////\r\n                */\r\n\r\n                mstore(0x80, calldataload(0x44)) // h_x\r\n                mstore(0xa0, calldataload(0x64)) // h_y\r\n                let notes := add(0x104, calldataload(0x144)) // start position of notes\r\n                let n := calldataload(notes) // first element of the notes array is it's length\r\n\r\n                if iszero(eq(n, 0x04)) { // eq(n, 4) will resolve to 0 if n != 4\r\n\r\n                    mstore(0x00, 400) // 400 error code - due to incorrect number of notes supplied\r\n                    revert(0x00, 0x20)\r\n\r\n                }\r\n\r\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\r\n                let challenge := mod(calldataload(0x124), gen_order)\r\n\r\n                mstore(0x2e0, calldataload(0x24)) // store the msg.sender, to be hashed later\r\n\r\n                hashCommitments(notes, n)\r\n                let b := add(0x300, mul(n, 0x80)) // set pointer to memory location of commitments where the commitments\r\n\r\n                /*\r\n                ///////////////////////////  CALCULATE BLINDING FACTORS  /////////////////////////////////////\r\n                */\r\n                let x := 1\r\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\r\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\r\n\r\n                    // Get the calldata index of this note and associated parameters\r\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\r\n                    let k\r\n                    let a := calldataload(add(noteIndex, 0x20))\r\n                    let c := challenge\r\n\r\n                    switch gt(i, 1) // i (an indexer) > 1 denotes a taker note\r\n                    case 1 { // if it's a taker note\r\n\r\n                        // indexing the k value of the note that is 2 indices behind the current note\r\n                        k := calldataload(sub(noteIndex, 0x180))\r\n                    }\r\n\r\n                    case 0 { // if it's a maker note\r\n                        k := calldataload(noteIndex)\r\n                    }\r\n\r\n\r\n                    // Check this commitment is well formed\r\n                    validateCommitment(noteIndex, k, a)\r\n\r\n                    x := mulmod(x, mload(0x00), gen_order)\r\n                    // Set k = kx_j, a = ax_j, c = cx_j, where j = note index\r\n                    if gt(i, 0) {\r\n                        k := mulmod(k, x, gen_order)\r\n                        a := mulmod(a, x, gen_order)\r\n                        c := mulmod(challenge, x, gen_order)\r\n                    } \r\n\r\n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\r\n                    // Memory map:\r\n                    // 0x20: \\gamma_iX\r\n                    // 0x40: \\gamma_iY\r\n                    // 0x60: k_i\r\n                    // 0x80: hX\r\n                    // 0xa0: hY\r\n                    // 0xc0: a_i\r\n                    // 0xe0: \\sigma_iX\r\n                    // 0x100: \\sigma_iY\r\n                    // 0x120: -c\r\n\r\n                    // loading into memory\r\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\r\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\r\n                    mstore(0x120, sub(gen_order, c))\r\n                    mstore(0x60, k)\r\n                    mstore(0xc0, a)\r\n\r\n                    // Call bn128 scalar multiplication precompiles\r\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\r\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\r\n                    // Store \\gamma_i^{k} at 0x120:0x160\r\n                    // Store h^{a} at 0x160:0x1a0\r\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\r\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\r\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\r\n\r\n                    // Call bn128 group addition precompiles\r\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\r\n                    // Store result of addition at 0x160:0x1a0\r\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\r\n\r\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\r\n                    // Store resulting point B at memory index b\r\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\r\n\r\n                    if eq(i, 0) { // m = 0\r\n                        mstore(0x260, mload(0x20)) //  gamma_iX\r\n                        mstore(0x280, mload(0x40)) // gamma_iY\r\n                        mstore(0x1e0, mload(0xe0)) // sigma_iX\r\n                        mstore(\r\n                            0x200,\r\n                            sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100))\r\n                            )\r\n                    }\r\n\r\n                    // If i > 0 (i.e. all notes other than the first)\r\n                    // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\r\n                    // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\r\n                    if gt(i, 0) {\r\n                        mstore(0x60, c)\r\n\r\n                        result := and(\r\n                            result,\r\n                            and(\r\n                                and(\r\n                                    staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40), // \\sigma_i^{-cx_{i-m-1}}\r\n                                    staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40) // \\gamma_i^{cx_{i-m-1}}\r\n                                ),\r\n                                staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40) // \\gamma_i^k\r\n                            )\r\n                        )\r\n                    }\r\n\r\n\r\n                    // throw transaction if any calls to precompiled contracts failed\r\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\r\n                    b := add(b, 0x40) // increase B pointer by 2 words\r\n                }\r\n                \r\n                validatePairing(0x84)\r\n\r\n\r\n                /*\r\n                ////////////////////  RECONSTRUCT INITIAL CHALLENGE AND VERIFY A MATCH  ////////////////////////////////\r\n                */\r\n\r\n                // We now have the note commitments and the calculated blinding factors in a block of memory\r\n                // starting at 0x2e0, of size (b - 0x2e0).\r\n                // Hash this block to reconstruct the initial challenge and validate that they match\r\n                let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\r\n\r\n                if iszero(eq(expected, challenge)) {\r\n\r\n                    // No! Bad! No soup for you!\r\n                    mstore(0x00, 404)\r\n                    revert(0x00, 0x20)\r\n                }\r\n            }\r\n\r\n             /**        \r\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\r\n             * @notice we don't hard-code t2 so that contracts that call this library can use\r\n             * different trusted setups.\r\n             **/\r\n            function validatePairing(t2) {\r\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\r\n                let t2_x_1 := calldataload(t2)\r\n                let t2_x_2 := calldataload(add(t2, 0x20))\r\n                let t2_y_1 := calldataload(add(t2, 0x40))\r\n                let t2_y_2 := calldataload(add(t2, 0x60))\r\n\r\n                // check provided setup pubkey is not zero or g2\r\n                if or(or(or(or(or(or(or(\r\n                    iszero(t2_x_1),\r\n                    iszero(t2_x_2)),\r\n                    iszero(t2_y_1)),\r\n                    iszero(t2_y_2)),\r\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\r\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\r\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\r\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\r\n                {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n\r\n                // store coords in memory\r\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\r\n                // to what precompile expects\r\n                // We can overwrite the memory we used previously as this function is called at the\r\n                // end of the validation routine.\r\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\r\n                mstore(0x40, mload(0x200)) // sigma accumulator y\r\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\r\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\r\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\r\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\r\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\r\n                mstore(0x100, mload(0x280)) // gamma accumulator y\r\n                mstore(0x140, t2_x_1)\r\n                mstore(0x120, t2_x_2)\r\n                mstore(0x180, t2_y_1)\r\n                mstore(0x160, t2_y_2)\r\n\r\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\r\n\r\n                if or(iszero(success), iszero(mload(0x20))) {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n            }\r\n\r\n            /**\r\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\r\n             * and that signatures 'k' and 'a' are modulo the order of the curve. Transaction\r\n             * throws if this is not the case.\r\n             * @param note the calldata loation of the note\r\n             **/\r\n            function validateCommitment(note, k, a) {\r\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\r\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\r\n                let gammaX := calldataload(add(note, 0x40))\r\n                let gammaY := calldataload(add(note, 0x60))\r\n                let sigmaX := calldataload(add(note, 0x80))\r\n                let sigmaY := calldataload(add(note, 0xa0))\r\n                if iszero(\r\n                    and(\r\n                        and(\r\n                            and(\r\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\r\n                                gt(a, 1)                  // can't be 0 or 1 either!\r\n                            ),\r\n                            and(\r\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\r\n                                gt(k, 1)                  // and not 0 or 1\r\n                            )\r\n                        ),\r\n                        and(\r\n                            eq( // y^2 ?= x^3 + 3\r\n                                addmod(mulmod(\r\n                                    mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order),\r\n                                    3,\r\n                                    field_order),\r\n                                mulmod(sigmaY, sigmaY, field_order)\r\n                            ),\r\n                            eq( // y^2 ?= x^3 + 3\r\n                                addmod(mulmod(\r\n                                    mulmod(gammaX, gammaX, field_order),\r\n                                    gammaX,\r\n                                    field_order),\r\n                                    3, field_order),\r\n                                mulmod(gammaY, gammaY, field_order)\r\n                            )\r\n                        )\r\n                    )\r\n                ) {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n            }\r\n\r\n            /**\r\n             * @dev Calculate the keccak256 hash of the commitments for both\r\n             * input notes and output notes. This is used both as an input to\r\n             * validate the challenge `c` and also to generate pseudorandom relationships\r\n             * between commitments for different outputNotes, so that we can combine\r\n             * them into a single multi-exponentiation for the purposes of validating\r\n             * the bilinear pairing relationships.\r\n             * @param notes calldata location notes\r\n             * @param n number of notes\r\n             **/\r\n            function hashCommitments(notes, n) {\r\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\r\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\r\n                calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\r\n                }\r\n                // storing at position 0x00 in memory, the kecca hash of everything from\r\n                // start of the commitments to the end\r\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\r\n            }\r\n        }\r\n        // if we've reached here, we've validated the Swap and haven't thrown an error.\r\n        // Encode the output according to the ACE standard and exit.\r\n        SwapABIEncoder.encodeAndExit();\r\n    }\r\n}","ABI":"[{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}]","ContractName":"Swap","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://3a50215f399a9f3e44c89c15f0175e526d9e3dc43a245668871529f891a3d188"}]}