{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\n\r\ninterface IPriceOracle {\r\n    function getExpectedReturn(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 amount,\r\n        uint256 parts,\r\n        uint256 disableFlags // 1 - Uniswap, 2 - Kyber, 4 - Bancor, 8 - Oasis, 16 - Compound\r\n    ) external view returns(\r\n        uint256 returnAmount,\r\n        uint[4] memory distribution // [Uniswap, Kyber, Bancor, Oasis]\r\n    );\r\n}\r\n\r\n\r\n\r\ninterface ISoftETHToken {\r\n    function burn(uint256 _amount) external;\r\n    function mint(address _account, uint256 _amount) external returns(bool);\r\n    function totalSupply() external view returns(uint256);\r\n}\r\n\r\n\r\n\r\ninterface IExitToken {\r\n    function mint(address _account, uint256 _amount) external returns(bool);\r\n    function totalSupply() external view returns(uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\ncontract Reward is Initializable {\r\n    using SafeMath for uint256;\r\n\r\n    // =============================================== Storage ========================================================\r\n\r\n    // WARNING: since this contract is upgradeable, do not remove\r\n    // existing storage variables and do not change their types!\r\n\r\n    /// @dev The serial number of the latest finished staking epoch.\r\n    uint256 public lastStakingEpochFinished;\r\n\r\n    /// @dev The address of staker. Used by `finishStakingEpoch` function\r\n    /// to emulate staking. EXIT tokens are minted to this address.\r\n    address public staker;\r\n\r\n    /// @dev The address that has the rights to change STAKE/USD rate.\r\n    address public currencyRateChanger;\r\n\r\n    /// @dev The address of EXIT token contract.\r\n    IExitToken public exitToken;\r\n\r\n    /// @dev The address of softETH token contract.\r\n    ISoftETHToken public softETHToken;\r\n\r\n    /// @dev The latest known ETH/USD rate (in USD cents) set by `rebalance` function.\r\n    /// Has 2 decimals (e.g., 160.35 USD presented as 16035).\r\n    uint256 public ethUsd;\r\n\r\n    /// @dev The STAKE/USD rate (in USD cents) set by `setSTAKEUSD` function.\r\n    /// Has 2 decimals (e.g., 20.45 USD presented as 2045).\r\n    uint256 public stakeUsd;\r\n\r\n    // ============================================== Constants =======================================================\r\n\r\n    /// @dev How many EXIT tokens must be minted in relation to\r\n    /// the USD worth of STAKE tokens staked into all pools.\r\n    uint256 public constant EXIT_MINT_RATE = 10; // percents\r\n\r\n    /// @dev How many times the USD worth of softETH tokens must\r\n    /// exceed the total supply of EXIT tokens.\r\n    uint256 public constant COLLATERAL_MULTIPLIER = 2;\r\n\r\n    // ================================================ Events ========================================================\r\n\r\n    /// @dev Emitted by the `rebalance` function.\r\n    /// @param newTotalSupply The new `totalSupply` of softETH tokens.\r\n    /// @param caller The address called the function.\r\n    event Rebalanced(uint256 newTotalSupply, address indexed caller);\r\n\r\n    /// @dev Emitted by the `finishStakingEpoch` function.\r\n    /// @param stakingEpoch The number of finished staking epoch.\r\n    /// @param totalStakeAmount The total amount of STAKE tokens staked before the epoch finished.\r\n    /// @param exitMintAmount How many EXIT tokens were minted.\r\n    /// @param caller The address called the function.\r\n    event StakingEpochFinished(\r\n        uint256 indexed stakingEpoch,\r\n        uint256 totalStakeAmount,\r\n        uint256 exitMintAmount,\r\n        address indexed caller\r\n    );\r\n\r\n    // ============================================== Modifiers =======================================================\r\n\r\n    /// @dev Modifier to check whether the `msg.sender` is the `currencyRateChanger`.\r\n    modifier ifCurrencyRateChanger() {\r\n        require(msg.sender == currencyRateChanger);\r\n        _;\r\n    }\r\n\r\n    // =============================================== Setters ========================================================\r\n\r\n    /// @dev Emulates finishing of staking epoch, mints EXIT tokens for the `staker` address.\r\n    /// Can by called by anyone. The amount of EXIT tokens to be minted is calculated\r\n    /// based on the `_totalStakeAmount` parameter, EXIT_MINT_RATE, and the current\r\n    /// STAKE/USD rate defined in `stakeUsd`.\r\n    /// @param _totalStakeAmount The total amount of STAKE tokens staked at the moment of\r\n    /// the end of staking epoch. The amount must have 18 decimals.\r\n    function finishStakingEpoch(uint256 _totalStakeAmount) public {\r\n        require(exitToken != IExitToken(0));\r\n        require(staker != address(0));\r\n        require(stakeUsd != 0);\r\n\r\n        uint256 usdAmount = _totalStakeAmount.mul(stakeUsd).div(100);\r\n        uint256 mintAmount = usdAmount.mul(EXIT_MINT_RATE).div(100);\r\n        exitToken.mint(staker, mintAmount);\r\n        rebalance();\r\n\r\n        lastStakingEpochFinished++;\r\n\r\n        emit StakingEpochFinished(lastStakingEpochFinished, _totalStakeAmount, mintAmount, msg.sender);\r\n    }\r\n\r\n    /// @dev Initializes the contract. Used instead of constructor since this contract is upgradeable.\r\n    /// @param _staker The address of staker. EXIT tokens will be minted to this address.\r\n    /// @param _currencyRateChanger The address that has the rights to change STAKE/USD rate.\r\n    /// @param _exitToken The address of EXIT token contract.\r\n    /// @param _softETHToken The address of softETH token contract.\r\n    function initialize(\r\n        address _staker,\r\n        address _currencyRateChanger,\r\n        IExitToken _exitToken,\r\n        ISoftETHToken _softETHToken\r\n    ) public initializer {\r\n        require(_admin() != address(0)); // make sure it is called by the proxy contract with `delegatecall`\r\n        require(_staker != address(0));\r\n        require(_currencyRateChanger != address(0));\r\n        require(_exitToken != IExitToken(0));\r\n        require(_softETHToken != ISoftETHToken(0));\r\n        staker = _staker;\r\n        currencyRateChanger = _currencyRateChanger;\r\n        exitToken = _exitToken;\r\n        softETHToken = _softETHToken;\r\n    }\r\n\r\n    /// @dev Rebalances the totalSupply of softETH so that it would exceed\r\n    /// EXIT token supply COLLATERAL_MULTIPLIER times in USD worth.\r\n    /// Can be called by anyone.\r\n    function rebalance() public {\r\n        require(exitToken != IExitToken(0));\r\n        require(softETHToken != ISoftETHToken(0));\r\n\r\n        uint256 ethInUSD = usdEthCurrent(); // how many ETHs in 1 USD at the moment\r\n        require(ethInUSD != 0);\r\n        \r\n        // Calculate the current and new softETH amounts\r\n        uint256 currentSupply = softETHCurrentSupply();\r\n        uint256 expectedSupply = _softETHExpectedSupply(ethInUSD);\r\n\r\n        if (expectedSupply > currentSupply) {\r\n            // We need to have more softETH tokens, so mint the lack tokens\r\n            softETHToken.mint(address(this), expectedSupply - currentSupply);\r\n        } else if (expectedSupply < currentSupply) {\r\n            // We need to have less softETH tokens, so burn the excess tokens\r\n            softETHToken.burn(currentSupply - expectedSupply);\r\n        }\r\n\r\n        ethUsd = 100 ether / ethInUSD;\r\n\r\n        emit Rebalanced(expectedSupply, msg.sender);\r\n    }\r\n\r\n    /// @dev Sets the current STAKE/USD rate in USD cents.\r\n    /// Can only be called by the `currencyRateChanger`.\r\n    /// @param _cents The rate in USD cents. Must have 2 decimals,\r\n    /// e.g., 20.45 USD presented as 2045.\r\n    function setSTAKEUSD(uint256 _cents) public ifCurrencyRateChanger {\r\n        require(_cents != 0);\r\n        stakeUsd = _cents;\r\n    }\r\n\r\n    // =============================================== Getters ========================================================\r\n\r\n    /// @dev Returns the current amount of USDTs in 1 ETH, i.e. ETH/USDT rate (in USD cents).\r\n    /// The returned amount has 2 decimals (e.g., 160.35 USD presented as 16035).\r\n    function ethUsdCurrent() public view returns(uint256) {\r\n        uint256 ethers = usdEthCurrent();\r\n        if (ethers == 0) return 0;\r\n        return 100 ether / ethers;\r\n    }\r\n\r\n    /// @dev Returns the current total supply of EXIT tokens.\r\n    function exitCurrentSupply() public view returns(uint256) {\r\n        return exitToken.totalSupply();\r\n    }\r\n\r\n    /// @dev Returns the current amount of ETHs in 1 USDT, i.e. USDT/ETH rate.\r\n    /// The returned amount has 18 decimals.\r\n    function usdEthCurrent() public view returns(uint256) {\r\n        (uint256 returnAmount,) = IPriceOracle(PRICE_ORACLE).getExpectedReturn(\r\n            0xdAC17F958D2ee523a2206206994597C13D831ec7, // fromToken (USDT)\r\n            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, // toToken (ETH)\r\n            1000000, // amount (1.00 USDT)\r\n            1, // parts\r\n            0  // disableFlags\r\n        );\r\n        return returnAmount;\r\n    }\r\n\r\n    /// @dev Returns the current total supply of softETH tokens.\r\n    function softETHCurrentSupply() public view returns(uint256) {\r\n        return softETHToken.totalSupply();\r\n    }\r\n\r\n    /// @dev Returns the current expected supply of softETH tokens\r\n    /// based on the supply of EXIT tokens, COLLATERAL_MULTIPLIER,\r\n    /// and the current USD/ETH rate.\r\n    function softETHExpectedSupply() public view returns(uint256) {\r\n        return _softETHExpectedSupply(usdEthCurrent());\r\n    }\r\n\r\n    /// @dev Returns the general data in a single request.\r\n    function getCurrentDataBatch() public view returns(\r\n        uint256 _ethUsd,\r\n        uint256 _ethUsdCurrent,\r\n        uint256 _exitCurrentSupply,\r\n        uint256 _lastStakingEpochFinished,\r\n        uint256 _softETHCurrentSupply,\r\n        uint256 _softETHExpectedSupply,\r\n        uint256 _stakeUsd\r\n    ) {\r\n        _ethUsd = ethUsd;\r\n        _ethUsdCurrent = ethUsdCurrent();\r\n        _exitCurrentSupply = exitCurrentSupply();\r\n        _lastStakingEpochFinished = lastStakingEpochFinished;\r\n        _softETHCurrentSupply = softETHCurrentSupply();\r\n        _softETHExpectedSupply = softETHExpectedSupply();\r\n        _stakeUsd = stakeUsd;\r\n    }\r\n\r\n    // ============================================== Internal ========================================================\r\n\r\n    /// @dev The address of the contract in Ethereum Mainnet which provides the current USD/ETH rate.\r\n    address internal constant PRICE_ORACLE = 0xAd13fE330B0aE312bC51d2E5B9Ca2ae3973957C7;\r\n\r\n    /// @dev Returns the admin slot.\r\n    function _admin() internal view returns(address adm) {\r\n        /// Storage slot with the admin of the contract.\r\n        /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\r\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n        assembly {\r\n            adm := sload(slot)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the current expected supply of softETH tokens\r\n    /// based on the supply of EXIT tokens, COLLATERAL_MULTIPLIER,\r\n    /// and the passed USD/ETH rate.\r\n    /// @param _ethInUSD The current USD/ETH rate (must have 18 decimals).\r\n    function _softETHExpectedSupply(uint256 _ethInUSD) internal view returns(uint256) {\r\n        return exitToken.totalSupply().mul(COLLATERAL_MULTIPLIER).mul(_ethInUSD).div(1 ether);\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalSupply\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Rebalanced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakingEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exitMintAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"StakingEpochFinished\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLLATERAL_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXIT_MINT_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currencyRateChanger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethUsdCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exitCurrentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exitToken\",\"outputs\":[{\"internalType\":\"contract IExitToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalStakeAmount\",\"type\":\"uint256\"}],\"name\":\"finishStakingEpoch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentDataBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethUsdCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exitCurrentSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastStakingEpochFinished\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_softETHCurrentSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_softETHExpectedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeUsd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currencyRateChanger\",\"type\":\"address\"},{\"internalType\":\"contract IExitToken\",\"name\":\"_exitToken\",\"type\":\"address\"},{\"internalType\":\"contract ISoftETHToken\",\"name\":\"_softETHToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastStakingEpochFinished\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cents\",\"type\":\"uint256\"}],\"name\":\"setSTAKEUSD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softETHCurrentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softETHExpectedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softETHToken\",\"outputs\":[{\"internalType\":\"contract ISoftETHToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdEthCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Reward","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://49093e91e2a93e03efe4cef272612f15ea97a2bd27e7dc6815f714d6c06cdf4c"}]}