{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n// OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\"},\"AucInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\nimport \\\"EIP20Interface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title AucInterface\\r\\n * @dev Interface for the Auc token.\\r\\n * Auc is an ERC 20 token with additional functions.\\r\\n * burn - To burn Auc amount.\\r\\n * transfer - EIP 223 transfer that calls the tokenFallback on destination contract.\\r\\n */\\r\\ninterface AucInterface is EIP20Interface {\\r\\n    function burn(uint256 amount) external returns(bool);\\r\\n    function transfer(address dst, uint256 amount, bytes calldata data) external returns(bool);\\r\\n}\"},\"CompoundInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title CompoundInterface\\r\\n * @dev Compound CErc20Interface for external functions used on dPiggy.\\r\\n * https://github.com/compound-finance/compound-protocol/tree/master/contracts\\r\\n */\\r\\ninterface CompoundInterface {\\r\\n    function balanceOf(address owner) external view returns(uint256);\\r\\n    function exchangeRateStored() external view returns(uint256);\\r\\n    function exchangeRateCurrent() external returns(uint256);\\r\\n    function mint(uint mintAmount) external returns(uint256);\\r\\n    function redeemUnderlying(uint redeemAmount) external returns(uint256);\\r\\n    function balanceOfUnderlying(address account) external returns(uint256);\\r\\n}\"},\"DPiggyAsset.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\nimport \\\"SafeMath.sol\\\";\\r\\nimport \\\"Address.sol\\\";\\r\\nimport \\\"EIP20Interface.sol\\\";\\r\\nimport \\\"AucInterface.sol\\\";\\r\\nimport \\\"CompoundInterface.sol\\\";\\r\\nimport \\\"UniswapExchangeInterface.sol\\\";\\r\\nimport \\\"DPiggyAssetInterface.sol\\\";\\r\\nimport \\\"DPiggyInterface.sol\\\";\\r\\nimport \\\"DPiggyAssetData.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DPiggyAsset\\r\\n * @dev The contract is proxied for dPiggyAssetProxy.\\r\\n * It is created and managed by dPiggy contract that is also the contract admin.\\r\\n * Implements all operations for the Dai deposited for an asset.\\r\\n */\\r\\ncontract DPiggyAsset is DPiggyAssetData, DPiggyAssetInterface {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev Function to initialize the contract.\\r\\n     * It should be called through the `data` argument when creating the proxy.\\r\\n     * It must be called only once. The `assert` is to guarantee that behavior.\\r\\n     * @param _tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. It is the asset for the respective contract. \\r\\n     * @param _minimumTimeBetweenExecutions The minimum time in seconds between executions to run the Compound redeem.\\r\\n     */\\r\\n    function init(address _tokenAddress, uint256 _minimumTimeBetweenExecutions) external {\\r\\n        \\r\\n        assert(\\r\\n            minimumTimeBetweenExecutions == 0 \\u0026\\u0026 \\r\\n            executionId == 0 \\u0026\\u0026 \\r\\n            totalBalance == 0 \\u0026\\u0026 \\r\\n            tokenAddress == address(0)\\r\\n        );\\r\\n        \\r\\n        tokenAddress = _tokenAddress;\\r\\n        minimumTimeBetweenExecutions = _minimumTimeBetweenExecutions;\\r\\n        \\r\\n        address _compound = DPiggyInterface(admin).compound();\\r\\n        isCompound = (_tokenAddress == _compound);\\r\\n        \\r\\n        totalBalance = 0;\\r\\n        feeExemptionAmountForAucEscrowed = 0;\\r\\n        executionId = 0;\\r\\n        executions[executionId] = Execution({\\r\\n            time: now, \\r\\n            rate: DPiggyInterface(admin).percentagePrecision(),\\r\\n            totalDai: 0,\\r\\n            totalRedeemed: 0,\\r\\n            totalBought: 0,\\r\\n            totalBalance: 0,\\r\\n            totalFeeDeduction: 0,\\r\\n            feeAmount: 0\\r\\n        });\\r\\n        \\r\\n        /* Initialize the stored data that controls the reentrancy guard.\\r\\n         * Due to the proxy, it must be set on a separate initialize method instead of the constructor.\\r\\n         */\\r\\n        _notEntered = true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to initialize the contract migrating the data from another contract.\\r\\n     * It should be called through the `data` argument when creating the proxy.\\r\\n     * It must be called only once. The `assert` is to guarantee that behavior.\\r\\n     * @param previousContract The contract to copy the data. \\r\\n     * @param users The users to copy their stored data.\\r\\n     */\\r\\n    function initMigratingData(address previousContract, address[] calldata users) external {\\r\\n        \\r\\n        assert(\\r\\n            minimumTimeBetweenExecutions == 0 \\u0026\\u0026 \\r\\n            executionId == 0 \\u0026\\u0026 \\r\\n            totalBalance == 0 \\u0026\\u0026 \\r\\n            tokenAddress == address(0)\\r\\n        );\\r\\n        \\r\\n        tokenAddress = _getContractAddress(previousContract, abi.encodeWithSignature(\\\"tokenAddress()\\\"));\\r\\n        isCompound = _getContractBool(previousContract, abi.encodeWithSignature(\\\"isCompound()\\\"));\\r\\n        minimumTimeBetweenExecutions = _getContractUint256(previousContract, abi.encodeWithSignature(\\\"minimumTimeBetweenExecutions()\\\"));\\r\\n        totalBalance = _getContractUint256(previousContract, abi.encodeWithSignature(\\\"totalBalance()\\\"));\\r\\n        feeExemptionAmountForAucEscrowed = _getContractUint256(previousContract, abi.encodeWithSignature(\\\"feeExemptionAmountForAucEscrowed()\\\"));\\r\\n        executionId = _getContractUint256(previousContract, abi.encodeWithSignature(\\\"executionId()\\\"));\\r\\n        \\r\\n        for (uint256 id = 0; id \\u003c= executionId; ++id) {\\r\\n            uint256 nextId = id + 1;\\r\\n            totalBalanceNormalizedDifference[nextId] = _getContractUint256(previousContract, abi.encodeWithSignature(\\\"totalBalanceNormalizedDifference(uint256)\\\", nextId));\\r\\n            feeExemptionAmountForUserBaseData[nextId] = _getContractUint256(previousContract, abi.encodeWithSignature(\\\"feeExemptionAmountForUserBaseData(uint256)\\\", nextId));\\r\\n            executions[id] = _getContractExecution(previousContract, abi.encodeWithSignature(\\\"executions(uint256)\\\", id));\\r\\n        }\\r\\n        \\r\\n        uint256 usersBalance = 0;\\r\\n        for (uint256 index = 0; index \\u003c users.length; ++index) {\\r\\n            usersData[users[index]] = _getContractUserData(previousContract, abi.encodeWithSignature(\\\"usersData(address)\\\", users[index]));\\r\\n            \\r\\n            UserData storage userData = usersData[users[index]];\\r\\n            usersBalance = usersBalance.add(userData.currentAllocated);\\r\\n            \\r\\n            // The fee exemption normalized difference must be set.\\r\\n            if (userData.currentAllocated \\u003e 0 \\u0026\\u0026 userData.baseExecutionId == executionId) {\\r\\n                uint256 normalizedDifference = _getNormalizedDifference(userData.baseExecutionAccumulatedAmount.sub(userData.baseExecutionAmountForFee), userData.baseExecutionAvgRate, executions[executionId].rate);\\r\\n                _setFeeExemptionNormalizedDifferenceForNextExecution(true, normalizedDifference);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        require(usersBalance == totalBalance, \\\"DPiggyAsset::initMigratingData: Invalid users\\\");\\r\\n\\r\\n        /* Initialize the stored data that controls the reentrancy guard.\\r\\n         * Due to the proxy, it must be set on a separate initialize method instead of the constructor.\\r\\n         */\\r\\n        _notEntered = true;\\r\\n        \\r\\n        emit SetMigration(previousContract);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to receive ether when it was bought on the Uniswap exchange.\\r\\n     */\\r\\n    receive() external payable {\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the minimum time for the next Compound redeem execution.\\r\\n     * @return The minimum time in Unix for the next Compound redeem execution.\\r\\n     */\\r\\n    function getMinimumTimeForNextExecution() public view returns(uint256) {\\r\\n        Execution storage lastExecution = executions[executionId];\\r\\n        return lastExecution.time.add(minimumTimeBetweenExecutions);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the user\\u0027s Dai gross profit, asset net profit and the fee amount in Dai.\\r\\n     * @param user User\\u0027s address. \\r\\n     * @return The user\\u0027s Dai gross profit, asset net profit and the fee amount charged in Dai. \\r\\n     * First return is the gross profit in Dai.\\r\\n     * Second return is the asset net profit.\\r\\n     * Third return is the fee amount charged in Dai.\\r\\n     */\\r\\n    function getUserProfitsAndFeeAmount(address user) public view override(DPiggyAssetInterface) returns(uint256, uint256, uint256) {\\r\\n        UserData storage userData = usersData[user];\\r\\n        return _getUserProfitsAndFeeAmount(DPiggyInterface(admin).escrowStart(user), userData);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the estimated current gross profit in Dai for the user.\\r\\n     * So it is not the total gross profit, it is only for the user amount of Dai on the next Compound redeem execution.\\r\\n     * The estimative of the amount of Dai on the Compound redeem execution considering the current Compound stored rate.\\r\\n     * For an estimated total of the gross profit: `getUserProfit` + `getUserEstimatedCurrentProfitWithoutFee`.\\r\\n     * @param user User\\u0027s address. \\r\\n     * @return The estimated gross profit in Dai. \\r\\n     */\\r\\n    function getUserEstimatedCurrentProfitWithoutFee(address user) public view returns(uint256) {\\r\\n        UserData storage userData = usersData[user];\\r\\n        if (userData.currentAllocated \\u003e 0) {\\r\\n            CompoundInterface _compound = CompoundInterface(DPiggyInterface(admin).compound());\\r\\n            Execution storage lastExecution = executions[executionId];\\r\\n            uint256 rate = _getRateForExecution(_compound.exchangeRateStored().mul(_compound.balanceOf(address(this))).div(1e18), lastExecution);\\r\\n            \\r\\n            uint256 remainingBalance = 0;\\r\\n            if (isCompound) {\\r\\n                (uint256 executionsProfit,,uint256 feeAmount) = _getUserProfitsAndFeeAmount(DPiggyInterface(admin).escrowStart(user), userData);\\r\\n                remainingBalance = executionsProfit.sub(feeAmount);\\r\\n            }\\r\\n            \\r\\n            return _getAccruedInterestForExecution(executionId, rate, remainingBalance, userData);\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the estimated current fee in Dai for the user.\\r\\n     * To estimate the amount of fee on the Compound redeem execution is calculated by the difference between the `time` and the last execution time.\\r\\n     * So it is not the total amount of fee, for an estimated total of the fee in Dai: \\r\\n     * `getUserAssetProfitAndFeeAmount(second return)` + `getUserEstimatedCurrentFee`.\\r\\n     * @param user User\\u0027s address. \\r\\n     * @param time The Unix time to calculate the fee. It should be the current Unix time. \\r\\n     * @return The estimated fee in Dai. \\r\\n     */\\r\\n    function getUserEstimatedCurrentFee(address user, uint256 time) public view returns(uint256) {\\r\\n        UserData storage userData = usersData[user];\\r\\n        if (userData.currentAllocated \\u003e 0) {\\r\\n            uint256 escrowStart = DPiggyInterface(admin).escrowStart(user);\\r\\n            \\r\\n            // Whether the user has the Auc escrowed the fee is zero.\\r\\n            if (escrowStart == 0 || escrowStart \\u003e time) {\\r\\n                Execution storage lastExecution = executions[executionId];\\r\\n                if (lastExecution.time \\u003c time) {\\r\\n                    uint256 _percentagePrecision = DPiggyInterface(admin).percentagePrecision();\\r\\n                    uint256 fee = DPiggyInterface(admin).executionFee(time.sub(lastExecution.time));\\r\\n                    return _getFeeAmountForExecution(userData.baseExecutionId == executionId, fee, _percentagePrecision, userData);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the amount of asset redeemed for the user.\\r\\n     * @param user User\\u0027s address. \\r\\n     * @return The amount of asset redeemed. \\r\\n     */\\r\\n    function getUserAssetRedeemed(address user) public view returns(uint256) {\\r\\n        UserData storage userData = usersData[user];\\r\\n        return userData.redeemed;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the amount of Dai deposited for the user.\\r\\n     * @param user User\\u0027s address. \\r\\n     * @return The amount of Dai deposited. \\r\\n     */\\r\\n    function getUserTotalInvested(address user) public view returns(uint256) {\\r\\n        UserData storage userData = usersData[user];\\r\\n        return userData.currentAllocated;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the minimum time between the Compound redeem executions.\\r\\n     * Only can be called by the admin (dPiggy contract).\\r\\n     * @param time New minimum time in seconds between the Compound redeem executions.\\r\\n     */\\r\\n    function setMinimumTimeBetweenExecutions(uint256 time) onlyAdmin external override(DPiggyAssetInterface) {\\r\\n        uint256 oldTime = minimumTimeBetweenExecutions;\\r\\n        minimumTimeBetweenExecutions = time;\\r\\n        emit SetMinimumTimeBetweenExecutions(time, oldTime);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to deposit Dai.\\r\\n     * Only can be called by the admin (dPiggy contract).\\r\\n     * On deposit, it sets all previous Dai profit, asset profit and fee amount until the last Compound redeem execution.\\r\\n     * It sets stored data to be able to calculate the proportional profit and fee on the next Compound redeem execution\\r\\n     * because the rate is a weighted average of all deposits rate in this period (between executions) \\r\\n     * and the same for the fee that should be proportional to the number of days in this period.\\r\\n     * @param user User\\u0027s address. \\r\\n     * @param amount Amount of Dai deposited.\\r\\n     */\\r\\n    function deposit(address user, uint256 amount) nonReentrant onlyAdmin external override(DPiggyAssetInterface) {\\r\\n        uint256 _percentagePrecision = DPiggyInterface(admin).percentagePrecision();\\r\\n        \\r\\n        CompoundInterface _compound = CompoundInterface(DPiggyInterface(admin).compound());\\r\\n        require(EIP20Interface(DPiggyInterface(admin).dai()).approve(address(_compound), amount), \\\"DPiggyAsset::deposit: Error on approve Compound\\\");\\r\\n        \\r\\n        Execution storage lastExecution = executions[executionId];\\r\\n        uint256 rate;\\r\\n        if (totalBalance \\u003e 0) {\\r\\n            rate = _getRateForExecution(_compound.balanceOfUnderlying(address(this)), lastExecution);\\r\\n        } else {\\r\\n            rate = lastExecution.rate;\\r\\n        }\\r\\n        \\r\\n        _assertCompoundReturn(_compound.mint(amount));\\r\\n        \\r\\n        uint256 baseExecutionAmountForFee = 0;\\r\\n        uint256 allAmountNormalizedDifference = _getNormalizedDifference(amount, rate, lastExecution.rate);\\r\\n        uint256 escrowStart = DPiggyInterface(admin).escrowStart(user);\\r\\n        \\r\\n        /* If the user has Auc escrowed, all the amount of Dai must set on the respective fee exemption control data. \\r\\n         * Otherwise, the fee exemption is the proportional amount of deposited Dai between the last execution and the current execution.  \\r\\n         * The fee will be charged only during the days that Dai was invested, not all period.\\r\\n         */\\r\\n        if (escrowStart \\u003e 0) {\\r\\n            _setEscrow(true, amount);\\r\\n            _setFeeExemptionNormalizedDifferenceForNextExecution(true, allAmountNormalizedDifference);\\r\\n        } else {\\r\\n            baseExecutionAmountForFee = _getNextExecutionFeeProportion(amount);\\r\\n            uint256 amountWithFeeExemption = amount.sub(baseExecutionAmountForFee);\\r\\n            _setFeeExemptionForNextExecution(true, amountWithFeeExemption);\\r\\n            _setFeeExemptionNormalizedDifferenceForNextExecution(true, _getNormalizedDifference(amountWithFeeExemption, rate, lastExecution.rate));\\r\\n        }\\r\\n        \\r\\n        UserData storage userData = usersData[user];\\r\\n        uint256 currentWeight = amount.mul(_percentagePrecision).div(rate);\\r\\n        \\r\\n        /* Whether there is a previous deposit for the user after the last Compound redeem execution the `base` data should be accumulated.\\r\\n         * So the average weighted rate for this period is calculated: (total deposit for this period) / Sum [ (deposit n) / (rate n) ]\\r\\n         */\\r\\n        if (userData.currentAllocated \\u003e 0 \\u0026\\u0026 userData.baseExecutionId == executionId) {\\r\\n            userData.baseExecutionAmountForFee = userData.baseExecutionAmountForFee.add(baseExecutionAmountForFee);\\r\\n            userData.baseExecutionAccumulatedAmount = userData.baseExecutionAccumulatedAmount.add(amount);\\r\\n            userData.baseExecutionAccumulatedWeightForRate = userData.baseExecutionAccumulatedWeightForRate.add(currentWeight);\\r\\n            userData.baseExecutionAvgRate = userData.baseExecutionAccumulatedAmount.mul(_percentagePrecision).div(userData.baseExecutionAccumulatedWeightForRate);\\r\\n        } else {\\r\\n            (uint256 previousProfit, uint256 previousAssetAmount, uint256 previousFeeAmount) = _getUserProfitsAndFeeAmount(escrowStart, userData);\\r\\n            userData.previousProfit = previousProfit;\\r\\n            userData.previousAssetAmount = previousAssetAmount;\\r\\n            userData.previousFeeAmount = previousFeeAmount;\\r\\n            userData.previousAllocated = userData.currentAllocated;\\r\\n            userData.baseExecutionAmountForFee = baseExecutionAmountForFee;\\r\\n            userData.baseExecutionAccumulatedAmount = amount;\\r\\n            userData.baseExecutionAccumulatedWeightForRate = currentWeight;\\r\\n            userData.baseExecutionAvgRate = rate;\\r\\n            userData.baseExecutionId = executionId;\\r\\n        }\\r\\n        \\r\\n        userData.currentAllocated = userData.currentAllocated.add(amount);\\r\\n        \\r\\n        totalBalance = totalBalance.add(amount);\\r\\n        _setTotalBalanceNormalizedDifferenceForNextExecution(true, allAmountNormalizedDifference);\\r\\n        \\r\\n        emit Deposit(user, amount, rate, executionId, baseExecutionAmountForFee);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the fee exemption due to the Auc escrowed for the user.\\r\\n     * Only can be called by the admin (dPiggy contract).\\r\\n     * @param user User\\u0027s address. \\r\\n     * @return True if the user has some Dai deposited on the asset otherwise False. \\r\\n     */\\r\\n    function addEscrow(address user) nonReentrant onlyAdmin external override(DPiggyAssetInterface) returns(bool) {\\r\\n        UserData storage userData = usersData[user];\\r\\n        if (userData.currentAllocated \\u003e 0) {\\r\\n            _setEscrow(true, userData.currentAllocated);\\r\\n            \\r\\n            /* Whether the user deposited Dai after the last Compound redeem execution:\\r\\n             * The fee deduction calculated must be undone because with the Auc escrowed all user amount of Dai has fee exemption and it was set in other stored data.\\r\\n             * Also must be set the difference between the amount of Dai and the respective value normalized to the last Compound redeem execution time.\\r\\n             */\\r\\n            if (userData.baseExecutionId == executionId) {\\r\\n                \\r\\n                Execution storage lastExecution = executions[executionId];\\r\\n                uint256 amountWithFeeExemption = userData.baseExecutionAccumulatedAmount.sub(userData.baseExecutionAmountForFee);\\r\\n                uint256 currentNormalizedDifference = _getNormalizedDifference(amountWithFeeExemption, userData.baseExecutionAvgRate, lastExecution.rate);\\r\\n                uint256 allAmountNormalizedDifference = _getNormalizedDifference(userData.baseExecutionAccumulatedAmount, userData.baseExecutionAvgRate, lastExecution.rate);\\r\\n                \\r\\n                _setFeeExemptionForNextExecution(false, amountWithFeeExemption);\\r\\n                _setFeeExemptionNormalizedDifferenceForNextExecution(true, allAmountNormalizedDifference.sub(currentNormalizedDifference));\\r\\n                userData.baseExecutionAmountForFee = 0; \\r\\n            }\\r\\n            \\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to force redeem of the asset profit for the user address.\\r\\n     * Only can be called by the admin (dPiggy contract).\\r\\n     * @param user User\\u0027s address. \\r\\n     */\\r\\n    function forceRedeem(address user) nonReentrant onlyAdmin external {\\r\\n        _redeem(user, DPiggyInterface(admin).escrowStart(user));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to force finish of the user participation for the asset.\\r\\n     * The asset profit is redeemed as well as all the Dai deposited.\\r\\n     * Only can be called by the admin (dPiggy contract).\\r\\n     * @param user User\\u0027s address. \\r\\n     */\\r\\n    function forceFinish(address user) nonReentrant onlyAdmin external {\\r\\n        _finish(user);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to execute the Compound redeem.\\r\\n     * It is redeemed all Dai profit for the period: (total on Compound contract - total deposited).\\r\\n     * The fee is calculated over total Dai deposited minus:\\r\\n     *  - Amount of Dai of the users that has Auc escrowed.\\r\\n     *  - Proportional amount of Dai for users that deposited Dai between last execution and current execution. \\r\\n     *    The fee is charged only during the days that the Dai was invested, not all period.\\r\\n     * The amount of Dai for the fee is used to buy Auc on Uniswap and then the Auc is burned.\\r\\n     * So the remaining amount of Dai redeemed is used to buy the respective asset on Uniswap.\\r\\n     * The execution is general, not for a user, the distribution of profit to each user is calculated on redeem/finish functions.\\r\\n     */\\r\\n    function executeCompoundRedeem() nonReentrant external {\\r\\n        require(now \\u003e= getMinimumTimeForNextExecution(), \\\"DPiggyAsset::executeCompoundRedeem: Invalid time for execution\\\");\\r\\n        \\r\\n        Execution storage lastExecution = executions[executionId];\\r\\n        CompoundInterface _compound = CompoundInterface(DPiggyInterface(admin).compound());\\r\\n        \\r\\n        uint256 feeAmount = 0;\\r\\n        uint256 totalRedeemed = 0;\\r\\n        uint256 totalFeeDeduction = 0;\\r\\n        uint256 daiAmount = 0;\\r\\n        uint256 rate;\\r\\n        \\r\\n        //Whether there is no Dai deposited (totalBalance is zero) the execution still runs to register the basic data on the chain.\\r\\n        if (totalBalance \\u003e 0) {\\r\\n            \\r\\n            daiAmount = _compound.balanceOfUnderlying(address(this));\\r\\n            rate = _getRateForExecution(daiAmount, lastExecution);\\r\\n            \\r\\n            totalRedeemed = daiAmount.sub(totalBalance);\\r\\n            uint256 remainingProfit = 0;\\r\\n            if (isCompound) {\\r\\n                remainingProfit = _getRemainingExecutionProfit(lastExecution);\\r\\n                totalRedeemed = totalRedeemed.sub(remainingProfit);\\r\\n            }\\r\\n            \\r\\n            totalFeeDeduction = feeExemptionAmountForUserBaseData[(executionId+1)].add(feeExemptionAmountForAucEscrowed);\\r\\n            uint256 regardedAmountWithFee = totalBalance.sub(totalFeeDeduction);\\r\\n            if (regardedAmountWithFee \\u003e 0) {\\r\\n                \\r\\n                feeAmount = regardedAmountWithFee.mul(DPiggyInterface(admin).executionFee(now.sub(lastExecution.time))).div(DPiggyInterface(admin).percentagePrecision());\\r\\n                \\r\\n                // The maximum amount of fee must be lesser or equal to the total of Dai available after the redeemed and cannot ignore the interest generated for Dai with fee exemption.\\r\\n                if (totalFeeDeduction \\u003e 0) {\\r\\n                    uint256 amountNoFee = totalFeeDeduction.add(remainingProfit);\\r\\n                    uint256 feeExemptionAmountRate = amountNoFee.mul(lastExecution.rate).div(amountNoFee.sub(feeExemptionNormalizedDifference[(executionId+1)]));\\r\\n                    uint256 maxFeeAmount = totalRedeemed.sub(_calculatetAccruedInterest(amountNoFee, rate, feeExemptionAmountRate));\\r\\n                    \\r\\n                    if (feeAmount \\u003e maxFeeAmount) {\\r\\n                        feeAmount = maxFeeAmount;\\r\\n                    }\\r\\n                } else if (feeAmount \\u003e totalRedeemed) {\\r\\n                    feeAmount = totalRedeemed;\\r\\n                }\\r\\n            }\\r\\n            \\r\\n            //For Compound asset (cDai), the execution only redeems the fee amount because the cDai keeps invested on Compound contract.\\r\\n            if (isCompound) {\\r\\n                totalRedeemed = feeAmount;\\r\\n            }\\r\\n            \\r\\n            if (totalRedeemed \\u003e 0) {\\r\\n                _assertCompoundReturn(_compound.redeemUnderlying(totalRedeemed));\\r\\n            }\\r\\n        } else {\\r\\n            rate = lastExecution.rate;\\r\\n        }\\r\\n        \\r\\n        executionId++;\\r\\n        executions[executionId] = Execution({\\r\\n            time: now, \\r\\n            rate: rate,\\r\\n            totalDai: daiAmount,\\r\\n            totalRedeemed: totalRedeemed,\\r\\n            totalBought: 0,\\r\\n            totalBalance: totalBalance,\\r\\n            totalFeeDeduction: totalFeeDeduction,\\r\\n            feeAmount: feeAmount\\r\\n        });\\r\\n        \\r\\n        uint256 totalAucBurned = 0;\\r\\n        if (feeAmount \\u003e 0) {\\r\\n            totalAucBurned = _burnAuc(feeAmount);\\r\\n        }\\r\\n        \\r\\n        uint256 remainingAmount = totalRedeemed.sub(feeAmount);\\r\\n        Execution storage currentExecution = executions[executionId];\\r\\n        if (remainingAmount \\u003e 0) {\\r\\n            currentExecution.totalBought = _buy(remainingAmount, tokenAddress);\\r\\n        }\\r\\n        \\r\\n        emit CompoundRedeem(executionId, rate, totalBalance, totalRedeemed, feeAmount, currentExecution.totalBought, totalAucBurned);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to redeem the asset profit for the sender address.\\r\\n     */\\r\\n    function redeem() nonReentrant external {\\r\\n        _redeem(msg.sender, DPiggyInterface(admin).escrowStart(msg.sender));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to finish the sender\\u0027s participation for the asset.\\r\\n     * The asset profit is redeemed as well as all the Dai deposited.\\r\\n     */\\r\\n    function finish() nonReentrant external {\\r\\n       _finish(msg.sender);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to redeem the asset profit for the user.\\r\\n     * @param user User\\u0027s address. \\r\\n     * @param escrowStart The Unix time for user escrow start. Zero means no escrow. \\r\\n     */\\r\\n    function _redeem(address user, uint256 escrowStart) internal {\\r\\n        //There is no asset profit for Compound asset (cDai).\\r\\n        if (!isCompound) {\\r\\n            UserData storage userData = usersData[user];\\r\\n            (,uint256 previousAssetAmount,) = _getUserProfitsAndFeeAmount(escrowStart, userData);\\r\\n            if (previousAssetAmount \\u003e 0) { \\r\\n                uint256 amount = previousAssetAmount.sub(userData.redeemed);\\r\\n                if (amount \\u003e 0) {\\r\\n                    userData.redeemed = userData.redeemed.add(amount);\\r\\n                    if (tokenAddress != address(0)) {\\r\\n                        require(EIP20Interface(tokenAddress).transfer(user, amount), \\\"DPiggyAsset::redeem: Error on transfer\\\");\\r\\n                    } else {\\r\\n                        Address.toPayable(user).transfer(amount);\\r\\n                    }\\r\\n                    \\r\\n                    emit Redeem(user, amount);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to finish the user participation for the asset.\\r\\n     * The asset profit is redeemed as well as all the Dai deposited.\\r\\n     * It is executed a Compound redeem with total of Dai deposited plus the accrued interest since last Compound redeem execution.\\r\\n     * @param user User\\u0027s address. \\r\\n     */\\r\\n    function _finish(address user) internal {\\r\\n        UserData storage userData = usersData[user];\\r\\n        if (userData.currentAllocated \\u003e 0) {\\r\\n            uint256 escrowStart = DPiggyInterface(admin).escrowStart(user);\\r\\n            \\r\\n            _redeem(user, escrowStart);\\r\\n            \\r\\n            CompoundInterface _compound = CompoundInterface(DPiggyInterface(admin).compound());\\r\\n            \\r\\n            Execution storage lastExecution = executions[executionId];\\r\\n            uint256 currentRate = _getRateForExecution(_compound.balanceOfUnderlying(address(this)), lastExecution);\\r\\n            \\r\\n            uint256 userAccruedInterest; \\r\\n            if (isCompound) {\\r\\n                (uint256 executionsProfit,,uint256 feeAmount) = _getUserProfitsAndFeeAmount(escrowStart, userData);\\r\\n                userAccruedInterest = executionsProfit.sub(feeAmount);\\r\\n                \\r\\n                //Set the user accrued interest to be subtracted from the remaining balance on next Compound redeem execution. \\r\\n                remainingValueRedeemed[(executionId+1)] = remainingValueRedeemed[(executionId+1)].add(userAccruedInterest);\\r\\n                \\r\\n                userAccruedInterest = userAccruedInterest.add(_getAccruedInterestForExecution(executionId, currentRate, userAccruedInterest, userData));\\r\\n            } else {\\r\\n                userAccruedInterest = _getAccruedInterestForExecution(executionId, currentRate, 0, userData);\\r\\n            }\\r\\n            uint256 totalRedeemed = userData.currentAllocated.add(userAccruedInterest);\\r\\n            \\r\\n            _assertCompoundReturn(_compound.redeemUnderlying(totalRedeemed));\\r\\n            \\r\\n            require(EIP20Interface(DPiggyInterface(admin).dai()).transfer(user, totalRedeemed), \\\"DPiggyAsset::finish: Error on transfer Dai\\\");\\r\\n            \\r\\n            totalBalance = totalBalance.sub(userData.currentAllocated);\\r\\n            \\r\\n            // Whether the user did a deposit after the last Compound redeem execution the total balance normalized difference and fee related storages must be undone.\\r\\n            if (userData.baseExecutionId == executionId) {\\r\\n                uint256 normalizedDifference = _getNormalizedDifference(userData.baseExecutionAccumulatedAmount, userData.baseExecutionAvgRate, lastExecution.rate);\\r\\n                _setTotalBalanceNormalizedDifferenceForNextExecution(false, normalizedDifference);\\r\\n                \\r\\n                // Undo fee related storages.\\r\\n                if (escrowStart \\u003e 0) {\\r\\n                    _setFeeExemptionNormalizedDifferenceForNextExecution(false, normalizedDifference);\\r\\n                } else {\\r\\n                    uint256 amountWithFeeExemption = userData.baseExecutionAccumulatedAmount.sub(userData.baseExecutionAmountForFee);\\r\\n                    _setFeeExemptionForNextExecution(false, amountWithFeeExemption);\\r\\n                    _setFeeExemptionNormalizedDifferenceForNextExecution(false, _getNormalizedDifference(amountWithFeeExemption, userData.baseExecutionAvgRate, lastExecution.rate));\\r\\n                }\\r\\n            }\\r\\n            \\r\\n            // Whether the user has Auc escrowed the Dai must be undone on the stored control data.\\r\\n            if (escrowStart \\u003e 0) {\\r\\n                _setEscrow(false, userData.currentAllocated);\\r\\n            }    \\r\\n            \\r\\n            userData.baseExecutionId = 0;\\r\\n            userData.baseExecutionAvgRate = 0;\\r\\n            userData.baseExecutionAccumulatedAmount = 0;\\r\\n            userData.baseExecutionAccumulatedWeightForRate = 0;\\r\\n            userData.baseExecutionAmountForFee = 0;\\r\\n            userData.currentAllocated = 0;\\r\\n            userData.previousAllocated = 0;\\r\\n            userData.previousProfit = 0;\\r\\n            userData.previousAssetAmount = 0;\\r\\n            userData.previousFeeAmount = 0;\\r\\n            userData.redeemed = 0;\\r\\n        \\r\\n            emit Finish(user, totalRedeemed, userAccruedInterest, 0, 0);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the next Compound redeem execution fee proportion.\\r\\n     * The proportion is the relation between the fee for the full amount of days between the executions \\r\\n     * and the fee for the number of days considering starting now, not the last execution time.\\r\\n     * @param amount The amount of Dai to be calculated the proportion.\\r\\n     * @return The proportional amount for the fee on the next Compound redeem execution.\\r\\n     */\\r\\n    function _getNextExecutionFeeProportion(uint256 amount) internal view returns(uint256) {\\r\\n        uint256 nextExecution = getMinimumTimeForNextExecution();\\r\\n        if (nextExecution \\u003e now) {\\r\\n            Execution storage lastExecution = executions[executionId];\\r\\n            uint256 fullFee = DPiggyInterface(admin).executionFee(nextExecution.sub(lastExecution.time));\\r\\n            if (fullFee \\u003e 0) {\\r\\n                uint256 proportionalFee = DPiggyInterface(admin).executionFee(nextExecution.sub(now));\\r\\n                return proportionalFee.mul(amount).div(fullFee);\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the calculated rate.\\r\\n     * @param amount The amount of Dai.\\r\\n     * @param lastExecution The last Compound redeem execution data.\\r\\n     * @return The calculated rate for the execution.\\r\\n     */\\r\\n    function _getRateForExecution(uint256 amount, Execution storage lastExecution) internal view returns(uint256) {\\r\\n        uint256 remainingBalance = 0;\\r\\n        //Whether the asset is cDai then the net profit continues on Compound contract.\\r\\n        if (isCompound \\u0026\\u0026 lastExecution.totalDai \\u003e 0) {\\r\\n            remainingBalance = _getRemainingExecutionProfit(lastExecution);\\r\\n        }\\r\\n        return amount.mul(lastExecution.rate).div(totalBalance.add(remainingBalance).sub(totalBalanceNormalizedDifference[(executionId+1)]));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the remaining profit on the Compound contract from the last redeemed execution.\\r\\n     * @param lastExecution The last Compound redeem execution data.\\r\\n     * @return The remaining profit.\\r\\n     */\\r\\n    function _getRemainingExecutionProfit(Execution storage lastExecution) internal view returns(uint256) {\\r\\n        return lastExecution.totalDai.sub(lastExecution.totalBalance).sub(lastExecution.totalRedeemed).sub(remainingValueRedeemed[(executionId+1)]);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the user accrued interest for the Compound redeem execution.\\r\\n     * @param previousExecutionId The previous execution id.\\r\\n     * @param currentRate The rate for the current execution.\\r\\n     * @param compoundRemainingBalance Remaining balance of Dai on Compound.\\r\\n     * @param userData Stored data for the user.\\r\\n     * @return The user accrued interest in Dai.\\r\\n     */\\r\\n    function _getAccruedInterestForExecution(\\r\\n        uint256 previousExecutionId, \\r\\n        uint256 currentRate, \\r\\n        uint256 compoundRemainingBalance,\\r\\n        UserData storage userData\\r\\n    ) internal view returns(uint256) {\\r\\n        Execution storage previousExecution = executions[previousExecutionId];\\r\\n        uint256 userAccruedInterest;\\r\\n        \\r\\n        //Whether there is a deposit after the previous Compound redeem execution the base average rate must be used for the amount deposited.\\r\\n        if (userData.baseExecutionId == previousExecutionId) {\\r\\n            \\r\\n            userAccruedInterest = _calculatetAccruedInterest(userData.baseExecutionAccumulatedAmount, currentRate, userData.baseExecutionAvgRate);\\r\\n            \\r\\n            //Whether there is a previous accrued interest of Dai since the previous execution.\\r\\n            if (userData.previousAllocated \\u003e 0) {\\r\\n                userAccruedInterest = userAccruedInterest.add(_calculatetAccruedInterest(compoundRemainingBalance.add(userData.previousAllocated), currentRate, previousExecution.rate));\\r\\n            }\\r\\n        } else {\\r\\n            userAccruedInterest = _calculatetAccruedInterest(compoundRemainingBalance.add(userData.currentAllocated), currentRate, previousExecution.rate);\\r\\n        }\\r\\n        \\r\\n        return userAccruedInterest;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to calculate the accrued interest.\\r\\n     * @param amount The invested amount.\\r\\n     * @param currentRate The rate for the current execution.\\r\\n     * @param previousRate The rate for the previous execution.\\r\\n     * @return Tha accrued interest calculated.\\r\\n     */\\r\\n    function _calculatetAccruedInterest(\\r\\n        uint256 amount, \\r\\n        uint256 currentRate, \\r\\n        uint256 previousRate\\r\\n    ) internal pure returns(uint256) {\\r\\n        if (currentRate \\u003e previousRate) {\\r\\n            return amount.mul(currentRate).div(previousRate).sub(amount);\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the user asset net profit and the fee amount charged in Dai.\\r\\n     * @param escrowStart The Unix time for user escrow start. Zero means no escrow. \\r\\n     * @param userData Stored data for the user.\\r\\n     * @return The user\\u0027s Dai gross profit, asset net profit and the fee amount in Dai.\\r\\n     */\\r\\n    function _getUserProfitsAndFeeAmount(uint256 escrowStart, UserData storage userData) internal view returns(uint256, uint256, uint256) {\\r\\n        if (userData.currentAllocated \\u003e 0) {\\r\\n            uint256 accruedInterest = userData.previousProfit;\\r\\n            uint256 assetAmount = userData.previousAssetAmount;\\r\\n            uint256 feeAmount = userData.previousFeeAmount;\\r\\n            uint256 remainingBalance = 0;\\r\\n            if (isCompound) {\\r\\n                remainingBalance = accruedInterest.sub(feeAmount);\\r\\n            }\\r\\n            for (uint256 i = (userData.baseExecutionId+1); i \\u003c= executionId; i++) {\\r\\n                Execution storage execution = executions[i];\\r\\n                if (execution.totalDai \\u003e 0) {   \\r\\n                    \\r\\n                    uint256 userAccruedInterest = _getAccruedInterestForExecution(i - 1, execution.rate, remainingBalance, userData);\\r\\n                    \\r\\n                    accruedInterest = accruedInterest.add(userAccruedInterest);            \\r\\n                    \\r\\n                    uint256 userFeeAmount = 0;\\r\\n                    //Whether there is no Auc escrowed and the execution had a fee.\\r\\n                    if ((escrowStart == 0 || escrowStart \\u003e execution.time) \\u0026\\u0026 execution.feeAmount \\u003e 0) {\\r\\n                        userFeeAmount = _getFeeAmountForExecution((userData.baseExecutionId+1) == i, execution.feeAmount, execution.totalBalance.sub(execution.totalFeeDeduction), userData);\\r\\n                        \\r\\n                        //The maximum amount of fee must be lesser or equal to the user\\u0027s accrued interest.\\r\\n                        if (userFeeAmount \\u003e userAccruedInterest) {\\r\\n                            userFeeAmount = userAccruedInterest;\\r\\n                        }\\r\\n                        feeAmount = feeAmount.add(userFeeAmount);\\r\\n                    }\\r\\n                    \\r\\n                    //Whether the asset is cDai then the net profit continues on Compound contract.\\r\\n                    if (isCompound) {\\r\\n                        remainingBalance = remainingBalance.add(userAccruedInterest.sub(userFeeAmount));\\r\\n                    }\\r\\n                    \\r\\n                    if (execution.totalBought \\u003e 0) {\\r\\n                        assetAmount = assetAmount.add(userAccruedInterest.sub(userFeeAmount).mul(execution.totalBought).div(execution.totalRedeemed.sub(execution.feeAmount)));\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            return (accruedInterest, assetAmount, feeAmount);\\r\\n        } else {\\r\\n            return (0, 0, 0);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the user fee amount in Dai for the execution.\\r\\n     * @param isBaseMonth Whether it is the month just after the user deposit.\\r\\n     * @param multiplier Multiplier value on the calculation. \\r\\n     * @param denominator Denominator value on the calculation.  \\r\\n     * @param userData Stored data for the user.\\r\\n     * @return The fee amount in Dai.\\r\\n     */\\r\\n    function _getFeeAmountForExecution(\\r\\n        bool isBaseMonth,\\r\\n        uint256 multiplier,\\r\\n        uint256 denominator,\\r\\n        UserData storage userData\\r\\n    ) internal view returns(uint256) {\\r\\n        uint256 regardedAmountWithFee;\\r\\n        \\r\\n        if (isBaseMonth) {\\r\\n            regardedAmountWithFee = userData.previousAllocated.add(userData.baseExecutionAmountForFee);\\r\\n        } else {\\r\\n            regardedAmountWithFee = userData.currentAllocated;\\r\\n        }\\r\\n        \\r\\n        return regardedAmountWithFee.mul(multiplier).div(denominator); \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set an amount of Dai that has fee exemption on the next Compound redeem execution.\\r\\n     * @param commit Whether it is adding the fee exemption.\\r\\n     * @param amount The amount of Dai with fee exemption.\\r\\n     */\\r\\n    function _setFeeExemptionForNextExecution(bool commit, uint256 amount) internal {\\r\\n        if (amount \\u003e 0) {\\r\\n            uint256 nextExecution = executionId + 1;\\r\\n            if (commit) {\\r\\n                feeExemptionAmountForUserBaseData[nextExecution] = feeExemptionAmountForUserBaseData[nextExecution].add(amount);\\r\\n            } else {\\r\\n                feeExemptionAmountForUserBaseData[nextExecution] = feeExemptionAmountForUserBaseData[nextExecution].sub(amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the difference between the amount of Dai and the respective value normalized to the last Compound redeem execution time.\\r\\n     * @param totalAmount The total amount of Dai to be normalized.\\r\\n     * @param currentRate The current rate.\\r\\n     * @param previousRate The previous rate.\\r\\n     * @return The difference between the amount of Dai and the respective value normalized to the last Compound redeem execution time.\\r\\n     */\\r\\n    function _getNormalizedDifference(\\r\\n        uint256 totalAmount,\\r\\n        uint256 currentRate,\\r\\n        uint256 previousRate\\r\\n    ) internal pure returns(uint256) {\\r\\n        if (currentRate \\u003e previousRate) {\\r\\n            return totalAmount.sub(totalAmount.mul(previousRate).div(currentRate));\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the difference between the amount of Dai with fee exemption and the respective value normalized to the last Compound redeem execution time.\\r\\n     * @param commit Whether it is adding the difference for next Compound redeem execution.\\r\\n     * @param normalizedDifference The difference between the amount of Dai with fee exemption and the respective value normalized to the last Compound redeem execution time.\\r\\n     */\\r\\n    function _setFeeExemptionNormalizedDifferenceForNextExecution(\\r\\n        bool commit, \\r\\n        uint256 normalizedDifference\\r\\n    ) internal {\\r\\n        uint256 nextExecution = executionId + 1;\\r\\n        if (commit) {\\r\\n            feeExemptionNormalizedDifference[nextExecution] = feeExemptionNormalizedDifference[nextExecution].add(normalizedDifference);\\r\\n        } else {\\r\\n            feeExemptionNormalizedDifference[nextExecution] = feeExemptionNormalizedDifference[nextExecution].sub(normalizedDifference);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the difference between the amount of Dai deposited and the respective value normalized to the last Compound redeem execution time.\\r\\n     * @param commit Whether it is adding the difference for next Compound redeem execution.\\r\\n     * @param normalizedDifference The difference between the amount of Dai deposited and the respective value normalized to the last Compound redeem execution time.\\r\\n     */\\r\\n    function _setTotalBalanceNormalizedDifferenceForNextExecution(\\r\\n        bool commit, \\r\\n        uint256 normalizedDifference\\r\\n    ) internal {\\r\\n        uint256 nextExecution = executionId + 1;\\r\\n        if (commit) {\\r\\n            totalBalanceNormalizedDifference[nextExecution] = totalBalanceNormalizedDifference[nextExecution].add(normalizedDifference);\\r\\n        } else {\\r\\n            totalBalanceNormalizedDifference[nextExecution] = totalBalanceNormalizedDifference[nextExecution].sub(normalizedDifference);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set an amount of Dai that has fee exemption due to Auc escrowed.\\r\\n     * @param commit Whether it is adding the fee exemption.\\r\\n     * @param amount The amount of Dai with fee exemption.\\r\\n     */\\r\\n    function _setEscrow(bool commit, uint256 amount) internal {\\r\\n        if (commit) {\\r\\n            feeExemptionAmountForAucEscrowed = feeExemptionAmountForAucEscrowed.add(amount);\\r\\n        } else {\\r\\n            feeExemptionAmountForAucEscrowed = feeExemptionAmountForAucEscrowed.sub(amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to buy an asset on Uniswap.\\r\\n     * @param _tokenAddress The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum that should be purchased.\\r\\n     * @param amount The amount of Dai to buy the asset.\\r\\n     * @return The total amount of asset purchased.\\r\\n     */\\r\\n    function _buy(uint256 amount, address _tokenAddress) internal returns(uint256) {\\r\\n        address _exchange = DPiggyInterface(admin).exchange();\\r\\n        uint256 deadline = now + 86400;\\r\\n        require(EIP20Interface(DPiggyInterface(admin).dai()).approve(_exchange, amount), \\\"DPiggyAsset::_buy: Error on approve UniswapExchange\\\");\\r\\n        if (_tokenAddress != address(0)) {\\r\\n            return UniswapExchangeInterface(_exchange).tokenToTokenSwapInput(amount, 1, 1, deadline, _tokenAddress);\\r\\n        } else {\\r\\n            return UniswapExchangeInterface(_exchange).tokenToEthSwapInput(amount, 1, deadline);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to buy and then burn the Auc.\\r\\n     * @param amount The amount of Dai. It is the fee amount on the Compound redeem execution.\\r\\n     * @return The total amount of Auc burned.\\r\\n     */\\r\\n    function _burnAuc(uint256 amount) internal returns(uint256) {\\r\\n        address _auc = DPiggyInterface(admin).auc();\\r\\n        uint256 totalBought = _buy(amount, _auc);\\r\\n        require(AucInterface(_auc).burn(totalBought), \\\"DPiggyAsset::_burnAuc: Error on burn AUC\\\");\\r\\n        return totalBought;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to assert Compound return.\\r\\n     * @param compoundReturn The Compound return.\\r\\n     */\\r\\n    function _assertCompoundReturn(uint256 compoundReturn) internal pure {\\r\\n        require(compoundReturn == 0, _getCompoundError(compoundReturn));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get Compound error.\\r\\n     * @param compoundReturn The Compound return.\\r\\n     * @return Error message.\\r\\n     */\\r\\n    function _getCompoundError(uint256 compoundReturn) internal pure returns(string memory) {\\r\\n        uint256 i = compoundReturn;\\r\\n        uint256 length;\\r\\n        while (i != 0) {\\r\\n            length++;\\r\\n            i /= 10;\\r\\n        }\\r\\n        bytes memory errorCode = new bytes(length);\\r\\n        uint256 j = length - 1;\\r\\n        while (compoundReturn != 0) {\\r\\n            errorCode[j--] = byte(uint8(48 + compoundReturn % 10));\\r\\n            compoundReturn /= 10;\\r\\n        }\\r\\n        return string(abi.encodePacked(\\\"Compound error \\\", string(errorCode)));\\r\\n    }\\r\\n    \\r\\n    /******************************************************\\r\\n     * @dev Functions to get data from previous contract. *\\r\\n     ******************************************************/\\r\\n     \\r\\n    function _getContractUint256(address _contract, bytes memory data) internal view returns(uint256) {\\r\\n        bytes memory returnData = _getData(_contract, data);\\r\\n        return abi.decode(returnData, (uint256));\\r\\n    }\\r\\n    \\r\\n    function _getContractAddress(address _contract, bytes memory data) internal view returns(address) {\\r\\n        bytes memory returnData = _getData(_contract, data);\\r\\n        return abi.decode(returnData, (address));\\r\\n    }\\r\\n    \\r\\n    function _getContractBool(address _contract, bytes memory data) internal view returns(bool) {\\r\\n        bytes memory returnData = _getData(_contract, data);\\r\\n        return abi.decode(returnData, (bool));\\r\\n    }\\r\\n    \\r\\n    function _getContractExecution(address _contract, bytes memory data) internal view returns(Execution memory) {\\r\\n        bytes memory returnData = _getData(_contract, data);\\r\\n        uint256[] memory executionData = _getUint256Array(returnData);\\r\\n        return Execution({\\r\\n            time: executionData[0],\\r\\n            rate: executionData[1],\\r\\n            totalDai: executionData[2],\\r\\n            totalRedeemed: executionData[3],\\r\\n            totalBought: executionData[4],\\r\\n            totalBalance: executionData[5],\\r\\n            totalFeeDeduction: executionData[6],\\r\\n            feeAmount: executionData[7]\\r\\n        });\\r\\n    }\\r\\n    \\r\\n    function _getContractUserData(address _contract, bytes memory data) internal view returns(UserData memory) {\\r\\n        bytes memory returnData = _getData(_contract, data);\\r\\n        uint256[] memory userData = _getUint256Array(returnData);\\r\\n        return UserData({\\r\\n            baseExecutionId: userData[0],\\r\\n            baseExecutionAvgRate: userData[1],\\r\\n            baseExecutionAccumulatedAmount: userData[2],\\r\\n            baseExecutionAccumulatedWeightForRate: userData[3],\\r\\n            baseExecutionAmountForFee: userData[4],\\r\\n            currentAllocated: userData[5],\\r\\n            previousAllocated: userData[6],\\r\\n            previousProfit: userData[7],\\r\\n            previousAssetAmount: userData[8],\\r\\n            previousFeeAmount: userData[9],\\r\\n            redeemed: userData[10]\\r\\n        });\\r\\n    }\\r\\n    \\r\\n    function _getData(address _contract, bytes memory data) internal view returns(bytes memory) {\\r\\n        (bool success, bytes memory returnData) = _contract.staticcall(data);\\r\\n        assert(success); \\r\\n        return returnData;\\r\\n    }\\r\\n    \\r\\n    function _getUint256Array(bytes memory data) internal pure returns(uint256[] memory) {\\r\\n        uint256 size = data.length / 32;\\r\\n        uint256[] memory returnUint = new uint256[](size);\\r\\n        uint256 offset = 0;\\r\\n        for (uint256 i = 0; i \\u003c size; ++i) {\\r\\n            bytes32 number;\\r\\n            for (uint256 j = 0; j \\u003c 32; j++) {\\r\\n                number |= bytes32(data[offset + j] \\u0026 0xFF) \\u003e\\u003e (j * 8);\\r\\n            }\\r\\n            returnUint[i] = uint256(number);\\r\\n            offset += 32;\\r\\n        }\\r\\n        return returnUint;\\r\\n    }\\r\\n}\\r\\n\"},\"DPiggyAssetData.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\nimport \\\"DPiggyBaseProxyData.sol\\\";\\r\\nimport \\\"ReentrancyGuard.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DPiggyAssetData\\r\\n * @dev Contract for all dPiggy asset stored data.\\r\\n * It must inherit from DPiggyBaseProxyData contract for properly generate the proxy.\\r\\n * Each dPiggy asset has your own DPiggyAssetData.\\r\\n */\\r\\ncontract DPiggyAssetData is DPiggyBaseProxyData, ReentrancyGuard {\\r\\n    \\r\\n    /**\\r\\n     * @dev The Struct to store each Compound redeem execution data.\\r\\n     */\\r\\n    struct Execution {\\r\\n        /**\\r\\n         * @dev The time in Unix.\\r\\n         */\\r\\n        uint256 time;\\r\\n        \\r\\n        /**\\r\\n         * @dev The calculated rate based on Dai amount variation on Compound.\\r\\n         */\\r\\n        uint256 rate;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total amount of Dai on Compound.\\r\\n         */\\r\\n        uint256 totalDai;\\r\\n        \\r\\n        /**\\r\\n         * @dev The amount of Dai redeemed on Compound.\\r\\n         */\\r\\n        uint256 totalRedeemed;\\r\\n        \\r\\n        /**\\r\\n         * @dev The amount of asset purchased.\\r\\n         */\\r\\n        uint256 totalBought;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai deposited on the contract.\\r\\n         */\\r\\n        uint256 totalBalance;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai with fee exemption.\\r\\n         */\\r\\n        uint256 totalFeeDeduction;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai redeemed that was regarded as the fee.\\r\\n         */\\r\\n        uint256 feeAmount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev The Struct to store the user data.\\r\\n     */\\r\\n    struct UserData {\\r\\n        /**\\r\\n         * @dev The last execution Id on deposit.\\r\\n         */\\r\\n        uint256 baseExecutionId;\\r\\n        \\r\\n        /**\\r\\n         * @dev The rate on deposit.\\r\\n         * The value is the weighted average of all deposit rates with the same base execution Id.\\r\\n         * It is used to calculate the user\\u0027s corresponding profit on the next Compound redeem execution (baseExecutionId + 1).\\r\\n         */\\r\\n        uint256 baseExecutionAvgRate;\\r\\n        \\r\\n        /**\\r\\n         * @dev The amount of Dai on deposit.\\r\\n         * The value is the amount of Dai accumulated of all deposits with the same base execution Id.\\r\\n         */\\r\\n        uint256 baseExecutionAccumulatedAmount;\\r\\n        \\r\\n        /**\\r\\n         * @dev The accumulated weight for the rate calculation.\\r\\n         * The value is auxiliary for the base execution rate calculation for all deposits with the same base execution Id.\\r\\n         */\\r\\n        uint256 baseExecutionAccumulatedWeightForRate;\\r\\n        \\r\\n        /**\\r\\n         * @dev The amount of Dai that will be applied the fee on the next Compound redeem execution (baseExecutionId + 1).\\r\\n         */\\r\\n        uint256 baseExecutionAmountForFee;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai deposited.\\r\\n         */\\r\\n        uint256 currentAllocated;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total of Dai previously deposited before the regarded deposit.\\r\\n         * The deposits are regarded the same if they have the same base execution Id.\\r\\n         */\\r\\n        uint256 previousAllocated;\\r\\n        \\r\\n        /**\\r\\n         * @dev The previous Dai profit before the regarded deposit.\\r\\n         * The deposits are regarded the same if they have the same base execution Id.\\r\\n         */\\r\\n        uint256 previousProfit;\\r\\n        \\r\\n        /**\\r\\n         * @dev The previous asset amount before the regarded deposit.\\r\\n         * The deposits are regarded the same if they have the same base execution Id.\\r\\n         */\\r\\n        uint256 previousAssetAmount;\\r\\n        \\r\\n        /**\\r\\n         * @dev The previous fee on Dai before the regarded deposit.\\r\\n         * The deposits are regarded the same if they have the same base execution Id.\\r\\n         */\\r\\n        uint256 previousFeeAmount;\\r\\n        \\r\\n        /**\\r\\n         * @dev The total amount of asset redeemed.\\r\\n         */\\r\\n        uint256 redeemed;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the minimum time between Compound redeem executions has been changed.\\r\\n     * @param newTime The new minimum time between Compound redeem executions.\\r\\n     * @param oldTime The previous minimum time between Compound redeem executions.\\r\\n     */\\r\\n    event SetMinimumTimeBetweenExecutions(uint256 newTime, uint256 oldTime);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a user has deposited Dai on the contract.\\r\\n     * @param user The user\\u0027s address.\\r\\n     * @param amount The amount of Dai deposited.\\r\\n     * @param rate The calculated rate.\\r\\n     * @param baseExecutionId The last Compound redeem execution Id.\\r\\n     * @param baseExecutionAmountForFee The amount of Dai that will be applied the fee on the next Compound redeem execution (baseExecutionId + 1).\\r\\n     */\\r\\n    event Deposit(address indexed user, uint256 amount, uint256 rate, uint256 baseExecutionId, uint256 baseExecutionAmountForFee);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a user has redeemed the asset profit on the contract.\\r\\n     * @param user The user\\u0027s address.\\r\\n     * @param amount The amount of asset redeemed.\\r\\n     */\\r\\n    event Redeem(address indexed user, uint256 amount);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a Compound redeem has been executed.\\r\\n     * @param executionId The respective Id.\\r\\n     * @param rate The calculated rate.\\r\\n     * @param totalBalance The total of Dai deposited on the contract.\\r\\n     * @param totalRedeemed The amount of Dai redeemed on Compound.\\r\\n     * @param fee The total of Dai redeemed that was regarded as the fee.\\r\\n     * @param totalBought The amount of asset purchased.\\r\\n     * @param totalAucBurned The amount of Auc purchased and burned with the fee.\\r\\n     */\\r\\n    event CompoundRedeem(uint256 indexed executionId, uint256 rate, uint256 totalBalance, uint256 totalRedeemed, uint256 fee, uint256 totalBought, uint256 totalAucBurned);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a user has finished the own participation on the dPiggy asset.\\r\\n     * All asset profit is redeemed as well as all the Dai deposited. \\r\\n     * @param user The user\\u0027s address.\\r\\n     * @param totalRedeemed The amount of Dai redeemed on Compound.\\r\\n     * @param yield The user yield in Dai redeemed since the last Compound redeem execution.\\r\\n     * @param fee The total of Dai redeemed that was regarded as the fee.\\r\\n     * @param totalAucBurned The amount of Auc purchased and burned with the fee.\\r\\n     */\\r\\n    event Finish(address indexed user, uint256 totalRedeemed, uint256 yield, uint256 fee, uint256 totalAucBurned);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the contract is initialized with a previous data due to a proxy migration.\\r\\n     * @param previousContract The previous contract address.\\r\\n     */\\r\\n    event SetMigration(address previousContract);\\r\\n\\r\\n    /**\\r\\n     * @dev The ERC20 token address on the chain or \\u00270x0\\u0027 for Ethereum. \\r\\n     * It is the asset for the respective contract. \\r\\n     */\\r\\n    address public tokenAddress;\\r\\n    \\r\\n    /**\\r\\n     * @dev Minimum time in seconds between executions to run the Compound redeem.\\r\\n     */\\r\\n    uint256 public minimumTimeBetweenExecutions;\\r\\n    \\r\\n    /**\\r\\n     * @dev Last Compound redeem execution Id (it is an incremental number).\\r\\n     */\\r\\n    uint256 public executionId;\\r\\n    \\r\\n    /**\\r\\n     * @dev The total balance of Dai deposited.\\r\\n     */\\r\\n    uint256 public totalBalance;\\r\\n    \\r\\n    /**\\r\\n     * @dev The amount of deposited Dai that has a fee exemption due to the Auc escrowed.\\r\\n     */\\r\\n    uint256 public feeExemptionAmountForAucEscrowed;\\r\\n    \\r\\n    /**\\r\\n     * @dev It indicates if the contract asset is the cDai.\\r\\n     */\\r\\n    bool public isCompound;\\r\\n    \\r\\n    /**\\r\\n     * @dev The difference between the amount of Dai deposited and the respective value normalized to the last Compound redeem execution time.\\r\\n     * _key is the execution Id.\\r\\n     * _value is the difference of Dai.\\r\\n     */\\r\\n    mapping(uint256 =\\u003e uint256) public totalBalanceNormalizedDifference;\\r\\n    \\r\\n    /**\\r\\n     * @dev The difference between the amount of Dai with fee exemption and the respective value normalized to the last Compound redeem execution time.\\r\\n     * _key is the execution Id.\\r\\n     * _value is the difference of Dai.\\r\\n     */\\r\\n    mapping(uint256 =\\u003e uint256) public feeExemptionNormalizedDifference;\\r\\n    \\r\\n    /**\\r\\n     * @dev The remaining profit redeemed from Compound.\\r\\n     * Used on Compound asset to adjust the remaining value on the contract between executions.\\r\\n     * _key is the execution Id.\\r\\n     * _value is the redeemed value.\\r\\n     */\\r\\n    mapping(uint256 =\\u003e uint256) public remainingValueRedeemed;\\r\\n    \\r\\n    /**\\r\\n     * @dev The amount of Dai that has a fee exemption for the respective execution due to the user deposit time.\\r\\n     * _key is the execution Id.\\r\\n     * _value is the amount of Dai.\\r\\n     * The user amount of Dai proportion is calculated based on the difference between the deposit time and the next execution time.\\r\\n     */\\r\\n    mapping(uint256 =\\u003e uint256) public feeExemptionAmountForUserBaseData;\\r\\n    \\r\\n    /**\\r\\n     * @dev The Compound redeem executions data.\\r\\n     * _key is the execution Id.\\r\\n     * _value is the execution data.\\r\\n     */\\r\\n    mapping(uint256 =\\u003e Execution) public executions;\\r\\n    \\r\\n    /**\\r\\n     * @dev The user data for the asset.\\r\\n     * _key is the user address.\\r\\n     * _value is the user data.\\r\\n     */\\r\\n    mapping(address =\\u003e UserData) public usersData;\\r\\n}\\r\\n\"},\"DPiggyAssetInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title DPiggyAssetInterface\\r\\n * @dev DPiggyAsset interface for external functions used directly on dPiggy.\\r\\n */\\r\\ninterface DPiggyAssetInterface {\\r\\n    function getUserProfitsAndFeeAmount(address user) external view returns(uint256, uint256, uint256);\\r\\n    function setMinimumTimeBetweenExecutions(uint256 time) external;\\r\\n    function deposit(address user, uint256 amount) external;\\r\\n    function addEscrow(address user) external returns(bool);\\r\\n}\"},\"DPiggyBaseProxyData.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title DPiggyBaseProxyData\\r\\n * @dev Contract for all DPiggyBaseProxyData stored data.\\r\\n */\\r\\ncontract DPiggyBaseProxyData {\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the proxy implementation has been changed.\\r\\n     * @param newImplementation Address of the new proxy implementation.\\r\\n     * @param oldImplementation Address of the previous proxy implementation.\\r\\n     */\\r\\n    event SetProxyImplementation(address indexed newImplementation, address oldImplementation);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the admin address has been changed.\\r\\n     * @param newAdmin Address of the new admin.\\r\\n     * @param oldAdmin Address of the previous admin.\\r\\n     */\\r\\n    event SetProxyAdmin(address indexed newAdmin, address oldAdmin);\\r\\n    \\r\\n    /**\\r\\n     * @dev Modifier to check if the `msg.sender` is the admin.\\r\\n     * Only admin address can execute.\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev The contract address of the implementation.\\r\\n     */\\r\\n    address public implementation;\\r\\n    \\r\\n    /**\\r\\n     * @dev The admin address.\\r\\n     */\\r\\n    address public admin;\\r\\n}\\r\\n\"},\"DPiggyInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title DPiggyDataInterface\\r\\n * @dev DPiggyData interface with stored data used by other contracts.\\r\\n */\\r\\ninterface DPiggyDataInterface {\\r\\n    function auc() external view returns(address);\\r\\n    function dai() external view returns(address);\\r\\n    function compound() external view returns(address);\\r\\n    function exchange() external view returns(address);\\r\\n    function percentagePrecision() external view returns(uint256);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title DPiggyInterface\\r\\n * @dev DPiggy interface with stored data and functions used by other contracts.\\r\\n */\\r\\ninterface DPiggyInterface is DPiggyDataInterface {\\r\\n    function executionFee(uint256 baseTime) external view returns(uint256);\\r\\n    function escrowStart(address user) external view returns(uint256);\\r\\n}\"},\"EIP20Interface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title EIP20Interface\\r\\n * @dev EIP 20 token contract interface.\\r\\n */\\r\\ninterface EIP20Interface {\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function totalSupply() external view returns(uint256);\\r\\n    function balanceOf(address owner) external view returns(uint256);\\r\\n    function allowance(address owner, address spender) external view returns(uint256);\\r\\n    function approve(address usr, uint amount) external returns(bool);\\r\\n    function transfer(address dst, uint256 amount) external returns(bool);\\r\\n    function transferFrom(address src, address dst, uint amount) external returns(bool);\\r\\n    \\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title ReentrancyGuard\\r\\n * @dev Base contract with a modifier that implements a reentrancy guard.\\r\\n */\\r\\ncontract ReentrancyGuard {\\r\\n    /**\\r\\n     * @dev Internal data to control the reentrancy.\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"ReentrancyGuard:: reentry\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n// OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol \\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"UniswapExchangeInterface.sol\":{\"content\":\"pragma solidity ^0.6.4;\\r\\n\\r\\n/**\\r\\n * @title UniswapExchangeInterface\\r\\n * @dev Uniswap exchange interface.\\r\\n * https://docs.uniswap.io/smart-contract-api/exchange\\r\\n */\\r\\ninterface UniswapExchangeInterface {\\r\\n    // Address of ERC20 token sold on this exchange\\r\\n    function tokenAddress() external view returns (address token);\\r\\n    // Address of Uniswap Factory\\r\\n    function factoryAddress() external view returns (address factory);\\r\\n    // Provide Liquidity\\r\\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\\r\\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\\r\\n    // Get Prices\\r\\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\\r\\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\\r\\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\\r\\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\\r\\n    // Trade ETH to ERC20\\r\\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\\r\\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\\r\\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\\r\\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\\r\\n    // Trade ERC20 to ETH\\r\\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\\r\\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\\r\\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\\r\\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\\r\\n    // Trade ERC20 to ERC20\\r\\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\\r\\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\\r\\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\\r\\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\\r\\n    // Trade ERC20 to Custom Pool\\r\\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\\r\\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\\r\\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\\r\\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\\r\\n    // ERC20 comaptibility for liquidity tokens\\r\\n    function transfer(address _to, uint256 _value) external returns (bool);\\r\\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\\r\\n    function approve(address _spender, uint256 _value) external returns (bool);\\r\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    // Never use\\r\\n    function setup(address token_addr) external;\\r\\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalRedeemed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAucBurned\",\"type\":\"uint256\"}],\"name\":\"CompoundRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseExecutionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseExecutionAmountForFee\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalRedeemed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yield\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAucBurned\",\"type\":\"uint256\"}],\"name\":\"Finish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousContract\",\"type\":\"address\"}],\"name\":\"SetMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTime\",\"type\":\"uint256\"}],\"name\":\"SetMinimumTimeBetweenExecutions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"SetProxyAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"}],\"name\":\"SetProxyImplementation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addEscrow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeCompoundRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"executions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRedeemed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBought\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFeeDeduction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeExemptionAmountForAucEscrowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeExemptionAmountForUserBaseData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeExemptionNormalizedDifference\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"forceFinish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"forceRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumTimeForNextExecution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserAssetRedeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"getUserEstimatedCurrentFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserEstimatedCurrentProfitWithoutFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserProfitsAndFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTotalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumTimeBetweenExecutions\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"previousContract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"initMigratingData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCompound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTimeBetweenExecutions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remainingValueRedeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setMinimumTimeBetweenExecutions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalBalanceNormalizedDifference\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseExecutionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseExecutionAvgRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseExecutionAccumulatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseExecutionAccumulatedWeightForRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseExecutionAmountForFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentAllocated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousAllocated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousProfit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DPiggyAsset","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://ca9a88e49c7a5c00d602764ea1b723f0bed09d6d78236916e451193d1840c3fb"}]}