{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\n/* Beta - Do not use! \r\n * This is a mainnet launch of a beta contract, used\r\n * to test integration with other mainnet assets. \r\n * Use as own risk - david@hashtables.net\r\n */\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns(uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns(uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns(uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns(uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns(uint);\r\n    function balanceOf(address tokenOwner) public view returns(uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns(uint remaining);\r\n    function transfer(address to, uint tokens) public returns(bool success);\r\n    function approve(address spender, uint tokens) public returns(bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns(bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract TimeLock {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Deposit {\r\n        address tokenAddress;\r\n        uint depositTime;\r\n        uint tokenAmount;\r\n        uint freezeDuration;\r\n    }\r\n\r\n    mapping (address => uint) public tokensFrozen;\r\n    mapping (address => Deposit[]) public deposits;\r\n\r\n    uint defaultFreezeDuration = 5 minutes;\r\n\r\n    event TokensFrozen (\r\n        address indexed userAddress,\r\n        address indexed tokenAddress,\r\n        uint freezeIndex,\r\n        uint depositTime,\r\n        uint tokenAmount,\r\n        uint freezeDuration\r\n\t);\r\n\r\n    event TokensUnfrozen (\r\n        address indexed userAddress,\r\n        address indexed tokenAddress,\r\n        uint freezeIndex,\r\n        uint depositTime,\r\n        uint tokenAmount,\r\n        uint freezeDuration\r\n\t);\r\n\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    // This is the deposit/freeze function. You call the original token contract and it has a callback to this function.\r\n    // For this reason, this contract cannot accept direct deposits of tokens, so please do not send them here. \r\n    // See documentation for more detais. \r\n    function receiveApproval(address _sender, uint256 _value, address _tokenContract, bytes memory _extraData) public {\r\n        require(_value > 0, \"Error: Value must be > 0\");\r\n\r\n        // Once approved, transferFrom users wallet to ours. Calculate prior balance, and new balance to account for deflationary tokens.\r\n        uint _oldBalance = ERC20Interface(_tokenContract).balanceOf(address(this));\r\n        require(ERC20Interface(_tokenContract).transferFrom(_sender, address(this), _value), \"Could not transfer tokens to Time Lock contract address.\");\r\n        uint _newBalance = ERC20Interface(_tokenContract).balanceOf(address(this));\r\n        uint _balanceDiff = _newBalance.sub(_oldBalance); \r\n        uint _tokenAmount = _balanceDiff; //_balanceDiff; \r\n        \r\n        uint _freezeDuration = defaultFreezeDuration;\r\n        uint _freezeIndex = deposits[_sender].length;\r\n\r\n        if(deposits[_sender].length < 1) deposits[_sender];\r\n        \r\n        Deposit memory deposit;\r\n        deposit.tokenAddress = _tokenContract;\r\n        deposit.depositTime = now;\r\n        deposit.tokenAmount = _tokenAmount;\r\n        deposit.freezeDuration = _freezeDuration;\r\n        deposits[_sender].push(deposit);\r\n        \r\n        tokensFrozen[_tokenContract] += _tokenAmount; // Update global stats for token.\r\n\r\n        emit TokensFrozen(_sender, _tokenContract, _freezeIndex, now, _tokenAmount, _freezeDuration);\r\n    }\r\n\r\n    function addFreezeTime(uint _freezeIndex, uint _timeToAdd) public {\r\n        require(deposits[msg.sender][_freezeIndex].tokenAmount > 0, \"You do not have enough tokens!\");\r\n        deposits[msg.sender][_freezeIndex].freezeDuration += _timeToAdd;\r\n//        emit TokensFrozen(msg.sender, deposit.tokenAddress, _freezeIndex, now, deposit.tokenAmount, deposit.freezeDuration);\r\n    }\r\n\r\n    function unfreeze(uint _freezeIndex) public {\r\n        Deposit memory deposit = deposits[msg.sender][_freezeIndex];\r\n        //require(deposit, \"Deposit not found!\");\r\n        require(deposit.tokenAmount > 0, \"You do not have enough tokens!\");\r\n        require(now >= deposit.depositTime.add(deposit.freezeDuration), \"Tokens are locked!\");\r\n        require(_freezeIndex < deposits[msg.sender].length, \"Could not find any freeze at index provided during. Aborting removal of index.\");\r\n        require(tokensFrozen[deposit.tokenAddress] >= deposit.tokenAmount);\r\n        require(ERC20Interface(deposit.tokenAddress).transfer(msg.sender, deposit.tokenAmount), \"Could not withdraw token!\");\r\n\r\n        tokensFrozen[deposit.tokenAddress] -= deposit.tokenAmount; // Update global stats for token.\r\n        \r\n        for (uint i = _freezeIndex; i<deposits[msg.sender].length-1; i++){\r\n            deposits[msg.sender][i] = deposits[msg.sender][i+1];\r\n        }\r\n        deposits[msg.sender].length--;\r\n    \r\n        emit TokensUnfrozen(msg.sender, deposit.tokenAddress, _freezeIndex, now, deposit.tokenAmount, deposit.freezeDuration);\r\n    }\r\n    \r\n    function getDepositCount(address _addr) public view returns (uint256 _freezeCount) {\r\n        return deposits[_addr].length;\r\n    }\r\n\r\n    function getDepositByID(address _addr, uint _freezeIndex) public view returns (\r\n        address _userAddress,\r\n        address _tokenAddress,\r\n        uint _depositTime,\r\n        uint _tokenAmount,\r\n        uint _freezeDuration\r\n    ) {\r\n        Deposit memory deposit = deposits[_addr][_freezeIndex];\r\n        \r\n        return (_addr,\r\n            deposit.tokenAddress,\r\n            deposit.depositTime,\r\n            deposit.tokenAmount,\r\n            deposit.freezeDuration\r\n        );\r\n    }\r\n\r\n    function getTokenCount(address _tokenAddr) public view returns (uint256 _freezeCount) {\r\n        return tokensFrozen[_tokenAddr];\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freezeIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freezeDuration\",\"type\":\"uint256\"}],\"name\":\"TokensFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freezeIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freezeDuration\",\"type\":\"uint256\"}],\"name\":\"TokensUnfrozen\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_freezeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeToAdd\",\"type\":\"uint256\"}],\"name\":\"addFreezeTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freezeDuration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_freezeIndex\",\"type\":\"uint256\"}],\"name\":\"getDepositByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_freezeDuration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getDepositCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_freezeCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_freezeCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensFrozen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_freezeIndex\",\"type\":\"uint256\"}],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TimeLock","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://333b0e1fa445bcf00d1c59af526f9268c650131b8efc2e0aadaa78083af80bca"}]}