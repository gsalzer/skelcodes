{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n/// @title EventMetadata\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module emits metadata blob as an event.\ncontract EventMetadata {\n\n    event MetadataSet(bytes metadata);\n\n    // state functions\n\n    /// @notice Emit a metadata blob.\n    /// @param metadata data blob of any format.\n    function _setMetadata(bytes memory metadata) internal {\n        emit MetadataSet(metadata);\n    }\n}\n\n\n\n/// @title Operated\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\ncontract Operated {\n\n    address private _operator;\n\n    event OperatorUpdated(address operator);\n\n    // state functions\n\n    function _setOperator(address operator) internal {\n\n        // can only be called when operator is null\n        require(_operator == address(0), \"operator already set\");\n\n        // cannot set to address 0\n        require(operator != address(0), \"cannot set operator to address 0\");\n\n        // set operator in storage\n        _operator = operator;\n\n        // emit event\n        emit OperatorUpdated(operator);\n    }\n\n    function _transferOperator(address operator) internal {\n\n        // requires existing operator\n        require(_operator != address(0), \"only when operator set\");\n\n        // cannot set to address 0\n        require(operator != address(0), \"cannot set operator to address 0\");\n\n        // set operator in storage\n        _operator = operator;\n\n        // emit event\n        emit OperatorUpdated(operator);\n    }\n\n    function _renounceOperator() internal {\n\n        // requires existing operator\n        require(_operator != address(0), \"only when operator set\");\n\n        // set operator in storage\n        _operator = address(0);\n\n        // emit event\n        emit OperatorUpdated(address(0));\n    }\n\n    // view functions\n\n    function getOperator() public view returns (address operator) {\n        return _operator;\n    }\n\n    function isOperator(address caller) internal view returns (bool ok) {\n        return caller == _operator;\n    }\n\n}\n\n\n\n/// @title Deadline\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/release/v1.3.x/docs/state-machines/modules/Deadline.png\n/// @notice This module allows for setting and validating a deadline.\n///         The deadline makes use of block timestamps to determine end time.\ncontract Deadline {\n\n    using SafeMath for uint256;\n\n    uint256 private _deadline;\n\n    event DeadlineSet(uint256 deadline);\n\n    // state functions\n\n    /// @notice Set the deadline\n    /// @param deadline uint256 Unix timestamp to use as deadline.\n    function _setDeadline(uint256 deadline) internal {\n        _deadline = deadline;\n        emit DeadlineSet(deadline);\n    }\n\n    // view functions\n\n    /// @notice Get the timestamp of the deadline\n    /// @return deadline uint256 Unix timestamp of the deadline.\n    function getDeadline() public view returns (uint256 deadline) {\n        return _deadline;\n    }\n\n    // timeRemaining will default to 0 if _setDeadline is not called\n    // if the now exceeds deadline, just return 0 as the timeRemaining\n\n    /// @notice Get the amount of time remaining until the deadline.\n    ///         Returns 0 if deadline is not set or is passed.\n    /// @return time uint256 Amount of time in seconds until deadline.\n    function getTimeRemaining() public view returns (uint256 time) {\n        if (_deadline > now)\n            return _deadline.sub(now);\n        else\n            return 0;\n    }\n\n    enum DeadlineStatus { isNull, isSet, isOver }\n    /// @notice Get the status of the state machine\n    /// @return status DeadlineStatus from the following states:\n    ///         - isNull: the deadline has not been set\n    ///         - isSet: the deadline is set, but has not passed\n    ///         - isOver: the deadline has passed\n    function getDeadlineStatus() public view returns (DeadlineStatus status) {\n        if (_deadline == 0)\n            return DeadlineStatus.isNull;\n        if (_deadline > now)\n            return DeadlineStatus.isSet;\n        else\n            return DeadlineStatus.isOver;\n    }\n\n    /// @notice Validate if the state machine is in the DeadlineStatus.isNull state\n    /// @return validity bool true if correct state\n    function isNull() internal view returns (bool status) {\n        return getDeadlineStatus() == DeadlineStatus.isNull;\n    }\n\n    /// @notice Validate if the state machine is in the DeadlineStatus.isSet state\n    /// @return validity bool true if correct state\n    function isSet() internal view returns (bool status) {\n        return getDeadlineStatus() == DeadlineStatus.isSet;\n    }\n\n    /// @notice Validate if the state machine is in the DeadlineStatus.isOver state\n    /// @return validity bool true if correct state\n    function isOver() internal view returns (bool status) {\n        return getDeadlineStatus() == DeadlineStatus.isOver;\n    }\n\n}\n\n\n/* @title DecimalMath\n * @dev taken from https://github.com/PolymathNetwork/polymath-core\n * @dev Apache v2 License\n */\nlibrary DecimalMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\n\n    /**\n     * @notice This function multiplies two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of multiplication represented as (decimal * 10**DECIMALS)\n     */\n    function mul(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        z = SafeMath.add(SafeMath.mul(x, y), (e18) / 2) / (e18);\n    }\n\n    /**\n     * @notice This function divides two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of division represented as (decimal * 10**DECIMALS)\n     */\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        z = SafeMath.add(SafeMath.mul(x, (e18)), y / 2) / y;\n    }\n\n}\n\n\n/// @title iFactory\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\ninterface iFactory {\n\n    event InstanceCreated(address indexed instance, address indexed creator, bytes callData);\n\n    function create(bytes calldata callData) external returns (address instance);\n    function createSalty(bytes calldata callData, bytes32 salt) external returns (address instance);\n    function getInitSelector() external view returns (bytes4 initSelector);\n    function getInstanceRegistry() external view returns (address instanceRegistry);\n    function getTemplate() external view returns (address template);\n    function getSaltyInstance(address creator, bytes calldata callData, bytes32 salt) external view returns (address instance, bool validity);\n    function getNextNonceInstance(address creator, bytes calldata callData) external view returns (address instance);\n\n    function getInstanceCreator(address instance) external view returns (address creator);\n    function getInstanceType() external view returns (bytes4 instanceType);\n    function getInstanceCount() external view returns (uint256 count);\n    function getInstance(uint256 index) external view returns (address instance);\n    function getInstances() external view returns (address[] memory instances);\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ncontract UniswapExchangeInterface {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n    // Provide Liquidity\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\n    // ERC20 comaptibility for liquidity tokens\n    bytes32 public name;\n    bytes32 public symbol;\n    uint256 public decimals;\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    // Never use\n    function setup(address token_addr) external;\n}\n\n\n/// @title iNMR\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\ncontract iNMR {\n\n    // ERC20\n    function totalSupply() external returns (uint256);\n    function balanceOf(address _owner) external returns (uint256);\n    function allowance(address _owner, address _spender) external returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool ok);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool ok);\n    function approve(address _spender, uint256 _value) external returns (bool ok);\n    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) external returns (bool ok);\n\n    /// @dev Behavior has changed to match OpenZeppelin's `ERC20Burnable.burn(uint256 amount)`\n    /// @dev Destoys `amount` tokens from `msg.sender`, reducing the total supply.\n    ///\n    /// Emits a `Transfer` event with `to` set to the zero address.\n    /// Requirements:\n    /// - `account` must have at least `amount` tokens.\n    function mint(uint256 _value) external returns (bool ok);\n\n    /// @dev Behavior has changed to match OpenZeppelin's `ERC20Burnable.burnFrom(address account, uint256 amount)`\n    /// @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n    /// from the caller's allowance.\n    ///\n    /// Emits an `Approval` event indicating the updated allowance.\n    /// Emits a `Transfer` event with `to` set to the zero address.\n    ///\n    /// Requirements:\n    /// - `account` must have at least `amount` tokens.\n    /// - `account` must have approved `msg.sender` with allowance of at least `amount` tokens.\n    function numeraiTransfer(address _to, uint256 _value) external returns (bool ok);\n}\n\n\n\n\n/// @title Countdown\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/release/v1.3.x/docs/state-machines/modules/Countdown.png\n/// @notice This module provides an arbitrary length countdown.\n///         The countdown makes use of block timestamps to determine start time and end time.\ncontract Countdown is Deadline {\n\n    using SafeMath for uint256;\n\n    uint256 private _length;\n\n    event LengthSet(uint256 length);\n\n    // state functions\n\n    /// @notice Set the length of the countdown\n    /// @param length uint256 The amount of time in seconds.\n    function _setLength(uint256 length) internal {\n        _length = length;\n        emit LengthSet(length);\n    }\n\n    /// @notice Start the countdown based on the current block timestamp\n    /// @return deadline uint256 Unix timestamp of the end of the countdown (current timestamp + countdown length).\n    function _start() internal returns (uint256 deadline) {\n        deadline = _length.add(now);\n        Deadline._setDeadline(deadline);\n        return deadline;\n    }\n\n    // view functions\n\n    /// @notice Get the length of the countdown in seconds\n    /// @return length uint256 The amount of time in seconds.\n    function getLength() public view returns (uint256 length) {\n        return _length;\n    }\n\n    enum CountdownStatus { isNull, isSet, isActive, isOver }\n    /// @notice Get the status of the state machine\n    /// @return status CountdownStatus from the following states:\n    ///         - isNull: the length has not been set\n    ///         - isSet: the length is set, but the countdown is not started\n    ///         - isActive: the countdown has started but not yet ended\n    ///         - isOver: the countdown has completed\n    function getCountdownStatus() public view returns (CountdownStatus status) {\n        if (_length == 0)\n            return CountdownStatus.isNull;\n        if (Deadline.getDeadlineStatus() == DeadlineStatus.isNull)\n            return CountdownStatus.isSet;\n        if (Deadline.getDeadlineStatus() != DeadlineStatus.isOver)\n            return CountdownStatus.isActive;\n        else\n            return CountdownStatus.isOver;\n    }\n\n    /// @notice Validate if the state machine is in the CountdownStatus.isNull state\n    /// @return validity bool true if correct state\n    function isNull() internal view returns (bool validity) {\n        return getCountdownStatus() == CountdownStatus.isNull;\n    }\n\n    /// @notice Validate if the state machine is in the CountdownStatus.isSet state\n    /// @return validity bool true if correct state\n    function isSet() internal view returns (bool validity) {\n        return getCountdownStatus() == CountdownStatus.isSet;\n    }\n\n    /// @notice Validate if the state machine is in the CountdownStatus.isActive state\n    /// @return validity bool true if correct state\n    function isActive() internal view returns (bool validity) {\n        return getCountdownStatus() == CountdownStatus.isActive;\n    }\n\n    /// @notice Validate if the state machine is in the CountdownStatus.isOver state\n    /// @return validity bool true if correct state\n    function isOver() internal view returns (bool validity) {\n        return getCountdownStatus() == CountdownStatus.isOver;\n    }\n\n}\n\n\n\n/// @title Template\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module is imported by all template contracts to implement core functionality associated with the factories.\ncontract Template {\n\n    address private _factory;\n\n    // modifiers\n\n    /// @notice Modifier which only allows to be `DELEGATECALL`ed from within a constructor on initialization of the contract.\n    modifier initializeTemplate() {\n        // set factory\n        _factory = msg.sender;\n\n        // only allow function to be `DELEGATECALL`ed from within a constructor.\n        uint32 codeSize;\n        assembly { codeSize := extcodesize(address) }\n        require(codeSize == 0, \"must be called within contract constructor\");\n        _;\n    }\n\n    // view functions\n\n    /// @notice Get the address that created this clone.\n    ///         Note, this cannot be trusted because it is possible to frontrun the create function and become the creator.\n    /// @return creator address that created this clone.\n    function getCreator() public view returns (address creator) {\n        // iFactory(...) would revert if _factory address is not actually a factory contract\n        return iFactory(_factory).getInstanceCreator(address(this));\n    }\n\n    /// @notice Validate if address matches the stored creator.\n    /// @param caller address to validate.\n    /// @return validity bool true if matching address.\n    function isCreator(address caller) internal view returns (bool validity) {\n        return (caller == getCreator());\n    }\n\n    /// @notice Get the address of the factory for this clone.\n    /// @return factory address of the factory.\n    function getFactory() public view returns (address factory) {\n        return _factory;\n    }\n\n}\n\n\n/// @title BurnNMR\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module simplifies calling NMR burn functions using regular openzeppelin ERC20Burnable interface and revert on failure.\n///         This helper is required given the non-standard implementation of the NMR burn functions: https://github.com/numerai/contract\ncontract BurnNMR {\n\n    // address of the token\n    address private constant _NMRToken = address(0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671);\n    // uniswap exchange of the token\n    address private constant _NMRExchange = address(0x2Bf5A5bA29E60682fC56B2Fcf9cE07Bef4F6196f);\n\n    /// @notice Burns a specific amount of NMR from this contract.\n    /// @param value uint256 The amount of NMR (18 decimals) to be burned.\n    function _burn(uint256 value) internal {\n        require(iNMR(_NMRToken).mint(value), \"nmr burn failed\");\n    }\n\n    /// @notice Burns a specific amount of NMR from the target address and decrements allowance.\n    /// @param from address The account whose tokens will be burned.\n    /// @param value uint256 The amount of NMR (18 decimals) to be burned.\n    function _burnFrom(address from, uint256 value) internal {\n        require(iNMR(_NMRToken).numeraiTransfer(from, value), \"nmr burnFrom failed\");\n    }\n\n    /// @notice Get the NMR token address.\n    /// @return token address The NMR token address.\n    function getTokenAddress() internal pure returns (address token) {\n        token = _NMRToken;\n    }\n\n    /// @notice Get the NMR Uniswap exchange address.\n    /// @return token address The NMR Uniswap exchange address.\n    function getExchangeAddress() internal pure returns (address exchange) {\n        exchange = _NMRExchange;\n    }\n\n}\n\n\n\n\n/// @title BurnDAI\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module allows for burning DAI tokens by exchanging them for NMR on uniswap and burning the NMR.\ncontract BurnDAI is BurnNMR {\n\n    // address of the token\n    address private constant _DAIToken = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    // uniswap exchange of the token\n    address private constant _DAIExchange = address(0x2a1530C4C41db0B0b2bB646CB5Eb1A67b7158667);\n\n    /// @notice Burns a specific amount of DAI from the target address and decrements allowance.\n    /// @dev This implementation has no frontrunning protection.\n    /// @param from address The account whose tokens will be burned.\n    /// @param value uint256 The amount of DAI (18 decimals) to be burned.\n    function _burnFrom(address from, uint256 value) internal {\n\n        // transfer dai to this contract\n        IERC20(_DAIToken).transferFrom(from, address(this), value);\n\n        // butn nmr\n        _burn(value);\n    }\n\n    /// @notice Burns a specific amount of DAI from this contract.\n    /// @dev This implementation has no frontrunning protection.\n    /// @param value uint256 The amount of DAI (18 decimals) to be burned.\n    function _burn(uint256 value) internal {\n\n        // approve uniswap for token transfer\n        IERC20(_DAIToken).approve(_DAIExchange, value);\n\n        // swap dai for nmr\n        uint256 tokens_sold = value;\n        (uint256 min_tokens_bought, uint256 min_eth_bought) = getExpectedSwapAmount(tokens_sold);\n        uint256 deadline = now;\n        uint256 tokens_bought = UniswapExchangeInterface(_DAIExchange).tokenToTokenSwapInput(\n            tokens_sold,\n            min_tokens_bought,\n            min_eth_bought,\n            deadline,\n            BurnNMR.getTokenAddress()\n        );\n\n        // burn nmr\n        BurnNMR._burn(tokens_bought);\n    }\n\n    /// @notice Get the amount of NMR and ETH required to sell a given amount of DAI.\n    /// @param amountDAI uint256 The amount of DAI (18 decimals) to sell.\n    /// @param amountNMR uint256 The amount of NMR (18 decimals) required.\n    /// @param amountETH uint256 The amount of ETH (18 decimals) required.\n    function getExpectedSwapAmount(uint256 amountDAI) internal view returns (uint256 amountNMR, uint256 amountETH) {\n        amountETH = UniswapExchangeInterface(_DAIExchange).getTokenToEthInputPrice(amountDAI);\n        amountNMR = UniswapExchangeInterface(BurnNMR.getExchangeAddress()).getEthToTokenInputPrice(amountETH);\n        return (amountNMR, amountETH);\n    }\n\n    /// @notice Get the DAI token address.\n    /// @return token address The DAI token address.\n    function getTokenAddress() internal pure returns (address token) {\n        token = _DAIToken;\n    }\n\n    /// @notice Get the DAI Uniswap exchange address.\n    /// @return token address The DAI Uniswap exchange address.\n    function getExchangeAddress() internal pure returns (address exchange) {\n        exchange = _DAIExchange;\n    }\n\n}\n\n/// @title TokenManager\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module provides a standard interface for interacting with supported ERC20 tokens.\ncontract TokenManager is BurnDAI {\n\n    enum Tokens { NaN, NMR, DAI }\n\n    /// @notice Get the address of the given token ID.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @return tokenAddress address of the ERC20 token.\n    function getTokenAddress(Tokens tokenID) public pure returns (address tokenAddress) {\n        if (tokenID == Tokens.DAI)\n            return BurnDAI.getTokenAddress();\n        if (tokenID == Tokens.NMR)\n            return BurnNMR.getTokenAddress();\n        return address(0);\n    }\n\n    /// @notice Get the address of the uniswap exchange for given token ID.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @return exchangeAddress address of the uniswap exchange.\n    function getExchangeAddress(Tokens tokenID) public pure returns (address exchangeAddress) {\n        if (tokenID == Tokens.DAI)\n            return BurnDAI.getExchangeAddress();\n        if (tokenID == Tokens.NMR)\n            return BurnNMR.getExchangeAddress();\n        return address(0);\n    }\n\n    modifier onlyValidTokenID(Tokens tokenID) {\n        require(isValidTokenID(tokenID), 'invalid tokenID');\n        _;\n    }\n\n    /// @notice Validate the token ID is a supported token.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @return validity bool true if the token is supported.\n    function isValidTokenID(Tokens tokenID) internal pure returns (bool validity) {\n        return tokenID == Tokens.NMR || tokenID == Tokens.DAI;\n    }\n\n    /// @notice ERC20 ransfer.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param to address of the recipient.\n    /// @param value uint256 amount of tokens.\n    function _transfer(Tokens tokenID, address to, uint256 value) internal onlyValidTokenID(tokenID) {\n        require(IERC20(getTokenAddress(tokenID)).transfer(to, value), 'token transfer failed');\n    }\n\n    /// @notice ERC20 TransferFrom\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param from address to spend from.\n    /// @param to address of the recipient.\n    /// @param value uint256 amount of tokens.\n    function _transferFrom(Tokens tokenID, address from, address to, uint256 value) internal onlyValidTokenID(tokenID) {\n        require(IERC20(getTokenAddress(tokenID)).transferFrom(from, to, value), 'token transfer failed');\n    }\n\n    /// @notice ERC20 Burn\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param value uint256 amount of tokens.\n    function _burn(Tokens tokenID, uint256 value) internal onlyValidTokenID(tokenID) {\n        if (tokenID == Tokens.DAI) {\n            BurnDAI._burn(value);\n        } else if (tokenID == Tokens.NMR) {\n            BurnNMR._burn(value);\n        }\n    }\n\n    /// @notice ERC20 BurnFrom\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param from address to burn from.\n    /// @param value uint256 amount of tokens.\n    function _burnFrom(Tokens tokenID, address from, uint256 value) internal onlyValidTokenID(tokenID) {\n        if (tokenID == Tokens.DAI) {\n            BurnDAI._burnFrom(from, value);\n        } else if (tokenID == Tokens.NMR) {\n            BurnNMR._burnFrom(from, value);\n        }\n    }\n\n    /// @notice ERC20 Approve\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param spender address of the spender.\n    /// @param value uint256 amount of tokens.\n    function _approve(Tokens tokenID, address spender, uint256 value) internal onlyValidTokenID(tokenID) {\n        if (tokenID == Tokens.DAI) {\n            require(IERC20(BurnDAI.getTokenAddress()).approve(spender, value), 'token approval failed');\n        } else if (tokenID == Tokens.NMR) {\n            address nmr = BurnNMR.getTokenAddress();\n            uint256 currentAllowance = IERC20(nmr).allowance(msg.sender, spender);\n            require(iNMR(nmr).changeApproval(spender, currentAllowance, value), 'token approval failed');\n        }\n    }\n\n    /// @notice ERC20 TotalSupply\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @return value uint256 amount of tokens.\n    function totalSupply(Tokens tokenID) internal view onlyValidTokenID(tokenID) returns (uint256 value) {\n        return IERC20(getTokenAddress(tokenID)).totalSupply();\n    }\n\n    /// @notice ERC20 BalanceOf\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param who address of the owner.\n    /// @return value uint256 amount of tokens.\n    function balanceOf(Tokens tokenID, address who) internal view onlyValidTokenID(tokenID) returns (uint256 value) {\n        return IERC20(getTokenAddress(tokenID)).balanceOf(who);\n    }\n\n    /// @notice ERC20 Allowance\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param owner address of the owner.\n    /// @param spender address of the spender.\n    /// @return value uint256 amount of tokens.\n    function allowance(Tokens tokenID, address owner, address spender) internal view onlyValidTokenID(tokenID) returns (uint256 value) {\n        return IERC20(getTokenAddress(tokenID)).allowance(owner, spender);\n    }\n}\n\n\n\n\n/// @title Deposit\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/release/v1.3.x/docs/state-machines/modules/Deposit.png\n/// @notice This module allows for tracking user deposits for fungible tokens.\ncontract Deposit {\n\n    using SafeMath for uint256;\n\n    mapping (uint256 => mapping (address => uint256)) private _deposit;\n\n    event DepositIncreased(TokenManager.Tokens tokenID, address user, uint256 amount, uint256 newDeposit);\n    event DepositDecreased(TokenManager.Tokens tokenID, address user, uint256 amount, uint256 newDeposit);\n\n    /// @notice Increase the deposit of a user.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param user address of the user.\n    /// @param amountToAdd uint256 amount by which to increase the deposit.\n    /// @return newDeposit uint256 amount of the updated deposit.\n    function _increaseDeposit(TokenManager.Tokens tokenID, address user, uint256 amountToAdd) internal returns (uint256 newDeposit) {\n        // calculate new deposit amount\n        newDeposit = _deposit[uint256(tokenID)][user].add(amountToAdd);\n\n        // set new stake to storage\n        _deposit[uint256(tokenID)][user] = newDeposit;\n\n        // emit event\n        emit DepositIncreased(tokenID, user, amountToAdd, newDeposit);\n\n        // return\n        return newDeposit;\n    }\n\n    /// @notice Decrease the deposit of a user.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param user address of the user.\n    /// @param amountToRemove uint256 amount by which to decrease the deposit.\n    /// @return newDeposit uint256 amount of the updated deposit.\n    function _decreaseDeposit(TokenManager.Tokens tokenID, address user, uint256 amountToRemove) internal returns (uint256 newDeposit) {\n        // get current deposit\n        uint256 currentDeposit = _deposit[uint256(tokenID)][user];\n\n        // check if sufficient deposit\n        require(currentDeposit >= amountToRemove, \"insufficient deposit to remove\");\n\n        // calculate new deposit amount\n        newDeposit = currentDeposit.sub(amountToRemove);\n\n        // set new stake to storage\n        _deposit[uint256(tokenID)][user] = newDeposit;\n\n        // emit event\n        emit DepositDecreased(tokenID, user, amountToRemove, newDeposit);\n\n        // return\n        return newDeposit;\n    }\n\n    /// @notice Set the deposit of a user to zero.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param user address of the user.\n    /// @return amountRemoved uint256 amount removed from deposit.\n    function _clearDeposit(TokenManager.Tokens tokenID, address user) internal returns (uint256 amountRemoved) {\n        // get current deposit\n        uint256 currentDeposit = _deposit[uint256(tokenID)][user];\n\n        // remove deposit\n        _decreaseDeposit(tokenID, user, currentDeposit);\n\n        // return\n        return currentDeposit;\n    }\n\n    // view functions\n\n    /// @notice Get the current deposit of a user.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param user address of the user.\n    /// @return deposit uint256 current amount of the deposit.\n    function getDeposit(TokenManager.Tokens tokenID, address user) internal view returns (uint256 deposit) {\n        return _deposit[uint256(tokenID)][user];\n    }\n\n}\n\n\n\n\n\n/// @title Staking\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/release/v1.3.x/docs/state-machines/modules/Staking.png\n/// @notice This module wraps the Deposit functions and the ERC20 functions to provide combined actions.\ncontract Staking is Deposit, TokenManager {\n\n    using SafeMath for uint256;\n\n    event StakeBurned(TokenManager.Tokens tokenID, address staker, uint256 amount);\n\n    /// @notice Transfer and deposit ERC20 tokens to this contract.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param staker Address of the staker who owns the stake.\n    /// @param funder Address of the funder from whom the tokens are transfered.\n    /// @param amountToAdd uint256 amount of tokens (18 decimals) to be added to the stake.\n    /// @return newStake uint256 amount of tokens (18 decimals) remaining in the stake.\n    function _addStake(TokenManager.Tokens tokenID, address staker, address funder, uint256 amountToAdd) internal returns (uint256 newStake) {\n        // update deposit\n        newStake = Deposit._increaseDeposit(tokenID, staker, amountToAdd);\n\n        // transfer the stake amount\n        TokenManager._transferFrom(tokenID, funder, address(this), amountToAdd);\n\n        // explicit return\n        return newStake;\n    }\n\n    /// @notice Withdraw some deposited stake and transfer to recipient.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param staker Address of the staker who owns the stake.\n    /// @param recipient Address of the recipient who receives the tokens.\n    /// @param amountToTake uint256 amount of tokens (18 decimals) to be remove from the stake.\n    /// @return newStake uint256 amount of tokens (18 decimals) remaining in the stake.\n    function _takeStake(TokenManager.Tokens tokenID, address staker, address recipient, uint256 amountToTake) internal returns (uint256 newStake) {\n        // update deposit\n        newStake = Deposit._decreaseDeposit(tokenID, staker, amountToTake);\n\n        // transfer the stake amount\n        TokenManager._transfer(tokenID, recipient, amountToTake);\n\n        // explicit return\n        return newStake;\n    }\n\n    /// @notice Withdraw all deposited stake and transfer to recipient.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param staker Address of the staker who owns the stake.\n    /// @param recipient Address of the recipient who receives the tokens.\n    /// @return amountTaken uint256 amount of tokens (18 decimals) taken from the stake.\n    function _takeFullStake(TokenManager.Tokens tokenID, address staker, address recipient) internal returns (uint256 amountTaken) {\n        // get deposit\n        uint256 currentDeposit = Deposit.getDeposit(tokenID, staker);\n\n        // take full stake\n        _takeStake(tokenID, staker, recipient, currentDeposit);\n\n        // return\n        return currentDeposit;\n    }\n\n    /// @notice Burn some deposited stake.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param staker Address of the staker who owns the stake.\n    /// @param amountToBurn uint256 amount of tokens (18 decimals) to be burn from the stake.\n    /// @return newStake uint256 amount of tokens (18 decimals) remaining in the stake.\n    function _burnStake(TokenManager.Tokens tokenID, address staker, uint256 amountToBurn) internal returns (uint256 newStake) {\n        // update deposit\n        uint256 newDeposit = Deposit._decreaseDeposit(tokenID, staker, amountToBurn);\n\n        // burn the stake amount\n        TokenManager._burn(tokenID, amountToBurn);\n\n        // emit event\n        emit StakeBurned(tokenID, staker, amountToBurn);\n\n        // return\n        return newDeposit;\n    }\n\n    /// @notice Burn all deposited stake.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param staker Address of the staker who owns the stake.\n    /// @return amountBurned uint256 amount of tokens (18 decimals) taken from the stake.\n    function _burnFullStake(TokenManager.Tokens tokenID, address staker) internal returns (uint256 amountBurned) {\n        // get deposit\n        uint256 currentDeposit = Deposit.getDeposit(tokenID, staker);\n\n        // burn full stake\n        _burnStake(tokenID, staker, currentDeposit);\n\n        // return\n        return currentDeposit;\n    }\n\n}\n\n\n\n\n/// @title Griefing\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/release/v1.3.x/docs/state-machines/modules/Griefing.png\n/// @notice This module uses the griefing mechanism to punish the stake.\ncontract Griefing is Staking {\n\n    enum RatioType { NaN, Inf, Dec }\n\n    mapping (address => GriefRatio) private _griefRatio;\n    struct GriefRatio {\n        uint256 ratio;\n        RatioType ratioType;\n        TokenManager.Tokens tokenID;\n   }\n\n    event RatioSet(address staker, TokenManager.Tokens tokenID, uint256 ratio, RatioType ratioType);\n    event Griefed(address punisher, address staker, uint256 punishment, uint256 cost, bytes message);\n\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\n\n    // state functions\n\n    /// @notice Set the grief ratio and type for a given staker\n    /// @param staker Address of the staker\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. This ID must be one of the IDs supported by TokenManager.\n    /// @param ratio Uint256 number (18 decimals) multiplied by punishment to get cost. The number of tokens it cost to punish 1 token.\n    ///              NOTE: ratio must be 0 if ratioType is Inf or NaN\n    /// @param ratioType Griefing.RatioType number. Ratio Type must be one of the following three values:\n    ///                   - Dec: Ratio is a decimal number with 18 decimals\n    ///                   - Inf: Punishment at no cost\n    ///                   - NaN: No Punishment\n    function _setRatio(address staker, TokenManager.Tokens tokenID, uint256 ratio, RatioType ratioType) internal {\n        if (ratioType == RatioType.NaN || ratioType == RatioType.Inf) {\n            require(ratio == 0, \"ratio must be 0 when ratioType is NaN or Inf\");\n        }\n\n        // set token in storage\n        require(TokenManager.isValidTokenID(tokenID), 'invalid tokenID');\n        _griefRatio[staker].tokenID = tokenID;\n\n        // set data in storage\n        _griefRatio[staker].ratio = ratio;\n        _griefRatio[staker].ratioType = ratioType;\n\n        // emit event\n        emit RatioSet(staker, tokenID, ratio, ratioType);\n    }\n\n    /// @notice Punish a stake through griefing\n    ///         NOTE: the cost of the punishment is taken form the account of the punisher. This therefore requires appropriate ERC-20 token approval.\n    ///         NOTE: the punishment will use the token from the ratio settings.\n    /// @param punisher Address of the punisher\n    /// @param staker Address of the staker\n    /// @param punishment Amount of tokens (18 decimals) to punish\n    /// @param message Bytes reason string for the punishment\n    /// @return cost Amount of tokens (18 decimals) to pay\n    function _grief(\n        address punisher,\n        address staker,\n        uint256 punishment,\n        bytes memory message\n    ) internal returns (uint256 cost) {\n        // get grief data from storage\n        uint256 ratio = _griefRatio[staker].ratio;\n        RatioType ratioType = _griefRatio[staker].ratioType;\n        TokenManager.Tokens tokenID = _griefRatio[staker].tokenID;\n\n        require(ratioType != RatioType.NaN, \"no punishment allowed\");\n\n        // calculate cost\n        // getCost also acts as a guard when _setRatio is not called before\n        cost = getCost(ratio, punishment, ratioType);\n\n        // burn the cost from the punisher's balance\n        TokenManager._burnFrom(tokenID, punisher, cost);\n\n        // burn the punishment from the target's stake\n        Staking._burnStake(tokenID, staker, punishment);\n\n        // emit event\n        emit Griefed(punisher, staker, punishment, cost, message);\n\n        // return\n        return cost;\n    }\n\n    // view functions\n\n    /// @notice Get the ratio of a staker\n    /// @param staker Address of the staker\n    /// @return ratio Uint256 number (18 decimals)\n    /// @return ratioType Griefing.RatioType number. Ratio Type must be one of the following three values:\n    ///                   - Dec: Ratio is a decimal number with 18 decimals\n    ///                   - Inf: Punishment at no cost\n    ///                   - NaN: No Punishment\n    function getRatio(address staker) public view returns (uint256 ratio, RatioType ratioType) {\n        // get stake data from storage\n        return (_griefRatio[staker].ratio, _griefRatio[staker].ratioType);\n    }\n\n    /// @notice Get the tokenID used by a staker\n    /// @param staker Address of the staker\n    /// @return tokenID TokenManager.Tokens ID of the ERC20 token.\n    function getTokenID(address staker) internal view returns (TokenManager.Tokens tokenID) {\n        // get stake data from storage\n        return (_griefRatio[staker].tokenID);\n    }\n\n    // pure functions\n\n    /// @notice Get exact cost for a given punishment and ratio\n    /// @param ratio Uint256 number (18 decimals)\n    /// @param punishment Amount of tokens (18 decimals) to punish\n    /// @param ratioType Griefing.RatioType number. Ratio Type must be one of the following three values:\n    ///                   - Dec: Ratio is a decimal number with 18 decimals\n    ///                   - Inf: Punishment at no cost\n    ///                   - NaN: No Punishment\n    /// @return cost Amount of tokens (18 decimals) to pay\n    function getCost(uint256 ratio, uint256 punishment, RatioType ratioType) public pure returns(uint256 cost) {\n        if (ratioType == RatioType.Dec)\n            return DecimalMath.mul(SafeMath.mul(punishment, e18), ratio) / e18;\n        if (ratioType == RatioType.Inf)\n            return 0;\n        if (ratioType == RatioType.NaN)\n            revert(\"ratioType cannot be RatioType.NaN\");\n    }\n\n    /// @notice Get approximate punishment for a given cost and ratio.\n    ///         The punishment is an approximate value due to quantization / rounding.\n    /// @param ratio Uint256 number (18 decimals)\n    /// @param cost Amount of tokens (18 decimals) to pay\n    /// @param ratioType Griefing.RatioType number. Ratio Type must be one of the following three values:\n    ///                   - Dec: Ratio is a decimal number with 18 decimals\n    ///                   - Inf: Punishment at no cost\n    ///                   - NaN: No Punishment\n    /// @return punishment Approximate amount of tokens (18 decimals) to punish\n    function getPunishment(uint256 ratio, uint256 cost, RatioType ratioType) public pure returns(uint256 punishment) {\n        if (ratioType == RatioType.Dec)\n            return DecimalMath.div(SafeMath.mul(cost, e18), ratio) / e18;\n        if (ratioType == RatioType.Inf)\n            revert(\"ratioType cannot be RatioType.Inf\");\n        if (ratioType == RatioType.NaN)\n            revert(\"ratioType cannot be RatioType.NaN\");\n    }\n\n}\n\n\n\n\n\n\n\n/// @title CountdownGriefing\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @dev State Machine: https://github.com/erasureprotocol/erasure-protocol/blob/release/v1.3.x/docs/state-machines/agreements/CountdownGriefing.png\n/// @notice This agreement template allows a staker to grant permission to a counterparty to punish, reward, or release their stake until the countdown is completed.\n///         A new instance is initialized by the factory using the `initData` received. See the `initialize()` function for details on initialization parameters.\n///         Notable features:\n///             - The staker can increase the stake at any time before the end of the countdown.\n///             - The counterparty can increase, release, or punish the stake at any time before the end of the countdown.\n///             - The agreement can be terminated by the staker by starting the countdown. Once the countdown completes the staker can retrieve their remaining stake.\n///             - Punishments use griefing which requires the counterparty to pay an appropriate amount based on the desired punishment and a predetermined ratio.\n///             - An operator can optionally be defined to grant full permissions to a trusted external address or contract.\ncontract CountdownGriefing is Countdown, Griefing, EventMetadata, Operated, Template {\n\n    using SafeMath for uint256;\n\n    Data private _data;\n    struct Data {\n        address staker;\n        address counterparty;\n    }\n\n    event Initialized(\n        address operator,\n        address staker,\n        address counterparty,\n        TokenManager.Tokens tokenID,\n        uint256 ratio,\n        Griefing.RatioType ratioType,\n        uint256 countdownLength,\n        bytes metadata\n    );\n\n    /// @notice Constructor used to initialize the agreement parameters.\n    ///         All parameters are passed as ABI-encoded calldata to the factory. This calldata must include the function selector.\n    /// @dev Access Control: only factory\n    ///      State Machine: before all\n    /// @param operator address of the operator that overrides access control. Optional parameter. Passing the address(0) will disable operator functionality.\n    /// @param staker address of the staker who owns the stake. Required parameter. This address is the only one able to retrieve the stake and cannot be changed.\n    /// @param counterparty address of the counterparty who has the right to reward, release, and punish the stake. Required parameter. This address cannot be changed.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token. Required parameter. This ID must be one of the IDs supported by TokenManager.\n    /// @param ratio uint256 number (18 decimals) used to determine punishment cost. Required parameter. See Griefing module for details on valid input.\n    /// @param ratioType Griefing.RatioType number used to determine punishment cost. Required parameter. See Griefing module for details on valid input.\n    /// @param countdownLength uint256 amount of time (in seconds) the counterparty has to punish or reward before the agreement ends. Required parameter.\n    /// @param metadata bytes data (any format) to emit as event on initialization. Optional parameter.\n    function initialize(\n        address operator,\n        address staker,\n        address counterparty,\n        TokenManager.Tokens tokenID,\n        uint256 ratio,\n        Griefing.RatioType ratioType,\n        uint256 countdownLength,\n        bytes memory metadata\n    ) public initializeTemplate() {\n        // set storage values\n        _data.staker = staker;\n        _data.counterparty = counterparty;\n\n        // set operator\n        if (operator != address(0)) {\n            Operated._setOperator(operator);\n        }\n\n        // set griefing ratio\n        Griefing._setRatio(staker, tokenID, ratio, ratioType);\n\n        // set countdown length\n        Countdown._setLength(countdownLength);\n\n        // set metadata\n        if (metadata.length != 0) {\n            EventMetadata._setMetadata(metadata);\n        }\n\n        // log initialization params\n        emit Initialized(operator, staker, counterparty, tokenID, ratio, ratioType, countdownLength, metadata);\n    }\n\n    // state functions\n\n    /// @notice Emit metadata event\n    /// @dev Access Control: operator\n    ///      State Machine: always\n    /// @param metadata bytes data (any format) to emit as event\n    function setMetadata(bytes memory metadata) public {\n        // restrict access\n        require(Operated.isOperator(msg.sender), \"only operator\");\n\n        // update metadata\n        EventMetadata._setMetadata(metadata);\n    }\n\n    /// @notice Called by the staker to increase the stake\n    ///          - tokens (ERC-20) are transfered from the caller and requires approval of this contract for appropriate amount\n    /// @dev Access Control: staker OR operator\n    ///      State Machine: before isTerminated()\n    /// @param amountToAdd uint256 amount of tokens (18 decimals) to be added to the stake\n    function increaseStake(uint256 amountToAdd) public {\n        // restrict access\n        require(isStaker(msg.sender) || Operated.isOperator(msg.sender), \"only staker or operator\");\n\n        // require agreement is not ended\n        require(!isTerminated(), \"agreement ended\");\n\n        // declare variable in memory\n        address staker = _data.staker;\n\n        // add stake\n        Staking._addStake(Griefing.getTokenID(staker), staker, msg.sender, amountToAdd);\n    }\n\n    /// @notice Called by the counterparty to increase the stake\n    ///          - tokens (ERC-20) are transfered from the caller and requires approval of this contract for appropriate amount\n    /// @dev Access Control: counterparty OR operator\n    ///      State Machine: before isTerminated()\n    /// @param amountToAdd uint256 amount of tokens (18 decimals) to be added to the stake\n    function reward(uint256 amountToAdd) public {\n        // restrict access\n        require(isCounterparty(msg.sender) || Operated.isOperator(msg.sender), \"only counterparty or operator\");\n\n        // require agreement is not ended\n        require(!isTerminated(), \"agreement ended\");\n\n        // declare variable in memory\n        address staker = _data.staker;\n\n        // add stake\n        Staking._addStake(Griefing.getTokenID(staker), staker, msg.sender, amountToAdd);\n    }\n\n    /// @notice Called by the counterparty to punish the stake\n    ///          - burns the punishment from the stake and a proportional amount from the counterparty balance\n    ///          - the cost of the punishment is calculated with the `Griefing.getCost()` function using the predetermined griefing ratio\n    ///          - tokens (ERC-20) are burned from the caller and requires approval of this contract for appropriate amount\n    /// @dev Access Control: counterparty OR operator\n    ///      State Machine: before isTerminated()\n    /// @param punishment uint256 amount of tokens (18 decimals) to be burned from the stake\n    /// @param message bytes data (any format) to emit as event giving reason for the punishment\n    /// @return cost uint256 amount of tokens (18 decimals) it cost to perform punishment\n    function punish(uint256 punishment, bytes memory message) public returns (uint256 cost) {\n        // restrict access\n        require(isCounterparty(msg.sender) || Operated.isOperator(msg.sender), \"only counterparty or operator\");\n\n        // require agreement is not ended\n        require(!isTerminated(), \"agreement ended\");\n\n        // execute griefing\n        return Griefing._grief(msg.sender, _data.staker, punishment, message);\n    }\n\n    /// @notice Called by the counterparty to release the stake to the staker\n    /// @dev Access Control: counterparty OR operator\n    ///      State Machine: anytime\n    /// @param amountToRelease uint256 amount of tokens (18 decimals) to be released from the stake\n    function releaseStake(uint256 amountToRelease) public {\n        // restrict access\n        require(isCounterparty(msg.sender) || Operated.isOperator(msg.sender), \"only counterparty or operator\");\n\n        // declare variable in memory\n        address staker = _data.staker;\n\n        // release stake back to the staker\n        Staking._takeStake(Griefing.getTokenID(staker), staker, staker, amountToRelease);\n    }\n\n    /// @notice Called by the staker to begin countdown to finalize the agreement\n    /// @dev Access Control: staker OR operator\n    ///      State Machine: before Countdown.isActive()\n    /// @return deadline uint256 timestamp (Unix seconds) at which the agreement will be finalized\n    function startCountdown() public returns (uint256 deadline) {\n        // restrict access\n        require(isStaker(msg.sender) || Operated.isOperator(msg.sender), \"only staker or operator\");\n\n        // require countdown is not started\n        require(isInitialized(), \"deadline already set\");\n\n        // start countdown\n        return Countdown._start();\n    }\n\n    /// @notice Called by anyone to return the remaining stake once the agreement has ended\n    /// @dev Access Control: anyone\n    ///      State Machine: after Countdown.isOver()\n    /// @return amount uint256 amount of tokens (18 decimals) returned\n    function returnStake() public returns (uint256 amount) {\n        // require deadline is passed\n        require(isTerminated(), \"deadline not passed\");\n\n        // declare variable in memory\n        address staker = _data.staker;\n\n        // retrieve stake\n        return Staking._takeFullStake(Griefing.getTokenID(staker), staker, staker);\n    }\n\n    /// @notice Called by the staker to retrieve the remaining stake once the agreement has ended\n    /// @dev Access Control: staker OR operator\n    ///      State Machine: after Countdown.isOver()\n    /// @param recipient address of the account where to send the stake\n    /// @return amount uint256 amount of tokens (18 decimals) retrieved\n    function retrieveStake(address recipient) public returns (uint256 amount) {\n        // restrict access\n        require(isStaker(msg.sender) || Operated.isOperator(msg.sender), \"only staker or operator\");\n\n        // require deadline is passed\n        require(isTerminated(), \"deadline not passed\");\n\n        // declare variable in memory\n        address staker = _data.staker;\n\n        // retrieve stake\n        return Staking._takeFullStake(Griefing.getTokenID(staker), staker, recipient);\n    }\n\n    /// @notice Called by the operator to transfer control to new operator\n    /// @dev Access Control: operator\n    ///      State Machine: anytime\n    /// @param operator address of the new operator\n    function transferOperator(address operator) public {\n        // restrict access\n        require(Operated.isOperator(msg.sender), \"only operator\");\n\n        // transfer operator\n        Operated._transferOperator(operator);\n    }\n\n    /// @notice Called by the operator to renounce control\n    /// @dev Access Control: operator\n    ///      State Machine: anytime\n    function renounceOperator() public {\n        // restrict access\n        require(Operated.isOperator(msg.sender), \"only operator\");\n\n        // renounce operator\n        Operated._renounceOperator();\n    }\n\n    // view functions\n\n    /// @notice Get the address of the staker (if set)\n    /// @return staker address of the staker\n    function getStaker() public view returns (address staker) {\n        return _data.staker;\n    }\n\n    /// @notice Validate if the address matches the stored staker address\n    /// @param caller address to validate\n    /// @return validity bool true if matching address\n    function isStaker(address caller) internal view returns (bool validity) {\n        return caller == getStaker();\n    }\n\n    /// @notice Get the address of the counterparty (if set)\n    /// @return counterparty address of counterparty account\n    function getCounterparty() public view returns (address counterparty) {\n        return _data.counterparty;\n    }\n\n    /// @notice Validate if the address matches the stored counterparty address\n    /// @param caller address to validate\n    /// @return validity bool true if matching address\n    function isCounterparty(address caller) internal view returns (bool validity) {\n        return caller == getCounterparty();\n    }\n\n    /// @notice Get the token ID and address used by the agreement\n    /// @return tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @return token address of the ERC20 token.\n    function getToken() public view returns (TokenManager.Tokens tokenID, address token) {\n        tokenID = Griefing.getTokenID(_data.staker);\n        return (tokenID, TokenManager.getTokenAddress(tokenID));\n    }\n\n    /// @notice Get the current stake of the agreement\n    /// @return stake uint256 amount of tokens (18 decimals) staked.\n    function getStake() public view returns (uint256 stake) {\n        return Deposit.getDeposit(Griefing.getTokenID(_data.staker), _data.staker);\n    }\n\n    /// @notice Validate if the current stake is greater than 0\n    /// @return validity bool true if non-zero stake\n    function isStaked() public view returns (bool validity) {\n        uint256 currentStake = getStake();\n        return currentStake > 0;\n    }\n\n    enum AgreementStatus { isInitialized, isInCountdown, isTerminated }\n    /// @notice Get the status of the state machine\n    /// @return status AgreementStatus from the following states:\n    ///          - isInitialized: initialized but no deposits made\n    ///          - isInCountdown: staker has triggered countdown to termination\n    ///          - isTerminated: griefing agreement is over, staker can retrieve stake\n    function getAgreementStatus() public view returns (AgreementStatus status) {\n        if (Countdown.isOver()) {\n            return AgreementStatus.isTerminated;\n        } else if (Countdown.isActive()) {\n            return AgreementStatus.isInCountdown;\n        } else {\n            return AgreementStatus.isInitialized;\n        }\n    }\n\n    /// @notice Validate if the state machine is in the AgreementStatus.isInitialized state\n    /// @return validity bool true if correct state\n    function isInitialized() internal view returns (bool validity) {\n        return getAgreementStatus() == AgreementStatus.isInitialized;\n    }\n\n    /// @notice Validate if the state machine is in the AgreementStatus.isInCountdown state\n    /// @return validity bool true if correct state\n    function isInCountdown() internal view returns (bool validity) {\n        return getAgreementStatus() == AgreementStatus.isInCountdown;\n    }\n\n    /// @notice Validate if the state machine is in the AgreementStatus.isTerminated state\n    /// @return validity bool true if correct state\n    function isTerminated() internal view returns (bool validity) {\n        return getAgreementStatus() == AgreementStatus.isTerminated;\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"DeadlineSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum TokenManager.Tokens\",\"name\":\"tokenID\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"DepositDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum TokenManager.Tokens\",\"name\":\"tokenID\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"DepositIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"punisher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"punishment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"Griefed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum TokenManager.Tokens\",\"name\":\"tokenID\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"countdownLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"LengthSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"MetadataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum TokenManager.Tokens\",\"name\":\"tokenID\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"}],\"name\":\"RatioSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum TokenManager.Tokens\",\"name\":\"tokenID\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeBurned\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAgreementStatus\",\"outputs\":[{\"internalType\":\"enum CountdownGriefing.AgreementStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"punishment\",\"type\":\"uint256\"},{\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"}],\"name\":\"getCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCountdownStatus\",\"outputs\":[{\"internalType\":\"enum Countdown.CountdownStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCounterparty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDeadlineStatus\",\"outputs\":[{\"internalType\":\"enum Deadline.DeadlineStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum TokenManager.Tokens\",\"name\":\"tokenID\",\"type\":\"uint8\"}],\"name\":\"getExchangeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"}],\"name\":\"getPunishment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"punishment\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"enum TokenManager.Tokens\",\"name\":\"tokenID\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum TokenManager.Tokens\",\"name\":\"tokenID\",\"type\":\"uint8\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToAdd\",\"type\":\"uint256\"}],\"name\":\"increaseStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"},{\"internalType\":\"enum TokenManager.Tokens\",\"name\":\"tokenID\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"enum Griefing.RatioType\",\"name\":\"ratioType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"countdownLength\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"validity\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"punishment\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"punish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToRelease\",\"type\":\"uint256\"}],\"name\":\"releaseStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"retrieveStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"returnStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToAdd\",\"type\":\"uint256\"}],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"setMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCountdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CountdownGriefing","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}]}