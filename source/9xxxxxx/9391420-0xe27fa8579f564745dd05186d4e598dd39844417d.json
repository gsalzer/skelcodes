{"status":"1","message":"OK","result":[{"SourceCode":"// File: @aragon/os/contracts/common/UnstructuredStorage.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary UnstructuredStorage {\r\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function setStorageBool(bytes32 position, bool data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageAddress(bytes32 position, address data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageUint256(bytes32 position, uint256 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/acl/IACL.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IACL {\r\n    function initialize(address permissionsCreator) external;\r\n\r\n    // TODO: this should be external\r\n    // See https://github.com/ethereum/solidity/issues/4832\r\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\r\n}\r\n\r\n// File: @aragon/os/contracts/common/IVaultRecoverable.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IVaultRecoverable {\r\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\r\n\r\n    function transferToVault(address token) external;\r\n\r\n    function allowRecoverability(address token) external view returns (bool);\r\n    function getRecoveryVault() external view returns (address);\r\n}\r\n\r\n// File: @aragon/os/contracts/kernel/IKernel.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\ninterface IKernelEvents {\r\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\r\n}\r\n\r\n\r\n// This should be an interface, but interfaces can't inherit yet :(\r\ncontract IKernel is IKernelEvents, IVaultRecoverable {\r\n    function acl() public view returns (IACL);\r\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\r\n\r\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\r\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\r\n}\r\n\r\n// File: @aragon/os/contracts/apps/AppStorage.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\ncontract AppStorage {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant KERNEL_POSITION = keccak256(\"aragonOS.appStorage.kernel\");\r\n    bytes32 internal constant APP_ID_POSITION = keccak256(\"aragonOS.appStorage.appId\");\r\n    */\r\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\r\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\r\n\r\n    function kernel() public view returns (IKernel) {\r\n        return IKernel(KERNEL_POSITION.getStorageAddress());\r\n    }\r\n\r\n    function appId() public view returns (bytes32) {\r\n        return APP_ID_POSITION.getStorageBytes32();\r\n    }\r\n\r\n    function setKernel(IKernel _kernel) internal {\r\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\r\n    }\r\n\r\n    function setAppId(bytes32 _appId) internal {\r\n        APP_ID_POSITION.setStorageBytes32(_appId);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/acl/ACLSyntaxSugar.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract ACLSyntaxSugar {\r\n    function arr() internal pure returns (uint256[]) {\r\n        return new uint256[](0);\r\n    }\r\n\r\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a));\r\n    }\r\n\r\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b));\r\n    }\r\n\r\n    function arr(address _a) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a));\r\n    }\r\n\r\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b));\r\n    }\r\n\r\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), _b, _c);\r\n    }\r\n\r\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), _b, _c, _d);\r\n    }\r\n\r\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b));\r\n    }\r\n\r\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\r\n    }\r\n\r\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b), uint256(_c));\r\n    }\r\n\r\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b), uint256(_c));\r\n    }\r\n\r\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\r\n        r = new uint256[](1);\r\n        r[0] = _a;\r\n    }\r\n\r\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\r\n        r = new uint256[](2);\r\n        r[0] = _a;\r\n        r[1] = _b;\r\n    }\r\n\r\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\r\n        r = new uint256[](3);\r\n        r[0] = _a;\r\n        r[1] = _b;\r\n        r[2] = _c;\r\n    }\r\n\r\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\r\n        r = new uint256[](4);\r\n        r[0] = _a;\r\n        r[1] = _b;\r\n        r[2] = _c;\r\n        r[3] = _d;\r\n    }\r\n\r\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\r\n        r = new uint256[](5);\r\n        r[0] = _a;\r\n        r[1] = _b;\r\n        r[2] = _c;\r\n        r[3] = _d;\r\n        r[4] = _e;\r\n    }\r\n}\r\n\r\n\r\ncontract ACLHelpers {\r\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\r\n        return uint8(_x >> (8 * 30));\r\n    }\r\n\r\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\r\n        return uint8(_x >> (8 * 31));\r\n    }\r\n\r\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\r\n        a = uint32(_x);\r\n        b = uint32(_x >> (8 * 4));\r\n        c = uint32(_x >> (8 * 8));\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/Uint256Helpers.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary Uint256Helpers {\r\n    uint256 private constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\r\n\r\n    function toUint64(uint256 a) internal pure returns (uint64) {\r\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\r\n        return uint64(a);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/TimeHelpers.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract TimeHelpers {\r\n    using Uint256Helpers for uint256;\r\n\r\n    /**\r\n    * @dev Returns the current block number.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current block number, converted to uint64.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber64() internal view returns (uint64) {\r\n        return getBlockNumber().toUint64();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp() internal view returns (uint256) {\r\n        return block.timestamp; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp, converted to uint64.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp64() internal view returns (uint64) {\r\n        return getTimestamp().toUint64();\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/Initializable.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\ncontract Initializable is TimeHelpers {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    // keccak256(\"aragonOS.initializable.initializationBlock\")\r\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\r\n\r\n    string private constant ERROR_ALREADY_INITIALIZED = \"INIT_ALREADY_INITIALIZED\";\r\n    string private constant ERROR_NOT_INITIALIZED = \"INIT_NOT_INITIALIZED\";\r\n\r\n    modifier onlyInit {\r\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\r\n        _;\r\n    }\r\n\r\n    modifier isInitialized {\r\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return Block number in which the contract was initialized\r\n    */\r\n    function getInitializationBlock() public view returns (uint256) {\r\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n    * @return Whether the contract has been initialized by the time of the current block\r\n    */\r\n    function hasInitialized() public view returns (bool) {\r\n        uint256 initializationBlock = getInitializationBlock();\r\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract after initialization has finished.\r\n    */\r\n    function initialized() internal onlyInit {\r\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract after initialization to enable the contract\r\n    *      at a future block number rather than immediately.\r\n    */\r\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\r\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/Petrifiable.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract Petrifiable is Initializable {\r\n    // Use block UINT256_MAX (which should be never) as the initializable date\r\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\r\n\r\n    function isPetrified() public view returns (bool) {\r\n        return getInitializationBlock() == PETRIFIED_BLOCK;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract to prevent being initialized.\r\n    *      Useful for freezing base contracts when they're used behind proxies.\r\n    */\r\n    function petrify() internal onlyInit {\r\n        initializedAt(PETRIFIED_BLOCK);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/Autopetrified.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract Autopetrified is Petrifiable {\r\n    constructor() public {\r\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\r\n        // This renders them uninitializable (and unusable without a proxy).\r\n        petrify();\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/ConversionHelpers.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary ConversionHelpers {\r\n    string private constant ERROR_IMPROPER_LENGTH = \"CONVERSION_IMPROPER_LENGTH\";\r\n\r\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\r\n        // Force cast the uint256[] into a bytes array, by overwriting its length\r\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\r\n        // with the input and a new length. The input becomes invalid from this point forward.\r\n        uint256 byteLength = _input.length * 32;\r\n        assembly {\r\n            output := _input\r\n            mstore(output, byteLength)\r\n        }\r\n    }\r\n\r\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\r\n        // Force cast the bytes array into a uint256[], by overwriting its length\r\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\r\n        // with the input and a new length. The input becomes invalid from this point forward.\r\n        uint256 intsLength = _input.length / 32;\r\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\r\n\r\n        assembly {\r\n            output := _input\r\n            mstore(output, intsLength)\r\n        }\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/ReentrancyGuard.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract ReentrancyGuard {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256(\"aragonOS.reentrancyGuard.mutex\");\r\n    */\r\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\r\n\r\n    string private constant ERROR_REENTRANT = \"REENTRANCY_REENTRANT_CALL\";\r\n\r\n    modifier nonReentrant() {\r\n        // Ensure mutex is unlocked\r\n        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\r\n\r\n        // Lock mutex before function call\r\n        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\r\n\r\n        // Perform function call\r\n        _;\r\n\r\n        // Unlock mutex after function call\r\n        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/lib/token/ERC20.sol\r\n\r\n// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        public returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: @aragon/os/contracts/common/EtherTokenConstant.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\r\n// contracts where both tokens and ETH are accepted\r\ncontract EtherTokenConstant {\r\n    address internal constant ETH = address(0);\r\n}\r\n\r\n// File: @aragon/os/contracts/common/IsContract.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract IsContract {\r\n    /*\r\n    * NOTE: this should NEVER be used for authentication\r\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\r\n    *\r\n    * This is only intended to be used as a sanity check that an address is actually a contract,\r\n    * RATHER THAN an address not being a contract.\r\n    */\r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := extcodesize(_target) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/SafeERC20.sol\r\n\r\n// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\r\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\r\n    // https://github.com/ethereum/solidity/issues/3544\r\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\r\n\r\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \"SAFE_ERC_20_BALANCE_REVERTED\";\r\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \"SAFE_ERC_20_ALLOWANCE_REVERTED\";\r\n\r\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\r\n        private\r\n        returns (bool)\r\n    {\r\n        bool ret;\r\n        assembly {\r\n            let ptr := mload(0x40)    // free memory pointer\r\n\r\n            let success := call(\r\n                gas,                  // forward all gas\r\n                _addr,                // address\r\n                0,                    // no value\r\n                add(_calldata, 0x20), // calldata start\r\n                mload(_calldata),     // calldata length\r\n                ptr,                  // write output over free memory\r\n                0x20                  // uint256 return\r\n            )\r\n\r\n            if gt(success, 0) {\r\n                // Check number of bytes returned from last function call\r\n                switch returndatasize\r\n\r\n                // No bytes returned: assume success\r\n                case 0 {\r\n                    ret := 1\r\n                }\r\n\r\n                // 32 bytes returned: check if non-zero\r\n                case 0x20 {\r\n                    // Only return success if returned data was true\r\n                    // Already have output in ptr\r\n                    ret := eq(mload(ptr), 1)\r\n                }\r\n\r\n                // Not sure what was returned: don't mark as success\r\n                default { }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function staticInvoke(address _addr, bytes memory _calldata)\r\n        private\r\n        view\r\n        returns (bool, uint256)\r\n    {\r\n        bool success;\r\n        uint256 ret;\r\n        assembly {\r\n            let ptr := mload(0x40)    // free memory pointer\r\n\r\n            success := staticcall(\r\n                gas,                  // forward all gas\r\n                _addr,                // address\r\n                add(_calldata, 0x20), // calldata start\r\n                mload(_calldata),     // calldata length\r\n                ptr,                  // write output over free memory\r\n                0x20                  // uint256 return\r\n            )\r\n\r\n            if gt(success, 0) {\r\n                ret := mload(ptr)\r\n            }\r\n        }\r\n        return (success, ret);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferCallData = abi.encodeWithSelector(\r\n            TRANSFER_SELECTOR,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(_token, transferCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferFromCallData = abi.encodeWithSelector(\r\n            _token.transferFrom.selector,\r\n            _from,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(_token, transferFromCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\r\n        bytes memory approveCallData = abi.encodeWithSelector(\r\n            _token.approve.selector,\r\n            _spender,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(_token, approveCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Static call into ERC20.balanceOf().\r\n    * Reverts if the call fails for some reason (should never fail).\r\n    */\r\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\r\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\r\n            _token.balanceOf.selector,\r\n            _owner\r\n        );\r\n\r\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\r\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\r\n\r\n        return tokenBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev Static call into ERC20.allowance().\r\n    * Reverts if the call fails for some reason (should never fail).\r\n    */\r\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\r\n        bytes memory allowanceCallData = abi.encodeWithSelector(\r\n            _token.allowance.selector,\r\n            _owner,\r\n            _spender\r\n        );\r\n\r\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\r\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\r\n\r\n        return allowance;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/VaultRecoverable.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\r\n    using SafeERC20 for ERC20;\r\n\r\n    string private constant ERROR_DISALLOWED = \"RECOVER_DISALLOWED\";\r\n    string private constant ERROR_VAULT_NOT_CONTRACT = \"RECOVER_VAULT_NOT_CONTRACT\";\r\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \"RECOVER_TOKEN_TRANSFER_FAILED\";\r\n\r\n    /**\r\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\r\n     *         but in case it does, this function allows one to recover them.\r\n     * @param _token Token balance to be sent to recovery vault.\r\n     */\r\n    function transferToVault(address _token) external {\r\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\r\n        address vault = getRecoveryVault();\r\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\r\n\r\n        uint256 balance;\r\n        if (_token == ETH) {\r\n            balance = address(this).balance;\r\n            vault.transfer(balance);\r\n        } else {\r\n            ERC20 token = ERC20(_token);\r\n            balance = token.staticBalanceOf(this);\r\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\r\n        }\r\n\r\n        emit RecoverToVault(vault, _token, balance);\r\n    }\r\n\r\n    /**\r\n    * @dev By default deriving from AragonApp makes it recoverable\r\n    * @param token Token address that would be recovered\r\n    * @return bool whether the app allows the recovery\r\n    */\r\n    function allowRecoverability(address token) public view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    // Cast non-implemented interface to be public so we can use it internally\r\n    function getRecoveryVault() public view returns (address);\r\n}\r\n\r\n// File: @aragon/os/contracts/evmscript/IEVMScriptExecutor.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IEVMScriptExecutor {\r\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\r\n    function executorType() external pure returns (bytes32);\r\n}\r\n\r\n// File: @aragon/os/contracts/evmscript/IEVMScriptRegistry.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract EVMScriptRegistryConstants {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\"evmreg\");\r\n    */\r\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\r\n}\r\n\r\n\r\ninterface IEVMScriptRegistry {\r\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\r\n    function disableScriptExecutor(uint256 executorId) external;\r\n\r\n    // TODO: this should be external\r\n    // See https://github.com/ethereum/solidity/issues/4832\r\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\r\n}\r\n\r\n// File: @aragon/os/contracts/kernel/KernelConstants.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract KernelAppIds {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\"kernel\");\r\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\"acl\");\r\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\"vault\");\r\n    */\r\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\r\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\r\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\r\n}\r\n\r\n\r\ncontract KernelNamespaceConstants {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\"core\");\r\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\"base\");\r\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\"app\");\r\n    */\r\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\r\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\r\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\r\n}\r\n\r\n// File: @aragon/os/contracts/evmscript/EVMScriptRunner.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\r\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = \"EVMRUN_EXECUTOR_UNAVAILABLE\";\r\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = \"EVMRUN_PROTECTED_STATE_MODIFIED\";\r\n\r\n    /* This is manually crafted in assembly\r\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = \"EVMRUN_EXECUTOR_INVALID_RETURN\";\r\n    */\r\n\r\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\r\n\r\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\r\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\r\n    }\r\n\r\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\r\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\r\n        return IEVMScriptRegistry(registryAddr);\r\n    }\r\n\r\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\r\n        internal\r\n        isInitialized\r\n        protectState\r\n        returns (bytes)\r\n    {\r\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\r\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\r\n\r\n        bytes4 sig = executor.execScript.selector;\r\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\r\n\r\n        bytes memory output;\r\n        assembly {\r\n            let success := delegatecall(\r\n                gas,                // forward all gas\r\n                executor,           // address\r\n                add(data, 0x20),    // calldata start\r\n                mload(data),        // calldata length\r\n                0,                  // don't write output (we'll handle this ourselves)\r\n                0                   // don't write output\r\n            )\r\n\r\n            output := mload(0x40) // free mem ptr get\r\n\r\n            switch success\r\n            case 0 {\r\n                // If the call errored, forward its full error data\r\n                returndatacopy(output, 0, returndatasize)\r\n                revert(output, returndatasize)\r\n            }\r\n            default {\r\n                switch gt(returndatasize, 0x3f)\r\n                case 0 {\r\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\r\n                    // revert with \"EVMRUN_EXECUTOR_INVALID_RETURN\"\r\n                    // See remix: doing a `revert(\"EVMRUN_EXECUTOR_INVALID_RETURN\")` always results in\r\n                    // this memory layout\r\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\r\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\r\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\r\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\r\n\r\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\r\n                }\r\n                default {\r\n                    // Copy result\r\n                    //\r\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\r\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\r\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\r\n                    //    [ output length (32 bytes) ]\r\n                    //    [ output content (N bytes) ]\r\n                    //\r\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\r\n                    let copysize := sub(returndatasize, 0x20)\r\n                    returndatacopy(output, 0x20, copysize)\r\n\r\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\r\n                }\r\n            }\r\n        }\r\n\r\n        emit ScriptResult(address(executor), _script, _input, output);\r\n\r\n        return output;\r\n    }\r\n\r\n    modifier protectState {\r\n        address preKernel = address(kernel());\r\n        bytes32 preAppId = appId();\r\n        _; // exec\r\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\r\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/apps/AragonApp.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\r\n// that they can never be initialized.\r\n// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\r\n// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\r\n// are included so that they are automatically usable by subclassing contracts\r\ncontract AragonApp is AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\r\n    string private constant ERROR_AUTH_FAILED = \"APP_AUTH_FAILED\";\r\n\r\n    modifier auth(bytes32 _role) {\r\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\r\n        _;\r\n    }\r\n\r\n    modifier authP(bytes32 _role, uint256[] _params) {\r\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\r\n    * @param _sender Sender of the call\r\n    * @param _role Role on this app\r\n    * @param _params Permission params for the role\r\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\r\n    *         Always returns false if the app hasn't been initialized yet.\r\n    */\r\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\r\n        if (!hasInitialized()) {\r\n            return false;\r\n        }\r\n\r\n        IKernel linkedKernel = kernel();\r\n        if (address(linkedKernel) == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        return linkedKernel.hasPermission(\r\n            _sender,\r\n            address(this),\r\n            _role,\r\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Get the recovery vault for the app\r\n    * @return Recovery vault address for the app\r\n    */\r\n    function getRecoveryVault() public view returns (address) {\r\n        // Funds recovery via a vault is only available when used with a kernel\r\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\r\n    }\r\n}\r\n\r\n// File: @tps/apps-address-book/contracts/AddressBook.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer: GPL-3.0-or-later\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title AddressBook App\r\n * @author Autark\r\n * @dev Defines an address book (registry) that allows the\r\n * association of an ethereum address with an IPFS CID pointing to JSON content\r\n */\r\ncontract AddressBook is AragonApp {\r\n\r\n    /// Hardcoded constants to save gas\r\n    /// bytes32 public constant ADD_ENTRY_ROLE = keccak256(\"ADD_ENTRY_ROLE\");\r\n    bytes32 public constant ADD_ENTRY_ROLE = 0x4a167688760e93a8dd0a899c70e125af7d665ed37fd06496b8c83ce9fdac41bd;\r\n    /// bytes32 public constant REMOVE_ENTRY_ROLE = keccak256(\"REMOVE_ENTRY_ROLE\");\r\n    bytes32 public constant REMOVE_ENTRY_ROLE = 0x4bf67e2ff5501162fc2ee020c851b17118c126a125e7f189b1c10056a35a8ed1;\r\n    /// bytes32 public constant UPDATE_ENTRY_ROLE = keccak256(\"UPDATE_ENTRY_ROLE\");\r\n    bytes32 public constant UPDATE_ENTRY_ROLE = 0x6838798f8ade371d93fbc95e535888e5fdc0abba71f87ab7320dd9c8220b4da0;\r\n\r\n    /// Error string constants\r\n    string private constant ERROR_NOT_FOUND = \"ENTRY_DOES_NOT_EXIST\";\r\n    string private constant ERROR_EXISTS = \"ENTRY_ALREADY_EXISTS\";\r\n    string private constant ERROR_CID_MALFORMED = \"CID_MALFORMED\";\r\n    string private constant ERROR_CID_LENGTH = \"CID_LENGTH_INCORRECT\";\r\n    string private constant ERROR_NO_CID = \"CID_DOES_NOT_MATCH\";\r\n\r\n    struct Entry {\r\n        string data;\r\n        uint256 index;\r\n    }\r\n\r\n    /// The entries in the registry\r\n    mapping(address => Entry) public entries;\r\n\r\n    /// Array-like struct to access all addresses\r\n    mapping(uint256 => address) public entryArr;\r\n    uint256 public entryArrLength;\r\n\r\n    /// Events\r\n    event EntryAdded(address addr); /// Fired when an entry is added to the registry\r\n    event EntryRemoved(address addr); /// Fired when an entry is removed from the registry\r\n    event EntryUpdated(address addr); /// Fired when an entry is updated with a new CID.\r\n\r\n    /**\r\n     * @dev Guard to check existence of address in the registry\r\n     * @param _addr The address to enforce its existence in the registry\r\n     */\r\n    modifier entryExists(address _addr) {\r\n        require(isEntryAdded(_addr), ERROR_NOT_FOUND);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guard to ensure the CID is 46 chars long according to base58 encoding\r\n     * @param _cid The IPFS hash of the entry to add to the registry\r\n     */\r\n    modifier cidIsValid(string _cid) {\r\n        bytes memory cidBytes = bytes(_cid);\r\n        require(cidBytes[0] == \"Q\" && cidBytes[1] == \"m\", ERROR_CID_MALFORMED);\r\n        require(cidBytes.length == 46, ERROR_CID_LENGTH);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Initialize AddressBook app\r\n     * @dev Initializes the app, this is the Aragon custom constructor\r\n     */\r\n    function initialize() external onlyInit {\r\n        initialized();\r\n    }\r\n\r\n    /**\r\n     * @notice Add `_addr` to the registry with metadata `_cid`\r\n     * @dev CIDs must be base58-encoded in order to work with this function\r\n     * @param _addr The Ethereum address of the entry to add to the registry\r\n     * @param _cid The IPFS hash of the entry to add to the registry\r\n     */\r\n    function addEntry(address _addr, string _cid) external cidIsValid(_cid) auth(ADD_ENTRY_ROLE) {\r\n        require(bytes(entries[_addr].data).length == 0, ERROR_EXISTS);\r\n        // This is auth-guarded, so it'll overflow well after the app becomes unusable\r\n        // due to the quantity of entries\r\n        uint256 entryIndex = entryArrLength++;\r\n        entryArr[entryIndex] = _addr;\r\n        entries[_addr] = Entry(_cid, entryIndex);\r\n        emit EntryAdded(_addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove `_addr` from the registry with metadata `_cid`\r\n     * @dev this function only supports CIDs that are base58-encoded\r\n     * @param _addr The Ethereum address of the entry to remove from the registry\r\n     * @param _cid The IPFS hash of the entry to remove from the registry; used only for radspec here\r\n     */\r\n    function removeEntry(address _addr, string _cid) external entryExists(_addr) auth(REMOVE_ENTRY_ROLE) {\r\n        require(keccak256(bytes(_cid)) == keccak256(bytes(entries[_addr].data)), ERROR_NO_CID);\r\n        uint256 rowToDelete = entries[_addr].index;\r\n        if (entryArrLength != 1) {\r\n            address entryToMove = entryArr[entryArrLength - 1];\r\n            entryArr[rowToDelete] = entryToMove;\r\n            entries[entryToMove].index = rowToDelete;\r\n        }\r\n        delete entries[_addr];\r\n        // Doesn't require underflow checking because entry existence is verified\r\n        entryArrLength--;\r\n        emit EntryRemoved(_addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Update `_addr` from current metadata `_oldCid` to new metadata `_newCid`\r\n     * @dev this function only supports CIDs that are base58-encoded\r\n     * @param _addr The Ethereum address of the entry to update\r\n     * @param _oldCid The current IPFS hash containing the metadata of the entry\r\n     * @param _newCid The new IPFS hash containing the metadata of the entry\r\n     */\r\n    function updateEntry(\r\n        address _addr,\r\n        string _oldCid,\r\n        string _newCid\r\n    ) external auth(UPDATE_ENTRY_ROLE) entryExists(_addr) cidIsValid(_newCid)\r\n    {\r\n        require(keccak256(bytes(_oldCid)) == keccak256(bytes(entries[_addr].data)), ERROR_NO_CID);\r\n        entries[_addr].data = _newCid;\r\n        emit EntryUpdated(_addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Get data associated to entry `_addr` from the registry.\r\n     * @dev getter for the entries mapping to IPFS data\r\n     * @param _addr The Ethereum address of the entry to get\r\n     * @return contentId pointing to the IPFS structured content object for the entry\r\n     */\r\n    function getEntry(address _addr) external view isInitialized returns (string contentId) {\r\n        contentId = entries[_addr].data;\r\n    }\r\n\r\n    /**\r\n     * @notice Get index associated to entry `_addr` from the registry.\r\n     * @dev getter for the entries mapping for an index in entryArr\r\n     * @param _addr The Ethereum address of the entry to get\r\n     * @return contentId pointing to the IPFS structured content object for the entry\r\n     */\r\n    function getEntryIndex(address _addr) external view isInitialized entryExists(_addr) returns (uint256 index) {\r\n        index = entries[_addr].index;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if `_entry` exists in the registry\r\n     * @param _entry the Ethereum address to check\r\n     * @return _repoId Id for entry in entryArr\r\n     */\r\n    function isEntryAdded(address _entry) public view returns (bool isAdded) {\r\n        if (entryArrLength == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (entries[_entry].index >= entryArrLength) {\r\n            return false;\r\n        }\r\n\r\n        return (entryArr[entries[_entry].index] == _entry);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/lib/math/SafeMath.sol\r\n\r\n// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\r\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/lib/math/SafeMath64.sol\r\n\r\n// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\r\n// Adapted for uint64, pragma ^0.4.24, and satisfying our linter rules\r\n// Also optimized the mul() implementation, see https://github.com/aragon/aragonOS/pull/417\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath64\r\n * @dev Math operations for uint64 with safety checks that revert on error\r\n */\r\nlibrary SafeMath64 {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH64_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH64_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH64_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH64_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        uint256 c = uint256(_a) * uint256(_b);\r\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\r\n\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint64 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint64 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        uint64 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/DepositableStorage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract DepositableStorage {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    // keccak256(\"aragonOS.depositableStorage.depositable\")\r\n    bytes32 internal constant DEPOSITABLE_POSITION = 0x665fd576fbbe6f247aff98f5c94a561e3f71ec2d3c988d56f12d342396c50cea;\r\n\r\n    function isDepositable() public view returns (bool) {\r\n        return DEPOSITABLE_POSITION.getStorageBool();\r\n    }\r\n\r\n    function setDepositable(bool _depositable) internal {\r\n        DEPOSITABLE_POSITION.setStorageBool(_depositable);\r\n    }\r\n}\r\n\r\n// File: @aragon/apps-vault/contracts/Vault.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Vault is EtherTokenConstant, AragonApp, DepositableStorage {\r\n    using SafeERC20 for ERC20;\r\n\r\n    bytes32 public constant TRANSFER_ROLE = keccak256(\"TRANSFER_ROLE\");\r\n\r\n    string private constant ERROR_DATA_NON_ZERO = \"VAULT_DATA_NON_ZERO\";\r\n    string private constant ERROR_NOT_DEPOSITABLE = \"VAULT_NOT_DEPOSITABLE\";\r\n    string private constant ERROR_DEPOSIT_VALUE_ZERO = \"VAULT_DEPOSIT_VALUE_ZERO\";\r\n    string private constant ERROR_TRANSFER_VALUE_ZERO = \"VAULT_TRANSFER_VALUE_ZERO\";\r\n    string private constant ERROR_SEND_REVERTED = \"VAULT_SEND_REVERTED\";\r\n    string private constant ERROR_VALUE_MISMATCH = \"VAULT_VALUE_MISMATCH\";\r\n    string private constant ERROR_TOKEN_TRANSFER_FROM_REVERTED = \"VAULT_TOKEN_TRANSFER_FROM_REVERT\";\r\n    string private constant ERROR_TOKEN_TRANSFER_REVERTED = \"VAULT_TOKEN_TRANSFER_REVERTED\";\r\n\r\n    event VaultTransfer(address indexed token, address indexed to, uint256 amount);\r\n    event VaultDeposit(address indexed token, address indexed sender, uint256 amount);\r\n\r\n    /**\r\n    * @dev On a normal send() or transfer() this fallback is never executed as it will be\r\n    *      intercepted by the Proxy (see aragonOS#281)\r\n    */\r\n    function () external payable isInitialized {\r\n        require(msg.data.length == 0, ERROR_DATA_NON_ZERO);\r\n        _deposit(ETH, msg.value);\r\n    }\r\n\r\n    /**\r\n    * @notice Initialize Vault app\r\n    * @dev As an AragonApp it needs to be initialized in order for roles (`auth` and `authP`) to work\r\n    */\r\n    function initialize() external onlyInit {\r\n        initialized();\r\n        setDepositable(true);\r\n    }\r\n\r\n    /**\r\n    * @notice Deposit `_value` `_token` to the vault\r\n    * @param _token Address of the token being transferred\r\n    * @param _value Amount of tokens being transferred\r\n    */\r\n    function deposit(address _token, uint256 _value) external payable isInitialized {\r\n        _deposit(_token, _value);\r\n    }\r\n\r\n    /**\r\n    * @notice Transfer `_value` `_token` from the Vault to `_to`\r\n    * @param _token Address of the token being transferred\r\n    * @param _to Address of the recipient of tokens\r\n    * @param _value Amount of tokens being transferred\r\n    */\r\n    /* solium-disable-next-line function-order */\r\n    function transfer(address _token, address _to, uint256 _value)\r\n        external\r\n        authP(TRANSFER_ROLE, arr(_token, _to, _value))\r\n    {\r\n        require(_value > 0, ERROR_TRANSFER_VALUE_ZERO);\r\n\r\n        if (_token == ETH) {\r\n            require(_to.send(_value), ERROR_SEND_REVERTED);\r\n        } else {\r\n            require(ERC20(_token).safeTransfer(_to, _value), ERROR_TOKEN_TRANSFER_REVERTED);\r\n        }\r\n\r\n        emit VaultTransfer(_token, _to, _value);\r\n    }\r\n\r\n    function balance(address _token) public view returns (uint256) {\r\n        if (_token == ETH) {\r\n            return address(this).balance;\r\n        } else {\r\n            return ERC20(_token).staticBalanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Disable recovery escape hatch, as it could be used\r\n    *      maliciously to transfer funds away from the vault\r\n    */\r\n    function allowRecoverability(address) public view returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function _deposit(address _token, uint256 _value) internal {\r\n        require(isDepositable(), ERROR_NOT_DEPOSITABLE);\r\n        require(_value > 0, ERROR_DEPOSIT_VALUE_ZERO);\r\n\r\n        if (_token == ETH) {\r\n            // Deposit is implicit in this case\r\n            require(msg.value == _value, ERROR_VALUE_MISMATCH);\r\n        } else {\r\n            require(\r\n                ERC20(_token).safeTransferFrom(msg.sender, address(this), _value),\r\n                ERROR_TOKEN_TRANSFER_FROM_REVERTED\r\n            );\r\n        }\r\n\r\n        emit VaultDeposit(_token, msg.sender, _value);\r\n    }\r\n}\r\n\r\n// File: @tps/apps-allocations/contracts/Allocations.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer: GPL-3.0-or-later\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Allocations is AragonApp {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n    using SafeERC20 for ERC20;\r\n\r\n    bytes32 public constant CREATE_ACCOUNT_ROLE = 0x9b9e262b9ea0587fdc5926b22b8ed5837efef4f4cc67bc1a7ee18f68ad83062f;\r\n    bytes32 public constant CREATE_ALLOCATION_ROLE = 0x8af1e3d6225e5adff5174a4949cb3cc04f0f62937083325a9e302eaf5d07cdf1;\r\n    bytes32 public constant EXECUTE_ALLOCATION_ROLE = 0x1ced0be26d1bb2db7a1a0a01064be22894ce4ca0321b6f4b28d0b1a5ce62e7ea;\r\n    bytes32 public constant EXECUTE_PAYOUT_ROLE = 0xa5cf757319c734091fd95cf4b09938ff69ee22637eda897ea92ca59e56f00bcb;\r\n    bytes32 public constant CHANGE_PERIOD_ROLE = 0xd35e458bacdd5343c2f050f574554b2f417a8ea38d6a9a65ce2225dbe8bb9a9d;\r\n    bytes32 public constant CHANGE_BUDGETS_ROLE = 0xd79730e82bfef7d2f9639b9d10bf37ebb662b22ae2211502a00bdf7b2cc3a23a;\r\n    bytes32 public constant SET_MAX_CANDIDATES_ROLE = 0xe593f1908655effa3e2eb1eab075684bd646a51d97f20646bb9ecb2df3e4f2bb;\r\n\r\n    uint256 internal constant MAX_UINT256 = uint256(-1);\r\n    uint64 internal constant MAX_UINT64 = uint64(-1);\r\n    uint64 internal constant MINIMUM_PERIOD = uint64(1 days);\r\n    uint256 internal constant MAX_SCHEDULED_PAYOUTS_PER_TX = 20;\r\n\r\n    string private constant ERROR_NO_PERIOD = \"NO_PERIOD\";\r\n    string private constant ERROR_NO_ACCOUNT = \"NO_ACCOUNT\";\r\n    string private constant ERROR_NO_PAYOUT = \"NO_PAYOUT\";\r\n    string private constant ERROR_NO_CANDIDATE = \"NO_CANDIDATE\";\r\n    string private constant ERROR_PERIOD_SHORT = \"SET_PERIOD_TOO_SHORT\";\r\n    string private constant ERROR_COMPLETE_TRANSITION = \"COMPLETE_TRANSITION\";\r\n    string private constant ERROR_MIN_RECURRENCE = \"RECURRENCES_BELOW_ONE\";\r\n    string private constant ERROR_CANDIDATE_NOT_RECEIVER = \"CANDIDATE_NOT_RECEIVER\";\r\n    string private constant ERROR_INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\";\r\n\r\n    struct Payout {\r\n        uint64 startTime;\r\n        uint64 recurrences;\r\n        uint64 period;\r\n        address[] candidateAddresses;\r\n        uint256[] supports;\r\n        uint64[] executions;\r\n        uint256 amount;\r\n        string description;\r\n    }\r\n\r\n    struct Account {\r\n        uint64 payoutsLength;\r\n        bool hasBudget;\r\n        address token;\r\n        mapping (uint64 => Payout) payouts;\r\n        string metadata;\r\n        uint256 budget;\r\n    }\r\n\r\n    struct AccountStatement {\r\n        mapping(address => uint256) expenses;\r\n    }\r\n\r\n    struct Period {\r\n        uint64 startTime;\r\n        uint64 endTime;\r\n        mapping (uint256 => AccountStatement) accountStatement;\r\n    }\r\n\r\n    uint64 accountsLength;\r\n    uint64 periodsLength;\r\n    uint64 periodDuration;\r\n    uint256 maxCandidates;\r\n    Vault public vault;\r\n    mapping (uint64 => Account) accounts;\r\n    mapping (uint64 => Period) periods;\r\n    mapping(address => uint) accountProxies; // proxy address -> account Id\r\n\r\n    event PayoutExecuted(uint64 accountId, uint64 payoutId, uint candidateId);\r\n    event NewAccount(uint64 accountId);\r\n    event NewPeriod(uint64 indexed periodId, uint64 periodStarts, uint64 periodEnds);\r\n    event FundAccount(uint64 accountId);\r\n    event SetDistribution(uint64 accountId, uint64 payoutId);\r\n    event PaymentFailure(uint64 accountId, uint64 payoutId, uint256 candidateId);\r\n    event SetBudget(uint256 indexed accountId, uint256 amount, string name, bool hasBudget);\r\n    event ChangePeriodDuration(uint64 newDuration);\r\n\r\n    modifier periodExists(uint64 _periodId) {\r\n        require(_periodId < periodsLength, ERROR_NO_PERIOD);\r\n        _;\r\n    }\r\n\r\n    modifier accountExists(uint64 _accountId) {\r\n        require(_accountId < accountsLength, ERROR_NO_ACCOUNT);\r\n        _;\r\n    }\r\n\r\n    modifier payoutExists(uint64 _accountId, uint64 _payoutId) {\r\n        require(_payoutId < accounts[_accountId].payoutsLength, ERROR_NO_PAYOUT);\r\n        _;\r\n    }\r\n\r\n    // Modifier used by all methods that impact accounting to make sure accounting period\r\n    // is changed before the operation if needed\r\n    // NOTE: its use **MUST** be accompanied by an initialization check\r\n    modifier transitionsPeriod {\r\n        require(\r\n            _tryTransitionAccountingPeriod(getMaxPeriodTransitions()),\r\n            ERROR_COMPLETE_TRANSITION\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev On initialization the contract sets a vault, and initializes the periods\r\n    *      and accounts.\r\n    * @param _vault The Aragon vault to pull payments from.\r\n    * @param _periodDuration Base duration of a \"period\" used for value calculations.\r\n    */\r\n    function initialize(\r\n        Vault _vault,\r\n        uint64 _periodDuration\r\n    ) external onlyInit\r\n    {\r\n        vault = _vault;\r\n        require(_periodDuration >= MINIMUM_PERIOD, ERROR_PERIOD_SHORT);\r\n        periodDuration = _periodDuration;\r\n        _newPeriod(getTimestamp64());\r\n        accountsLength++;  // position 0 is reserved and unused\r\n        maxCandidates = 50;\r\n        initialized();\r\n    }\r\n\r\n///////////////////////\r\n// Getter functions\r\n///////////////////////\r\n    /** @notice Basic getter for accounts.\r\n    *   @param _accountId The budget ID you'd like to get.\r\n    */\r\n    function getAccount(uint64 _accountId) external view accountExists(_accountId) isInitialized\r\n    returns(string metadata, address token, bool hasBudget, uint256 budget)\r\n    {\r\n        Account storage account = accounts[_accountId];\r\n        metadata = account.metadata;\r\n        token = account.token;\r\n        hasBudget = account.hasBudget;\r\n        budget = account.budget;\r\n    }\r\n\r\n    /** @notice Basic getter for Allocations.\r\n    *   @param _accountId The ID of the budget.\r\n    *   @param _payoutId The ID of the allocation within the budget you'd like to retrieve.\r\n    */\r\n    function getPayout(uint64 _accountId, uint64 _payoutId) external view payoutExists(_accountId, _payoutId) isInitialized\r\n    returns(uint amount, uint64 recurrences, uint startTime, uint period)\r\n    {\r\n        Payout storage payout = accounts[_accountId].payouts[_payoutId];\r\n        amount = payout.amount;\r\n        recurrences = payout.recurrences;\r\n        startTime = payout.startTime;\r\n        period = payout.period;\r\n    }\r\n\r\n    /**\r\n    * @notice get the account's remaining budget for the current period\r\n    * @param _accountId The account ID of the budget remaining to be calculated\r\n    */\r\n    function getRemainingBudget(uint64 _accountId) external view accountExists(_accountId)\r\n    returns(uint256)\r\n    {\r\n        return _getRemainingBudget(_accountId);\r\n    }\r\n\r\n    /** @notice Basic getter for Allocation descriptions.\r\n    *   @param _accountId The Id of the budget.\r\n    *   @param _payoutId The Id of the allocation within the budget.\r\n    */\r\n    function getPayoutDescription(uint64 _accountId, uint64 _payoutId)\r\n    external\r\n    view\r\n    payoutExists(_accountId, _payoutId)\r\n    isInitialized\r\n    returns(string description)\r\n    {\r\n        Payout storage payout = accounts[_accountId].payouts[_payoutId];\r\n        description = payout.description;\r\n    }\r\n\r\n    /** @notice Basic getter for getting the number of options in an Allocation.\r\n    *   @param _accountId The Id of the budget.\r\n    *   @param _payoutId The Id of the allocation within the budget.\r\n    */\r\n    function getNumberOfCandidates(uint64 _accountId, uint64 _payoutId) external view isInitialized payoutExists(_accountId, _payoutId)\r\n    returns(uint256 numCandidates)\r\n    {\r\n        Payout storage payout = accounts[_accountId].payouts[_payoutId];\r\n        numCandidates = payout.supports.length;\r\n    }\r\n\r\n    /** @notice Basic getter for Allocation value for a specific recipient.\r\n    *   @param _accountId The Id of the budget.\r\n    *   @param _payoutId The Id of the allocation within the budget.\r\n    *   @param _idx The Id of the specific recipient you'd like to retrieve information for.\r\n    */\r\n    function getPayoutDistributionValue(uint64 _accountId, uint64 _payoutId, uint256 _idx)\r\n    external\r\n    view\r\n    isInitialized\r\n    payoutExists(_accountId, _payoutId)\r\n    returns(uint256 supports, address candidateAddress, uint64 executions)\r\n    {\r\n        Payout storage payout = accounts[_accountId].payouts[_payoutId];\r\n        require(_idx < payout.supports.length, ERROR_NO_CANDIDATE);\r\n        supports = payout.supports[_idx];\r\n        candidateAddress = payout.candidateAddresses[_idx];\r\n        executions = payout.executions[_idx];\r\n    }\r\n\r\n    /**\r\n    * @dev We have to check for initialization as periods are only valid after initializing\r\n    */\r\n    function getCurrentPeriodId() external view isInitialized returns (uint64) {\r\n        return _currentPeriodId();\r\n    }\r\n\r\n    /** @notice Basic getter for period information.\r\n    *   @param _periodId The Id of the period you'd like to receive information for.\r\n    */\r\n    function getPeriod(uint64 _periodId)\r\n    external\r\n    view\r\n    isInitialized\r\n    periodExists(_periodId)\r\n    returns (\r\n        bool isCurrent,\r\n        uint64 startTime,\r\n        uint64 endTime\r\n    )\r\n    {\r\n        Period storage period = periods[_periodId];\r\n\r\n        isCurrent = _currentPeriodId() == _periodId;\r\n\r\n        startTime = period.startTime;\r\n        endTime = period.endTime;\r\n    }\r\n\r\n///////////////////////\r\n// Allocation functions\r\n///////////////////////\r\n    /**\r\n    * @dev This is the function that sets up a budget for creating allocations.\r\n    * @notice Create \"`_metadata`\" budget of `@tokenAmount(_token, _budget)` per period.\r\n    * @param _metadata The budget description\r\n    * @param _token Token used for account payouts.\r\n    * @param _hasBudget Whether the account uses budgeting.\r\n    * @param _budget The budget amount\r\n    */\r\n    function newAccount(\r\n        string _metadata,\r\n        address _token,\r\n        bool _hasBudget,\r\n        uint256 _budget\r\n    ) external auth(CREATE_ACCOUNT_ROLE) returns(uint64 accountId)\r\n    {\r\n        accountId = accountsLength++;\r\n        Account storage account = accounts[accountId];\r\n        account.metadata = _metadata;\r\n        account.hasBudget = _hasBudget;\r\n        account.budget = _budget;\r\n        account.token = _token;\r\n        emit NewAccount(accountId);\r\n    }\r\n\r\n    /**\r\n    * @notice Change period duration to `@transformTime(_periodDuration)`, effective for next accounting period\r\n    * @param _periodDuration Duration in seconds for accounting periods\r\n    */\r\n    function setPeriodDuration(uint64 _periodDuration)\r\n        external\r\n        auth(CHANGE_PERIOD_ROLE)\r\n        transitionsPeriod\r\n    {\r\n        require(_periodDuration >= MINIMUM_PERIOD, ERROR_PERIOD_SHORT);\r\n        periodDuration = _periodDuration;\r\n        emit ChangePeriodDuration(_periodDuration);\r\n    }\r\n\r\n    /**\r\n    * @notice Set the maximum number of candidates that can be paid out in an allocation to `_maxCandidates`.\r\n    * @param _maxCandidates Maximum number of Candidates\r\n    */\r\n    function setMaxCandidates(uint256 _maxCandidates) external auth(SET_MAX_CANDIDATES_ROLE) {\r\n        maxCandidates = _maxCandidates;\r\n    }\r\n\r\n    /**\r\n    * @notice `_amount == 0 ? 'Deactivate ' + _metadata + ' budget (#' + _accountId + ')' : 'Update budget #' + _accountId + ' to ' + @tokenAmount(0x0000000000000000000000000000000000000000, _amount, false) + ', effective immediately and optionally update metadata'`\r\n    * @param _accountId Budget Identifier\r\n    * @param _amount New budget amount\r\n    * @param _metadata descriptor for the account (pass in empty string if unchanged)\r\n    */\r\n    function setBudget(\r\n        uint64 _accountId,\r\n        uint256 _amount,\r\n        string _metadata\r\n    )\r\n        external\r\n        auth(CHANGE_BUDGETS_ROLE)\r\n        transitionsPeriod\r\n        accountExists(_accountId)\r\n    {\r\n        accounts[_accountId].budget = _amount;\r\n        // only access storage if necessary\r\n        if (bytes(_metadata).length > 0) {\r\n            accounts[_accountId].metadata = _metadata;\r\n        }\r\n        if (!accounts[_accountId].hasBudget) {\r\n            accounts[_accountId].hasBudget = true;\r\n        }\r\n        emit SetBudget(_accountId, _amount, _metadata, true);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove budget #`_accountId`, effective immediately and optionally update budget name.\r\n    * @param _accountId Id for the budget.\r\n    * @param _metadata descriptor for account (pass in empty string if unchanged)\r\n    */\r\n    function removeBudget(uint64 _accountId, string _metadata)\r\n        external\r\n        auth(CHANGE_BUDGETS_ROLE)\r\n        transitionsPeriod\r\n        accountExists(_accountId)\r\n    {\r\n        accounts[_accountId].budget = 0;\r\n        accounts[_accountId].hasBudget = false;\r\n        // only access storage if necessary\r\n        if (bytes(_metadata).length > 0) {\r\n            accounts[_accountId].metadata = _metadata;\r\n        }\r\n        emit SetBudget(_accountId, 0, _metadata, false);\r\n    }\r\n\r\n    /**\r\n    * @notice This transaction will execute the allocation for the senders address for budget #`_accountId`\r\n    * @param _accountId The Id of the budget you'd like to take action against\r\n    * @param _payoutId The Id of the allocation within the budget you'd like to execute\r\n    * @param _candidateId The Candidate whose allocation you'll execute (must be sender)\r\n    */\r\n    function candidateExecutePayout(\r\n        uint64 _accountId,\r\n        uint64 _payoutId,\r\n        uint256 _candidateId\r\n    ) external transitionsPeriod isInitialized accountExists(_accountId) payoutExists(_accountId, _payoutId) // solium-disable-line error-reason\r\n    {\r\n        //Payout storage payout = accounts[_accountId].payouts[_payoutId];\r\n        require(msg.sender == accounts[_accountId].payouts[_payoutId].candidateAddresses[_candidateId], ERROR_CANDIDATE_NOT_RECEIVER);\r\n        _executePayoutAtLeastOnce(_accountId, _payoutId, _candidateId, 0);\r\n    }\r\n\r\n    /**\r\n    * @notice This transaction will execute the allocation for candidate `_candidateId` within budget #`_accountId`\r\n    * @param _accountId The Id of the budget you'd like to take action against\r\n    * @param _payoutId The Id of the allocation within the budget you'd like to execute\r\n    * @param _candidateId The Candidate whose allocation you'll execute (must be sender)\r\n    */\r\n    function executePayout(\r\n        uint64 _accountId,\r\n        uint64 _payoutId,\r\n        uint256 _candidateId\r\n    ) external transitionsPeriod auth(EXECUTE_PAYOUT_ROLE) accountExists(_accountId) payoutExists(_accountId, _payoutId)\r\n    {\r\n        _executePayoutAtLeastOnce(_accountId, _payoutId, _candidateId, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev This function distributes the allocations to the candidates in accordance with the distribution values\r\n    * @notice Distribute allocation #`_payoutId` from budget #`_accountId`.\r\n    * @param _accountId The Id of the budget you'd like to take action against\r\n    * @param _payoutId The Id of the allocation within the budget you'd like to execute\r\n    */\r\n    function runPayout(uint64 _accountId, uint64 _payoutId)\r\n    external\r\n    auth(EXECUTE_ALLOCATION_ROLE)\r\n    transitionsPeriod\r\n    accountExists(_accountId)\r\n    payoutExists(_accountId, _payoutId)\r\n    returns(bool success)\r\n    {\r\n        success = _runPayout(_accountId, _payoutId);\r\n    }\r\n\r\n    /**\r\n    * @dev This function is provided to circumvent situations where the transition period\r\n    *      becomes impossible to execute\r\n    * @param _limit Maximum number of periods to advance in this execution\r\n    */\r\n    function advancePeriod(uint64 _limit) external isInitialized {\r\n        _tryTransitionAccountingPeriod(_limit);\r\n    }\r\n\r\n    /**\r\n    * @dev This is the function that the DotVote will call. It doesn’t need\r\n    *      to be called by a DotVote (options get weird if it's not)\r\n    *      but for our use case the “CREATE_ALLOCATION_ROLE” will be given to\r\n    *      the DotVote. This function is public for stack-depth reasons\r\n    * @notice Create an allocation from budget #`_accountId` for \"`_description`\" `(_recurrences > 1) ? 'that will execute ' + _recurrences + ' times': ''`.\r\n    * @param _candidateAddresses Array of potential addresses receiving a share of the allocation.\r\n    * @param _supports The Array of all support values for the various candidates. These values are set in dot voting.\r\n    * @param _description The distribution description\r\n    * @param _accountId The Id of the budget used for the allocation\r\n    * @param _recurrences Quantity used to indicate whether this is a recurring or one-time payout\r\n    * @param _period Time interval between each recurring allocation\r\n    * @param _amount The quantity of funds to be allocated\r\n    */\r\n    function setDistribution(\r\n        address[] _candidateAddresses,\r\n        uint256[] _supports,\r\n        uint256[] /*unused_infoIndices*/,\r\n        string /*unused_candidateInfo*/,\r\n        string _description,\r\n        uint256[] /*unused_level 1 ID - converted to bytes32*/,\r\n        uint256[] /*unused_level 2 ID - converted to bytes32*/,\r\n        uint64 _accountId,\r\n        uint64 _recurrences,\r\n        uint64 _startTime,\r\n        uint64 _period,\r\n        uint256 _amount\r\n    ) public auth(CREATE_ALLOCATION_ROLE) returns(uint64 payoutId)\r\n    {\r\n        require(maxCandidates >= _candidateAddresses.length); // solium-disable-line error-reason\r\n        Account storage account = accounts[_accountId];\r\n        require(vault.balance(account.token) >= _amount * _recurrences); // solium-disable-line error-reason\r\n        require(_recurrences > 0, ERROR_MIN_RECURRENCE);\r\n\r\n        Payout storage payout = account.payouts[account.payoutsLength++];\r\n\r\n        payout.amount = _amount;\r\n        payout.recurrences = _recurrences;\r\n        payout.candidateAddresses = _candidateAddresses;\r\n        if (_recurrences > 1) {\r\n            payout.period = _period;\r\n            // minimum granularity is a single day\r\n            require(payout.period >= 1 days, ERROR_PERIOD_SHORT);\r\n        }\r\n        payout.startTime = _startTime; // solium-disable-line security/no-block-members\r\n        payout.supports = _supports;\r\n        payout.description = _description;\r\n        payout.executions.length = _supports.length;\r\n        payoutId = account.payoutsLength - 1;\r\n        emit SetDistribution(_accountId, payoutId);\r\n        if (_startTime <= getTimestamp64()) {\r\n            _runPayout(_accountId, payoutId);\r\n        }\r\n    }\r\n\r\n    function _executePayoutAtLeastOnce(\r\n        uint64 _accountId,\r\n        uint64 _payoutId,\r\n        uint256 _candidateId,\r\n        uint256 _paid\r\n    )\r\n        internal accountExists(_accountId) returns (uint256)\r\n    {\r\n        Account storage account = accounts[_accountId];\r\n        Payout storage payout = account.payouts[_payoutId];\r\n        require(_candidateId < payout.supports.length, ERROR_NO_CANDIDATE);\r\n\r\n        uint256 paid = _paid;\r\n        uint256 totalSupport = _getTotalSupport(payout);\r\n\r\n        uint256 individualPayout = payout.supports[_candidateId].mul(payout.amount).div(totalSupport);\r\n        if (individualPayout == 0) {\r\n            return;\r\n        }\r\n        while (_nextPaymentTime(_accountId, _payoutId, _candidateId) <= getTimestamp64() && paid < MAX_SCHEDULED_PAYOUTS_PER_TX) {\r\n            if (!_canMakePayment(_accountId, individualPayout)) {\r\n                emit PaymentFailure(_accountId, _payoutId, _candidateId);\r\n                break;\r\n            }\r\n\r\n            // The while() predicate prevents these two from ever overflowing\r\n            paid += 1;\r\n\r\n            // We've already checked the remaining budget with `_canMakePayment()`\r\n            _executeCandidatePayout(_accountId, _payoutId, _candidateId, totalSupport);\r\n        }\r\n        return paid;\r\n    }\r\n\r\n    function _newPeriod(uint64 _startTime) internal returns (Period storage) {\r\n        // There should be no way for this to overflow since each period is at least one day\r\n        uint64 newPeriodId = periodsLength++;\r\n\r\n        Period storage period = periods[newPeriodId];\r\n        period.startTime = _startTime;\r\n\r\n        // Be careful here to not overflow; if startTime + periodDuration overflows, we set endTime\r\n        // to MAX_UINT64 (let's assume that's the end of time for now).\r\n        uint64 endTime = _startTime + periodDuration - 1;\r\n        if (endTime < _startTime) { // overflowed\r\n            endTime = MAX_UINT64;\r\n        }\r\n        period.endTime = endTime;\r\n\r\n        emit NewPeriod(newPeriodId, period.startTime, period.endTime);\r\n\r\n        return period;\r\n    }\r\n\r\n    function _tryTransitionAccountingPeriod(uint64 _maxTransitions) internal returns (bool success) {\r\n        Period storage currentPeriod = periods[_currentPeriodId()];\r\n        uint64 maxTransitions = _maxTransitions;\r\n        uint64 timestamp = getTimestamp64();\r\n\r\n        // Transition periods if necessary\r\n        while (timestamp > currentPeriod.endTime) {\r\n            if (maxTransitions == 0) {\r\n                // Required number of transitions is over allowed number, return false indicating\r\n                // it didn't fully transition\r\n                return false;\r\n            }\r\n            // We're already protected from underflowing above\r\n            maxTransitions -= 1;\r\n\r\n            currentPeriod = _newPeriod(currentPeriod.endTime.add(1));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _currentPeriodId() internal view returns (uint64) {\r\n        // There is no way for this to overflow if protected by an initialization check\r\n        return periodsLength - 1;\r\n    }\r\n\r\n    function _canMakePayment(uint64 _accountId, uint256 _amount) internal view returns (bool) {\r\n        Account storage account = accounts[_accountId];\r\n        return _getRemainingBudget(_accountId) >= _amount && vault.balance(account.token) >= _amount && _amount > 0;\r\n    }\r\n\r\n    function _getRemainingBudget(uint64 _accountId) internal view returns (uint256) {\r\n        Account storage account = accounts[_accountId];\r\n        if (!account.hasBudget) {\r\n            return MAX_UINT256;\r\n        }\r\n\r\n        uint256 budget = account.budget;\r\n        uint256 spent = periods[_currentPeriodId()].accountStatement[_accountId].expenses[account.token];\r\n\r\n        // A budget decrease can cause the spent amount to be greater than period budget\r\n        // If so, return 0 to not allow more spending during period\r\n        if (spent >= budget) {\r\n            return 0;\r\n        }\r\n\r\n        // We're already protected from the overflow above\r\n        return budget - spent;\r\n    }\r\n\r\n    function _runPayout(uint64 _accountId, uint64 _payoutId) internal returns(bool success) {\r\n        Account storage account = accounts[_accountId];\r\n        uint256[] storage supports = account.payouts[_payoutId].supports;\r\n        uint64 i;\r\n        uint256 paid = 0;\r\n        uint256 length = account.payouts[_payoutId].candidateAddresses.length;\r\n        //handle vault\r\n        for (i = 0; i < length; i++) {\r\n            if (supports[i] != 0 && _nextPaymentTime(_accountId, _payoutId, i) <= getTimestamp64()) {\r\n                paid = _executePayoutAtLeastOnce(_accountId, _payoutId, i, paid);\r\n            } else {\r\n                emit PaymentFailure(_accountId, _payoutId, i);\r\n            }\r\n        }\r\n        success = true;\r\n    }\r\n\r\n    function _getTotalSupport(Payout storage payout) internal view returns (uint256 totalSupport) {\r\n        for (uint256 i = 0; i < payout.supports.length; i++) {\r\n            totalSupport += payout.supports[i];\r\n        }\r\n    }\r\n\r\n    function _nextPaymentTime(uint64 _accountId, uint64 _payoutId, uint256 _candidateIndex) internal view returns (uint64) {\r\n        Account storage account = accounts[_accountId];\r\n        Payout storage payout = account.payouts[_payoutId];\r\n\r\n        if (payout.executions[_candidateIndex] >= payout.recurrences) {\r\n            return MAX_UINT64; // re-executes in some billions of years time... should not need to worry\r\n        }\r\n\r\n        // Split in multiple lines to circumvent linter warning\r\n        uint64 increase = payout.executions[_candidateIndex].mul(payout.period);\r\n        uint64 nextPayment = payout.startTime.add(increase);\r\n        return nextPayment;\r\n    }\r\n\r\n    function _executeCandidatePayout(\r\n        uint64 _accountId,\r\n        uint64 _payoutId,\r\n        uint256 _candidateIndex,\r\n        uint256 _totalSupport\r\n    ) internal\r\n    {\r\n        Account storage account = accounts[_accountId];\r\n        Payout storage payout = account.payouts[_payoutId];\r\n        uint256 individualPayout = payout.supports[_candidateIndex].mul(payout.amount).div(_totalSupport);\r\n        require(_canMakePayment(_accountId, individualPayout), ERROR_INSUFFICIENT_FUNDS);\r\n\r\n        address token = account.token;\r\n        uint256 expenses = periods[_currentPeriodId()].accountStatement[_accountId].expenses[token];\r\n        periods[_currentPeriodId()].accountStatement[_accountId].expenses[token] = expenses.add(individualPayout);\r\n        payout.executions[_candidateIndex] = payout.executions[_candidateIndex].add(1);\r\n        vault.transfer(token, payout.candidateAddresses[_candidateIndex], individualPayout);\r\n        emit PayoutExecuted(_accountId, _payoutId, _candidateIndex);\r\n    }\r\n\r\n    // Mocked fns (overrided during testing)\r\n    // Must be view for mocking purposes\r\n\r\n    function getMaxPeriodTransitions() internal view returns (uint64) { return MAX_UINT64; }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/IForwarder.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IForwarder {\r\n    function isForwarder() external pure returns (bool);\r\n\r\n    // TODO: this should be external\r\n    // See https://github.com/ethereum/solidity/issues/4832\r\n    function canForward(address sender, bytes evmCallScript) public view returns (bool);\r\n\r\n    // TODO: this should be external\r\n    // See https://github.com/ethereum/solidity/issues/4832\r\n    function forward(bytes evmCallScript) public;\r\n}\r\n\r\n// File: @tps/apps-discussions/contracts/DiscussionApp.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract DiscussionApp is IForwarder, AragonApp {\r\n    using SafeMath for uint256;\r\n\r\n    event Post(address indexed author, string postCid, uint256 discussionThreadId, uint256 postId, uint256 createdAt);\r\n    event Revise(\r\n        address indexed author,\r\n        string revisedPostCid,\r\n        uint256 discussionThreadId,\r\n        uint256 postId,\r\n        uint256 createdAt,\r\n        uint256 revisedAt\r\n    );\r\n    event Hide(address indexed author, uint256 discussionThreadId, uint256 postId, uint256 hiddenAt);\r\n    event CreateDiscussionThread(uint256 actionId, bytes _evmScript);\r\n\r\n    bytes32 public constant EMPTY_ROLE = keccak256(\"EMPTY_ROLE\");\r\n\r\n    string private constant ERROR_CAN_NOT_FORWARD = \"DISCUSSIONS_CAN_NOT_FORWARD\";\r\n\r\n    struct DiscussionPost {\r\n        address author;\r\n        string postCid;\r\n        uint256 discussionThreadId;\r\n        uint256 id;\r\n        uint256 createdAt;\r\n        bool show;\r\n        string[] revisionCids;\r\n    }\r\n\r\n    uint256 discussionThreadId;\r\n\r\n    mapping(uint256 => DiscussionPost[]) public discussionThreadPosts;\r\n\r\n    function initialize() external onlyInit {\r\n        discussionThreadId = 0;\r\n        initialized();\r\n    }\r\n\r\n    /**\r\n     * @notice Create discussion post with an IPFS content hash '`postCid`'.\r\n     * @param postCid The IPFS content hash of the discussion post data\r\n     * @param discussionThreadId The thread to post this discussion to\r\n     */\r\n    function post(string postCid, uint256 discussionThreadId) external {\r\n        DiscussionPost storage post;\r\n        post.author = msg.sender;\r\n        post.postCid = postCid;\r\n        post.discussionThreadId = discussionThreadId;\r\n        post.createdAt = now; // solium-disable-line security/no-block-members\r\n        post.show = true;\r\n        uint256 postId = discussionThreadPosts[discussionThreadId].length;\r\n        post.id = postId;\r\n        discussionThreadPosts[discussionThreadId].push(post);\r\n        emit Post(msg.sender, postCid, discussionThreadId, postId, now); // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n     * @notice Hide a discussion post with ID '`postId`'.\r\n     * @param postId The postId to hide\r\n     * @param discussionThreadId The thread to hide this discussion from\r\n     */\r\n    function hide(uint256 postId, uint256 discussionThreadId) external {\r\n        DiscussionPost storage post = discussionThreadPosts[discussionThreadId][postId];\r\n        require(post.author == msg.sender, \"You cannot hide a post you did not author.\");\r\n        post.show = false;\r\n        emit Hide(msg.sender, discussionThreadId, postId, now); // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n     * @notice Revise a discussion post with ID '`postId`'.\r\n     * @param revisedPostCid The cid of the pre-revised post\r\n     * @param postId The postId to revise\r\n     * @param discussionThreadId The thread to hide this discussion from\r\n     */\r\n    function revise(string revisedPostCid, uint256 postId, uint256 discussionThreadId) external {\r\n        DiscussionPost storage post = discussionThreadPosts[discussionThreadId][postId];\r\n        require(post.author == msg.sender, \"You cannot revise a post you did not author.\");\r\n        // add the current post to the revision history\r\n        // should we limit the number of revisions you can make to save storage?\r\n        post.revisionCids.push(post.postCid);\r\n        post.postCid = revisedPostCid;\r\n        emit Revise(\r\n            msg.sender,\r\n            revisedPostCid,\r\n            discussionThreadId,\r\n            postId,\r\n            post.createdAt,\r\n            now // solium-disable-line security/no-block-members\r\n        );\r\n    }\r\n\r\n    // Forwarding fns\r\n\r\n    /**\r\n    * @notice Tells whether the Discussion app is a forwarder or not\r\n    * @dev IForwarder interface conformance\r\n    * @return Always true\r\n    */\r\n    function isForwarder() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Creates a discussion thread around the desired action\r\n    * @dev IForwarder interface conformance\r\n    * @param _evmScript Start vote with script\r\n    */\r\n    function forward(bytes _evmScript) public {\r\n        require(canForward(msg.sender, _evmScript), ERROR_CAN_NOT_FORWARD);\r\n        bytes memory input = new bytes(0); // TODO: Consider input for this\r\n        address[] memory blacklist = new address[](1);\r\n        emit CreateDiscussionThread(discussionThreadId, _evmScript);\r\n        discussionThreadId = discussionThreadId + 1;\r\n        runScript(_evmScript, input, blacklist);\r\n    }\r\n\r\n    /**\r\n    * @notice Tells whether `_sender` can forward actions or not\r\n    * @dev IForwarder interface conformance\r\n    * @param _sender Address of the account intending to forward an action\r\n    * @return True (eventually we should return if the given address can create a discussion thread, false otherwise)\r\n    */\r\n    function canForward(address _sender, bytes) public view returns (bool) {\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: @tps/apps-projects/contracts/Projects.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer: GPL-3.0-or-later\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @title Bounties Interface\r\n  * @dev Defines a minimal interface blueprint for the StandardBounties contract\r\n  */\r\ninterface Bounties {\r\n    /**\r\n     * @notice Submit a fulfillment for issue #`_bountyId` with the following info: `_data`\r\n     */\r\n    function fulfillBounty(\r\n        address _sender,\r\n        uint _bountyId,\r\n        address[] _fulfillers,\r\n        string _data\r\n    ) external; //{}\r\n\r\n    /**\r\n     * @notice Update fulfillment for issue #`_bountyId` with the following info: `_data`\r\n     */\r\n    function updateFulfillment(\r\n        address _sender,\r\n        uint _bountyId,\r\n        uint _fulfillmentId,\r\n        address[] _fulfillers,\r\n        string _data\r\n    ) external; //{}\r\n\r\n    function issueBounty(\r\n        address sender,\r\n        address[] _issuers,\r\n        address[] _approvers,\r\n        string _data,\r\n        uint _deadline,\r\n        address _token,\r\n        uint _tokenVersion\r\n    ) external returns (uint);\r\n\r\n    function contribute(\r\n        address _sender,\r\n        uint _bountyId,\r\n        uint _amount\r\n    ) external payable;\r\n\r\n    function issueAndContribute(\r\n        address sender,\r\n        address[] _issuers,\r\n        address[] _approvers,\r\n        string _data,\r\n        uint _deadline,\r\n        address _token,\r\n        uint _tokenVersion,\r\n        uint _depositAmount\r\n    ) external payable returns (uint);\r\n\r\n    function performAction(\r\n        address _sender,\r\n        uint _bountyId,\r\n        string _data\r\n    ) external;\r\n\r\n    function acceptFulfillment(\r\n        address _sender,\r\n        uint _bountyId,\r\n        uint _fulfillmentId,\r\n        uint _approverId,\r\n        uint[] _tokenAmounts\r\n    ) external;\r\n\r\n    function drainBounty(\r\n        address _sender,\r\n        uint _bountyId,\r\n        uint _issuerId,\r\n        uint[] _amounts\r\n    ) external;\r\n\r\n    function changeDeadline(\r\n        address _sender,\r\n        uint _bountyId,\r\n        uint _issuerId,\r\n        uint _deadline\r\n    ) external;\r\n\r\n    function changeData(\r\n        address _sender,\r\n        uint _bountyId,\r\n        uint _issuerId,\r\n        string _data\r\n    ) external;\r\n}\r\n\r\n/**\r\n  * @title ERC20 Interface\r\n  * @dev Defines a minimal interface blueprint for ERC20 tokens interaction\r\n  */\r\ninterface ERC20Token {\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n}\r\n\r\n\r\n/**\r\n  * @title Projects App\r\n  * @author Autark\r\n  * @dev Defines a registry for project tasks in addition to\r\n  * applying bounties in bulk and accepting fulfillment via this contract\r\n  */\r\ncontract Projects is AragonApp, DepositableStorage {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    Bounties public bountiesRegistry;\r\n    BountySettings public settings;\r\n    Vault public vault;\r\n    // Auth roles\r\n    bytes32 public constant FUND_ISSUES_ROLE =  keccak256(\"FUND_ISSUES_ROLE\");\r\n    bytes32 public constant REMOVE_ISSUES_ROLE = keccak256(\"REMOVE_ISSUES_ROLE\");\r\n    bytes32 public constant ADD_REPO_ROLE = keccak256(\"ADD_REPO_ROLE\");\r\n    bytes32 public constant CHANGE_SETTINGS_ROLE =  keccak256(\"CHANGE_SETTINGS_ROLE\");\r\n    bytes32 public constant CURATE_ISSUES_ROLE = keccak256(\"CURATE_ISSUES_ROLE\");\r\n    bytes32 public constant REMOVE_REPO_ROLE =  keccak256(\"REMOVE_REPO_ROLE\");\r\n    bytes32 public constant REVIEW_APPLICATION_ROLE = keccak256(\"REVIEW_APPLICATION_ROLE\");\r\n    bytes32 public constant WORK_REVIEW_ROLE = keccak256(\"WORK_REVIEW_ROLE\");\r\n    bytes32 public constant FUND_OPEN_ISSUES_ROLE = keccak256(\"FUND_OPEN_ISSUES_ROLE\");\r\n    bytes32 public constant UPDATE_BOUNTIES_ROLE = keccak256(\"UPDATE_BOUNTIES_ROLE\");\r\n\r\n    string private constant ERROR_PROJECTS_VAULT_NOT_CONTRACT = \"PROJECTS_VAULT_NOT_CONTRACT\";\r\n    string private constant ERROR_STANDARD_BOUNTIES_NOT_CONTRACT = \"STANDARD_BOUNTIES_NOT_CONTRACT\";\r\n    string private constant ERROR_LENGTH_EXCEEDED = \"LENGTH_EXCEEDED\";\r\n    string private constant ERROR_LENGTH_MISMATCH = \"ARRAY_LENGTH_MISMATCH\";\r\n    string private constant ERROR_CID_LENGTH = \"IPFS_ADDRESSES_LENGTH\";\r\n    string private constant ERROR_ISSUE_INACTIVE = \"ISSUE_NOT_ACTIVE\";\r\n    string private constant ERROR_ISSUE_ACTIVE = \"ISSUE_HAS_BOUNTY\";\r\n    string private constant ERROR_BOUNTY_FULFILLED = \"BOUNTY_FULFILLED\";\r\n    string private constant ERROR_BOUNTY_REMOVED = \"BOUNTY_REMOVED\";\r\n    string private constant ERROR_INVALID_AMOUNT = \"INVALID_TOKEN_AMOUNT\";\r\n    string private constant ERROR_ETH_CONTRACT = \"WRONG_ETH_TOKEN\";\r\n    string private constant ERROR_REPO_MISSING = \"REPO_NOT_ADDED\";\r\n    string private constant ERROR_REPO_EXISTS = \"REPO_ALREADY_ADDED\";\r\n    string private constant ERROR_USER_APPLIED = \"USER_ALREADY_APPLIED\";\r\n    string private constant ERROR_NO_APPLICATION = \"USER_APPLICATION_MISSING\";\r\n    string private constant ERROR_NO_ERC721 = \"ERC_721_FORBIDDEN\";\r\n    string private constant ERROR_PENDING_BOUNTIES = \"REPO_HAS_PENDING_BOUNTIES\";\r\n    string private constant ERROR_OPEN_BOUNTY = \"CANNOT_ASSIGN_OPEN_BOUNTY\";\r\n\r\n\r\n    // IPFS length const\r\n    uint256 private constant CID_LENGTH = 46;\r\n\r\n    // The entries in the repos registry.\r\n    mapping(bytes32 => Repo) private repos;\r\n    // issue counter to track how many open issues a repo has\r\n    mapping (bytes32 => uint256) openBounties;\r\n    // Gives us a repos array-like contruct so we can both \"iterate\" and upgrade gracefully\r\n    mapping(uint256 => bytes32) private repoIndex;\r\n    uint256 private repoIndexLength;\r\n    enum SubmissionStatus { Unreviewed, Accepted, Rejected }  // 0: unreviewed 1: Accepted 2: Rejected\r\n\r\n    // Structs\r\n    struct BountySettings {\r\n        uint256[] expMultipliers;\r\n        bytes32[] expLevels;\r\n        uint256 baseRate;\r\n        uint256 bountyDeadline;\r\n        address bountyCurrency;\r\n    }\r\n\r\n    struct Repo {\r\n        mapping(uint256 => Issue) issues;\r\n        uint index;\r\n    }\r\n\r\n    struct AssignmentRequest {\r\n        SubmissionStatus status;\r\n        string requestHash; //IPFS hash of the application data\r\n        bool exists;\r\n    }\r\n\r\n    struct Issue {\r\n        bytes32 repo;  // This is the internal repo identifier\r\n        uint256 number; // May be redundant tracking this\r\n        bool hasBounty;\r\n        bool fulfilled;\r\n        address tokenContract;\r\n        uint256 bountySize;\r\n        uint256 priority;\r\n        address bountyWallet; // Not sure if we'll have a way to \"retrieve\" this value from status open bounties\r\n        uint standardBountyId;\r\n        address assignee;\r\n        address[] applicants;\r\n        //uint256 submissionQty;\r\n        uint256[] submissionIndices;\r\n        mapping(address => AssignmentRequest) assignmentRequests;\r\n    }\r\n\r\n    // Fired when a repository is added to the registry.\r\n    event RepoAdded(bytes32 indexed repoId, uint index);\r\n    // Fired when a repository is removed from the registry.\r\n    event RepoRemoved(bytes32 indexed repoId, uint index);\r\n    // Fired when a repo is updated in the registry\r\n    event RepoUpdated(bytes32 indexed repoId, uint newIndex);\r\n    // Fired when a bounty is added to a repo\r\n    event BountyAdded(bytes32 repoId, uint256 issueNumber, uint256 bountySize, uint256 registryId, string ipfsHash);\r\n    // Fired when a bounty is removed\r\n    event BountyRemoved(bytes32 repoId, uint256 issueNumber, uint256 oldBountySize);\r\n    // Fired when an issue is curated\r\n    event IssueCurated(bytes32 repoId);\r\n    // Fired when settings are changed\r\n    event BountySettingsChanged();\r\n    // Fired when user requests issue assignment\r\n    event AssignmentRequested(bytes32 indexed repoId, uint256 issueNumber);\r\n    // Fired when Task Manager approves assignment request\r\n    event AssignmentApproved(address applicant, bytes32 indexed repoId, uint256 issueNumber);\r\n    // Fired when Task Manager rejects assignment request\r\n    event AssignmentRejected(address applicant, bytes32 indexed repoId, uint256 issueNumber);\r\n    // Fired when a reviewer accepts accepts a submission\r\n    event SubmissionAccepted(uint256 submissionNumber, bytes32 repoId, uint256 issueNumber);\r\n    // Fired when a reviewer rejects a submission\r\n    event SubmissionRejected(uint256 submissionNumber, bytes32 repoId, uint256 issueNumber);\r\n    // Fired when a bounty is opened up to work submissions from anyone\r\n    event AwaitingSubmissions(bytes32 repoId, uint256 issueNumber);\r\n\r\n\r\n    /**\r\n     * @notice Initialize Projects app for StandardBounties at `_bountiesAddr`\r\n     * @dev Initializes the Projects app, this is the Aragon custom constructor\r\n     * @param _bountiesAddr Address of the StandardBounties deployed instance Projects will rely on (changeable)\r\n     * @param _vault Address of the vault Projects will rely on (non changeable)\r\n     */\r\n    function initialize(\r\n        address _bountiesAddr,\r\n        Vault _vault\r\n    ) external onlyInit\r\n    {\r\n        require(isContract(_vault), ERROR_PROJECTS_VAULT_NOT_CONTRACT);\r\n        require(isContract(_bountiesAddr), ERROR_STANDARD_BOUNTIES_NOT_CONTRACT);\r\n\r\n        vault = _vault;\r\n\r\n        bountiesRegistry = Bounties(_bountiesAddr); // Standard Bounties instance\r\n\r\n        _addExperienceLevel(100, bytes32(\"Beginner\"));\r\n        _addExperienceLevel(300, bytes32(\"Intermediate\"));\r\n        _addExperienceLevel(500, bytes32(\"Advanced\"));\r\n\r\n        _changeBountySettings(\r\n            0, // baseRate\r\n            336, // bountyDeadline\r\n            ETH, // default bounty currency inits to ETH\r\n            _bountiesAddr // bountyAllocator\r\n        );\r\n\r\n        setDepositable(true);\r\n        initialized();\r\n    }\r\n\r\n///////////////////////\r\n// Set state functions\r\n///////////////////////\r\n\r\n\r\n    /**\r\n     * @notice Update settings for the Projects app\r\n     */\r\n    function changeBountySettings(\r\n        uint256[] _expMultipliers,\r\n        bytes32[] _expLevels,\r\n        uint256 _baseRate,\r\n        uint256 _bountyDeadline,\r\n        address _bountyCurrency,\r\n        address _bountyAllocator\r\n    ) external auth(CHANGE_SETTINGS_ROLE)\r\n    {\r\n        require(_expMultipliers.length == _expLevels.length, ERROR_LENGTH_MISMATCH);\r\n        require(_isBountiesContractValid(_bountyAllocator), ERROR_STANDARD_BOUNTIES_NOT_CONTRACT);\r\n        settings.expLevels.length = 0;\r\n        settings.expMultipliers.length = 0;\r\n        for (uint i = 0; i < _expLevels.length; i++) {\r\n            _addExperienceLevel(_expMultipliers[i], _expLevels[i]);\r\n        }\r\n        _changeBountySettings(_baseRate, _bountyDeadline, _bountyCurrency, _bountyAllocator);\r\n    }\r\n\r\n///////////////////////\r\n// View state functions\r\n///////////////////////\r\n\r\n    /**\r\n     * @notice Get issue data from the registry.\r\n     * @param _repoId The id of the repo in the projects registry\r\n     */\r\n    function getIssue(bytes32 _repoId, uint256 _issueNumber) external view isInitialized\r\n    returns(bool hasBounty, uint standardBountyId, bool fulfilled, uint balance, address assignee)\r\n    {\r\n        Issue storage issue = repos[_repoId].issues[_issueNumber];\r\n        hasBounty = issue.hasBounty;\r\n        fulfilled = issue.fulfilled;\r\n        standardBountyId = issue.standardBountyId;\r\n        balance = issue.bountySize;\r\n        assignee = issue.assignee;\r\n    }\r\n\r\n    /**\r\n     * @notice Get registry size.\r\n     */\r\n    function getReposCount() external view isInitialized returns (uint count) {\r\n        return repoIndexLength;\r\n    }\r\n\r\n    /**\r\n     * @notice Get an entry from the registry.\r\n     * @param _repoId The id of the repo in the projects registry\r\n     * @return index the repo registry index\r\n     */\r\n    function getRepo(bytes32 _repoId) external view isInitialized returns (uint256 index, uint256 openIssueCount) {\r\n        require(isRepoAdded(_repoId), ERROR_REPO_MISSING);\r\n        index = repos[_repoId].index;\r\n        openIssueCount = openBounties[_repoId];\r\n    }\r\n\r\n    /**\r\n     * @notice Get general settings.\r\n     * @return BountySettings\r\n     */\r\n\r\n    function getSettings() external view isInitialized returns (\r\n        uint256[] expMultipliers,\r\n        bytes32[] expLevels,\r\n        uint256 baseRate,\r\n        uint256 bountyDeadline,\r\n        address bountyCurrency,\r\n        address bountyAllocator\r\n        //address bountyArbiter\r\n    )\r\n    {\r\n        return (\r\n            settings.expMultipliers,\r\n            settings.expLevels,\r\n            settings.baseRate,\r\n            settings.bountyDeadline,\r\n            settings.bountyCurrency,\r\n            bountiesRegistry\r\n            //settings.bountyArbiter\r\n        );\r\n    }\r\n\r\n///////////////////////\r\n// Repository functions\r\n///////////////////////\r\n    /**\r\n     * @notice Add repository\r\n     * @param _repoId The id of the repo in the projects registry\r\n     * @return index for the added repo at the registry\r\n     */\r\n    function addRepo(\r\n        bytes32 _repoId\r\n    ) external auth(ADD_REPO_ROLE) returns (uint index)\r\n    {\r\n        require(!isRepoAdded(_repoId), ERROR_REPO_EXISTS);\r\n        repoIndex[repoIndexLength] = _repoId;\r\n        repos[_repoId].index = repoIndexLength++;\r\n        //repos[_repoId].index = repoIndex.push(_repoId) - 1;\r\n        emit RepoAdded(_repoId, repos[_repoId].index);\r\n        return repoIndexLength - 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove repository\r\n     * @param _repoId The id of the repo in the projects registry\r\n     */\r\n    function removeRepo(\r\n        bytes32 _repoId\r\n    ) external auth(REMOVE_REPO_ROLE) returns (bool success)\r\n    {\r\n        require(isRepoAdded(_repoId), ERROR_REPO_MISSING);\r\n        require(openBounties[_repoId] == 0, ERROR_PENDING_BOUNTIES);\r\n        uint rowToDelete = repos[_repoId].index;\r\n\r\n        if (repoIndexLength != 1) {\r\n            bytes32 repoToMove = repoIndex[repoIndexLength - 1];\r\n            repoIndex[rowToDelete] = repoToMove;\r\n            repos[repoToMove].index = rowToDelete;\r\n        }\r\n\r\n        repoIndexLength--;\r\n        emit RepoRemoved(_repoId, rowToDelete);\r\n        return true;\r\n    }\r\n\r\n///////////////////\r\n// External Bounty functions\r\n///////////////////\r\n\r\n    /**\r\n     * @notice Submit application for issue `_issueNumber` with application `_application`\r\n     * @param _repoId the repo id of the issue\r\n     * @param _issueNumber the issue up for assignment\r\n     * @param _application IPFS hash for the applicant's proposed timeline and strategy\r\n     */\r\n    function requestAssignment(\r\n        bytes32 _repoId,\r\n        uint256 _issueNumber,\r\n        string _application\r\n    ) external isInitialized\r\n    {\r\n        Issue storage issue = repos[_repoId].issues[_issueNumber];\r\n\r\n        require(!issue.fulfilled,ERROR_BOUNTY_FULFILLED);\r\n        require(issue.hasBounty, ERROR_ISSUE_INACTIVE);\r\n        require(issue.assignee != address(-1), ERROR_OPEN_BOUNTY);\r\n        require(issue.assignmentRequests[msg.sender].exists == false, ERROR_USER_APPLIED);\r\n\r\n        issue.applicants.push(msg.sender);\r\n        issue.assignmentRequests[msg.sender] = AssignmentRequest(\r\n            SubmissionStatus.Unreviewed,\r\n            _application,\r\n            true\r\n        );\r\n        bountiesRegistry.performAction(\r\n            address(this),\r\n            issue.standardBountyId,\r\n            _application\r\n        );\r\n        emit AssignmentRequested(_repoId, _issueNumber);\r\n    }\r\n\r\n    /**\r\n     * @notice `_approved ? 'Accept' : 'Reject'` `_requestor` for issue `_issueNumber`\r\n     * @param _repoId the repo id of the issue\r\n     * @param _issueNumber the issue up for assignment\r\n     * @param _requestor address of user that will be assigned the issue\r\n     * @param _updatedApplication IPFS hash of the application containing optional feedback\r\n     */\r\n    function reviewApplication(\r\n        bytes32 _repoId,\r\n        uint256 _issueNumber,\r\n        address _requestor,\r\n        string _updatedApplication,\r\n        bool _approved\r\n    ) external auth(REVIEW_APPLICATION_ROLE)\r\n    {\r\n        Issue storage issue = repos[_repoId].issues[_issueNumber];\r\n        require(issue.assignee != address(-1), ERROR_OPEN_BOUNTY);\r\n        require(issue.assignmentRequests[_requestor].exists == true, ERROR_NO_APPLICATION);\r\n        issue.assignmentRequests[_requestor].requestHash = _updatedApplication;\r\n\r\n        if (_approved) {\r\n            issue.assignee = _requestor;\r\n            issue.assignmentRequests[_requestor].status = SubmissionStatus.Accepted;\r\n            emit AssignmentApproved(_requestor, _repoId, _issueNumber);\r\n        } else {\r\n            issue.assignmentRequests[_requestor].status = SubmissionStatus.Rejected;\r\n            emit AssignmentRejected(_requestor, _repoId, _issueNumber);\r\n        }\r\n        bountiesRegistry.performAction(\r\n            address(this),\r\n            issue.standardBountyId,\r\n            _updatedApplication\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice `_approved ? 'Accept' : 'Reject'` work for issue `_issueNumber` with info: `_updatedSubmissionHash`\r\n     * @dev add a submission to local state after it's been added to StandardBounties.sol\r\n     * @param _repoId the repo id of the issue\r\n     * @param _issueNumber the issue up for resolution\r\n     * @param _submissionNumber submission index of the submitted work for review\r\n     * @param _approved decision to accept the contribution\r\n     * @param _updatedSubmissionHash IPFS hash of the submission containing optional feedback\r\n     * @param _tokenAmounts array of amounts???\r\n     */\r\n    function reviewSubmission(\r\n        bytes32 _repoId,\r\n        uint256 _issueNumber,\r\n        uint256 _submissionNumber,\r\n        bool _approved,\r\n        string _updatedSubmissionHash,\r\n        uint256[] _tokenAmounts\r\n    ) external auth(WORK_REVIEW_ROLE)\r\n    {\r\n        Issue storage issue = repos[_repoId].issues[_issueNumber];\r\n\r\n        require(!issue.fulfilled,ERROR_BOUNTY_FULFILLED);\r\n        require(issue.assignee != address(0), ERROR_ISSUE_INACTIVE);\r\n\r\n        if (_approved) {\r\n            uint256 tokenTotal;\r\n            for (uint256 i = 0; i < _tokenAmounts.length; i++) {\r\n                tokenTotal = tokenTotal.add(_tokenAmounts[i]);\r\n            }\r\n            require(tokenTotal >= issue.bountySize, ERROR_INVALID_AMOUNT);\r\n\r\n            issue.fulfilled = true;\r\n            bountiesRegistry.acceptFulfillment(\r\n                address(this),\r\n                issue.standardBountyId,\r\n                _submissionNumber,\r\n                0,\r\n                _tokenAmounts\r\n            );\r\n            openBounties[_repoId] = openBounties[_repoId].sub(1);\r\n            emit SubmissionAccepted(_submissionNumber, _repoId, _issueNumber);\r\n        } else {\r\n            emit SubmissionRejected(_submissionNumber, _repoId, _issueNumber);\r\n        }\r\n\r\n        bountiesRegistry.performAction(\r\n            address(this),\r\n            issue.standardBountyId,\r\n            _updatedSubmissionHash\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update bounty for issue `_issueNumber`: `_description`\r\n     * @param _repoId The id of the repos in the projects registry\r\n     * @param _issueNumber issue number the bounty is assigned to\r\n     * @param _data Information hash stored in the bounty\r\n     * @param _deadline new deadline for bounty fulfillments\r\n     * @param _description Utilized when forwarded to give background to the\r\n     *                     issues up for removal\r\n     */\r\n    function updateBounty(\r\n        bytes32 _repoId,\r\n        uint256 _issueNumber,\r\n        string _data,\r\n        uint256 _deadline,\r\n        string _description\r\n    ) external auth(UPDATE_BOUNTIES_ROLE)\r\n    {\r\n        Issue storage issue = repos[_repoId].issues[_issueNumber];\r\n\r\n        require(!issue.fulfilled,ERROR_BOUNTY_FULFILLED);\r\n        require(issue.hasBounty, ERROR_ISSUE_INACTIVE);\r\n\r\n        bountiesRegistry.changeData(\r\n            address(this),\r\n            issue.standardBountyId,\r\n            0,\r\n            _data\r\n        );\r\n        bountiesRegistry.changeDeadline(\r\n            address(this),\r\n            issue.standardBountyId,\r\n            0,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove funding from issues: `_description`\r\n     * @param _repoIds The ids of the repos in the projects registry\r\n     * @param _issueNumbers an array of bounty indexes\r\n     * @param _description Utilized when forwarded to give background to the\r\n     *                     issues up for removal\r\n     */\r\n    function removeBounties(\r\n        bytes32[] _repoIds,\r\n        uint256[] _issueNumbers,\r\n        string _description\r\n    ) external auth(REMOVE_ISSUES_ROLE)\r\n    {\r\n        require(_repoIds.length < 256, ERROR_LENGTH_EXCEEDED);\r\n        require(_issueNumbers.length < 256, ERROR_LENGTH_EXCEEDED);\r\n        require(_repoIds.length == _issueNumbers.length, ERROR_LENGTH_MISMATCH);\r\n        for (uint8 i = 0; i < _issueNumbers.length; i++) {\r\n            _removeBounty(_repoIds[i], _issueNumbers[i]);\r\n        }\r\n    }\r\n\r\n///////////////////////\r\n// External utility functions\r\n///////////////////////\r\n\r\n    /**\r\n     * @notice Returns Applicant array length\r\n     * @param _repoId the repo id of the issue\r\n     * @param _issueNumber the issue up for assignmen\r\n     * @return  array length of the applicants array\r\n     */\r\n    function getApplicantsLength(\r\n        bytes32 _repoId,\r\n        uint256 _issueNumber\r\n    ) external view isInitialized returns(uint256 applicantQty)\r\n    {\r\n        applicantQty = repos[_repoId].issues[_issueNumber].applicants.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns Applicant Address\r\n     * @param _repoId The repo id of the issue\r\n     * @param _issueNumber The issue up for assignment\r\n     * @param _idx The applicant's position in the array\r\n     * @return  applicant address\r\n     */\r\n    function getApplicant(\r\n        bytes32 _repoId,\r\n        uint256 _issueNumber,\r\n        uint256 _idx\r\n    ) external view isInitialized returns(address applicant, string application, SubmissionStatus status)\r\n    {\r\n        Issue storage issue = repos[_repoId].issues[_issueNumber];\r\n        applicant = issue.applicants[_idx];\r\n        application = issue.assignmentRequests[applicant].requestHash;\r\n        status = issue.assignmentRequests[applicant].status;\r\n    }\r\n\r\n///////////////////\r\n// Public Bounty functions\r\n///////////////////\r\n\r\n    /**\r\n     * @notice Fund issues: `_description`\r\n     * @param _repoIds The ids of the repos in the projects registry\r\n     * @param _issueNumbers An array of bounty indexes\r\n     * @param _bountySizes An array of bounty sizes\r\n     * @param _deadlines An array of bounty deadlines\r\n     * @param _tokenTypes An array of currency types: 0=ETH from user's wallet, 1=ETH from vault, 20=ERC20 token from vault\r\n     * @param _tokenContracts An array of token contracts\r\n     * @param _ipfsAddresses A string of IPFS addresses\r\n     * @param _description parsed and display to user when this function is forwarded\r\n     */\r\n    function addBounties(\r\n        bytes32[] _repoIds,\r\n        uint256[] _issueNumbers,\r\n        uint256[] _bountySizes,\r\n        uint256[] _deadlines,\r\n        uint256[] _tokenTypes,\r\n        address[] _tokenContracts,\r\n        string _ipfsAddresses,\r\n        string _description\r\n    ) public payable auth(FUND_ISSUES_ROLE)\r\n    {\r\n        // ensure the transvalue passed equals transaction value\r\n        //checkTransValueEqualsMessageValue(msg.value, _bountySizes,_tokenBounties);\r\n        string memory ipfsHash;\r\n        uint standardBountyId;\r\n        require(bytes(_ipfsAddresses).length == (CID_LENGTH * _bountySizes.length), ERROR_CID_LENGTH);\r\n\r\n        for (uint i = 0; i < _bountySizes.length; i++) {\r\n            ipfsHash = getHash(_ipfsAddresses, i);\r\n\r\n            // submit the bounty to the StandardBounties contract\r\n            standardBountyId = _issueBounty(\r\n                ipfsHash,\r\n                _deadlines[i],\r\n                _tokenContracts[i],\r\n                _tokenTypes[i],\r\n                _bountySizes[i]\r\n            );\r\n\r\n            //Add bounty to local registry\r\n            _addBounty(\r\n                _repoIds[i],\r\n                _issueNumbers[i],\r\n                standardBountyId,\r\n                _tokenContracts[i],\r\n                _bountySizes[i],\r\n                ipfsHash\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Fund open-submission issues: `_description`\r\n     * @param _repoIds The ids of the repos in the projects registry\r\n     * @param _issueNumbers an array of bounty indexes\r\n     * @param _bountySizes an array of bounty sizes\r\n     * @param _deadlines an array of bounty deadlines\r\n     * @param _tokenTypes array of currency types: 0=ETH, 20=ERC20\r\n     * @param _tokenContracts an array of token contracts\r\n     * @param _ipfsAddresses a string of ipfs addresses\r\n     * @param _description parsed and display to user when this function is forwarded\r\n     */\r\n    function addBountiesNoAssignment(\r\n        bytes32[] _repoIds,\r\n        uint256[] _issueNumbers,\r\n        uint256[] _bountySizes,\r\n        uint256[] _deadlines,\r\n        uint256[] _tokenTypes,\r\n        address[] _tokenContracts,\r\n        string _ipfsAddresses,\r\n        string _description\r\n    ) public payable auth(FUND_OPEN_ISSUES_ROLE)\r\n    {\r\n        string memory ipfsHash;\r\n        uint standardBountyId;\r\n\r\n        for (uint i = 0; i < _bountySizes.length; i++) {\r\n            ipfsHash = getHash(_ipfsAddresses, i);\r\n\r\n            // submit the bounty to the StandardBounties contract\r\n            standardBountyId = _issueBounty(\r\n                ipfsHash,\r\n                _deadlines[i],\r\n                _tokenContracts[i],\r\n                _tokenTypes[i],\r\n                _bountySizes[i]\r\n            );\r\n\r\n            //Add bounty to local registry\r\n            _addBounty(\r\n                _repoIds[i],\r\n                _issueNumbers[i],\r\n                standardBountyId,\r\n                _tokenContracts[i],\r\n                _bountySizes[i],\r\n                ipfsHash\r\n            );\r\n\r\n            repos[_repoIds[i]].issues[_issueNumbers[i]].assignee = address(-1);\r\n            emit AwaitingSubmissions(_repoIds[i], _issueNumbers[i]);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Issue curation: `_description`\r\n     * @dev curateIssues(): This function conforms to the upcoming\r\n     *                      specId 2 forwarder interface\r\n     *                      and it is meant to be forwarded to a dot\r\n     *                      voting app instance or another voting app\r\n     *                      that utilizes dynamic forwarding.\r\n     *                      The unused parameters are in place to conform\r\n     *                      to the above specification.\r\n     * @param _description The description of the issue curation\r\n     */\r\n    function curateIssues(\r\n        address[] /*unused_Addresses*/,\r\n        uint256[] issuePriorities,\r\n        uint256[] issueDescriptionIndices,\r\n        string /* unused_issueDescriptions*/,\r\n        string _description,\r\n        uint256[] issueRepos,\r\n        uint256[] issueNumbers,\r\n        uint256 /* unused_curationId */\r\n    ) public auth(CURATE_ISSUES_ROLE)\r\n    {\r\n        bytes32 repoId;\r\n        uint256 issueLength = issuePriorities.length;\r\n        require(issueLength == issueDescriptionIndices.length, \"LENGTH_MISMATCH: issuePriorites and issueDescriptionIdx\");\r\n        require(issueLength == issueRepos.length, \"LENGTH_MISMATCH: issuePriorites and issueRepos\");\r\n        require(issueLength == issueNumbers.length, \"LENGTH_MISMATCH: issuePriorites and issueNumbers\");\r\n\r\n        for (uint256 i = 0; i < issueLength; i++) {\r\n            repoId = bytes32(issueRepos[i]);\r\n            repos[repoId].issues[uint256(issueNumbers[i])].priority = issuePriorities[i];\r\n            emit IssueCurated(repoId);\r\n        }\r\n    }\r\n\r\n///////////////////////\r\n// Public utility functions\r\n///////////////////////\r\n\r\n    /**\r\n     * @notice Checks if a repo exists in the registry\r\n     * @param _repoId The repo id to check\r\n     * @return _repoId Id for newly added repo\r\n     */\r\n    function isRepoAdded(bytes32 _repoId) public view isInitialized returns(bool isAdded) {\r\n        uint256 repoIdxVal = repos[_repoId].index;\r\n        if (repoIndexLength == 0)\r\n            return false;\r\n        if (repoIdxVal >= repoIndexLength)\r\n            return false;\r\n        return (repoIndex[repos[_repoId].index] == _repoId);\r\n    }\r\n\r\n///////////////////////\r\n// Internal functions\r\n///////////////////////\r\n\r\n    /**\r\n     * @dev checks the hashed contract code to ensure it matches the provided hash\r\n     */\r\n    function _isBountiesContractValid(address _bountyRegistry) internal view returns(bool) {\r\n        if (_bountyRegistry == address(0)) {\r\n            return false;\r\n        }\r\n        if (_bountyRegistry == address(bountiesRegistry)) {\r\n            return true;\r\n        }\r\n        uint256 size;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(_bountyRegistry) }\r\n        if (size != 23406) {\r\n            return false;\r\n        }\r\n        uint256 segments = 4;\r\n        uint256 segmentLength = size / segments;\r\n        bytes memory registryCode = new bytes(segmentLength);\r\n        bytes32[4] memory validRegistryHashes = [\r\n            bytes32(0x9904de0ff2a8144b30f80f0de9184731b7c39116b1f021bad12dcbb740f8371d),\r\n            bytes32(0xd2319fa5b8b5614a3634c84ff340d27fa6e5921162e44bc2256f379ad86608f3),\r\n            bytes32(0x0fd4c8d32b2c21b41989666a6d19f7a5f4987ae6d915dd96698de62db8a79643),\r\n            bytes32(0x6af9efdc22f9352086c68a7b5c270db4f0fdc2b5ab18984a2d17b92ae327e144)\r\n        ];\r\n        for (uint256 i = 0; i < segments; i++) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly{ extcodecopy(_bountyRegistry,add(0x20,registryCode),div(mul(i,segmentLength),segments),segmentLength) }\r\n            if (validRegistryHashes[i] != keccak256(registryCode)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Update bounty setting values\r\n     * @dev _changeBountySettings(): update app settings by changing contract setting state\r\n     */\r\n    function _changeBountySettings(\r\n        uint256 _baseRate,\r\n        uint256 _bountyDeadline,\r\n        address _bountyCurrency,\r\n        address _bountyAllocator\r\n    ) internal\r\n    {\r\n        settings.baseRate = _baseRate;\r\n        settings.bountyDeadline = _bountyDeadline;\r\n        settings.bountyCurrency = _bountyCurrency;\r\n        bountiesRegistry = Bounties(_bountyAllocator);\r\n\r\n        emit BountySettingsChanged();\r\n    }\r\n\r\n    /**\r\n     * @notice create a new experience level containing the multiplier and description\r\n     * @dev _addExperienceLevel():  Push new entries into the expMultiplier and expLevel\r\n     *                              arrays\r\n     */\r\n    function _addExperienceLevel(\r\n        uint _multiplier,\r\n        bytes32 _description\r\n    ) internal\r\n    {\r\n        settings.expMultipliers.push(_multiplier);\r\n        settings.expLevels.push(_description);\r\n    }\r\n\r\n    /**\r\n     * @notice passes provided info to the linked Standard Bounties contract\r\n     * @dev _issueBounty(): There are three forms of the contribute call.\r\n     *                      The first is used if ETH from the user is used as the bounty contribution\r\n     *                      The second is used if ETH from the vault is the bounty currency\r\n     *                      The third is used if an ERC20 token from the vault is the bounty currency\r\n     */\r\n    function _issueBounty(\r\n        string _ipfsHash,\r\n        uint256 _deadline,\r\n        address _tokenContract,\r\n        uint256 _tokenType,\r\n        uint256 _bountySize\r\n    ) internal returns (uint256 bountyId)\r\n    {\r\n        require(_tokenType != 721, ERROR_NO_ERC721);\r\n        uint256 registryTokenType;\r\n        if (_tokenType == 0) {\r\n            require(_tokenContract == ETH, ERROR_ETH_CONTRACT);\r\n            registryTokenType = _tokenType;\r\n        } else if (_tokenType == 1) {\r\n            require(_tokenContract == ETH, ERROR_ETH_CONTRACT);\r\n            registryTokenType = 0;\r\n        } else {\r\n            registryTokenType = _tokenType;\r\n        }\r\n\r\n        address[] memory issuers = new address[](1);\r\n        issuers[0] = address(this);\r\n\r\n        if (_tokenType > 0) {\r\n            vault.transfer(_tokenContract, this, _bountySize);\r\n            if (registryTokenType != 0) {\r\n                require(ERC20Token(_tokenContract).approve(bountiesRegistry, _bountySize), \"ERROR_ERC20_TRANSFER\");\r\n            }\r\n        }\r\n\r\n        if (registryTokenType == 0) {\r\n            bountyId = bountiesRegistry.issueAndContribute.value(_bountySize)(\r\n                address(this),      // address payable _sender\r\n                issuers,            // address payable [] memory _issuers\r\n                issuers,            // address [] memory _approvers\r\n                _ipfsHash,          // string memory _data\r\n                _deadline,          // uint _deadline\r\n                _tokenContract,     // address _token\r\n                registryTokenType,   // uint _tokenVersion\r\n                _bountySize\r\n            );\r\n        } else {\r\n            bountyId = bountiesRegistry.issueAndContribute(\r\n                address(this),      // address payable _sender\r\n                issuers,            // address payable [] memory _issuers\r\n                issuers,            // address [] memory _approvers\r\n                _ipfsHash,          // string memory _data\r\n                _deadline,          // uint _deadline\r\n                _tokenContract,     // address _token\r\n                registryTokenType,   // uint _tokenVersion\r\n                _bountySize\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice internal function that adds the bounty info to contract state\r\n     * @dev _addBounty():   Creates a new Issue instance in the specified Repo\r\n     *                      and initializes the the state parameters that aren't\r\n     *                      passed in\r\n     */\r\n    function _addBounty(\r\n        bytes32 _repoId,\r\n        uint256 _issueNumber,\r\n        uint _standardBountyId,\r\n        address _tokenContract,\r\n        uint256 _bountySize,\r\n        string _ipfsHash\r\n    ) internal\r\n    {\r\n        address[] memory emptyAddressArray = new address[](0);\r\n        uint256[] memory emptySubmissionIndexArray = new uint256[](0);\r\n        //Issue storage issue = repos[_repoId].issues[_issueNumber];\r\n        require(isRepoAdded(_repoId), ERROR_REPO_MISSING);\r\n        require(!repos[_repoId].issues[_issueNumber].hasBounty, ERROR_ISSUE_ACTIVE);\r\n\r\n        repos[_repoId].issues[_issueNumber] = Issue(\r\n            _repoId,\r\n            _issueNumber,\r\n            true,\r\n            false,\r\n            _tokenContract,\r\n            _bountySize,\r\n            999,\r\n            ETH,\r\n            _standardBountyId,\r\n            ETH,\r\n            emptyAddressArray,\r\n            //address(0),\r\n            //0,\r\n            emptySubmissionIndexArray\r\n        );\r\n        openBounties[_repoId] = openBounties[_repoId].add(1);\r\n        emit BountyAdded(\r\n            _repoId,\r\n            _issueNumber,\r\n            _bountySize,\r\n            _standardBountyId,\r\n            _ipfsHash\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice remove bounty from StandardBounties and local registry\r\n     * @dev _removeBounty():    First transfers the bounty value from\r\n     *                          the StandardBounties registry back\r\n     *                          to the Project's integrated vault.\r\n     *                          Next resets the issue's contract state.\r\n     * @param _repoId the repo id of the issue\r\n     * @param _issueNumber the issue up for assignment\r\n     */\r\n    function _removeBounty(\r\n        bytes32 _repoId,\r\n        uint256 _issueNumber\r\n    ) internal\r\n    {\r\n        Issue storage issue = repos[_repoId].issues[_issueNumber];\r\n        require(issue.hasBounty, ERROR_BOUNTY_REMOVED);\r\n        require(!issue.fulfilled, ERROR_BOUNTY_FULFILLED);\r\n        issue.hasBounty = false;\r\n        uint256[] memory originalAmount = new uint256[](1);\r\n        originalAmount[0] = issue.bountySize;\r\n        bountiesRegistry.drainBounty(\r\n            address(this),\r\n            issue.standardBountyId,\r\n            0,\r\n            originalAmount\r\n        );\r\n        _returnValueToVault(originalAmount[0], issue.tokenContract);\r\n        issue.bountySize = 0;\r\n        bountiesRegistry.changeDeadline(\r\n            address(this),\r\n            issue.standardBountyId,\r\n            0,\r\n            getTimestamp()\r\n        );\r\n        openBounties[_repoId] = openBounties[_repoId].sub(1);\r\n        emit BountyRemoved(\r\n            _repoId,\r\n            _issueNumber,\r\n            originalAmount[0]\r\n        );\r\n    }\r\n\r\n    function _returnValueToVault(uint256 _amount, address _token) internal {\r\n        if (_token == ETH)\r\n            vault.deposit.value(_amount)(_token, _amount);\r\n        else {\r\n            require(ERC20Token(_token).approve(vault, _amount), \"ERROR_ERC20__APPROVAL\");\r\n            vault.deposit(_token, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice parses InfoStrings for the CID hash\r\n     * @dev getHash():  First copies over the first 32 bytes.\r\n     *                  Next copies the remaining 14 bytes and\r\n     *                  and masks the remainder of the word\r\n     * @param _str The raw string to be parsed by the function\r\n     * @param _hashIndex The index of the hash to be parsed from\r\n     *                   the string of combined hashes\r\n     */\r\n    function getHash(\r\n        string _str,\r\n        uint256 _hashIndex\r\n    ) internal pure returns (string)\r\n    {\r\n        // first char is at location 0\r\n        //IPFS addresses span from 0 (startindex) to 46 (endIndex)\r\n        uint256 startIndex = _hashIndex * CID_LENGTH;\r\n        uint256 endIndex = startIndex + CID_LENGTH;\r\n        bytes memory strBytes = bytes(_str);\r\n        bytes memory result = new bytes(endIndex-startIndex);\r\n        uint256 length = endIndex - startIndex;\r\n        // destination in memory for the returned hash\r\n        uint256 dest;\r\n        // source location in memory for the returned hash\r\n        uint256 src;\r\n        // need to offset by 0x20 (32 bytes) to account for the first\r\n        // 32 \"header\" bytes\r\n        // then copy the first 32 bytes of the hash into the destination location\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            dest := add(result,0x20)\r\n            src := add(strBytes,add(0x20,startIndex))\r\n            mstore(dest, mload(src))\r\n        }\r\n        // copy the remaining 14 bytes and ensure the remaining\r\n        // 18 bytes of the word are set to \"00\" using a mask\r\n        src += 32;\r\n        dest += 32;\r\n        length -= 32;\r\n        uint mask = 256 ** (32 - length) - 1;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n\r\n}\r\n\r\n// File: @aragon/apps-shared-minime/contracts/ITokenController.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/// @dev The token controller contract must implement these functions\r\n\r\n\r\ninterface ITokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) external payable returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) external returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) external returns(bool);\r\n}\r\n\r\n// File: @aragon/apps-shared-minime/contracts/MiniMeToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n/// @title MiniMeToken Contract\r\n/// @author Jordi Baylina\r\n/// @dev This token contract's goal is to make it easy for anyone to clone this\r\n///  token using the token distribution at a given block, this will allow DAO's\r\n///  and DApps to upgrade their features in a decentralized manner without\r\n///  affecting the original token\r\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\r\n\r\n\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController {\r\n        require(msg.sender == controller);\r\n        _;\r\n    }\r\n\r\n    address public controller;\r\n\r\n    function Controlled()  public { controller = msg.sender;}\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController  public {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(\r\n        address from,\r\n        uint256 _amount,\r\n        address _token,\r\n        bytes _data\r\n    ) public;\r\n}\r\n\r\n/// @dev The actual token contract, the default controller is the msg.sender\r\n///  that deploys the contract, so usually this token will be deployed by a\r\n///  token controller contract, which Giveth will call a \"Campaign\"\r\ncontract MiniMeToken is Controlled {\r\n\r\n    string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             //Number of decimals of the smallest unit\r\n    string public symbol;              //An identifier: e.g. REP\r\n    string public version = \"MMT_0.1\"; //An arbitrary versioning scheme\r\n\r\n\r\n    /// @dev `Checkpoint` is the structure that attaches a block number to a\r\n    ///  given value, the block number attached is the one that last changed the\r\n    ///  value\r\n    struct Checkpoint {\r\n\r\n        // `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        // `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n\r\n    // `parentToken` is the Token address that was cloned to produce this token;\r\n    //  it will be 0x0 for a token that was not cloned\r\n    MiniMeToken public parentToken;\r\n\r\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\r\n    //  used to determine the initial distribution of the Clone Token\r\n    uint public parentSnapShotBlock;\r\n\r\n    // `creationBlock` is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n\r\n    // `balances` is the map that tracks the balance of each address, in this\r\n    //  contract when the balance changes the block number that the change\r\n    //  occurred is also included in the map\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Tracks the history of the `totalSupply` of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n    // The factory used to create new clone tokens\r\n    MiniMeTokenFactory public tokenFactory;\r\n\r\n////////////////\r\n// Constructor\r\n////////////////\r\n\r\n    /// @notice Constructor to create a MiniMeToken\r\n    /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\n    ///  will create the Clone token contracts, the token factory needs to be\r\n    ///  deployed first\r\n    /// @param _parentToken Address of the parent token, set to 0x0 if it is a\r\n    ///  new token\r\n    /// @param _parentSnapShotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token, set to 0 if it\r\n    ///  is a new token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    function MiniMeToken(\r\n        MiniMeTokenFactory _tokenFactory,\r\n        MiniMeToken _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    )  public\r\n    {\r\n        tokenFactory = _tokenFactory;\r\n        name = _tokenName;                                 // Set the name\r\n        decimals = _decimalUnits;                          // Set the decimals\r\n        symbol = _tokenSymbol;                             // Set the symbol\r\n        parentToken = _parentToken;\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n\r\n///////////////////\r\n// ERC20 Methods\r\n///////////////////\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n        return doTransfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\r\n\r\n        // The controller of this contract can move tokens around at will,\r\n        //  this is important to recognize! Confirm that you trust the\r\n        //  controller of this contract, which in most situations should be\r\n        //  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            require(transfersEnabled);\r\n\r\n            // The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount)\r\n                return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\r\n        if (_amount == 0) {\r\n            return true;\r\n        }\r\n        require(parentSnapShotBlock < block.number);\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require((_to != 0) && (_to != address(this)));\r\n        // If the amount being transfered is more than the balance of the\r\n        //  account the transfer returns false\r\n        var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n        if (previousBalanceFrom < _amount) {\r\n            return false;\r\n        }\r\n        // Alerts the token controller of the transfer\r\n        if (isContract(controller)) {\r\n            // Adding the ` == true` makes the linter shut up so...\r\n            require(ITokenController(controller).onTransfer(_from, _to, _amount) == true);\r\n        }\r\n        // First update the balance array with the new value for the address\r\n        //  sending the tokens\r\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n        // Then update the balance array with the new value for the address\r\n        //  receiving the tokens\r\n        var previousBalanceTo = balanceOfAt(_to, block.number);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n        // An event to make the transfer easy to find on the blockchain\r\n        Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            // Adding the ` == true` makes the linter shut up so...\r\n            require(ITokenController(controller).onApprove(msg.sender, _spender, _amount) == true);\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\r\n        require(approve(_spender, _amount));\r\n\r\n        _spender.receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply() public constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n\r\n////////////////\r\n// Query balance and totalSupply in History\r\n////////////////\r\n\r\n    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _blockNumber The block number when the balance is queried\r\n    /// @return The balance at `_blockNumber`\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {\r\n\r\n        // These next few lines are used when the balance of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.balanceOfAt` be queried at the\r\n        //  genesis block for that token as this contains initial balance of\r\n        //  this token\r\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    /// @notice Total amount of tokens at a specific `_blockNumber`.\r\n    /// @param _blockNumber The block number when the totalSupply is queried\r\n    /// @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\r\n\r\n        // These next few lines are used when the totalSupply of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        //  genesis block for this token as that contains totalSupply of this\r\n        //  token at this block number.\r\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n////////////////\r\n// Clone Token Method\r\n////////////////\r\n\r\n    /// @notice Creates a new clone token with the initial distribution being\r\n    ///  this token at `_snapshotBlock`\r\n    /// @param _cloneTokenName Name of the clone token\r\n    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\r\n    /// @param _cloneTokenSymbol Symbol of the clone token\r\n    /// @param _snapshotBlock Block when the distribution of the parent token is\r\n    ///  copied to set the initial distribution of the new clone token;\r\n    ///  if the block is zero than the actual block, the current block is used\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    /// @return The address of the new MiniMeToken Contract\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n    ) public returns(MiniMeToken)\r\n    {\r\n        uint256 snapshot = _snapshotBlock == 0 ? block.number - 1 : _snapshotBlock;\r\n\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            snapshot,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n        );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        // An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), snapshot);\r\n        return cloneToken;\r\n    }\r\n\r\n////////////////\r\n// Generate and destroy tokens\r\n////////////////\r\n\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _owner The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount) onlyController public returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _owner The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount) onlyController public returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n////////////////\r\n// Enable tokens transfers\r\n////////////////\r\n\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) onlyController public {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n////////////////\r\n// Internal helper functions to query and set a value in a snapshot array\r\n////////////////\r\n\r\n    /// @dev `getValueAt` retrieves the number of tokens at a given block number\r\n    /// @param checkpoints The history of values being queried\r\n    /// @param _block The block number to retrieve the value at\r\n    /// @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) constant internal returns (uint) {\r\n        if (checkpoints.length == 0)\r\n            return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock)\r\n            return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1) / 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /// @dev `updateValueAtNow` used to update the `balances` map and the\r\n    ///  `totalSupplyHistory`\r\n    /// @param checkpoints The history of data being updated\r\n    /// @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\r\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\r\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\r\n            newCheckPoint.fromBlock = uint128(block.number);\r\n            newCheckPoint.value = uint128(_value);\r\n        } else {\r\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\r\n            oldCheckPoint.value = uint128(_value);\r\n        }\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0)\r\n            return false;\r\n\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n\r\n        return size>0;\r\n    }\r\n\r\n    /// @dev Helper function to return a min betwen the two uints\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /// @notice The fallback function: If the contract's controller has not been\r\n    ///  set to 0, then the `proxyPayment` method is called which relays the\r\n    ///  ether and creates tokens as described in the token controller contract\r\n    function () external payable {\r\n        require(isContract(controller));\r\n        // Adding the ` == true` makes the linter shut up so...\r\n        require(ITokenController(controller).proxyPayment.value(msg.value)(msg.sender) == true);\r\n    }\r\n\r\n//////////\r\n// Safety Methods\r\n//////////\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) onlyController public {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        MiniMeToken token = MiniMeToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n////////////////\r\n// Events\r\n////////////////\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n        );\r\n\r\n}\r\n\r\n\r\n////////////////\r\n// MiniMeTokenFactory\r\n////////////////\r\n\r\n/// @dev This contract is used to generate clone contracts from a contract.\r\n///  In solidity this is the way to create a contract from a contract of the\r\n///  same class\r\ncontract MiniMeTokenFactory {\r\n\r\n    /// @notice Update the DApp by creating a new token with new functionalities\r\n    ///  the msg.sender becomes the controller of this clone token\r\n    /// @param _parentToken Address of the token being cloned\r\n    /// @param _snapshotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    /// @return The address of the new token contract\r\n    function createCloneToken(\r\n        MiniMeToken _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) public returns (MiniMeToken)\r\n    {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n        );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}\r\n\r\n// File: @tps/apps-rewards/contracts/Rewards.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer: GPL-3.0-or-later\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Rewards is AragonApp {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n    /// Hardcoded constants to save gas\r\n    bytes32 public constant ADD_REWARD_ROLE = 0x7941efc179bdce37ebd8db3e2deb46ce5280bf6d2de2e50938a9e920494c1941;\r\n\r\n    /// Used to limit dividends occurrences for dividend rewards\r\n    uint8 internal constant MAX_OCCURRENCES = uint8(42);\r\n\r\n    /// Error string constants\r\n    string private constant ERROR_VAULT = \"VAULT_NOT_A_CONTRACT\";\r\n    string private constant ERROR_REWARD_TIME_SPAN = \"REWARD_CLAIMED_BEFORE_DURATION_AND_DELAY\";\r\n    string private constant ERROR_VAULT_FUNDS = \"VAULT_NOT_ENOUGH_FUNDS_TO_COVER_REWARD\";\r\n    string private constant ERROR_REFERENCE_TOKEN = \"REFERENCE_TOKEN_NOT_A_CONTRACT\";\r\n    string private constant ERROR_REWARD_TOKEN = \"REWARD_TOKEN_NOT_ETH_OR_CONTRACT\";\r\n    string private constant ERROR_MERIT_OCCURRENCES = \"MERIT_REWARD_MUST_ONLY_OCCUR_ONCE\";\r\n    string private constant ERROR_MAX_OCCURRENCES = \"OCURRENCES_LIMIT_REACHED\";\r\n    string private constant ERROR_START_BLOCK = \"START_PERIOD_BEFORE_TOKEN_CREATION\";\r\n    string private constant ERROR_REWARD_CLAIMED = \"REWARD_ALREADY_CLAIMED\";\r\n    string private constant ERROR_ZERO_DURATION = \"DURATION_MUST_BE_AT_LEAST_ONE_BLOCK\";\r\n    string private constant ERROR_ZERO_OCCURRENCE = \"OCCURRENCES_LESS_THAN_ONE\";\r\n    string private constant ERROR_ZERO_REWARD = \"NO_REWARD_TO_CLAIM\";\r\n    string private constant ERROR_EXISTS = \"REWARD_DOES_NOT_EXIST\";\r\n    string private constant ERROR_NONTRANSFERRABLE = \"MINIME_CANNOT_TRANSFER\";\r\n\r\n    /// Order optimized for storage\r\n    struct Reward {\r\n        MiniMeToken referenceToken;\r\n        bool isMerit;\r\n        uint64 blockStart;\r\n        uint64 duration;\r\n        uint64 delay;\r\n        uint256 amount;\r\n        address creator;\r\n        address rewardToken;\r\n        string description;\r\n        mapping (address => uint) timeClaimed;\r\n    }\r\n\r\n    /// Amount claimed for each token\r\n    mapping (address => uint) internal totalAmountClaimed;\r\n    uint256 public totalClaimsEach;\r\n\r\n    /// Rewards internal registry\r\n    mapping(uint256 => Reward) rewards;\r\n    uint256 rewardsRegistryLength;\r\n    /// Public vault that holds the funds\r\n    Vault public vault;\r\n\r\n    /// Events\r\n    event RewardAdded(uint256 rewardId); /// Emitted when a new reward is created\r\n    event RewardClaimed(uint256 rewardId, address claimant);\r\n\r\n    /**\r\n     * @notice Initialize Rewards app for Vault at `_vault`\r\n     * @dev Initializes the Rewards app, this is the Aragon custom constructor\r\n     * @param _vault Address of the vault Rewards will rely on (non changeable)\r\n     */\r\n    function initialize(Vault _vault) external onlyInit {\r\n        require(isContract(_vault), ERROR_VAULT);\r\n        vault = _vault;\r\n        initialized();\r\n    }\r\n\r\n    /**\r\n     * @notice Claim my reward for #`_rewardID`\r\n     * @dev Allows a user to claim their reward (if one is available)\r\n     * @param _rewardID The ID of the reward\r\n     * @return rewardAmount calculated for that reward ID\r\n     */\r\n    function claimReward(uint256 _rewardID) external isInitialized returns (uint256) {\r\n        Reward storage reward = rewards[_rewardID];\r\n        require(reward.blockStart > 0, ERROR_EXISTS);\r\n        uint256 rewardTimeSpan = reward.blockStart.add(reward.duration).add(reward.delay);\r\n        require(rewardTimeSpan < getBlockNumber(), ERROR_REWARD_TIME_SPAN);\r\n\r\n        require(reward.timeClaimed[msg.sender] == 0, ERROR_REWARD_CLAIMED);\r\n        reward.timeClaimed[msg.sender] = getTimestamp();\r\n\r\n        uint256 rewardAmount = _calculateRewardAmount(reward);\r\n        require(rewardAmount > 0, ERROR_ZERO_REWARD);\r\n        require(vault.balance(reward.rewardToken) >= rewardAmount, ERROR_VAULT_FUNDS);\r\n\r\n        _transferReward(reward, rewardAmount);\r\n\r\n        emit RewardClaimed(_rewardID, msg.sender);\r\n        return rewardAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Get total rewards count\r\n     * @dev Gets the lenght of the rewards registry array\r\n     * @return rewardsLength the length of the rewards array\r\n     */\r\n    function getRewardsLength() external view isInitialized returns (uint256 rewardsLength) {\r\n        rewardsLength = rewardsRegistryLength;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets information for the reward with ID #`rewardID`\r\n     * @dev Allows a user to get information about a specific reward\r\n     * @param rewardID The ID of the reward\r\n     * @return description message for this reward\r\n     * @return isMerit true or false in case it is a dividend reward\r\n     * @return referenceToken used as reference to weight the reward\r\n     * @return rewardToken used to pay the reward\r\n     * @return amount for this reward\r\n     * @return startBlock when the reward went active\r\n     * @return endBlock when the reward period ended\r\n     * @return duration number of blocks for the reward duration\r\n     * @return delay in number of blocks in case the reward claiming is postponed\r\n     * @return rewardAmount which amount is available to claim\r\n     * @return timeClaimed when it was claimed by the msg.sender\r\n     * @return creator the address of the reward creator\r\n     */\r\n    function getReward(uint256 rewardID) external view isInitialized returns (\r\n        string description,\r\n        bool isMerit,\r\n        address referenceToken,\r\n        address rewardToken,\r\n        uint256 amount,\r\n        uint256 startBlock,\r\n        uint256 endBlock,\r\n        uint256 duration,\r\n        uint256 delay,\r\n        uint256 rewardAmount,\r\n        uint256 timeClaimed,\r\n        address creator\r\n    )\r\n    {\r\n        Reward storage reward = rewards[rewardID];\r\n        description = reward.description;\r\n        isMerit = reward.isMerit;\r\n        referenceToken = reward.referenceToken;\r\n        rewardToken = reward.rewardToken;\r\n        amount = reward.amount;\r\n        endBlock = reward.blockStart + reward.duration;\r\n        startBlock = reward.blockStart;\r\n        duration = reward.duration;\r\n        delay = reward.delay;\r\n        timeClaimed = reward.timeClaimed[msg.sender];\r\n        creator = reward.creator;\r\n        rewardAmount = _calculateRewardAmount(reward);\r\n    }\r\n\r\n    /**\r\n     * @notice Get total amount of `_token` claimed\r\n     * @dev Gets the amount of this token claimed\r\n     * @return totalAmountClaimed for that token\r\n     */\r\n    function getTotalAmountClaimed(address _token)\r\n    external view isInitialized returns (uint256)\r\n    {\r\n        return totalAmountClaimed[_token];\r\n    }\r\n\r\n    /**\r\n     * @notice Create a `_isMerit ? 'merit reward' : 'dividend'` that will distribute `@tokenAmount(_rewardToken, _amount)` to token holders who `_isMerit ? 'earned ' : 'hold '` `_referenceToken.symbol(): string` `(_occurrences > 1) ? ' from block ' + _startBlock + ' to block ' + (_startBlock + _duration) + '. This dividend will disburse every ' + _duration + ' blocks in proportion to the holders balance on the disbursement date. The first disbursement occurs at the end of the first cycle, on block ' + (_startBlock + _duration) + '.' : (_isMerit ? 'from block ' + _startBlock + 'to block ' + (_startBlock + _duration) +'.' : 'on block '+ _startBlock + '.')` (Reference: `_description`)\r\n     * @dev This function creates a reward instance to be added to the rewards array. ID's\r\n     *      are assigned the new intance's index of that array\r\n     * @param _description description of the reward\r\n     * @param _isMerit Recurring dividend reward or one-off merit reward\r\n     * @param _referenceToken the token used to calculate reward distributions for each holder\r\n     * @param _rewardToken currency received as reward, accepts address 0 for ETH reward\r\n     * @param _amount the reward amount to be distributed\r\n     * @param _startBlock block in which token transactions will begin to be tracked\r\n     * @param _duration the block duration over which reference token earnings are calculated\r\n     * @param _occurrences the number of occurrences of a dividend reward\r\n     * @param _delay the number of blocks to delay after the end of the period that the reward can be claimed\r\n     * @return rewardId of the newly created Reward\r\n     */\r\n    function newReward(\r\n        string _description,\r\n        bool _isMerit,\r\n        MiniMeToken _referenceToken,\r\n        address _rewardToken,\r\n        uint256 _amount,\r\n        uint64 _startBlock,\r\n        uint64 _duration,\r\n        uint8 _occurrences,\r\n        uint64 _delay\r\n    ) public auth(ADD_REWARD_ROLE) returns (uint256 rewardId)\r\n    {\r\n        require(isContract(_referenceToken), ERROR_REFERENCE_TOKEN);\r\n        require(_rewardToken == address(0) || isContract(_rewardToken), ERROR_REWARD_TOKEN);\r\n        require(_duration > 0, ERROR_ZERO_DURATION);\r\n        require(_occurrences > 0, ERROR_ZERO_OCCURRENCE);\r\n        require(!_isMerit || _occurrences == 1, ERROR_MERIT_OCCURRENCES);\r\n        require(_occurrences < MAX_OCCURRENCES, ERROR_MAX_OCCURRENCES);\r\n        require(_startBlock > _referenceToken.creationBlock(), ERROR_START_BLOCK);\r\n        if (_isMerit) {\r\n            require(!_referenceToken.transfersEnabled(), ERROR_NONTRANSFERRABLE);\r\n        }\r\n        rewardId = rewardsRegistryLength++; // increment the rewards array to create a new one\r\n        Reward storage reward = rewards[rewardsRegistryLength - 1]; // length-1 takes the last, newly created \"empty\" reward\r\n        reward.description = _description;\r\n        reward.isMerit = _isMerit;\r\n        reward.referenceToken = _referenceToken;\r\n        reward.rewardToken = _rewardToken;\r\n        reward.amount = _amount;\r\n        reward.duration = _duration;\r\n        reward.delay = _delay;\r\n        reward.blockStart = _startBlock;\r\n        reward.creator = msg.sender;\r\n        emit RewardAdded(rewardId);\r\n        if (_occurrences > 1) {\r\n            newReward(\r\n                _description,\r\n                _isMerit,\r\n                _referenceToken,\r\n                _rewardToken,\r\n                _amount,\r\n                _startBlock + _duration,\r\n                _duration,\r\n                _occurrences - 1,\r\n                _delay\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private intermediate function that does the actual vault transfer for a reward and reward amoun\r\n     */\r\n    function _transferReward(Reward storage reward, uint256 rewardAmount) private {\r\n        totalClaimsEach++;\r\n        totalAmountClaimed[reward.rewardToken] = totalAmountClaimed[reward.rewardToken].add(rewardAmount);\r\n        vault.transfer(reward.rewardToken, msg.sender, rewardAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Private intermediate function to calculate reward amount depending of the type, balance and supply\r\n     * @return rewardAmount calculated for that reward\r\n     */\r\n    function _calculateRewardAmount(Reward storage reward) private view returns (uint256 rewardAmount) {\r\n        uint256 balance;\r\n        uint256 supply;\r\n        balance = reward.referenceToken.balanceOfAt(msg.sender, reward.blockStart + reward.duration);\r\n        supply = reward.referenceToken.totalSupplyAt(reward.blockStart + reward.duration);\r\n        if (reward.isMerit) {\r\n            // This is a pending implementation. We need to look into a way to track earned tokens\r\n            // to better calculate merit reward amounts\r\n            uint256 originalBalance = balance;\r\n            uint256 originalSupply = supply;\r\n            balance -= reward.referenceToken.balanceOfAt(msg.sender, reward.blockStart);\r\n            supply -= reward.referenceToken.totalSupplyAt(reward.blockStart);\r\n            if (originalBalance <= balance || originalSupply < supply) {\r\n                return 0;\r\n            }\r\n        }\r\n        rewardAmount = supply == 0 ? 0 : reward.amount.mul(balance).div(supply);\r\n    }\r\n}\r\n\r\n// File: @aragon/apps-agent/contracts/standards/ERC1271.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n// ERC1271 on Feb 12th, 2019: https://github.com/ethereum/EIPs/blob/a97dc434930d0ccc4461c97d8c7a920dc585adf2/EIPS/eip-1271.md\r\n// Using `isValidSignature(bytes32,bytes)` even though the standard still hasn't been modified\r\n// Rationale: https://github.com/ethereum/EIPs/issues/1271#issuecomment-462719728\r\n\r\n\r\ncontract ERC1271 {\r\n    bytes4 constant public ERC1271_INTERFACE_ID = 0xfb855dc9; // this.isValidSignature.selector\r\n\r\n    bytes4 constant public ERC1271_RETURN_VALID_SIGNATURE =   0x20c13b0b; // TODO: Likely needs to be updated\r\n    bytes4 constant public ERC1271_RETURN_INVALID_SIGNATURE = 0x00000000;\r\n\r\n    /**\r\n    * @dev Function must be implemented by deriving contract\r\n    * @param _hash Arbitrary length data signed on the behalf of address(this)\r\n    * @param _signature Signature byte array associated with _data\r\n    * @return A bytes4 magic value 0x20c13b0b if the signature check passes, 0x00000000 if not\r\n    *\r\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n    * MUST allow external calls\r\n    */\r\n    function isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4);\r\n\r\n    function returnIsValidSignatureMagicNumber(bool isValid) internal pure returns (bytes4) {\r\n        return isValid ? ERC1271_RETURN_VALID_SIGNATURE : ERC1271_RETURN_INVALID_SIGNATURE;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC1271Bytes is ERC1271 {\r\n    /**\r\n    * @dev Default behavior of `isValidSignature(bytes,bytes)`, can be overloaded for custom validation\r\n    * @param _data Arbitrary length data signed on the behalf of address(this)\r\n    * @param _signature Signature byte array associated with _data\r\n    * @return A bytes4 magic value 0x20c13b0b if the signature check passes, 0x00000000 if not\r\n    *\r\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n    * MUST allow external calls\r\n    */\r\n    function isValidSignature(bytes _data, bytes _signature) public view returns (bytes4) {\r\n        return isValidSignature(keccak256(_data), _signature);\r\n    }\r\n}\r\n\r\n// File: @aragon/apps-agent/contracts/SignatureValidator.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n// Inspired by https://github.com/horizon-games/multi-token-standard/blob/319740cf2a78b8816269ae49a09c537b3fd7303b/contracts/utils/SignatureValidator.sol\r\n// This should probably be moved into aOS: https://github.com/aragon/aragonOS/pull/442\r\n\r\n\r\n\r\nlibrary SignatureValidator {\r\n    enum SignatureMode {\r\n        Invalid, // 0x00\r\n        EIP712,  // 0x01\r\n        EthSign, // 0x02\r\n        ERC1271, // 0x03\r\n        NMode    // 0x04, to check if mode is specified, leave at the end\r\n    }\r\n\r\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n    bytes4 public constant ERC1271_RETURN_VALID_SIGNATURE = 0x20c13b0b;\r\n    uint256 internal constant ERC1271_ISVALIDSIG_MAX_GAS = 250000;\r\n\r\n    string private constant ERROR_INVALID_LENGTH_POP_BYTE = \"SIGVAL_INVALID_LENGTH_POP_BYTE\";\r\n\r\n    /// @dev Validates that a hash was signed by a specified signer.\r\n    /// @param hash Hash which was signed.\r\n    /// @param signer Address of the signer.\r\n    /// @param signature ECDSA signature along with the mode (0 = Invalid, 1 = EIP712, 2 = EthSign, 3 = ERC1271) {mode}{r}{s}{v}.\r\n    /// @return Returns whether signature is from a specified user.\r\n    function isValidSignature(bytes32 hash, address signer, bytes signature) internal view returns (bool) {\r\n        if (signature.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint8 modeByte = uint8(signature[0]);\r\n        if (modeByte >= uint8(SignatureMode.NMode)) {\r\n            return false;\r\n        }\r\n        SignatureMode mode = SignatureMode(modeByte);\r\n\r\n        if (mode == SignatureMode.EIP712) {\r\n            return ecVerify(hash, signer, signature);\r\n        } else if (mode == SignatureMode.EthSign) {\r\n            return ecVerify(\r\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),\r\n                signer,\r\n                signature\r\n            );\r\n        } else if (mode == SignatureMode.ERC1271) {\r\n            // Pop the mode byte before sending it down the validation chain\r\n            return safeIsValidSignature(signer, hash, popFirstByte(signature));\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function ecVerify(bytes32 hash, address signer, bytes memory signature) private pure returns (bool) {\r\n        (bool badSig, bytes32 r, bytes32 s, uint8 v) = unpackEcSig(signature);\r\n\r\n        if (badSig) {\r\n            return false;\r\n        }\r\n\r\n        return signer == ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function unpackEcSig(bytes memory signature) private pure returns (bool badSig, bytes32 r, bytes32 s, uint8 v) {\r\n        if (signature.length != 66) {\r\n            badSig = true;\r\n            return;\r\n        }\r\n\r\n        v = uint8(signature[65]);\r\n        assembly {\r\n            r := mload(add(signature, 33))\r\n            s := mload(add(signature, 65))\r\n        }\r\n\r\n        // Allow signature version to be 0 or 1\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            badSig = true;\r\n        }\r\n    }\r\n\r\n    function popFirstByte(bytes memory input) private pure returns (bytes memory output) {\r\n        uint256 inputLength = input.length;\r\n        require(inputLength > 0, ERROR_INVALID_LENGTH_POP_BYTE);\r\n\r\n        output = new bytes(inputLength - 1);\r\n\r\n        if (output.length == 0) {\r\n            return output;\r\n        }\r\n\r\n        uint256 inputPointer;\r\n        uint256 outputPointer;\r\n        assembly {\r\n            inputPointer := add(input, 0x21)\r\n            outputPointer := add(output, 0x20)\r\n        }\r\n        memcpy(outputPointer, inputPointer, output.length);\r\n    }\r\n\r\n    function safeIsValidSignature(address validator, bytes32 hash, bytes memory signature) private view returns (bool) {\r\n        bytes memory data = abi.encodeWithSelector(ERC1271(validator).isValidSignature.selector, hash, signature);\r\n        bytes4 erc1271Return = safeBytes4StaticCall(validator, data, ERC1271_ISVALIDSIG_MAX_GAS);\r\n        return erc1271Return == ERC1271_RETURN_VALID_SIGNATURE;\r\n    }\r\n\r\n    function safeBytes4StaticCall(address target, bytes data, uint256 maxGas) private view returns (bytes4 ret) {\r\n        uint256 gasLeft = gasleft();\r\n\r\n        uint256 callGas = gasLeft > maxGas ? maxGas : gasLeft;\r\n        bool ok;\r\n        assembly {\r\n            ok := staticcall(callGas, target, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n\r\n        if (!ok) {\r\n            return;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := returndatasize }\r\n        if (size != 32) {\r\n            return;\r\n        }\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)       // get next free memory ptr\r\n            returndatacopy(ptr, 0, size) // copy return from above `staticcall`\r\n            ret := mload(ptr)            // read data at ptr and set it to be returned\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    // From: https://github.com/Arachnid/solidity-stringutils/blob/01e955c1d6/src/strings.sol\r\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: @aragon/apps-agent/contracts/standards/IERC165.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\r\n}\r\n\r\n// File: @aragon/apps-agent/contracts/Agent.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    GPL-3.0-or-later\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Agent is IERC165, ERC1271Bytes, IForwarder, IsContract, Vault {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 public constant EXECUTE_ROLE = keccak256(\"EXECUTE_ROLE\");\r\n    bytes32 public constant SAFE_EXECUTE_ROLE = keccak256(\"SAFE_EXECUTE_ROLE\");\r\n    bytes32 public constant ADD_PROTECTED_TOKEN_ROLE = keccak256(\"ADD_PROTECTED_TOKEN_ROLE\");\r\n    bytes32 public constant REMOVE_PROTECTED_TOKEN_ROLE = keccak256(\"REMOVE_PROTECTED_TOKEN_ROLE\");\r\n    bytes32 public constant ADD_PRESIGNED_HASH_ROLE = keccak256(\"ADD_PRESIGNED_HASH_ROLE\");\r\n    bytes32 public constant DESIGNATE_SIGNER_ROLE = keccak256(\"DESIGNATE_SIGNER_ROLE\");\r\n    bytes32 public constant RUN_SCRIPT_ROLE = keccak256(\"RUN_SCRIPT_ROLE\");\r\n    */\r\n\r\n    bytes32 public constant EXECUTE_ROLE = 0xcebf517aa4440d1d125e0355aae64401211d0848a23c02cc5d29a14822580ba4;\r\n    bytes32 public constant SAFE_EXECUTE_ROLE = 0x0a1ad7b87f5846153c6d5a1f761d71c7d0cfd122384f56066cd33239b7933694;\r\n    bytes32 public constant ADD_PROTECTED_TOKEN_ROLE = 0x6eb2a499556bfa2872f5aa15812b956cc4a71b4d64eb3553f7073c7e41415aaa;\r\n    bytes32 public constant REMOVE_PROTECTED_TOKEN_ROLE = 0x71eee93d500f6f065e38b27d242a756466a00a52a1dbcd6b4260f01a8640402a;\r\n    bytes32 public constant ADD_PRESIGNED_HASH_ROLE = 0x0b29780bb523a130b3b01f231ef49ed2fa2781645591a0b0a44ca98f15a5994c;\r\n    bytes32 public constant DESIGNATE_SIGNER_ROLE = 0x23ce341656c3f14df6692eebd4757791e33662b7dcf9970c8308303da5472b7c;\r\n    bytes32 public constant RUN_SCRIPT_ROLE = 0xb421f7ad7646747f3051c50c0b8e2377839296cd4973e27f63821d73e390338f;\r\n\r\n    uint256 public constant PROTECTED_TOKENS_CAP = 10;\r\n\r\n    bytes4 private constant ERC165_INTERFACE_ID = 0x01ffc9a7;\r\n\r\n    string private constant ERROR_TARGET_PROTECTED = \"AGENT_TARGET_PROTECTED\";\r\n    string private constant ERROR_PROTECTED_TOKENS_MODIFIED = \"AGENT_PROTECTED_TOKENS_MODIFIED\";\r\n    string private constant ERROR_PROTECTED_BALANCE_LOWERED = \"AGENT_PROTECTED_BALANCE_LOWERED\";\r\n    string private constant ERROR_TOKENS_CAP_REACHED = \"AGENT_TOKENS_CAP_REACHED\";\r\n    string private constant ERROR_TOKEN_NOT_ERC20 = \"AGENT_TOKEN_NOT_ERC20\";\r\n    string private constant ERROR_TOKEN_ALREADY_PROTECTED = \"AGENT_TOKEN_ALREADY_PROTECTED\";\r\n    string private constant ERROR_TOKEN_NOT_PROTECTED = \"AGENT_TOKEN_NOT_PROTECTED\";\r\n    string private constant ERROR_DESIGNATED_TO_SELF = \"AGENT_DESIGNATED_TO_SELF\";\r\n    string private constant ERROR_CAN_NOT_FORWARD = \"AGENT_CAN_NOT_FORWARD\";\r\n\r\n    mapping (bytes32 => bool) public isPresigned;\r\n    address public designatedSigner;\r\n    address[] public protectedTokens;\r\n\r\n    event SafeExecute(address indexed sender, address indexed target, bytes data);\r\n    event Execute(address indexed sender, address indexed target, uint256 ethValue, bytes data);\r\n    event AddProtectedToken(address indexed token);\r\n    event RemoveProtectedToken(address indexed token);\r\n    event PresignHash(address indexed sender, bytes32 indexed hash);\r\n    event SetDesignatedSigner(address indexed sender, address indexed oldSigner, address indexed newSigner);\r\n\r\n    /**\r\n    * @notice Execute '`@radspec(_target, _data)`' on `_target``_ethValue == 0 ? '' : ' (Sending' + @tokenAmount(0x0000000000000000000000000000000000000000, _ethValue) + ')'`\r\n    * @param _target Address where the action is being executed\r\n    * @param _ethValue Amount of ETH from the contract that is sent with the action\r\n    * @param _data Calldata for the action\r\n    * @return Exits call frame forwarding the return data of the executed call (either error or success data)\r\n    */\r\n    function execute(address _target, uint256 _ethValue, bytes _data)\r\n        external // This function MUST always be external as the function performs a low level return, exiting the Agent app execution context\r\n        authP(EXECUTE_ROLE, arr(_target, _ethValue, uint256(_getSig(_data)))) // bytes4 casted as uint256 sets the bytes as the LSBs\r\n    {\r\n        bool result = _target.call.value(_ethValue)(_data);\r\n\r\n        if (result) {\r\n            emit Execute(msg.sender, _target, _ethValue, _data);\r\n        }\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, returndatasize)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result case 0 { revert(ptr, returndatasize) }\r\n            default { return(ptr, returndatasize) }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Execute '`@radspec(_target, _data)`' on `_target` ensuring that protected tokens can't be spent\r\n    * @param _target Address where the action is being executed\r\n    * @param _data Calldata for the action\r\n    * @return Exits call frame forwarding the return data of the executed call (either error or success data)\r\n    */\r\n    function safeExecute(address _target, bytes _data)\r\n        external // This function MUST always be external as the function performs a low level return, exiting the Agent app execution context\r\n        authP(SAFE_EXECUTE_ROLE, arr(_target, uint256(_getSig(_data)))) // bytes4 casted as uint256 sets the bytes as the LSBs\r\n    {\r\n        uint256 protectedTokensLength = protectedTokens.length;\r\n        address[] memory protectedTokens_ = new address[](protectedTokensLength);\r\n        uint256[] memory balances = new uint256[](protectedTokensLength);\r\n\r\n        for (uint256 i = 0; i < protectedTokensLength; i++) {\r\n            address token = protectedTokens[i];\r\n            require(_target != token, ERROR_TARGET_PROTECTED);\r\n            // we copy the protected tokens array to check whether the storage array has been modified during the underlying call\r\n            protectedTokens_[i] = token;\r\n            // we copy the balances to check whether they have been modified during the underlying call\r\n            balances[i] = balance(token);\r\n        }\r\n\r\n        bool result = _target.call(_data);\r\n\r\n        bytes32 ptr;\r\n        uint256 size;\r\n        assembly {\r\n            size := returndatasize\r\n            ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, returndatasize))\r\n            returndatacopy(ptr, 0, returndatasize)\r\n        }\r\n\r\n        if (result) {\r\n            // if the underlying call has succeeded, we check that the protected tokens\r\n            // and their balances have not been modified and return the call's return data\r\n            require(protectedTokens.length == protectedTokensLength, ERROR_PROTECTED_TOKENS_MODIFIED);\r\n            for (uint256 j = 0; j < protectedTokensLength; j++) {\r\n                require(protectedTokens[j] == protectedTokens_[j], ERROR_PROTECTED_TOKENS_MODIFIED);\r\n                require(balance(protectedTokens[j]) >= balances[j], ERROR_PROTECTED_BALANCE_LOWERED);\r\n            }\r\n\r\n            emit SafeExecute(msg.sender, _target, _data);\r\n\r\n            assembly {\r\n                return(ptr, size)\r\n            }\r\n        } else {\r\n            // if the underlying call has failed, we revert and forward returned error data\r\n            assembly {\r\n                revert(ptr, size)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Add `_token.symbol(): string` to the list of protected tokens\r\n    * @param _token Address of the token to be protected\r\n    */\r\n    function addProtectedToken(address _token) external authP(ADD_PROTECTED_TOKEN_ROLE, arr(_token)) {\r\n        require(protectedTokens.length < PROTECTED_TOKENS_CAP, ERROR_TOKENS_CAP_REACHED);\r\n        require(_isERC20(_token), ERROR_TOKEN_NOT_ERC20);\r\n        require(!_tokenIsProtected(_token), ERROR_TOKEN_ALREADY_PROTECTED);\r\n\r\n        _addProtectedToken(_token);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove `_token.symbol(): string` from the list of protected tokens\r\n    * @param _token Address of the token to be unprotected\r\n    */\r\n    function removeProtectedToken(address _token) external authP(REMOVE_PROTECTED_TOKEN_ROLE, arr(_token)) {\r\n        require(_tokenIsProtected(_token), ERROR_TOKEN_NOT_PROTECTED);\r\n\r\n        _removeProtectedToken(_token);\r\n    }\r\n\r\n    /**\r\n    * @notice Pre-sign hash `_hash`\r\n    * @param _hash Hash that will be considered signed regardless of the signature checked with 'isValidSignature()'\r\n    */\r\n    function presignHash(bytes32 _hash)\r\n        external\r\n        authP(ADD_PRESIGNED_HASH_ROLE, arr(_hash))\r\n    {\r\n        isPresigned[_hash] = true;\r\n\r\n        emit PresignHash(msg.sender, _hash);\r\n    }\r\n\r\n    /**\r\n    * @notice Set `_designatedSigner` as the designated signer of the app, which will be able to sign messages on behalf of the app\r\n    * @param _designatedSigner Address that will be able to sign messages on behalf of the app\r\n    */\r\n    function setDesignatedSigner(address _designatedSigner)\r\n        external\r\n        authP(DESIGNATE_SIGNER_ROLE, arr(_designatedSigner))\r\n    {\r\n        // Prevent an infinite loop by setting the app itself as its designated signer.\r\n        // An undetectable loop can be created by setting a different contract as the\r\n        // designated signer which calls back into `isValidSignature`.\r\n        // Given that `isValidSignature` is always called with just 50k gas, the max\r\n        // damage of the loop is wasting 50k gas.\r\n        require(_designatedSigner != address(this), ERROR_DESIGNATED_TO_SELF);\r\n\r\n        address oldDesignatedSigner = designatedSigner;\r\n        designatedSigner = _designatedSigner;\r\n\r\n        emit SetDesignatedSigner(msg.sender, oldDesignatedSigner, _designatedSigner);\r\n    }\r\n\r\n    // Forwarding fns\r\n\r\n    /**\r\n    * @notice Tells whether the Agent app is a forwarder or not\r\n    * @dev IForwarder interface conformance\r\n    * @return Always true\r\n    */\r\n    function isForwarder() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Execute the script as the Agent app\r\n    * @dev IForwarder interface conformance. Forwards any token holder action.\r\n    * @param _evmScript Script being executed\r\n    */\r\n    function forward(bytes _evmScript) public {\r\n        require(canForward(msg.sender, _evmScript), ERROR_CAN_NOT_FORWARD);\r\n\r\n        bytes memory input = \"\"; // no input\r\n        address[] memory blacklist = new address[](0); // no addr blacklist, can interact with anything\r\n        runScript(_evmScript, input, blacklist);\r\n        // We don't need to emit an event here as EVMScriptRunner will emit ScriptResult if successful\r\n    }\r\n\r\n    /**\r\n    * @notice Tells whether `_sender` can forward actions or not\r\n    * @dev IForwarder interface conformance\r\n    * @param _sender Address of the account intending to forward an action\r\n    * @return True if the given address can run scripts, false otherwise\r\n    */\r\n    function canForward(address _sender, bytes _evmScript) public view returns (bool) {\r\n        // Note that `canPerform()` implicitly does an initialization check itself\r\n        return canPerform(_sender, RUN_SCRIPT_ROLE, arr(_getScriptACLParam(_evmScript)));\r\n    }\r\n\r\n    // ERC-165 conformance\r\n\r\n    /**\r\n     * @notice Tells whether this contract supports a given ERC-165 interface\r\n     * @param _interfaceId Interface bytes to check\r\n     * @return True if this contract supports the interface\r\n     */\r\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\r\n        return\r\n            _interfaceId == ERC1271_INTERFACE_ID ||\r\n            _interfaceId == ERC165_INTERFACE_ID;\r\n    }\r\n\r\n    // ERC-1271 conformance\r\n\r\n    /**\r\n     * @notice Tells whether a signature is seen as valid by this contract through ERC-1271\r\n     * @param _hash Arbitrary length data signed on the behalf of address (this)\r\n     * @param _signature Signature byte array associated with _data\r\n     * @return The ERC-1271 magic value if the signature is valid\r\n     */\r\n    function isValidSignature(bytes32 _hash, bytes _signature) public view returns (bytes4) {\r\n        // Short-circuit in case the hash was presigned. Optimization as performing calls\r\n        // and ecrecover is more expensive than an SLOAD.\r\n        if (isPresigned[_hash]) {\r\n            return returnIsValidSignatureMagicNumber(true);\r\n        }\r\n\r\n        bool isValid;\r\n        if (designatedSigner == address(0)) {\r\n            isValid = false;\r\n        } else {\r\n            isValid = SignatureValidator.isValidSignature(_hash, designatedSigner, _signature);\r\n        }\r\n\r\n        return returnIsValidSignatureMagicNumber(isValid);\r\n    }\r\n\r\n    // Getters\r\n\r\n    function getProtectedTokensLength() public view isInitialized returns (uint256) {\r\n        return protectedTokens.length;\r\n    }\r\n\r\n    // Internal fns\r\n\r\n    function _addProtectedToken(address _token) internal {\r\n        protectedTokens.push(_token);\r\n\r\n        emit AddProtectedToken(_token);\r\n    }\r\n\r\n    function _removeProtectedToken(address _token) internal {\r\n        protectedTokens[_protectedTokenIndex(_token)] = protectedTokens[protectedTokens.length - 1];\r\n        protectedTokens.length--;\r\n\r\n        emit RemoveProtectedToken(_token);\r\n    }\r\n\r\n    function _isERC20(address _token) internal view returns (bool) {\r\n        if (!isContract(_token)) {\r\n            return false;\r\n        }\r\n\r\n        // Throwaway sanity check to make sure the token's `balanceOf()` does not error (for now)\r\n        balance(_token);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _protectedTokenIndex(address _token) internal view returns (uint256) {\r\n        for (uint i = 0; i < protectedTokens.length; i++) {\r\n            if (protectedTokens[i] == _token) {\r\n              return i;\r\n            }\r\n        }\r\n\r\n        revert(ERROR_TOKEN_NOT_PROTECTED);\r\n    }\r\n\r\n    function _tokenIsProtected(address _token) internal view returns (bool) {\r\n        for (uint256 i = 0; i < protectedTokens.length; i++) {\r\n            if (protectedTokens[i] == _token) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function _getScriptACLParam(bytes _evmScript) internal pure returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(_evmScript)));\r\n    }\r\n\r\n    function _getSig(bytes _data) internal pure returns (bytes4 sig) {\r\n        if (_data.length < 4) {\r\n            return;\r\n        }\r\n\r\n        assembly { sig := mload(add(_data, 0x20)) }\r\n    }\r\n}\r\n\r\n// File: @aragon/apps-finance/contracts/Finance.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    GPL-3.0-or-later\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Finance is EtherTokenConstant, IsContract, AragonApp {\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n    using SafeERC20 for ERC20;\r\n\r\n    bytes32 public constant CREATE_PAYMENTS_ROLE = keccak256(\"CREATE_PAYMENTS_ROLE\");\r\n    bytes32 public constant CHANGE_PERIOD_ROLE = keccak256(\"CHANGE_PERIOD_ROLE\");\r\n    bytes32 public constant CHANGE_BUDGETS_ROLE = keccak256(\"CHANGE_BUDGETS_ROLE\");\r\n    bytes32 public constant EXECUTE_PAYMENTS_ROLE = keccak256(\"EXECUTE_PAYMENTS_ROLE\");\r\n    bytes32 public constant MANAGE_PAYMENTS_ROLE = keccak256(\"MANAGE_PAYMENTS_ROLE\");\r\n\r\n    uint256 internal constant NO_SCHEDULED_PAYMENT = 0;\r\n    uint256 internal constant NO_TRANSACTION = 0;\r\n    uint256 internal constant MAX_SCHEDULED_PAYMENTS_PER_TX = 20;\r\n    uint256 internal constant MAX_UINT256 = uint256(-1);\r\n    uint64 internal constant MAX_UINT64 = uint64(-1);\r\n    uint64 internal constant MINIMUM_PERIOD = uint64(1 days);\r\n\r\n    string private constant ERROR_COMPLETE_TRANSITION = \"FINANCE_COMPLETE_TRANSITION\";\r\n    string private constant ERROR_NO_SCHEDULED_PAYMENT = \"FINANCE_NO_SCHEDULED_PAYMENT\";\r\n    string private constant ERROR_NO_TRANSACTION = \"FINANCE_NO_TRANSACTION\";\r\n    string private constant ERROR_NO_PERIOD = \"FINANCE_NO_PERIOD\";\r\n    string private constant ERROR_VAULT_NOT_CONTRACT = \"FINANCE_VAULT_NOT_CONTRACT\";\r\n    string private constant ERROR_SET_PERIOD_TOO_SHORT = \"FINANCE_SET_PERIOD_TOO_SHORT\";\r\n    string private constant ERROR_NEW_PAYMENT_AMOUNT_ZERO = \"FINANCE_NEW_PAYMENT_AMOUNT_ZERO\";\r\n    string private constant ERROR_NEW_PAYMENT_INTERVAL_ZERO = \"FINANCE_NEW_PAYMENT_INTRVL_ZERO\";\r\n    string private constant ERROR_NEW_PAYMENT_EXECS_ZERO = \"FINANCE_NEW_PAYMENT_EXECS_ZERO\";\r\n    string private constant ERROR_NEW_PAYMENT_IMMEDIATE = \"FINANCE_NEW_PAYMENT_IMMEDIATE\";\r\n    string private constant ERROR_RECOVER_AMOUNT_ZERO = \"FINANCE_RECOVER_AMOUNT_ZERO\";\r\n    string private constant ERROR_DEPOSIT_AMOUNT_ZERO = \"FINANCE_DEPOSIT_AMOUNT_ZERO\";\r\n    string private constant ERROR_ETH_VALUE_MISMATCH = \"FINANCE_ETH_VALUE_MISMATCH\";\r\n    string private constant ERROR_BUDGET = \"FINANCE_BUDGET\";\r\n    string private constant ERROR_EXECUTE_PAYMENT_NUM = \"FINANCE_EXECUTE_PAYMENT_NUM\";\r\n    string private constant ERROR_EXECUTE_PAYMENT_TIME = \"FINANCE_EXECUTE_PAYMENT_TIME\";\r\n    string private constant ERROR_PAYMENT_RECEIVER = \"FINANCE_PAYMENT_RECEIVER\";\r\n    string private constant ERROR_TOKEN_TRANSFER_FROM_REVERTED = \"FINANCE_TKN_TRANSFER_FROM_REVERT\";\r\n    string private constant ERROR_TOKEN_APPROVE_FAILED = \"FINANCE_TKN_APPROVE_FAILED\";\r\n    string private constant ERROR_PAYMENT_INACTIVE = \"FINANCE_PAYMENT_INACTIVE\";\r\n    string private constant ERROR_REMAINING_BUDGET = \"FINANCE_REMAINING_BUDGET\";\r\n\r\n    // Order optimized for storage\r\n    struct ScheduledPayment {\r\n        address token;\r\n        address receiver;\r\n        address createdBy;\r\n        bool inactive;\r\n        uint256 amount;\r\n        uint64 initialPaymentTime;\r\n        uint64 interval;\r\n        uint64 maxExecutions;\r\n        uint64 executions;\r\n    }\r\n\r\n    // Order optimized for storage\r\n    struct Transaction {\r\n        address token;\r\n        address entity;\r\n        bool isIncoming;\r\n        uint256 amount;\r\n        uint256 paymentId;\r\n        uint64 paymentExecutionNumber;\r\n        uint64 date;\r\n        uint64 periodId;\r\n    }\r\n\r\n    struct TokenStatement {\r\n        uint256 expenses;\r\n        uint256 income;\r\n    }\r\n\r\n    struct Period {\r\n        uint64 startTime;\r\n        uint64 endTime;\r\n        uint256 firstTransactionId;\r\n        uint256 lastTransactionId;\r\n        mapping (address => TokenStatement) tokenStatement;\r\n    }\r\n\r\n    struct Settings {\r\n        uint64 periodDuration;\r\n        mapping (address => uint256) budgets;\r\n        mapping (address => bool) hasBudget;\r\n    }\r\n\r\n    Vault public vault;\r\n    Settings internal settings;\r\n\r\n    // We are mimicing arrays, we use mappings instead to make app upgrade more graceful\r\n    mapping (uint256 => ScheduledPayment) internal scheduledPayments;\r\n    // Payments start at index 1, to allow us to use scheduledPayments[0] for transactions that are not\r\n    // linked to a scheduled payment\r\n    uint256 public paymentsNextIndex;\r\n\r\n    mapping (uint256 => Transaction) internal transactions;\r\n    uint256 public transactionsNextIndex;\r\n\r\n    mapping (uint64 => Period) internal periods;\r\n    uint64 public periodsLength;\r\n\r\n    event NewPeriod(uint64 indexed periodId, uint64 periodStarts, uint64 periodEnds);\r\n    event SetBudget(address indexed token, uint256 amount, bool hasBudget);\r\n    event NewPayment(uint256 indexed paymentId, address indexed recipient, uint64 maxExecutions, string reference);\r\n    event NewTransaction(uint256 indexed transactionId, bool incoming, address indexed entity, uint256 amount, string reference);\r\n    event ChangePaymentState(uint256 indexed paymentId, bool active);\r\n    event ChangePeriodDuration(uint64 newDuration);\r\n    event PaymentFailure(uint256 paymentId);\r\n\r\n    // Modifier used by all methods that impact accounting to make sure accounting period\r\n    // is changed before the operation if needed\r\n    // NOTE: its use **MUST** be accompanied by an initialization check\r\n    modifier transitionsPeriod {\r\n        bool completeTransition = _tryTransitionAccountingPeriod(getMaxPeriodTransitions());\r\n        require(completeTransition, ERROR_COMPLETE_TRANSITION);\r\n        _;\r\n    }\r\n\r\n    modifier scheduledPaymentExists(uint256 _paymentId) {\r\n        require(_paymentId > 0 && _paymentId < paymentsNextIndex, ERROR_NO_SCHEDULED_PAYMENT);\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint256 _transactionId) {\r\n        require(_transactionId > 0 && _transactionId < transactionsNextIndex, ERROR_NO_TRANSACTION);\r\n        _;\r\n    }\r\n\r\n    modifier periodExists(uint64 _periodId) {\r\n        require(_periodId < periodsLength, ERROR_NO_PERIOD);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit ETH to the Vault, to avoid locking them in this Finance app forever\r\n     * @dev Send ETH to Vault. Send all the available balance.\r\n     */\r\n    function () external payable isInitialized transitionsPeriod {\r\n        require(msg.value > 0, ERROR_DEPOSIT_AMOUNT_ZERO);\r\n        _deposit(\r\n            ETH,\r\n            msg.value,\r\n            \"Ether transfer to Finance app\",\r\n            msg.sender,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Initialize Finance app for Vault at `_vault` with period length of `@transformTime(_periodDuration)`\r\n    * @param _vault Address of the vault Finance will rely on (non changeable)\r\n    * @param _periodDuration Duration in seconds of each period\r\n    */\r\n    function initialize(Vault _vault, uint64 _periodDuration) external onlyInit {\r\n        initialized();\r\n\r\n        require(isContract(_vault), ERROR_VAULT_NOT_CONTRACT);\r\n        vault = _vault;\r\n\r\n        require(_periodDuration >= MINIMUM_PERIOD, ERROR_SET_PERIOD_TOO_SHORT);\r\n        settings.periodDuration = _periodDuration;\r\n\r\n        // Reserve the first scheduled payment index as an unused index for transactions not linked\r\n        // to a scheduled payment\r\n        scheduledPayments[0].inactive = true;\r\n        paymentsNextIndex = 1;\r\n\r\n        // Reserve the first transaction index as an unused index for periods with no transactions\r\n        transactionsNextIndex = 1;\r\n\r\n        // Start the first period\r\n        _newPeriod(getTimestamp64());\r\n    }\r\n\r\n    /**\r\n    * @notice Deposit `@tokenAmount(_token, _amount)`\r\n    * @dev Deposit for approved ERC20 tokens or ETH\r\n    * @param _token Address of deposited token\r\n    * @param _amount Amount of tokens sent\r\n    * @param _reference Reason for payment\r\n    */\r\n    function deposit(address _token, uint256 _amount, string _reference) external payable isInitialized transitionsPeriod {\r\n        require(_amount > 0, ERROR_DEPOSIT_AMOUNT_ZERO);\r\n        if (_token == ETH) {\r\n            // Ensure that the ETH sent with the transaction equals the amount in the deposit\r\n            require(msg.value == _amount, ERROR_ETH_VALUE_MISMATCH);\r\n        }\r\n\r\n        _deposit(\r\n            _token,\r\n            _amount,\r\n            _reference,\r\n            msg.sender,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Create a new payment of `@tokenAmount(_token, _amount)` to `_receiver` for '`_reference`'\r\n    * @dev Note that this function is protected by the `CREATE_PAYMENTS_ROLE` but uses `MAX_UINT256`\r\n    *      as its interval auth parameter (as a sentinel value for \"never repeating\").\r\n    *      While this protects against most cases (you typically want to set a baseline requirement\r\n    *      for interval time), it does mean users will have to explicitly check for this case when\r\n    *      granting a permission that includes a upperbound requirement on the interval time.\r\n    * @param _token Address of token for payment\r\n    * @param _receiver Address that will receive payment\r\n    * @param _amount Tokens that are paid every time the payment is due\r\n    * @param _reference String detailing payment reason\r\n    */\r\n    function newImmediatePayment(address _token, address _receiver, uint256 _amount, string _reference)\r\n        external\r\n        // Use MAX_UINT256 as the interval parameter, as this payment will never repeat\r\n        // Payment time parameter is left as the last param as it was added later\r\n        authP(CREATE_PAYMENTS_ROLE, _arr(_token, _receiver, _amount, MAX_UINT256, uint256(1), getTimestamp()))\r\n        transitionsPeriod\r\n    {\r\n        require(_amount > 0, ERROR_NEW_PAYMENT_AMOUNT_ZERO);\r\n\r\n        _makePaymentTransaction(\r\n            _token,\r\n            _receiver,\r\n            _amount,\r\n            NO_SCHEDULED_PAYMENT,   // unrelated to any payment id; it isn't created\r\n            0,   // also unrelated to any payment executions\r\n            _reference\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Create a new payment of `@tokenAmount(_token, _amount)` to `_receiver` for `_reference`, executing `_maxExecutions` times at intervals of `@transformTime(_interval)`\r\n    * @dev See `newImmediatePayment()` for limitations on how the interval auth parameter can be used\r\n    * @param _token Address of token for payment\r\n    * @param _receiver Address that will receive payment\r\n    * @param _amount Tokens that are paid every time the payment is due\r\n    * @param _initialPaymentTime Timestamp for when the first payment is done\r\n    * @param _interval Number of seconds that need to pass between payment transactions\r\n    * @param _maxExecutions Maximum instances a payment can be executed\r\n    * @param _reference String detailing payment reason\r\n    */\r\n    function newScheduledPayment(\r\n        address _token,\r\n        address _receiver,\r\n        uint256 _amount,\r\n        uint64 _initialPaymentTime,\r\n        uint64 _interval,\r\n        uint64 _maxExecutions,\r\n        string _reference\r\n    )\r\n        external\r\n        // Payment time parameter is left as the last param as it was added later\r\n        authP(CREATE_PAYMENTS_ROLE, _arr(_token, _receiver, _amount, uint256(_interval), uint256(_maxExecutions), uint256(_initialPaymentTime)))\r\n        transitionsPeriod\r\n        returns (uint256 paymentId)\r\n    {\r\n        require(_amount > 0, ERROR_NEW_PAYMENT_AMOUNT_ZERO);\r\n        require(_interval > 0, ERROR_NEW_PAYMENT_INTERVAL_ZERO);\r\n        require(_maxExecutions > 0, ERROR_NEW_PAYMENT_EXECS_ZERO);\r\n\r\n        // Token budget must not be set at all or allow at least one instance of this payment each period\r\n        require(!settings.hasBudget[_token] || settings.budgets[_token] >= _amount, ERROR_BUDGET);\r\n\r\n        // Don't allow creating single payments that are immediately executable, use `newImmediatePayment()` instead\r\n        if (_maxExecutions == 1) {\r\n            require(_initialPaymentTime > getTimestamp64(), ERROR_NEW_PAYMENT_IMMEDIATE);\r\n        }\r\n\r\n        paymentId = paymentsNextIndex++;\r\n        emit NewPayment(paymentId, _receiver, _maxExecutions, _reference);\r\n\r\n        ScheduledPayment storage payment = scheduledPayments[paymentId];\r\n        payment.token = _token;\r\n        payment.receiver = _receiver;\r\n        payment.amount = _amount;\r\n        payment.initialPaymentTime = _initialPaymentTime;\r\n        payment.interval = _interval;\r\n        payment.maxExecutions = _maxExecutions;\r\n        payment.createdBy = msg.sender;\r\n\r\n        // We skip checking how many times the new payment was executed to allow creating new\r\n        // scheduled payments before having enough vault balance\r\n        _executePayment(paymentId);\r\n    }\r\n\r\n    /**\r\n    * @notice Change period duration to `@transformTime(_periodDuration)`, effective for next accounting period\r\n    * @param _periodDuration Duration in seconds for accounting periods\r\n    */\r\n    function setPeriodDuration(uint64 _periodDuration)\r\n        external\r\n        authP(CHANGE_PERIOD_ROLE, arr(uint256(_periodDuration), uint256(settings.periodDuration)))\r\n        transitionsPeriod\r\n    {\r\n        require(_periodDuration >= MINIMUM_PERIOD, ERROR_SET_PERIOD_TOO_SHORT);\r\n        settings.periodDuration = _periodDuration;\r\n        emit ChangePeriodDuration(_periodDuration);\r\n    }\r\n\r\n    /**\r\n    * @notice Set budget for `_token.symbol(): string` to `@tokenAmount(_token, _amount, false)`, effective immediately\r\n    * @param _token Address for token\r\n    * @param _amount New budget amount\r\n    */\r\n    function setBudget(\r\n        address _token,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        authP(CHANGE_BUDGETS_ROLE, arr(_token, _amount, settings.budgets[_token], uint256(settings.hasBudget[_token] ? 1 : 0)))\r\n        transitionsPeriod\r\n    {\r\n        settings.budgets[_token] = _amount;\r\n        if (!settings.hasBudget[_token]) {\r\n            settings.hasBudget[_token] = true;\r\n        }\r\n        emit SetBudget(_token, _amount, true);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove spending limit for `_token.symbol(): string`, effective immediately\r\n    * @param _token Address for token\r\n    */\r\n    function removeBudget(address _token)\r\n        external\r\n        authP(CHANGE_BUDGETS_ROLE, arr(_token, uint256(0), settings.budgets[_token], uint256(settings.hasBudget[_token] ? 1 : 0)))\r\n        transitionsPeriod\r\n    {\r\n        settings.budgets[_token] = 0;\r\n        settings.hasBudget[_token] = false;\r\n        emit SetBudget(_token, 0, false);\r\n    }\r\n\r\n    /**\r\n    * @notice Execute pending payment #`_paymentId`\r\n    * @dev Executes any payment (requires role)\r\n    * @param _paymentId Identifier for payment\r\n    */\r\n    function executePayment(uint256 _paymentId)\r\n        external\r\n        authP(EXECUTE_PAYMENTS_ROLE, arr(_paymentId, scheduledPayments[_paymentId].amount))\r\n        scheduledPaymentExists(_paymentId)\r\n        transitionsPeriod\r\n    {\r\n        _executePaymentAtLeastOnce(_paymentId);\r\n    }\r\n\r\n    /**\r\n    * @notice Execute pending payment #`_paymentId`\r\n    * @dev Always allow receiver of a payment to trigger execution\r\n    *      Initialization check is implicitly provided by `scheduledPaymentExists()` as new\r\n    *      scheduled payments can only be created via `newScheduledPayment(),` which requires initialization\r\n    * @param _paymentId Identifier for payment\r\n    */\r\n    function receiverExecutePayment(uint256 _paymentId) external scheduledPaymentExists(_paymentId) transitionsPeriod {\r\n        require(scheduledPayments[_paymentId].receiver == msg.sender, ERROR_PAYMENT_RECEIVER);\r\n        _executePaymentAtLeastOnce(_paymentId);\r\n    }\r\n\r\n    /**\r\n    * @notice `_active ? 'Activate' : 'Disable'` payment #`_paymentId`\r\n    * @dev Note that we do not require this action to transition periods, as it doesn't directly\r\n    *      impact any accounting periods.\r\n    *      Not having to transition periods also makes disabling payments easier to prevent funds\r\n    *      from being pulled out in the event of a breach.\r\n    * @param _paymentId Identifier for payment\r\n    * @param _active Whether it will be active or inactive\r\n    */\r\n    function setPaymentStatus(uint256 _paymentId, bool _active)\r\n        external\r\n        authP(MANAGE_PAYMENTS_ROLE, arr(_paymentId, uint256(_active ? 1 : 0)))\r\n        scheduledPaymentExists(_paymentId)\r\n    {\r\n        scheduledPayments[_paymentId].inactive = !_active;\r\n        emit ChangePaymentState(_paymentId, _active);\r\n    }\r\n\r\n    /**\r\n     * @notice Send tokens held in this contract to the Vault\r\n     * @dev Allows making a simple payment from this contract to the Vault, to avoid locked tokens.\r\n     *      This contract should never receive tokens with a simple transfer call, but in case it\r\n     *      happens, this function allows for their recovery.\r\n     * @param _token Token whose balance is going to be transferred.\r\n     */\r\n    function recoverToVault(address _token) external isInitialized transitionsPeriod {\r\n        uint256 amount = _token == ETH ? address(this).balance : ERC20(_token).staticBalanceOf(address(this));\r\n        require(amount > 0, ERROR_RECOVER_AMOUNT_ZERO);\r\n\r\n        _deposit(\r\n            _token,\r\n            amount,\r\n            \"Recover to Vault\",\r\n            address(this),\r\n            false\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Transition accounting period if needed\r\n    * @dev Transitions accounting periods if needed. For preventing OOG attacks, a maxTransitions\r\n    *      param is provided. If more than the specified number of periods need to be transitioned,\r\n    *      it will return false.\r\n    * @param _maxTransitions Maximum periods that can be transitioned\r\n    * @return success Boolean indicating whether the accounting period is the correct one (if false,\r\n    *                 maxTransitions was surpased and another call is needed)\r\n    */\r\n    function tryTransitionAccountingPeriod(uint64 _maxTransitions) external isInitialized returns (bool success) {\r\n        return _tryTransitionAccountingPeriod(_maxTransitions);\r\n    }\r\n\r\n    // Getter fns\r\n\r\n    /**\r\n    * @dev Disable recovery escape hatch if the app has been initialized, as it could be used\r\n    *      maliciously to transfer funds in the Finance app to another Vault\r\n    *      finance#recoverToVault() should be used to recover funds to the Finance's vault\r\n    */\r\n    function allowRecoverability(address) public view returns (bool) {\r\n        return !hasInitialized();\r\n    }\r\n\r\n    function getPayment(uint256 _paymentId)\r\n        public\r\n        view\r\n        scheduledPaymentExists(_paymentId)\r\n        returns (\r\n            address token,\r\n            address receiver,\r\n            uint256 amount,\r\n            uint64 initialPaymentTime,\r\n            uint64 interval,\r\n            uint64 maxExecutions,\r\n            bool inactive,\r\n            uint64 executions,\r\n            address createdBy\r\n        )\r\n    {\r\n        ScheduledPayment storage payment = scheduledPayments[_paymentId];\r\n\r\n        token = payment.token;\r\n        receiver = payment.receiver;\r\n        amount = payment.amount;\r\n        initialPaymentTime = payment.initialPaymentTime;\r\n        interval = payment.interval;\r\n        maxExecutions = payment.maxExecutions;\r\n        executions = payment.executions;\r\n        inactive = payment.inactive;\r\n        createdBy = payment.createdBy;\r\n    }\r\n\r\n    function getTransaction(uint256 _transactionId)\r\n        public\r\n        view\r\n        transactionExists(_transactionId)\r\n        returns (\r\n            uint64 periodId,\r\n            uint256 amount,\r\n            uint256 paymentId,\r\n            uint64 paymentExecutionNumber,\r\n            address token,\r\n            address entity,\r\n            bool isIncoming,\r\n            uint64 date\r\n        )\r\n    {\r\n        Transaction storage transaction = transactions[_transactionId];\r\n\r\n        token = transaction.token;\r\n        entity = transaction.entity;\r\n        isIncoming = transaction.isIncoming;\r\n        date = transaction.date;\r\n        periodId = transaction.periodId;\r\n        amount = transaction.amount;\r\n        paymentId = transaction.paymentId;\r\n        paymentExecutionNumber = transaction.paymentExecutionNumber;\r\n    }\r\n\r\n    function getPeriod(uint64 _periodId)\r\n        public\r\n        view\r\n        periodExists(_periodId)\r\n        returns (\r\n            bool isCurrent,\r\n            uint64 startTime,\r\n            uint64 endTime,\r\n            uint256 firstTransactionId,\r\n            uint256 lastTransactionId\r\n        )\r\n    {\r\n        Period storage period = periods[_periodId];\r\n\r\n        isCurrent = _currentPeriodId() == _periodId;\r\n\r\n        startTime = period.startTime;\r\n        endTime = period.endTime;\r\n        firstTransactionId = period.firstTransactionId;\r\n        lastTransactionId = period.lastTransactionId;\r\n    }\r\n\r\n    function getPeriodTokenStatement(uint64 _periodId, address _token)\r\n        public\r\n        view\r\n        periodExists(_periodId)\r\n        returns (uint256 expenses, uint256 income)\r\n    {\r\n        TokenStatement storage tokenStatement = periods[_periodId].tokenStatement[_token];\r\n        expenses = tokenStatement.expenses;\r\n        income = tokenStatement.income;\r\n    }\r\n\r\n    /**\r\n    * @dev We have to check for initialization as periods are only valid after initializing\r\n    */\r\n    function currentPeriodId() public view isInitialized returns (uint64) {\r\n        return _currentPeriodId();\r\n    }\r\n\r\n    /**\r\n    * @dev We have to check for initialization as periods are only valid after initializing\r\n    */\r\n    function getPeriodDuration() public view isInitialized returns (uint64) {\r\n        return settings.periodDuration;\r\n    }\r\n\r\n    /**\r\n    * @dev We have to check for initialization as budgets are only valid after initializing\r\n    */\r\n    function getBudget(address _token) public view isInitialized returns (uint256 budget, bool hasBudget) {\r\n        budget = settings.budgets[_token];\r\n        hasBudget = settings.hasBudget[_token];\r\n    }\r\n\r\n    /**\r\n    * @dev We have to check for initialization as budgets are only valid after initializing\r\n    */\r\n    function getRemainingBudget(address _token) public view isInitialized returns (uint256) {\r\n        return _getRemainingBudget(_token);\r\n    }\r\n\r\n    /**\r\n    * @dev We have to check for initialization as budgets are only valid after initializing\r\n    */\r\n    function canMakePayment(address _token, uint256 _amount) public view isInitialized returns (bool) {\r\n        return _canMakePayment(_token, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Initialization check is implicitly provided by `scheduledPaymentExists()` as new\r\n    *      scheduled payments can only be created via `newScheduledPayment(),` which requires initialization\r\n    */\r\n    function nextPaymentTime(uint256 _paymentId) public view scheduledPaymentExists(_paymentId) returns (uint64) {\r\n        return _nextPaymentTime(_paymentId);\r\n    }\r\n\r\n    // Internal fns\r\n\r\n    function _deposit(address _token, uint256 _amount, string _reference, address _sender, bool _isExternalDeposit) internal {\r\n        _recordIncomingTransaction(\r\n            _token,\r\n            _sender,\r\n            _amount,\r\n            _reference\r\n        );\r\n\r\n        if (_token == ETH) {\r\n            vault.deposit.value(_amount)(ETH, _amount);\r\n        } else {\r\n            // First, transfer the tokens to Finance if necessary\r\n            // External deposit will be false when the assets were already in the Finance app\r\n            // and just need to be transferred to the Vault\r\n            if (_isExternalDeposit) {\r\n                // This assumes the sender has approved the tokens for Finance\r\n                require(\r\n                    ERC20(_token).safeTransferFrom(msg.sender, address(this), _amount),\r\n                    ERROR_TOKEN_TRANSFER_FROM_REVERTED\r\n                );\r\n            }\r\n            // Approve the tokens for the Vault (it does the actual transferring)\r\n            require(ERC20(_token).safeApprove(vault, _amount), ERROR_TOKEN_APPROVE_FAILED);\r\n            // Finally, initiate the deposit\r\n            vault.deposit(_token, _amount);\r\n        }\r\n    }\r\n\r\n    function _executePayment(uint256 _paymentId) internal returns (uint256) {\r\n        ScheduledPayment storage payment = scheduledPayments[_paymentId];\r\n        require(!payment.inactive, ERROR_PAYMENT_INACTIVE);\r\n\r\n        uint64 paid = 0;\r\n        while (_nextPaymentTime(_paymentId) <= getTimestamp64() && paid < MAX_SCHEDULED_PAYMENTS_PER_TX) {\r\n            if (!_canMakePayment(payment.token, payment.amount)) {\r\n                emit PaymentFailure(_paymentId);\r\n                break;\r\n            }\r\n\r\n            // The while() predicate prevents these two from ever overflowing\r\n            payment.executions += 1;\r\n            paid += 1;\r\n\r\n            // We've already checked the remaining budget with `_canMakePayment()`\r\n            _unsafeMakePaymentTransaction(\r\n                payment.token,\r\n                payment.receiver,\r\n                payment.amount,\r\n                _paymentId,\r\n                payment.executions,\r\n                \"\"\r\n            );\r\n        }\r\n\r\n        return paid;\r\n    }\r\n\r\n    function _executePaymentAtLeastOnce(uint256 _paymentId) internal {\r\n        uint256 paid = _executePayment(_paymentId);\r\n        if (paid == 0) {\r\n            if (_nextPaymentTime(_paymentId) <= getTimestamp64()) {\r\n                revert(ERROR_EXECUTE_PAYMENT_NUM);\r\n            } else {\r\n                revert(ERROR_EXECUTE_PAYMENT_TIME);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _makePaymentTransaction(\r\n        address _token,\r\n        address _receiver,\r\n        uint256 _amount,\r\n        uint256 _paymentId,\r\n        uint64 _paymentExecutionNumber,\r\n        string _reference\r\n    )\r\n        internal\r\n    {\r\n        require(_getRemainingBudget(_token) >= _amount, ERROR_REMAINING_BUDGET);\r\n        _unsafeMakePaymentTransaction(_token, _receiver, _amount, _paymentId, _paymentExecutionNumber, _reference);\r\n    }\r\n\r\n    /**\r\n    * @dev Unsafe version of _makePaymentTransaction that assumes you have already checked the\r\n    *      remaining budget\r\n    */\r\n    function _unsafeMakePaymentTransaction(\r\n        address _token,\r\n        address _receiver,\r\n        uint256 _amount,\r\n        uint256 _paymentId,\r\n        uint64 _paymentExecutionNumber,\r\n        string _reference\r\n    )\r\n        internal\r\n    {\r\n        _recordTransaction(\r\n            false,\r\n            _token,\r\n            _receiver,\r\n            _amount,\r\n            _paymentId,\r\n            _paymentExecutionNumber,\r\n            _reference\r\n        );\r\n\r\n        vault.transfer(_token, _receiver, _amount);\r\n    }\r\n\r\n    function _newPeriod(uint64 _startTime) internal returns (Period storage) {\r\n        // There should be no way for this to overflow since each period is at least one day\r\n        uint64 newPeriodId = periodsLength++;\r\n\r\n        Period storage period = periods[newPeriodId];\r\n        period.startTime = _startTime;\r\n\r\n        // Be careful here to not overflow; if startTime + periodDuration overflows, we set endTime\r\n        // to MAX_UINT64 (let's assume that's the end of time for now).\r\n        uint64 endTime = _startTime + settings.periodDuration - 1;\r\n        if (endTime < _startTime) { // overflowed\r\n            endTime = MAX_UINT64;\r\n        }\r\n        period.endTime = endTime;\r\n\r\n        emit NewPeriod(newPeriodId, period.startTime, period.endTime);\r\n\r\n        return period;\r\n    }\r\n\r\n    function _recordIncomingTransaction(\r\n        address _token,\r\n        address _sender,\r\n        uint256 _amount,\r\n        string _reference\r\n    )\r\n        internal\r\n    {\r\n        _recordTransaction(\r\n            true, // incoming transaction\r\n            _token,\r\n            _sender,\r\n            _amount,\r\n            NO_SCHEDULED_PAYMENT, // unrelated to any existing payment\r\n            0, // and no payment executions\r\n            _reference\r\n        );\r\n    }\r\n\r\n    function _recordTransaction(\r\n        bool _incoming,\r\n        address _token,\r\n        address _entity,\r\n        uint256 _amount,\r\n        uint256 _paymentId,\r\n        uint64 _paymentExecutionNumber,\r\n        string _reference\r\n    )\r\n        internal\r\n    {\r\n        uint64 periodId = _currentPeriodId();\r\n        TokenStatement storage tokenStatement = periods[periodId].tokenStatement[_token];\r\n        if (_incoming) {\r\n            tokenStatement.income = tokenStatement.income.add(_amount);\r\n        } else {\r\n            tokenStatement.expenses = tokenStatement.expenses.add(_amount);\r\n        }\r\n\r\n        uint256 transactionId = transactionsNextIndex++;\r\n\r\n        Transaction storage transaction = transactions[transactionId];\r\n        transaction.token = _token;\r\n        transaction.entity = _entity;\r\n        transaction.isIncoming = _incoming;\r\n        transaction.amount = _amount;\r\n        transaction.paymentId = _paymentId;\r\n        transaction.paymentExecutionNumber = _paymentExecutionNumber;\r\n        transaction.date = getTimestamp64();\r\n        transaction.periodId = periodId;\r\n\r\n        Period storage period = periods[periodId];\r\n        if (period.firstTransactionId == NO_TRANSACTION) {\r\n            period.firstTransactionId = transactionId;\r\n        }\r\n\r\n        emit NewTransaction(transactionId, _incoming, _entity, _amount, _reference);\r\n    }\r\n\r\n    function _tryTransitionAccountingPeriod(uint64 _maxTransitions) internal returns (bool success) {\r\n        Period storage currentPeriod = periods[_currentPeriodId()];\r\n        uint64 timestamp = getTimestamp64();\r\n\r\n        // Transition periods if necessary\r\n        while (timestamp > currentPeriod.endTime) {\r\n            if (_maxTransitions == 0) {\r\n                // Required number of transitions is over allowed number, return false indicating\r\n                // it didn't fully transition\r\n                return false;\r\n            }\r\n            // We're already protected from underflowing above\r\n            _maxTransitions -= 1;\r\n\r\n            // If there were any transactions in period, record which was the last\r\n            // In case 0 transactions occured, first and last tx id will be 0\r\n            if (currentPeriod.firstTransactionId != NO_TRANSACTION) {\r\n                currentPeriod.lastTransactionId = transactionsNextIndex.sub(1);\r\n            }\r\n\r\n            // New period starts at end time + 1\r\n            currentPeriod = _newPeriod(currentPeriod.endTime.add(1));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _canMakePayment(address _token, uint256 _amount) internal view returns (bool) {\r\n        return _getRemainingBudget(_token) >= _amount && vault.balance(_token) >= _amount;\r\n    }\r\n\r\n    function _currentPeriodId() internal view returns (uint64) {\r\n        // There is no way for this to overflow if protected by an initialization check\r\n        return periodsLength - 1;\r\n    }\r\n\r\n    function _getRemainingBudget(address _token) internal view returns (uint256) {\r\n        if (!settings.hasBudget[_token]) {\r\n            return MAX_UINT256;\r\n        }\r\n\r\n        uint256 budget = settings.budgets[_token];\r\n        uint256 spent = periods[_currentPeriodId()].tokenStatement[_token].expenses;\r\n\r\n        // A budget decrease can cause the spent amount to be greater than period budget\r\n        // If so, return 0 to not allow more spending during period\r\n        if (spent >= budget) {\r\n            return 0;\r\n        }\r\n\r\n        // We're already protected from the overflow above\r\n        return budget - spent;\r\n    }\r\n\r\n    function _nextPaymentTime(uint256 _paymentId) internal view returns (uint64) {\r\n        ScheduledPayment storage payment = scheduledPayments[_paymentId];\r\n\r\n        if (payment.executions >= payment.maxExecutions) {\r\n            return MAX_UINT64; // re-executes in some billions of years time... should not need to worry\r\n        }\r\n\r\n        // Split in multiple lines to circumvent linter warning\r\n        uint64 increase = payment.executions.mul(payment.interval);\r\n        uint64 nextPayment = payment.initialPaymentTime.add(increase);\r\n        return nextPayment;\r\n    }\r\n\r\n    // Syntax sugar\r\n\r\n    function _arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e, uint256 _f) internal pure returns (uint256[] r) {\r\n        r = new uint256[](6);\r\n        r[0] = uint256(_a);\r\n        r[1] = uint256(_b);\r\n        r[2] = _c;\r\n        r[3] = _d;\r\n        r[4] = _e;\r\n        r[5] = _f;\r\n    }\r\n\r\n    // Mocked fns (overrided during testing)\r\n    // Must be view for mocking purposes\r\n\r\n    function getMaxPeriodTransitions() internal view returns (uint64) { return MAX_UINT64; }\r\n}\r\n\r\n// File: @aragon/ppf-contracts/contracts/IFeed.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\ninterface IFeed {\r\n    function ratePrecision() external pure returns (uint256);\r\n    function get(address base, address quote) external view returns (uint128 xrt, uint64 when);\r\n}\r\n\r\n// File: @aragon/apps-payroll/contracts/Payroll.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Payroll in multiple currencies\r\n */\r\ncontract Payroll is EtherTokenConstant, IForwarder, IsContract, AragonApp {\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n\r\n    /* Hardcoded constants to save gas\r\n    * bytes32 constant public ADD_EMPLOYEE_ROLE = keccak256(\"ADD_EMPLOYEE_ROLE\");\r\n    * bytes32 constant public TERMINATE_EMPLOYEE_ROLE = keccak256(\"TERMINATE_EMPLOYEE_ROLE\");\r\n    * bytes32 constant public SET_EMPLOYEE_SALARY_ROLE = keccak256(\"SET_EMPLOYEE_SALARY_ROLE\");\r\n    * bytes32 constant public ADD_BONUS_ROLE = keccak256(\"ADD_BONUS_ROLE\");\r\n    * bytes32 constant public ADD_REIMBURSEMENT_ROLE = keccak256(\"ADD_REIMBURSEMENT_ROLE\");\r\n    * bytes32 constant public MANAGE_ALLOWED_TOKENS_ROLE = keccak256(\"MANAGE_ALLOWED_TOKENS_ROLE\");\r\n    * bytes32 constant public MODIFY_PRICE_FEED_ROLE = keccak256(\"MODIFY_PRICE_FEED_ROLE\");\r\n    * bytes32 constant public MODIFY_RATE_EXPIRY_ROLE = keccak256(\"MODIFY_RATE_EXPIRY_ROLE\");\r\n    */\r\n\r\n    bytes32 constant public ADD_EMPLOYEE_ROLE = 0x9ecdc3c63716b45d0756eece5fe1614cae1889ec5a1ce62b3127c1f1f1615d6e;\r\n    bytes32 constant public TERMINATE_EMPLOYEE_ROLE = 0x69c67f914d12b6440e7ddf01961214818d9158fbcb19211e0ff42800fdea9242;\r\n    bytes32 constant public SET_EMPLOYEE_SALARY_ROLE = 0xea9ac65018da2421cf419ee2152371440c08267a193a33ccc1e39545d197e44d;\r\n    bytes32 constant public ADD_BONUS_ROLE = 0xceca7e2f5eb749a87aaf68f3f76d6b9251aa2f4600f13f93c5a4adf7a72df4ae;\r\n    bytes32 constant public ADD_REIMBURSEMENT_ROLE = 0x90698b9d54427f1e41636025017309bdb1b55320da960c8845bab0a504b01a16;\r\n    bytes32 constant public MANAGE_ALLOWED_TOKENS_ROLE = 0x0be34987c45700ee3fae8c55e270418ba903337decc6bacb1879504be9331c06;\r\n    bytes32 constant public MODIFY_PRICE_FEED_ROLE = 0x74350efbcba8b85341c5bbf70cc34e2a585fc1463524773a12fa0a71d4eb9302;\r\n    bytes32 constant public MODIFY_RATE_EXPIRY_ROLE = 0x79fe989a8899060dfbdabb174ebb96616fa9f1d9dadd739f8d814cbab452404e;\r\n\r\n    uint256 internal constant MAX_ALLOWED_TOKENS = 20; // prevent OOG issues with `payday()`\r\n    uint64 internal constant MIN_RATE_EXPIRY = uint64(1 minutes); // 1 min == ~4 block window to mine both a price feed update and a payout\r\n\r\n    uint256 internal constant MAX_UINT256 = uint256(-1);\r\n    uint64 internal constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_EMPLOYEE_DOESNT_EXIST = \"PAYROLL_EMPLOYEE_DOESNT_EXIST\";\r\n    string private constant ERROR_NON_ACTIVE_EMPLOYEE = \"PAYROLL_NON_ACTIVE_EMPLOYEE\";\r\n    string private constant ERROR_SENDER_DOES_NOT_MATCH = \"PAYROLL_SENDER_DOES_NOT_MATCH\";\r\n    string private constant ERROR_FINANCE_NOT_CONTRACT = \"PAYROLL_FINANCE_NOT_CONTRACT\";\r\n    string private constant ERROR_TOKEN_ALREADY_SET = \"PAYROLL_TOKEN_ALREADY_SET\";\r\n    string private constant ERROR_MAX_ALLOWED_TOKENS = \"PAYROLL_MAX_ALLOWED_TOKENS\";\r\n    string private constant ERROR_MIN_RATES_MISMATCH = \"PAYROLL_MIN_RATES_MISMATCH\";\r\n    string private constant ERROR_TOKEN_ALLOCATION_MISMATCH = \"PAYROLL_TOKEN_ALLOCATION_MISMATCH\";\r\n    string private constant ERROR_NOT_ALLOWED_TOKEN = \"PAYROLL_NOT_ALLOWED_TOKEN\";\r\n    string private constant ERROR_DISTRIBUTION_NOT_FULL = \"PAYROLL_DISTRIBUTION_NOT_FULL\";\r\n    string private constant ERROR_INVALID_PAYMENT_TYPE = \"PAYROLL_INVALID_PAYMENT_TYPE\";\r\n    string private constant ERROR_NOTHING_PAID = \"PAYROLL_NOTHING_PAID\";\r\n    string private constant ERROR_CAN_NOT_FORWARD = \"PAYROLL_CAN_NOT_FORWARD\";\r\n    string private constant ERROR_EMPLOYEE_NULL_ADDRESS = \"PAYROLL_EMPLOYEE_NULL_ADDRESS\";\r\n    string private constant ERROR_EMPLOYEE_ALREADY_EXIST = \"PAYROLL_EMPLOYEE_ALREADY_EXIST\";\r\n    string private constant ERROR_FEED_NOT_CONTRACT = \"PAYROLL_FEED_NOT_CONTRACT\";\r\n    string private constant ERROR_EXPIRY_TIME_TOO_SHORT = \"PAYROLL_EXPIRY_TIME_TOO_SHORT\";\r\n    string private constant ERROR_PAST_TERMINATION_DATE = \"PAYROLL_PAST_TERMINATION_DATE\";\r\n    string private constant ERROR_EXCHANGE_RATE_TOO_LOW = \"PAYROLL_EXCHANGE_RATE_TOO_LOW\";\r\n    string private constant ERROR_LAST_PAYROLL_DATE_TOO_BIG = \"PAYROLL_LAST_DATE_TOO_BIG\";\r\n    string private constant ERROR_INVALID_REQUESTED_AMOUNT = \"PAYROLL_INVALID_REQUESTED_AMT\";\r\n\r\n    enum PaymentType { Payroll, Reimbursement, Bonus }\r\n\r\n    struct Employee {\r\n        address accountAddress; // unique, but can be changed over time\r\n        uint256 denominationTokenSalary; // salary per second in denomination Token\r\n        uint256 accruedSalary; // keep track of any leftover accrued salary when changing salaries\r\n        uint256 bonus;\r\n        uint256 reimbursements;\r\n        uint64 lastPayroll;\r\n        uint64 endDate;\r\n        address[] allocationTokenAddresses;\r\n        mapping(address => uint256) allocationTokens;\r\n    }\r\n\r\n    Finance public finance;\r\n    address public denominationToken;\r\n    IFeed public feed;\r\n    uint64 public rateExpiryTime;\r\n\r\n    // Employees start at index 1, to allow us to use employees[0] to check for non-existent employees\r\n    uint256 public nextEmployee;\r\n    mapping(uint256 => Employee) internal employees;     // employee ID -> employee\r\n    mapping(address => uint256) internal employeeIds;    // employee address -> employee ID\r\n\r\n    mapping(address => bool) internal allowedTokens;\r\n\r\n    event AddEmployee(\r\n        uint256 indexed employeeId,\r\n        address indexed accountAddress,\r\n        uint256 initialDenominationSalary,\r\n        uint64 startDate,\r\n        string role\r\n    );\r\n    event TerminateEmployee(uint256 indexed employeeId, uint64 endDate);\r\n    event SetEmployeeSalary(uint256 indexed employeeId, uint256 denominationSalary);\r\n    event AddEmployeeAccruedSalary(uint256 indexed employeeId, uint256 amount);\r\n    event AddEmployeeBonus(uint256 indexed employeeId, uint256 amount);\r\n    event AddEmployeeReimbursement(uint256 indexed employeeId, uint256 amount);\r\n    event ChangeAddressByEmployee(uint256 indexed employeeId, address indexed newAccountAddress, address indexed oldAccountAddress);\r\n    event DetermineAllocation(uint256 indexed employeeId);\r\n    event SendPayment(\r\n        uint256 indexed employeeId,\r\n        address indexed accountAddress,\r\n        address indexed token,\r\n        uint256 amount,\r\n        uint256 exchangeRate,\r\n        string paymentReference\r\n    );\r\n    event SetAllowedToken(address indexed token, bool allowed);\r\n    event SetPriceFeed(address indexed feed);\r\n    event SetRateExpiryTime(uint64 time);\r\n\r\n    // Check employee exists by ID\r\n    modifier employeeIdExists(uint256 _employeeId) {\r\n        require(_employeeExists(_employeeId), ERROR_EMPLOYEE_DOESNT_EXIST);\r\n        _;\r\n    }\r\n\r\n    // Check employee exists and is still active\r\n    modifier employeeActive(uint256 _employeeId) {\r\n        // No need to check for existence as _isEmployeeIdActive() is false for non-existent employees\r\n        require(_isEmployeeIdActive(_employeeId), ERROR_NON_ACTIVE_EMPLOYEE);\r\n        _;\r\n    }\r\n\r\n    // Check sender matches an existing employee\r\n    modifier employeeMatches {\r\n        require(employees[employeeIds[msg.sender]].accountAddress == msg.sender, ERROR_SENDER_DOES_NOT_MATCH);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Initialize Payroll app for Finance at `_finance` and price feed at `_priceFeed`, setting denomination token to `_token` and exchange rate expiry time to `@transformTime(_rateExpiryTime)`\r\n     * @dev Note that we do not require _denominationToken to be a contract, as it may be a \"fake\"\r\n     *      address used by the price feed to denominate fiat currencies\r\n     * @param _finance Address of the Finance app this Payroll app will rely on for payments (non-changeable)\r\n     * @param _denominationToken Address of the denomination token used for salary accounting\r\n     * @param _priceFeed Address of the price feed\r\n     * @param _rateExpiryTime Acceptable expiry time in seconds for the price feed's exchange rates\r\n     */\r\n    function initialize(Finance _finance, address _denominationToken, IFeed _priceFeed, uint64 _rateExpiryTime) external onlyInit {\r\n        initialized();\r\n\r\n        require(isContract(_finance), ERROR_FINANCE_NOT_CONTRACT);\r\n        finance = _finance;\r\n\r\n        denominationToken = _denominationToken;\r\n        _setPriceFeed(_priceFeed);\r\n        _setRateExpiryTime(_rateExpiryTime);\r\n\r\n        // Employees start at index 1, to allow us to use employees[0] to check for non-existent employees\r\n        nextEmployee = 1;\r\n    }\r\n\r\n    /**\r\n     * @notice `_allowed ? 'Add' : 'Remove'` `_token.symbol(): string` `_allowed ? 'to' : 'from'` the set of allowed tokens\r\n     * @param _token Address of the token to be added or removed from the list of allowed tokens for payments\r\n     * @param _allowed Boolean to tell whether the given token should be added or removed from the list\r\n     */\r\n    function setAllowedToken(address _token, bool _allowed) external authP(MANAGE_ALLOWED_TOKENS_ROLE, arr(_token)) {\r\n        require(allowedTokens[_token] != _allowed, ERROR_TOKEN_ALREADY_SET);\r\n        allowedTokens[_token] = _allowed;\r\n        emit SetAllowedToken(_token, _allowed);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the price feed for exchange rates to `_feed`\r\n     * @param _feed Address of the new price feed instance\r\n     */\r\n    function setPriceFeed(IFeed _feed) external authP(MODIFY_PRICE_FEED_ROLE, arr(_feed, feed)) {\r\n        _setPriceFeed(_feed);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the acceptable expiry time for the price feed's exchange rates to `@transformTime(_time)`\r\n     * @dev Exchange rates older than the given value won't be accepted for payments and will cause payouts to revert\r\n     * @param _time The expiration time in seconds for exchange rates\r\n     */\r\n    function setRateExpiryTime(uint64 _time) external authP(MODIFY_RATE_EXPIRY_ROLE, arr(uint256(_time), uint256(rateExpiryTime))) {\r\n        _setRateExpiryTime(_time);\r\n    }\r\n\r\n    /**\r\n     * @notice Add employee with address `_accountAddress` to payroll with an salary of `_initialDenominationSalary` per second, starting on `@formatDate(_startDate)`\r\n     * @param _accountAddress Employee's address to receive payroll\r\n     * @param _initialDenominationSalary Employee's salary, per second in denomination token\r\n     * @param _startDate Employee's starting timestamp in seconds (it actually sets their initial lastPayroll value)\r\n     * @param _role Employee's role\r\n     */\r\n    function addEmployee(address _accountAddress, uint256 _initialDenominationSalary, uint64 _startDate, string _role)\r\n        external\r\n        authP(ADD_EMPLOYEE_ROLE, arr(_accountAddress, _initialDenominationSalary, uint256(_startDate)))\r\n    {\r\n        _addEmployee(_accountAddress, _initialDenominationSalary, _startDate, _role);\r\n    }\r\n\r\n    /**\r\n     * @notice Add `_amount` to bonus for employee #`_employeeId`\r\n     * @param _employeeId Employee's identifier\r\n     * @param _amount Amount to be added to the employee's bonuses in denomination token\r\n     */\r\n    function addBonus(uint256 _employeeId, uint256 _amount)\r\n        external\r\n        authP(ADD_BONUS_ROLE, arr(_employeeId, _amount))\r\n        employeeActive(_employeeId)\r\n    {\r\n        _addBonus(_employeeId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Add `_amount` to reimbursements for employee #`_employeeId`\r\n     * @param _employeeId Employee's identifier\r\n     * @param _amount Amount to be added to the employee's reimbursements in denomination token\r\n     */\r\n    function addReimbursement(uint256 _employeeId, uint256 _amount)\r\n        external\r\n        authP(ADD_REIMBURSEMENT_ROLE, arr(_employeeId, _amount))\r\n        employeeActive(_employeeId)\r\n    {\r\n        _addReimbursement(_employeeId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set employee #`_employeeId`'s salary to `_denominationSalary` per second\r\n     * @dev This reverts if either the employee's owed salary or accrued salary overflows, to avoid\r\n     *      losing any accrued salary for an employee due to the employer changing their salary.\r\n     * @param _employeeId Employee's identifier\r\n     * @param _denominationSalary Employee's new salary, per second in denomination token\r\n     */\r\n    function setEmployeeSalary(uint256 _employeeId, uint256 _denominationSalary)\r\n        external\r\n        authP(SET_EMPLOYEE_SALARY_ROLE, arr(_employeeId, _denominationSalary, employees[_employeeId].denominationTokenSalary))\r\n        employeeActive(_employeeId)\r\n    {\r\n        Employee storage employee = employees[_employeeId];\r\n\r\n        // Accrue employee's owed salary; don't cap to revert on overflow\r\n        uint256 owed = _getOwedSalarySinceLastPayroll(employee, false);\r\n        _addAccruedSalary(_employeeId, owed);\r\n\r\n        // Update employee to track the new salary and payment date\r\n        employee.lastPayroll = getTimestamp64();\r\n        employee.denominationTokenSalary = _denominationSalary;\r\n\r\n        emit SetEmployeeSalary(_employeeId, _denominationSalary);\r\n    }\r\n\r\n    /**\r\n     * @notice Terminate employee #`_employeeId` on `@formatDate(_endDate)`\r\n     * @param _employeeId Employee's identifier\r\n     * @param _endDate Termination timestamp in seconds\r\n     */\r\n    function terminateEmployee(uint256 _employeeId, uint64 _endDate)\r\n        external\r\n        authP(TERMINATE_EMPLOYEE_ROLE, arr(_employeeId, uint256(_endDate)))\r\n        employeeActive(_employeeId)\r\n    {\r\n        _terminateEmployee(_employeeId, _endDate);\r\n    }\r\n\r\n    /**\r\n     * @notice Change your employee account address to `_newAccountAddress`\r\n     * @dev Initialization check is implicitly provided by `employeeMatches` as new employees can\r\n     *      only be added via `addEmployee(),` which requires initialization.\r\n     *      As the employee is allowed to call this, we enforce non-reentrancy.\r\n     * @param _newAccountAddress New address to receive payments for the requesting employee\r\n     */\r\n    function changeAddressByEmployee(address _newAccountAddress) external employeeMatches nonReentrant {\r\n        uint256 employeeId = employeeIds[msg.sender];\r\n        address oldAddress = employees[employeeId].accountAddress;\r\n\r\n        _setEmployeeAddress(employeeId, _newAccountAddress);\r\n        // Don't delete the old address until after setting the new address to check that the\r\n        // employee specified a new address\r\n        delete employeeIds[oldAddress];\r\n\r\n        emit ChangeAddressByEmployee(employeeId, _newAccountAddress, oldAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the token distribution for your payments\r\n     * @dev Initialization check is implicitly provided by `employeeMatches` as new employees can\r\n     *      only be added via `addEmployee(),` which requires initialization.\r\n     *      As the employee is allowed to call this, we enforce non-reentrancy.\r\n     * @param _tokens Array of token addresses; they must belong to the list of allowed tokens\r\n     * @param _distribution Array with each token's corresponding proportions (must be integers summing to 100)\r\n     */\r\n    function determineAllocation(address[] _tokens, uint256[] _distribution) external employeeMatches nonReentrant {\r\n        // Check array lengthes match\r\n        require(_tokens.length <= MAX_ALLOWED_TOKENS, ERROR_MAX_ALLOWED_TOKENS);\r\n        require(_tokens.length == _distribution.length, ERROR_TOKEN_ALLOCATION_MISMATCH);\r\n\r\n        uint256 employeeId = employeeIds[msg.sender];\r\n        Employee storage employee = employees[employeeId];\r\n\r\n        // Delete previous token allocations\r\n        address[] memory previousAllowedTokenAddresses = employee.allocationTokenAddresses;\r\n        for (uint256 j = 0; j < previousAllowedTokenAddresses.length; j++) {\r\n            delete employee.allocationTokens[previousAllowedTokenAddresses[j]];\r\n        }\r\n        delete employee.allocationTokenAddresses;\r\n\r\n        // Set distributions only if given tokens are allowed\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            employee.allocationTokenAddresses.push(_tokens[i]);\r\n            employee.allocationTokens[_tokens[i]] = _distribution[i];\r\n        }\r\n\r\n        _ensureEmployeeTokenAllocationsIsValid(employee);\r\n        emit DetermineAllocation(employeeId);\r\n    }\r\n\r\n    /**\r\n     * @notice Request your `_type == 0 ? 'salary' : _type == 1 ? 'reimbursements' : 'bonus'`\r\n     * @dev Reverts if no payments were made.\r\n     *      Initialization check is implicitly provided by `employeeMatches` as new employees can\r\n     *      only be added via `addEmployee(),` which requires initialization.\r\n     *      As the employee is allowed to call this, we enforce non-reentrancy.\r\n     * @param _type Payment type being requested (Payroll, Reimbursement or Bonus)\r\n     * @param _requestedAmount Requested amount to pay for the payment type. Must be less than or equal to total owed amount for the payment type, or zero to request all.\r\n     * @param _minRates Array of employee's minimum acceptable rates for their allowed payment tokens\r\n     */\r\n    function payday(PaymentType _type, uint256 _requestedAmount, uint256[] _minRates) external employeeMatches nonReentrant {\r\n        uint256 paymentAmount;\r\n        uint256 employeeId = employeeIds[msg.sender];\r\n        Employee storage employee = employees[employeeId];\r\n        _ensureEmployeeTokenAllocationsIsValid(employee);\r\n        require(_minRates.length == 0 || _minRates.length == employee.allocationTokenAddresses.length, ERROR_MIN_RATES_MISMATCH);\r\n\r\n        // Do internal employee accounting\r\n        if (_type == PaymentType.Payroll) {\r\n            // Salary is capped here to avoid reverting at this point if it becomes too big\r\n            // (so employees aren't DDOSed if their salaries get too large)\r\n            // If we do use a capped value, the employee's lastPayroll date will be adjusted accordingly\r\n            uint256 totalOwedSalary = _getTotalOwedCappedSalary(employee);\r\n            paymentAmount = _ensurePaymentAmount(totalOwedSalary, _requestedAmount);\r\n            _updateEmployeeAccountingBasedOnPaidSalary(employee, paymentAmount);\r\n        } else if (_type == PaymentType.Reimbursement) {\r\n            uint256 owedReimbursements = employee.reimbursements;\r\n            paymentAmount = _ensurePaymentAmount(owedReimbursements, _requestedAmount);\r\n            employee.reimbursements = owedReimbursements.sub(paymentAmount);\r\n        } else if (_type == PaymentType.Bonus) {\r\n            uint256 owedBonusAmount = employee.bonus;\r\n            paymentAmount = _ensurePaymentAmount(owedBonusAmount, _requestedAmount);\r\n            employee.bonus = owedBonusAmount.sub(paymentAmount);\r\n        } else {\r\n            revert(ERROR_INVALID_PAYMENT_TYPE);\r\n        }\r\n\r\n        // Actually transfer the owed funds\r\n        require(_transferTokensAmount(employeeId, _type, paymentAmount, _minRates), ERROR_NOTHING_PAID);\r\n        _removeEmployeeIfTerminatedAndPaidOut(employeeId);\r\n    }\r\n\r\n    // Forwarding fns\r\n\r\n    /**\r\n     * @dev IForwarder interface conformance. Tells whether the Payroll app is a forwarder or not.\r\n     * @return Always true\r\n     */\r\n    function isForwarder() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Execute desired action as an active employee\r\n     * @dev IForwarder interface conformance. Allows active employees to run EVMScripts in the context of the Payroll app.\r\n     * @param _evmScript Script being executed\r\n     */\r\n    function forward(bytes _evmScript) public {\r\n        require(canForward(msg.sender, _evmScript), ERROR_CAN_NOT_FORWARD);\r\n        bytes memory input = new bytes(0); // TODO: Consider input for this\r\n\r\n        // Add the Finance app to the blacklist to disallow employees from executing actions on the\r\n        // Finance app from Payroll's context (since Payroll requires permissions on Finance)\r\n        address[] memory blacklist = new address[](1);\r\n        blacklist[0] = address(finance);\r\n\r\n        runScript(_evmScript, input, blacklist);\r\n    }\r\n\r\n    /**\r\n     * @dev IForwarder interface conformance. Tells whether a given address can forward actions or not.\r\n     * @param _sender Address of the account intending to forward an action\r\n     * @return True if the given address is an active employee, false otherwise\r\n     */\r\n    function canForward(address _sender, bytes) public view returns (bool) {\r\n        return _isEmployeeIdActive(employeeIds[_sender]);\r\n    }\r\n\r\n    // Getter fns\r\n\r\n    /**\r\n     * @dev Return employee's identifier by their account address\r\n     * @param _accountAddress Employee's address to receive payments\r\n     * @return Employee's identifier\r\n     */\r\n    function getEmployeeIdByAddress(address _accountAddress) public view returns (uint256) {\r\n        require(employeeIds[_accountAddress] != uint256(0), ERROR_EMPLOYEE_DOESNT_EXIST);\r\n        return employeeIds[_accountAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev Return all information for employee by their ID\r\n     * @param _employeeId Employee's identifier\r\n     * @return Employee's address to receive payments\r\n     * @return Employee's salary, per second in denomination token\r\n     * @return Employee's accrued salary\r\n     * @return Employee's bonus amount\r\n     * @return Employee's reimbursements amount\r\n     * @return Employee's last payment date\r\n     * @return Employee's termination date (max uint64 if none)\r\n     * @return Employee's allowed payment tokens\r\n     */\r\n    function getEmployee(uint256 _employeeId)\r\n        public\r\n        view\r\n        employeeIdExists(_employeeId)\r\n        returns (\r\n            address accountAddress,\r\n            uint256 denominationSalary,\r\n            uint256 accruedSalary,\r\n            uint256 bonus,\r\n            uint256 reimbursements,\r\n            uint64 lastPayroll,\r\n            uint64 endDate,\r\n            address[] allocationTokens\r\n        )\r\n    {\r\n        Employee storage employee = employees[_employeeId];\r\n\r\n        accountAddress = employee.accountAddress;\r\n        denominationSalary = employee.denominationTokenSalary;\r\n        accruedSalary = employee.accruedSalary;\r\n        bonus = employee.bonus;\r\n        reimbursements = employee.reimbursements;\r\n        lastPayroll = employee.lastPayroll;\r\n        endDate = employee.endDate;\r\n        allocationTokens = employee.allocationTokenAddresses;\r\n    }\r\n\r\n    /**\r\n     * @dev Get owed salary since last payroll for an employee. It will take into account the accrued salary as well.\r\n     *      The result will be capped to max uint256 to avoid having an overflow.\r\n     * @return Employee's total owed salary: current owed payroll since the last payroll date, plus the accrued salary.\r\n     */\r\n    function getTotalOwedSalary(uint256 _employeeId) public view employeeIdExists(_employeeId) returns (uint256) {\r\n        return _getTotalOwedCappedSalary(employees[_employeeId]);\r\n    }\r\n\r\n    /**\r\n     * @dev Get an employee's payment allocation for a token\r\n     * @param _employeeId Employee's identifier\r\n     * @param _token Token to query the payment allocation for\r\n     * @return Employee's payment allocation for the token being queried\r\n     */\r\n    function getAllocation(uint256 _employeeId, address _token) public view employeeIdExists(_employeeId) returns (uint256) {\r\n        return employees[_employeeId].allocationTokens[_token];\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a token is allowed to be used for payments\r\n     * @param _token Address of the token to be checked\r\n     * @return True if the given token is allowed, false otherwise\r\n     */\r\n    function isTokenAllowed(address _token) public view isInitialized returns (bool) {\r\n        return allowedTokens[_token];\r\n    }\r\n\r\n    // Internal fns\r\n\r\n    /**\r\n     * @dev Set the price feed used for exchange rates\r\n     * @param _feed Address of the new price feed instance\r\n     */\r\n    function _setPriceFeed(IFeed _feed) internal {\r\n        require(isContract(_feed), ERROR_FEED_NOT_CONTRACT);\r\n        feed = _feed;\r\n        emit SetPriceFeed(feed);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the exchange rate expiry time in seconds.\r\n     *      Exchange rates older than the given value won't be accepted for payments and will cause\r\n     *      payouts to revert.\r\n     * @param _time The expiration time in seconds for exchange rates\r\n     */\r\n    function _setRateExpiryTime(uint64 _time) internal {\r\n        // Require a sane minimum for the rate expiry time\r\n        require(_time >= MIN_RATE_EXPIRY, ERROR_EXPIRY_TIME_TOO_SHORT);\r\n        rateExpiryTime = _time;\r\n        emit SetRateExpiryTime(rateExpiryTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new employee to Payroll\r\n     * @param _accountAddress Employee's address to receive payroll\r\n     * @param _initialDenominationSalary Employee's salary, per second in denomination token\r\n     * @param _startDate Employee's starting timestamp in seconds\r\n     * @param _role Employee's role\r\n     */\r\n    function _addEmployee(address _accountAddress, uint256 _initialDenominationSalary, uint64 _startDate, string _role) internal {\r\n        uint256 employeeId = nextEmployee++;\r\n\r\n        _setEmployeeAddress(employeeId, _accountAddress);\r\n\r\n        Employee storage employee = employees[employeeId];\r\n        employee.denominationTokenSalary = _initialDenominationSalary;\r\n        employee.lastPayroll = _startDate;\r\n        employee.endDate = MAX_UINT64;\r\n\r\n        emit AddEmployee(employeeId, _accountAddress, _initialDenominationSalary, _startDate, _role);\r\n    }\r\n\r\n    /**\r\n     * @dev Add amount to an employee's bonuses\r\n     * @param _employeeId Employee's identifier\r\n     * @param _amount Amount be added to the employee's bonuses in denomination token\r\n     */\r\n    function _addBonus(uint256 _employeeId, uint256 _amount) internal {\r\n        Employee storage employee = employees[_employeeId];\r\n        employee.bonus = employee.bonus.add(_amount);\r\n        emit AddEmployeeBonus(_employeeId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Add amount to an employee's reimbursements\r\n     * @param _employeeId Employee's identifier\r\n     * @param _amount Amount be added to the employee's reimbursements in denomination token\r\n     */\r\n    function _addReimbursement(uint256 _employeeId, uint256 _amount) internal {\r\n        Employee storage employee = employees[_employeeId];\r\n        employee.reimbursements = employee.reimbursements.add(_amount);\r\n        emit AddEmployeeReimbursement(_employeeId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Add amount to an employee's accrued salary\r\n     * @param _employeeId Employee's identifier\r\n     * @param _amount Amount be added to the employee's accrued salary in denomination token\r\n     */\r\n    function _addAccruedSalary(uint256 _employeeId, uint256 _amount) internal {\r\n        Employee storage employee = employees[_employeeId];\r\n        employee.accruedSalary = employee.accruedSalary.add(_amount);\r\n        emit AddEmployeeAccruedSalary(_employeeId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Set an employee's account address\r\n     * @param _employeeId Employee's identifier\r\n     * @param _accountAddress Employee's address to receive payroll\r\n     */\r\n    function _setEmployeeAddress(uint256 _employeeId, address _accountAddress) internal {\r\n        // Check address is non-null\r\n        require(_accountAddress != address(0), ERROR_EMPLOYEE_NULL_ADDRESS);\r\n        // Check address isn't already being used\r\n        require(employeeIds[_accountAddress] == uint256(0), ERROR_EMPLOYEE_ALREADY_EXIST);\r\n\r\n        employees[_employeeId].accountAddress = _accountAddress;\r\n\r\n        // Create IDs mapping\r\n        employeeIds[_accountAddress] = _employeeId;\r\n    }\r\n\r\n    /**\r\n     * @dev Terminate employee on end date\r\n     * @param _employeeId Employee's identifier\r\n     * @param _endDate Termination timestamp in seconds\r\n     */\r\n    function _terminateEmployee(uint256 _employeeId, uint64 _endDate) internal {\r\n        // Prevent past termination dates\r\n        require(_endDate >= getTimestamp64(), ERROR_PAST_TERMINATION_DATE);\r\n        employees[_employeeId].endDate = _endDate;\r\n        emit TerminateEmployee(_employeeId, _endDate);\r\n    }\r\n\r\n    /**\r\n     * @dev Loop over allowed tokens to send requested amount to the employee in their desired allocation\r\n     * @param _employeeId Employee's identifier\r\n     * @param _totalAmount Total amount to be transferred to the employee distributed in accordance to the employee's token allocation.\r\n     * @param _type Payment type being transferred (Payroll, Reimbursement or Bonus)\r\n     * @param _minRates Array of employee's minimum acceptable rates for their allowed payment tokens\r\n     * @return True if there was at least one token transfer\r\n     */\r\n    function _transferTokensAmount(uint256 _employeeId, PaymentType _type, uint256 _totalAmount, uint256[] _minRates) internal returns (bool somethingPaid) {\r\n        if (_totalAmount == 0) {\r\n            return false;\r\n        }\r\n\r\n        Employee storage employee = employees[_employeeId];\r\n        address employeeAddress = employee.accountAddress;\r\n        string memory paymentReference = _paymentReferenceFor(_type);\r\n\r\n        address[] storage allocationTokenAddresses = employee.allocationTokenAddresses;\r\n        for (uint256 i = 0; i < allocationTokenAddresses.length; i++) {\r\n            address token = allocationTokenAddresses[i];\r\n            uint256 tokenAllocation = employee.allocationTokens[token];\r\n            if (tokenAllocation != uint256(0)) {\r\n                // Get the exchange rate for the payout token in denomination token,\r\n                // as we do accounting in denomination tokens\r\n                uint256 exchangeRate = _getExchangeRateInDenominationToken(token);\r\n                require(_minRates.length > 0 ? exchangeRate >= _minRates[i] : exchangeRate > 0, ERROR_EXCHANGE_RATE_TOO_LOW);\r\n\r\n                // Convert amount (in denomination tokens) to payout token and apply allocation\r\n                uint256 tokenAmount = _totalAmount.mul(exchangeRate).mul(tokenAllocation);\r\n                // Divide by 100 for the allocation percentage and by the exchange rate precision\r\n                tokenAmount = tokenAmount.div(100).div(feed.ratePrecision());\r\n\r\n                // Finance reverts if the payment wasn't possible\r\n                finance.newImmediatePayment(token, employeeAddress, tokenAmount, paymentReference);\r\n                emit SendPayment(_employeeId, employeeAddress, token, tokenAmount, exchangeRate, paymentReference);\r\n                somethingPaid = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Remove employee if there are no owed funds and employee's end date has been reached\r\n     * @param _employeeId Employee's identifier\r\n     */\r\n    function _removeEmployeeIfTerminatedAndPaidOut(uint256 _employeeId) internal {\r\n        Employee storage employee = employees[_employeeId];\r\n\r\n        if (\r\n            employee.lastPayroll == employee.endDate &&\r\n            (employee.accruedSalary == 0 && employee.bonus == 0 && employee.reimbursements == 0)\r\n        ) {\r\n            delete employeeIds[employee.accountAddress];\r\n            delete employees[_employeeId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the accrued salary and payroll date of an employee based on a payment amount and\r\n     *      their currently owed salary since last payroll date\r\n     * @param _employee Employee struct in storage\r\n     * @param _paymentAmount Amount being paid to the employee\r\n     */\r\n    function _updateEmployeeAccountingBasedOnPaidSalary(Employee storage _employee, uint256 _paymentAmount) internal {\r\n        uint256 accruedSalary = _employee.accruedSalary;\r\n\r\n        if (_paymentAmount <= accruedSalary) {\r\n            // Employee is only cashing out some previously owed salary so we don't need to update\r\n            // their last payroll date\r\n            // No need to use SafeMath as we already know _paymentAmount <= accruedSalary\r\n            _employee.accruedSalary = accruedSalary - _paymentAmount;\r\n            return;\r\n        }\r\n\r\n        // Employee is cashing out some of their currently owed salary so their last payroll date\r\n        // needs to be modified based on the amount of salary paid\r\n        uint256 currentSalaryPaid = _paymentAmount;\r\n        if (accruedSalary > 0) {\r\n            // Employee is cashing out a mixed amount between previous and current owed salaries;\r\n            // first use up their accrued salary\r\n            // No need to use SafeMath here as we already know _paymentAmount > accruedSalary\r\n            currentSalaryPaid = _paymentAmount - accruedSalary;\r\n            // We finally need to clear their accrued salary\r\n            _employee.accruedSalary = 0;\r\n        }\r\n\r\n        uint256 salary = _employee.denominationTokenSalary;\r\n        uint256 timeDiff = currentSalaryPaid.div(salary);\r\n\r\n        // If they're being paid an amount that doesn't match perfectly with the adjusted time\r\n        // (up to a seconds' worth of salary), add the second and put the extra remaining salary\r\n        // into their accrued salary\r\n        uint256 extraSalary = currentSalaryPaid % salary;\r\n        if (extraSalary > 0) {\r\n            timeDiff = timeDiff.add(1);\r\n            _employee.accruedSalary = salary - extraSalary;\r\n        }\r\n\r\n        uint256 lastPayrollDate = uint256(_employee.lastPayroll).add(timeDiff);\r\n        // Even though this function should never receive a currentSalaryPaid value that would\r\n        // result in the lastPayrollDate being higher than the current time,\r\n        // let's double check to be safe\r\n        require(lastPayrollDate <= uint256(getTimestamp64()), ERROR_LAST_PAYROLL_DATE_TOO_BIG);\r\n        // Already know lastPayrollDate must fit in uint64 from above\r\n        _employee.lastPayroll = uint64(lastPayrollDate);\r\n    }\r\n\r\n    /**\r\n     * @dev Tell whether an employee is registered in this Payroll or not\r\n     * @param _employeeId Employee's identifier\r\n     * @return True if the given employee ID belongs to an registered employee, false otherwise\r\n     */\r\n    function _employeeExists(uint256 _employeeId) internal view returns (bool) {\r\n        return employees[_employeeId].accountAddress != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Tell whether an employee has a valid token allocation or not.\r\n     *      A valid allocation is one that sums to 100 and only includes allowed tokens.\r\n     * @param _employee Employee struct in storage\r\n     * @return Reverts if employee's allocation is invalid\r\n     */\r\n    function _ensureEmployeeTokenAllocationsIsValid(Employee storage _employee) internal view {\r\n        uint256 sum = 0;\r\n        address[] memory allocationTokenAddresses = _employee.allocationTokenAddresses;\r\n        for (uint256 i = 0; i < allocationTokenAddresses.length; i++) {\r\n            address token = allocationTokenAddresses[i];\r\n            require(allowedTokens[token], ERROR_NOT_ALLOWED_TOKEN);\r\n            sum = sum.add(_employee.allocationTokens[token]);\r\n        }\r\n        require(sum == 100, ERROR_DISTRIBUTION_NOT_FULL);\r\n    }\r\n\r\n    /**\r\n     * @dev Tell whether an employee is still active or not\r\n     * @param _employee Employee struct in storage\r\n     * @return True if the employee exists and has an end date that has not been reached yet, false otherwise\r\n     */\r\n    function _isEmployeeActive(Employee storage _employee) internal view returns (bool) {\r\n        return _employee.endDate >= getTimestamp64();\r\n    }\r\n\r\n    /**\r\n     * @dev Tell whether an employee id is still active or not\r\n     * @param _employeeId Employee's identifier\r\n     * @return True if the employee exists and has an end date that has not been reached yet, false otherwise\r\n     */\r\n    function _isEmployeeIdActive(uint256 _employeeId) internal view returns (bool) {\r\n        return _isEmployeeActive(employees[_employeeId]);\r\n    }\r\n\r\n    /**\r\n     * @dev Get exchange rate for a token based on the denomination token.\r\n     *      As an example, if the denomination token was USD and ETH's price was 100USD,\r\n     *      this would return 0.01 * precision rate for ETH.\r\n     * @param _token Token to get price of in denomination tokens\r\n     * @return Exchange rate (multiplied by the PPF rate precision)\r\n     */\r\n    function _getExchangeRateInDenominationToken(address _token) internal view returns (uint256) {\r\n        // xrt is the number of `_token` that can be exchanged for one `denominationToken`\r\n        (uint128 xrt, uint64 when) = feed.get(\r\n            denominationToken,  // Base (e.g. USD)\r\n            _token              // Quote (e.g. ETH)\r\n        );\r\n\r\n        // Check the price feed is recent enough\r\n        if (getTimestamp64().sub(when) >= rateExpiryTime) {\r\n            return 0;\r\n        }\r\n\r\n        return uint256(xrt);\r\n    }\r\n\r\n    /**\r\n     * @dev Get owed salary since last payroll for an employee\r\n     * @param _employee Employee struct in storage\r\n     * @param _capped Safely cap the owed salary at max uint\r\n     * @return Owed salary in denomination tokens since last payroll for the employee.\r\n     *         If _capped is false, it reverts in case of an overflow.\r\n     */\r\n    function _getOwedSalarySinceLastPayroll(Employee storage _employee, bool _capped) internal view returns (uint256) {\r\n        uint256 timeDiff = _getOwedPayrollPeriod(_employee);\r\n        if (timeDiff == 0) {\r\n            return 0;\r\n        }\r\n        uint256 salary = _employee.denominationTokenSalary;\r\n\r\n        if (_capped) {\r\n            // Return max uint if the result overflows\r\n            uint256 result = salary * timeDiff;\r\n            return (result / timeDiff != salary) ? MAX_UINT256 : result;\r\n        } else {\r\n            return salary.mul(timeDiff);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get owed payroll period for an employee\r\n     * @param _employee Employee struct in storage\r\n     * @return Owed time in seconds since the employee's last payroll date\r\n     */\r\n    function _getOwedPayrollPeriod(Employee storage _employee) internal view returns (uint256) {\r\n        // Get the min of current date and termination date\r\n        uint64 date = _isEmployeeActive(_employee) ? getTimestamp64() : _employee.endDate;\r\n\r\n        // Make sure we don't revert if we try to get the owed salary for an employee whose last\r\n        // payroll date is now or in the future\r\n        // This can happen either by adding new employees with start dates in the future, to allow\r\n        // us to change their salary before their start date, or by terminating an employee and\r\n        // paying out their full owed salary\r\n        if (date <= _employee.lastPayroll) {\r\n            return 0;\r\n        }\r\n\r\n        // Return time diff in seconds, no need to use SafeMath as the underflow was covered by the previous check\r\n        return uint256(date - _employee.lastPayroll);\r\n    }\r\n\r\n    /**\r\n     * @dev Get owed salary since last payroll for an employee. It will take into account the accrued salary as well.\r\n     *      The result will be capped to max uint256 to avoid having an overflow.\r\n     * @param _employee Employee struct in storage\r\n     * @return Employee's total owed salary: current owed payroll since the last payroll date, plus the accrued salary.\r\n     */\r\n    function _getTotalOwedCappedSalary(Employee storage _employee) internal view returns (uint256) {\r\n        uint256 currentOwedSalary = _getOwedSalarySinceLastPayroll(_employee, true); // cap amount\r\n        uint256 totalOwedSalary = currentOwedSalary + _employee.accruedSalary;\r\n        if (totalOwedSalary < currentOwedSalary) {\r\n            totalOwedSalary = MAX_UINT256;\r\n        }\r\n        return totalOwedSalary;\r\n    }\r\n\r\n    /**\r\n     * @dev Get payment reference for a given payment type\r\n     * @param _type Payment type to query the reference of\r\n     * @return Payment reference for the given payment type\r\n     */\r\n    function _paymentReferenceFor(PaymentType _type) internal pure returns (string memory) {\r\n        if (_type == PaymentType.Payroll) {\r\n            return \"Employee salary\";\r\n        } else if (_type == PaymentType.Reimbursement) {\r\n            return \"Employee reimbursement\";\r\n        } if (_type == PaymentType.Bonus) {\r\n            return \"Employee bonus\";\r\n        }\r\n        revert(ERROR_INVALID_PAYMENT_TYPE);\r\n    }\r\n\r\n    function _ensurePaymentAmount(uint256 _owedAmount, uint256 _requestedAmount) private pure returns (uint256) {\r\n        require(_owedAmount > 0, ERROR_NOTHING_PAID);\r\n        require(_owedAmount >= _requestedAmount, ERROR_INVALID_REQUESTED_AMOUNT);\r\n        return _requestedAmount > 0 ? _requestedAmount : _owedAmount;\r\n    }\r\n}\r\n\r\n// File: @aragon/apps-survey/contracts/Survey.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    GPL-3.0-or-later\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Survey is AragonApp {\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n\r\n    bytes32 public constant CREATE_SURVEYS_ROLE = keccak256(\"CREATE_SURVEYS_ROLE\");\r\n    bytes32 public constant MODIFY_PARTICIPATION_ROLE = keccak256(\"MODIFY_PARTICIPATION_ROLE\");\r\n\r\n    uint64 public constant PCT_BASE = 10 ** 18; // 0% = 0; 1% = 10^16; 100% = 10^18\r\n    uint256 public constant ABSTAIN_VOTE = 0;\r\n\r\n    string private constant ERROR_MIN_PARTICIPATION = \"SURVEY_MIN_PARTICIPATION\";\r\n    string private constant ERROR_NO_SURVEY = \"SURVEY_NO_SURVEY\";\r\n    string private constant ERROR_NO_VOTING_POWER = \"SURVEY_NO_VOTING_POWER\";\r\n    string private constant ERROR_CAN_NOT_VOTE = \"SURVEY_CAN_NOT_VOTE\";\r\n    string private constant ERROR_VOTE_WRONG_INPUT = \"SURVEY_VOTE_WRONG_INPUT\";\r\n    string private constant ERROR_VOTE_WRONG_OPTION = \"SURVEY_VOTE_WRONG_OPTION\";\r\n    string private constant ERROR_NO_STAKE = \"SURVEY_NO_STAKE\";\r\n    string private constant ERROR_OPTIONS_NOT_ORDERED = \"SURVEY_OPTIONS_NOT_ORDERED\";\r\n    string private constant ERROR_NO_OPTION = \"SURVEY_NO_OPTION\";\r\n\r\n    struct OptionCast {\r\n        uint256 optionId;\r\n        uint256 stake;\r\n    }\r\n\r\n    /* Allows for multiple option votes.\r\n     * Index 0 is always used for the ABSTAIN_VOTE option, that's calculated automatically by the\r\n     * contract.\r\n     */\r\n    struct MultiOptionVote {\r\n        uint256 optionsCastedLength;\r\n        // `castedVotes` simulates an array\r\n        // Each OptionCast in `castedVotes` must be ordered by ascending option IDs\r\n        mapping (uint256 => OptionCast) castedVotes;\r\n    }\r\n\r\n    struct SurveyStruct {\r\n        uint64 startDate;\r\n        uint64 snapshotBlock;\r\n        uint64 minParticipationPct;\r\n        uint256 options;\r\n        uint256 votingPower;                    // total tokens that can cast a vote\r\n        uint256 participation;                  // tokens that casted a vote\r\n\r\n        // Note that option IDs are from 1 to `options`, due to ABSTAIN_VOTE taking 0\r\n        mapping (uint256 => uint256) optionPower;       // option ID -> voting power for option\r\n        mapping (address => MultiOptionVote) votes;     // voter -> options voted, with its stakes\r\n    }\r\n\r\n    MiniMeToken public token;\r\n    uint64 public minParticipationPct;\r\n    uint64 public surveyTime;\r\n\r\n    // We are mimicing an array, we use a mapping instead to make app upgrade more graceful\r\n    mapping (uint256 => SurveyStruct) internal surveys;\r\n    uint256 public surveysLength;\r\n\r\n    event StartSurvey(uint256 indexed surveyId, address indexed creator, string metadata);\r\n    event CastVote(uint256 indexed surveyId, address indexed voter, uint256 option, uint256 stake, uint256 optionPower);\r\n    event ResetVote(uint256 indexed surveyId, address indexed voter, uint256 option, uint256 previousStake, uint256 optionPower);\r\n    event ChangeMinParticipation(uint64 minParticipationPct);\r\n\r\n    modifier acceptableMinParticipationPct(uint64 _minParticipationPct) {\r\n        require(_minParticipationPct > 0 && _minParticipationPct <= PCT_BASE, ERROR_MIN_PARTICIPATION);\r\n        _;\r\n    }\r\n\r\n    modifier surveyExists(uint256 _surveyId) {\r\n        require(_surveyId < surveysLength, ERROR_NO_SURVEY);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Initialize Survey app with `_token.symbol(): string` for governance, minimum acceptance participation of `@formatPct(_minParticipationPct)`%, and a voting duration of `@transformTime(_surveyTime)`\r\n    * @param _token MiniMeToken address that will be used as governance token\r\n    * @param _minParticipationPct Percentage of total voting power that must participate in a survey for it to be taken into account (expressed as a 10^18 percentage, (eg 10^16 = 1%, 10^18 = 100%)\r\n    * @param _surveyTime Seconds that a survey will be open for token holders to vote\r\n    */\r\n    function initialize(\r\n        MiniMeToken _token,\r\n        uint64 _minParticipationPct,\r\n        uint64 _surveyTime\r\n    )\r\n        external\r\n        onlyInit\r\n        acceptableMinParticipationPct(_minParticipationPct)\r\n    {\r\n        initialized();\r\n\r\n        token = _token;\r\n        minParticipationPct = _minParticipationPct;\r\n        surveyTime = _surveyTime;\r\n    }\r\n\r\n    /**\r\n    * @notice Change minimum acceptance participation to `@formatPct(_minParticipationPct)`%\r\n    * @param _minParticipationPct New acceptance participation\r\n    */\r\n    function changeMinAcceptParticipationPct(uint64 _minParticipationPct)\r\n        external\r\n        authP(MODIFY_PARTICIPATION_ROLE, arr(uint256(_minParticipationPct), uint256(minParticipationPct)))\r\n        acceptableMinParticipationPct(_minParticipationPct)\r\n    {\r\n        minParticipationPct = _minParticipationPct;\r\n\r\n        emit ChangeMinParticipation(_minParticipationPct);\r\n    }\r\n\r\n    /**\r\n    * @notice Create a new non-binding survey about \"`_metadata`\"\r\n    * @param _metadata Survey metadata\r\n    * @param _options Number of options voters can decide between\r\n    * @return surveyId id for newly created survey\r\n    */\r\n    function newSurvey(string _metadata, uint256 _options) external auth(CREATE_SURVEYS_ROLE) returns (uint256 surveyId) {\r\n        uint64 snapshotBlock = getBlockNumber64() - 1; // avoid double voting in this very block\r\n        uint256 votingPower = token.totalSupplyAt(snapshotBlock);\r\n        require(votingPower > 0, ERROR_NO_VOTING_POWER);\r\n\r\n        surveyId = surveysLength++;\r\n\r\n        SurveyStruct storage survey = surveys[surveyId];\r\n        survey.startDate = getTimestamp64();\r\n        survey.snapshotBlock = snapshotBlock; // avoid double voting in this very block\r\n        survey.minParticipationPct = minParticipationPct;\r\n        survey.options = _options;\r\n        survey.votingPower = votingPower;\r\n\r\n        emit StartSurvey(surveyId, msg.sender, _metadata);\r\n    }\r\n\r\n    /**\r\n    * @notice Reset previously casted vote in survey #`_surveyId`, if any.\r\n    * @dev Initialization check is implicitly provided by `surveyExists()` as new surveys can only\r\n    *      be created via `newSurvey(),` which requires initialization\r\n    * @param _surveyId Id for survey\r\n    */\r\n    function resetVote(uint256 _surveyId) external surveyExists(_surveyId) {\r\n        require(canVote(_surveyId, msg.sender), ERROR_CAN_NOT_VOTE);\r\n\r\n        _resetVote(_surveyId);\r\n    }\r\n\r\n    /**\r\n    * @notice Vote for multiple options in survey #`_surveyId`.\r\n    * @dev Initialization check is implicitly provided by `surveyExists()` as new surveys can only\r\n    *      be created via `newSurvey(),` which requires initialization\r\n    * @param _surveyId Id for survey\r\n    * @param _optionIds Array with indexes of supported options\r\n    * @param _stakes Number of tokens assigned to each option\r\n    */\r\n    function voteOptions(uint256 _surveyId, uint256[] _optionIds, uint256[] _stakes)\r\n        external\r\n        surveyExists(_surveyId)\r\n    {\r\n        require(_optionIds.length == _stakes.length && _optionIds.length > 0, ERROR_VOTE_WRONG_INPUT);\r\n        require(canVote(_surveyId, msg.sender), ERROR_CAN_NOT_VOTE);\r\n\r\n        _voteOptions(_surveyId, _optionIds, _stakes);\r\n    }\r\n\r\n    /**\r\n    * @notice Vote option #`_optionId` in survey #`_surveyId`.\r\n    * @dev Initialization check is implicitly provided by `surveyExists()` as new surveys can only\r\n    *      be created via `newSurvey(),` which requires initialization\r\n    * @dev It will use the whole balance.\r\n    * @param _surveyId Id for survey\r\n    * @param _optionId Index of supported option\r\n    */\r\n    function voteOption(uint256 _surveyId, uint256 _optionId) external surveyExists(_surveyId) {\r\n        require(canVote(_surveyId, msg.sender), ERROR_CAN_NOT_VOTE);\r\n\r\n        SurveyStruct storage survey = surveys[_surveyId];\r\n        // This could re-enter, though we can asume the governance token is not maliciuous\r\n        uint256 voterStake = token.balanceOfAt(msg.sender, survey.snapshotBlock);\r\n        uint256[] memory options = new uint256[](1);\r\n        uint256[] memory stakes = new uint256[](1);\r\n        options[0] = _optionId;\r\n        stakes[0] = voterStake;\r\n\r\n        _voteOptions(_surveyId, options, stakes);\r\n    }\r\n\r\n    // Getter fns\r\n\r\n    function canVote(uint256 _surveyId, address _voter) public view surveyExists(_surveyId) returns (bool) {\r\n        SurveyStruct storage survey = surveys[_surveyId];\r\n\r\n        return _isSurveyOpen(survey) && token.balanceOfAt(_voter, survey.snapshotBlock) > 0;\r\n    }\r\n\r\n    function getSurvey(uint256 _surveyId)\r\n        public\r\n        view\r\n        surveyExists(_surveyId)\r\n        returns (\r\n            bool open,\r\n            uint64 startDate,\r\n            uint64 snapshotBlock,\r\n            uint64 minParticipation,\r\n            uint256 votingPower,\r\n            uint256 participation,\r\n            uint256 options\r\n        )\r\n    {\r\n        SurveyStruct storage survey = surveys[_surveyId];\r\n\r\n        open = _isSurveyOpen(survey);\r\n        startDate = survey.startDate;\r\n        snapshotBlock = survey.snapshotBlock;\r\n        minParticipation = survey.minParticipationPct;\r\n        votingPower = survey.votingPower;\r\n        participation = survey.participation;\r\n        options = survey.options;\r\n    }\r\n\r\n    /**\r\n    * @dev This is not meant to be used on-chain\r\n    */\r\n    /* solium-disable-next-line function-order */\r\n    function getVoterState(uint256 _surveyId, address _voter)\r\n        external\r\n        view\r\n        surveyExists(_surveyId)\r\n        returns (uint256[] options, uint256[] stakes)\r\n    {\r\n        MultiOptionVote storage vote = surveys[_surveyId].votes[_voter];\r\n\r\n        if (vote.optionsCastedLength == 0) {\r\n            return (new uint256[](0), new uint256[](0));\r\n        }\r\n\r\n        options = new uint256[](vote.optionsCastedLength + 1);\r\n        stakes = new uint256[](vote.optionsCastedLength + 1);\r\n        for (uint256 i = 0; i <= vote.optionsCastedLength; i++) {\r\n            options[i] = vote.castedVotes[i].optionId;\r\n            stakes[i] = vote.castedVotes[i].stake;\r\n        }\r\n    }\r\n\r\n    function getOptionPower(uint256 _surveyId, uint256 _optionId) public view surveyExists(_surveyId) returns (uint256) {\r\n        SurveyStruct storage survey = surveys[_surveyId];\r\n        require(_optionId <= survey.options, ERROR_NO_OPTION);\r\n\r\n        return survey.optionPower[_optionId];\r\n    }\r\n\r\n    function isParticipationAchieved(uint256 _surveyId) public view surveyExists(_surveyId) returns (bool) {\r\n        SurveyStruct storage survey = surveys[_surveyId];\r\n        // votingPower is always > 0\r\n        uint256 participationPct = survey.participation.mul(PCT_BASE) / survey.votingPower;\r\n        return participationPct >= survey.minParticipationPct;\r\n    }\r\n\r\n    // Internal fns\r\n\r\n    /*\r\n    * @dev Assumes the survey exists and that msg.sender can vote\r\n    */\r\n    function _resetVote(uint256 _surveyId) internal {\r\n        SurveyStruct storage survey = surveys[_surveyId];\r\n        MultiOptionVote storage previousVote = survey.votes[msg.sender];\r\n        if (previousVote.optionsCastedLength > 0) {\r\n            // Voter removes their vote (index 0 is the abstain vote)\r\n            for (uint256 i = 1; i <= previousVote.optionsCastedLength; i++) {\r\n                OptionCast storage previousOptionCast = previousVote.castedVotes[i];\r\n                uint256 previousOptionPower = survey.optionPower[previousOptionCast.optionId];\r\n                uint256 currentOptionPower = previousOptionPower.sub(previousOptionCast.stake);\r\n                survey.optionPower[previousOptionCast.optionId] = currentOptionPower;\r\n\r\n                emit ResetVote(_surveyId, msg.sender, previousOptionCast.optionId, previousOptionCast.stake, currentOptionPower);\r\n            }\r\n\r\n            // Compute previously casted votes (i.e. substract non-used tokens from stake)\r\n            uint256 voterStake = token.balanceOfAt(msg.sender, survey.snapshotBlock);\r\n            uint256 previousParticipation = voterStake.sub(previousVote.castedVotes[0].stake);\r\n            // And remove it from total participation\r\n            survey.participation = survey.participation.sub(previousParticipation);\r\n\r\n            // Reset previously voted options\r\n            delete survey.votes[msg.sender];\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Assumes the survey exists and that msg.sender can vote\r\n    */\r\n    function _voteOptions(uint256 _surveyId, uint256[] _optionIds, uint256[] _stakes) internal {\r\n        SurveyStruct storage survey = surveys[_surveyId];\r\n        MultiOptionVote storage senderVotes = survey.votes[msg.sender];\r\n\r\n        // Revert previous votes, if any\r\n        _resetVote(_surveyId);\r\n\r\n        uint256 totalVoted = 0;\r\n        // Reserve first index for ABSTAIN_VOTE\r\n        senderVotes.castedVotes[0] = OptionCast({ optionId: ABSTAIN_VOTE, stake: 0 });\r\n        for (uint256 optionIndex = 1; optionIndex <= _optionIds.length; optionIndex++) {\r\n            // Voters don't specify that they're abstaining,\r\n            // but we still keep track of this by reserving the first index of a survey's votes.\r\n            // We subtract 1 from the indexes of the arrays passed in by the voter to account for this.\r\n            uint256 optionId = _optionIds[optionIndex - 1];\r\n            uint256 stake = _stakes[optionIndex - 1];\r\n\r\n            require(optionId != ABSTAIN_VOTE && optionId <= survey.options, ERROR_VOTE_WRONG_OPTION);\r\n            require(stake > 0, ERROR_NO_STAKE);\r\n            // Let's avoid repeating an option by making sure that ascending order is preserved in\r\n            // the options array by checking that the current optionId is larger than the last one\r\n            // we added\r\n            require(senderVotes.castedVotes[optionIndex - 1].optionId < optionId, ERROR_OPTIONS_NOT_ORDERED);\r\n\r\n            // Register voter amount\r\n            senderVotes.castedVotes[optionIndex] = OptionCast({ optionId: optionId, stake: stake });\r\n\r\n            // Add to total option support\r\n            survey.optionPower[optionId] = survey.optionPower[optionId].add(stake);\r\n\r\n            // Keep track of stake used so far\r\n            totalVoted = totalVoted.add(stake);\r\n\r\n            emit CastVote(_surveyId, msg.sender, optionId, stake, survey.optionPower[optionId]);\r\n        }\r\n\r\n        // Compute and register non used tokens\r\n        // Implictly we are doing require(totalVoted <= voterStake) too\r\n        // (as stated before, index 0 is for ABSTAIN_VOTE option)\r\n        uint256 voterStake = token.balanceOfAt(msg.sender, survey.snapshotBlock);\r\n        senderVotes.castedVotes[0].stake = voterStake.sub(totalVoted);\r\n\r\n        // Register number of options voted\r\n        senderVotes.optionsCastedLength = _optionIds.length;\r\n\r\n        // Add voter tokens to participation\r\n        survey.participation = survey.participation.add(totalVoted);\r\n        assert(survey.participation <= survey.votingPower);\r\n    }\r\n\r\n    function _isSurveyOpen(SurveyStruct storage _survey) internal view returns (bool) {\r\n        return getTimestamp64() < _survey.startDate.add(surveyTime);\r\n    }\r\n}\r\n\r\n// File: @aragon/apps-voting/contracts/Voting.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    GPL-3.0-or-later\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Voting is IForwarder, AragonApp {\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n\r\n    bytes32 public constant CREATE_VOTES_ROLE = keccak256(\"CREATE_VOTES_ROLE\");\r\n    bytes32 public constant MODIFY_SUPPORT_ROLE = keccak256(\"MODIFY_SUPPORT_ROLE\");\r\n    bytes32 public constant MODIFY_QUORUM_ROLE = keccak256(\"MODIFY_QUORUM_ROLE\");\r\n\r\n    uint64 public constant PCT_BASE = 10 ** 18; // 0% = 0; 1% = 10^16; 100% = 10^18\r\n\r\n    string private constant ERROR_NO_VOTE = \"VOTING_NO_VOTE\";\r\n    string private constant ERROR_INIT_PCTS = \"VOTING_INIT_PCTS\";\r\n    string private constant ERROR_CHANGE_SUPPORT_PCTS = \"VOTING_CHANGE_SUPPORT_PCTS\";\r\n    string private constant ERROR_CHANGE_QUORUM_PCTS = \"VOTING_CHANGE_QUORUM_PCTS\";\r\n    string private constant ERROR_INIT_SUPPORT_TOO_BIG = \"VOTING_INIT_SUPPORT_TOO_BIG\";\r\n    string private constant ERROR_CHANGE_SUPPORT_TOO_BIG = \"VOTING_CHANGE_SUPP_TOO_BIG\";\r\n    string private constant ERROR_CAN_NOT_VOTE = \"VOTING_CAN_NOT_VOTE\";\r\n    string private constant ERROR_CAN_NOT_EXECUTE = \"VOTING_CAN_NOT_EXECUTE\";\r\n    string private constant ERROR_CAN_NOT_FORWARD = \"VOTING_CAN_NOT_FORWARD\";\r\n    string private constant ERROR_NO_VOTING_POWER = \"VOTING_NO_VOTING_POWER\";\r\n\r\n    enum VoterState { Absent, Yea, Nay }\r\n\r\n    struct Vote {\r\n        bool executed;\r\n        uint64 startDate;\r\n        uint64 snapshotBlock;\r\n        uint64 supportRequiredPct;\r\n        uint64 minAcceptQuorumPct;\r\n        uint256 yea;\r\n        uint256 nay;\r\n        uint256 votingPower;\r\n        bytes executionScript;\r\n        mapping (address => VoterState) voters;\r\n    }\r\n\r\n    MiniMeToken public token;\r\n    uint64 public supportRequiredPct;\r\n    uint64 public minAcceptQuorumPct;\r\n    uint64 public voteTime;\r\n\r\n    // We are mimicing an array, we use a mapping instead to make app upgrade more graceful\r\n    mapping (uint256 => Vote) internal votes;\r\n    uint256 public votesLength;\r\n\r\n    event StartVote(uint256 indexed voteId, address indexed creator, string metadata);\r\n    event CastVote(uint256 indexed voteId, address indexed voter, bool supports, uint256 stake);\r\n    event ExecuteVote(uint256 indexed voteId);\r\n    event ChangeSupportRequired(uint64 supportRequiredPct);\r\n    event ChangeMinQuorum(uint64 minAcceptQuorumPct);\r\n\r\n    modifier voteExists(uint256 _voteId) {\r\n        require(_voteId < votesLength, ERROR_NO_VOTE);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Initialize Voting app with `_token.symbol(): string` for governance, minimum support of `@formatPct(_supportRequiredPct)`%, minimum acceptance quorum of `@formatPct(_minAcceptQuorumPct)`%, and a voting duration of `@transformTime(_voteTime)`\r\n    * @param _token MiniMeToken Address that will be used as governance token\r\n    * @param _supportRequiredPct Percentage of yeas in casted votes for a vote to succeed (expressed as a percentage of 10^18; eg. 10^16 = 1%, 10^18 = 100%)\r\n    * @param _minAcceptQuorumPct Percentage of yeas in total possible votes for a vote to succeed (expressed as a percentage of 10^18; eg. 10^16 = 1%, 10^18 = 100%)\r\n    * @param _voteTime Seconds that a vote will be open for token holders to vote (unless enough yeas or nays have been cast to make an early decision)\r\n    */\r\n    function initialize(\r\n        MiniMeToken _token,\r\n        uint64 _supportRequiredPct,\r\n        uint64 _minAcceptQuorumPct,\r\n        uint64 _voteTime\r\n    )\r\n        external\r\n        onlyInit\r\n    {\r\n        initialized();\r\n\r\n        require(_minAcceptQuorumPct <= _supportRequiredPct, ERROR_INIT_PCTS);\r\n        require(_supportRequiredPct < PCT_BASE, ERROR_INIT_SUPPORT_TOO_BIG);\r\n\r\n        token = _token;\r\n        supportRequiredPct = _supportRequiredPct;\r\n        minAcceptQuorumPct = _minAcceptQuorumPct;\r\n        voteTime = _voteTime;\r\n    }\r\n\r\n    /**\r\n    * @notice Change required support to `@formatPct(_supportRequiredPct)`%\r\n    * @param _supportRequiredPct New required support\r\n    */\r\n    function changeSupportRequiredPct(uint64 _supportRequiredPct)\r\n        external\r\n        authP(MODIFY_SUPPORT_ROLE, arr(uint256(_supportRequiredPct), uint256(supportRequiredPct)))\r\n    {\r\n        require(minAcceptQuorumPct <= _supportRequiredPct, ERROR_CHANGE_SUPPORT_PCTS);\r\n        require(_supportRequiredPct < PCT_BASE, ERROR_CHANGE_SUPPORT_TOO_BIG);\r\n        supportRequiredPct = _supportRequiredPct;\r\n\r\n        emit ChangeSupportRequired(_supportRequiredPct);\r\n    }\r\n\r\n    /**\r\n    * @notice Change minimum acceptance quorum to `@formatPct(_minAcceptQuorumPct)`%\r\n    * @param _minAcceptQuorumPct New acceptance quorum\r\n    */\r\n    function changeMinAcceptQuorumPct(uint64 _minAcceptQuorumPct)\r\n        external\r\n        authP(MODIFY_QUORUM_ROLE, arr(uint256(_minAcceptQuorumPct), uint256(minAcceptQuorumPct)))\r\n    {\r\n        require(_minAcceptQuorumPct <= supportRequiredPct, ERROR_CHANGE_QUORUM_PCTS);\r\n        minAcceptQuorumPct = _minAcceptQuorumPct;\r\n\r\n        emit ChangeMinQuorum(_minAcceptQuorumPct);\r\n    }\r\n\r\n    /**\r\n    * @notice Create a new vote about \"`_metadata`\"\r\n    * @param _executionScript EVM script to be executed on approval\r\n    * @param _metadata Vote metadata\r\n    * @return voteId Id for newly created vote\r\n    */\r\n    function newVote(bytes _executionScript, string _metadata) external auth(CREATE_VOTES_ROLE) returns (uint256 voteId) {\r\n        return _newVote(_executionScript, _metadata, true, true);\r\n    }\r\n\r\n    /**\r\n    * @notice Create a new vote about \"`_metadata`\"\r\n    * @param _executionScript EVM script to be executed on approval\r\n    * @param _metadata Vote metadata\r\n    * @param _castVote Whether to also cast newly created vote\r\n    * @param _executesIfDecided Whether to also immediately execute newly created vote if decided\r\n    * @return voteId id for newly created vote\r\n    */\r\n    function newVote(bytes _executionScript, string _metadata, bool _castVote, bool _executesIfDecided)\r\n        external\r\n        auth(CREATE_VOTES_ROLE)\r\n        returns (uint256 voteId)\r\n    {\r\n        return _newVote(_executionScript, _metadata, _castVote, _executesIfDecided);\r\n    }\r\n\r\n    /**\r\n    * @notice Vote `_supports ? 'yes' : 'no'` in vote #`_voteId`\r\n    * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\r\n    *      created via `newVote(),` which requires initialization\r\n    * @param _voteId Id for vote\r\n    * @param _supports Whether voter supports the vote\r\n    * @param _executesIfDecided Whether the vote should execute its action if it becomes decided\r\n    */\r\n    function vote(uint256 _voteId, bool _supports, bool _executesIfDecided) external voteExists(_voteId) {\r\n        require(_canVote(_voteId, msg.sender), ERROR_CAN_NOT_VOTE);\r\n        _vote(_voteId, _supports, msg.sender, _executesIfDecided);\r\n    }\r\n\r\n    /**\r\n    * @notice Execute vote #`_voteId`\r\n    * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\r\n    *      created via `newVote(),` which requires initialization\r\n    * @param _voteId Id for vote\r\n    */\r\n    function executeVote(uint256 _voteId) external voteExists(_voteId) {\r\n        _executeVote(_voteId);\r\n    }\r\n\r\n    // Forwarding fns\r\n\r\n    function isForwarder() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Creates a vote to execute the desired action, and casts a support vote if possible\r\n    * @dev IForwarder interface conformance\r\n    * @param _evmScript Start vote with script\r\n    */\r\n    function forward(bytes _evmScript) public {\r\n        require(canForward(msg.sender, _evmScript), ERROR_CAN_NOT_FORWARD);\r\n        _newVote(_evmScript, \"\", true, true);\r\n    }\r\n\r\n    function canForward(address _sender, bytes) public view returns (bool) {\r\n        // Note that `canPerform()` implicitly does an initialization check itself\r\n        return canPerform(_sender, CREATE_VOTES_ROLE, arr());\r\n    }\r\n\r\n    // Getter fns\r\n\r\n    /**\r\n    * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\r\n    *      created via `newVote(),` which requires initialization\r\n    */\r\n    function canExecute(uint256 _voteId) public view voteExists(_voteId) returns (bool) {\r\n        return _canExecute(_voteId);\r\n    }\r\n\r\n    /**\r\n    * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\r\n    *      created via `newVote(),` which requires initialization\r\n    */\r\n    function canVote(uint256 _voteId, address _voter) public view voteExists(_voteId) returns (bool) {\r\n        return _canVote(_voteId, _voter);\r\n    }\r\n\r\n    function getVote(uint256 _voteId)\r\n        public\r\n        view\r\n        voteExists(_voteId)\r\n        returns (\r\n            bool open,\r\n            bool executed,\r\n            uint64 startDate,\r\n            uint64 snapshotBlock,\r\n            uint64 supportRequired,\r\n            uint64 minAcceptQuorum,\r\n            uint256 yea,\r\n            uint256 nay,\r\n            uint256 votingPower,\r\n            bytes script\r\n        )\r\n    {\r\n        Vote storage vote_ = votes[_voteId];\r\n\r\n        open = _isVoteOpen(vote_);\r\n        executed = vote_.executed;\r\n        startDate = vote_.startDate;\r\n        snapshotBlock = vote_.snapshotBlock;\r\n        supportRequired = vote_.supportRequiredPct;\r\n        minAcceptQuorum = vote_.minAcceptQuorumPct;\r\n        yea = vote_.yea;\r\n        nay = vote_.nay;\r\n        votingPower = vote_.votingPower;\r\n        script = vote_.executionScript;\r\n    }\r\n\r\n    function getVoterState(uint256 _voteId, address _voter) public view voteExists(_voteId) returns (VoterState) {\r\n        return votes[_voteId].voters[_voter];\r\n    }\r\n\r\n    // Internal fns\r\n\r\n    function _newVote(bytes _executionScript, string _metadata, bool _castVote, bool _executesIfDecided)\r\n        internal\r\n        returns (uint256 voteId)\r\n    {\r\n        uint64 snapshotBlock = getBlockNumber64() - 1; // avoid double voting in this very block\r\n        uint256 votingPower = token.totalSupplyAt(snapshotBlock);\r\n        require(votingPower > 0, ERROR_NO_VOTING_POWER);\r\n\r\n        voteId = votesLength++;\r\n\r\n        Vote storage vote_ = votes[voteId];\r\n        vote_.startDate = getTimestamp64();\r\n        vote_.snapshotBlock = snapshotBlock;\r\n        vote_.supportRequiredPct = supportRequiredPct;\r\n        vote_.minAcceptQuorumPct = minAcceptQuorumPct;\r\n        vote_.votingPower = votingPower;\r\n        vote_.executionScript = _executionScript;\r\n\r\n        emit StartVote(voteId, msg.sender, _metadata);\r\n\r\n        if (_castVote && _canVote(voteId, msg.sender)) {\r\n            _vote(voteId, true, msg.sender, _executesIfDecided);\r\n        }\r\n    }\r\n\r\n    function _vote(\r\n        uint256 _voteId,\r\n        bool _supports,\r\n        address _voter,\r\n        bool _executesIfDecided\r\n    ) internal\r\n    {\r\n        Vote storage vote_ = votes[_voteId];\r\n\r\n        // This could re-enter, though we can assume the governance token is not malicious\r\n        uint256 voterStake = token.balanceOfAt(_voter, vote_.snapshotBlock);\r\n        VoterState state = vote_.voters[_voter];\r\n\r\n        // If voter had previously voted, decrease count\r\n        if (state == VoterState.Yea) {\r\n            vote_.yea = vote_.yea.sub(voterStake);\r\n        } else if (state == VoterState.Nay) {\r\n            vote_.nay = vote_.nay.sub(voterStake);\r\n        }\r\n\r\n        if (_supports) {\r\n            vote_.yea = vote_.yea.add(voterStake);\r\n        } else {\r\n            vote_.nay = vote_.nay.add(voterStake);\r\n        }\r\n\r\n        vote_.voters[_voter] = _supports ? VoterState.Yea : VoterState.Nay;\r\n\r\n        emit CastVote(_voteId, _voter, _supports, voterStake);\r\n\r\n        if (_executesIfDecided && _canExecute(_voteId)) {\r\n            // We've already checked if the vote can be executed with `_canExecute()`\r\n            _unsafeExecuteVote(_voteId);\r\n        }\r\n    }\r\n\r\n    function _executeVote(uint256 _voteId) internal {\r\n        require(_canExecute(_voteId), ERROR_CAN_NOT_EXECUTE);\r\n        _unsafeExecuteVote(_voteId);\r\n    }\r\n\r\n    /**\r\n    * @dev Unsafe version of _executeVote that assumes you have already checked if the vote can be executed\r\n    */\r\n    function _unsafeExecuteVote(uint256 _voteId) internal {\r\n        Vote storage vote_ = votes[_voteId];\r\n\r\n        vote_.executed = true;\r\n\r\n        bytes memory input = new bytes(0); // TODO: Consider input for voting scripts\r\n        runScript(vote_.executionScript, input, new address[](0));\r\n\r\n        emit ExecuteVote(_voteId);\r\n    }\r\n\r\n    function _canExecute(uint256 _voteId) internal view returns (bool) {\r\n        Vote storage vote_ = votes[_voteId];\r\n\r\n        if (vote_.executed) {\r\n            return false;\r\n        }\r\n\r\n        // Voting is already decided\r\n        if (_isValuePct(vote_.yea, vote_.votingPower, vote_.supportRequiredPct)) {\r\n            return true;\r\n        }\r\n\r\n        // Vote ended?\r\n        if (_isVoteOpen(vote_)) {\r\n            return false;\r\n        }\r\n        // Has enough support?\r\n        uint256 totalVotes = vote_.yea.add(vote_.nay);\r\n        if (!_isValuePct(vote_.yea, totalVotes, vote_.supportRequiredPct)) {\r\n            return false;\r\n        }\r\n        // Has min quorum?\r\n        if (!_isValuePct(vote_.yea, vote_.votingPower, vote_.minAcceptQuorumPct)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _canVote(uint256 _voteId, address _voter) internal view returns (bool) {\r\n        Vote storage vote_ = votes[_voteId];\r\n\r\n        return _isVoteOpen(vote_) && token.balanceOfAt(_voter, vote_.snapshotBlock) > 0;\r\n    }\r\n\r\n    function _isVoteOpen(Vote storage vote_) internal view returns (bool) {\r\n        return getTimestamp64() < vote_.startDate.add(voteTime) && !vote_.executed;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates whether `_value` is more than a percentage `_pct` of `_total`\r\n    */\r\n    function _isValuePct(uint256 _value, uint256 _total, uint256 _pct) internal pure returns (bool) {\r\n        if (_total == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 computedPct = _value.mul(PCT_BASE) / _total;\r\n        return computedPct > _pct;\r\n    }\r\n}\r\n\r\n// File: @aragon/id/contracts/ens/IPublicResolver.sol\r\n\r\npragma solidity ^0.4.0;\r\n\r\n\r\ninterface IPublicResolver {\r\n    function supportsInterface(bytes4 interfaceID) constant returns (bool);\r\n    function addr(bytes32 node) constant returns (address ret);\r\n    function setAddr(bytes32 node, address addr);\r\n    function hash(bytes32 node) constant returns (bytes32 ret);\r\n    function setHash(bytes32 node, bytes32 hash);\r\n}\r\n\r\n// File: @aragon/id/contracts/IFIFSResolvingRegistrar.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ninterface IFIFSResolvingRegistrar {\r\n    function register(bytes32 _subnode, address _owner) external;\r\n    function registerWithResolver(bytes32 _subnode, address _owner, IPublicResolver _resolver) public;\r\n}\r\n\r\n// File: @aragon/os/contracts/acl/IACLOracle.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IACLOracle {\r\n    function canPerform(address who, address where, bytes32 what, uint256[] how) external view returns (bool);\r\n}\r\n\r\n// File: @aragon/os/contracts/acl/ACL.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* solium-disable function-order */\r\n// Allow public initialize() to be first\r\ncontract ACL is IACL, TimeHelpers, AragonApp, ACLHelpers {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 public constant CREATE_PERMISSIONS_ROLE = keccak256(\"CREATE_PERMISSIONS_ROLE\");\r\n    */\r\n    bytes32 public constant CREATE_PERMISSIONS_ROLE = 0x0b719b33c83b8e5d300c521cb8b54ae9bd933996a14bef8c2f4e0285d2d2400a;\r\n\r\n    enum Op { NONE, EQ, NEQ, GT, LT, GTE, LTE, RET, NOT, AND, OR, XOR, IF_ELSE } // op types\r\n\r\n    struct Param {\r\n        uint8 id;\r\n        uint8 op;\r\n        uint240 value; // even though value is an uint240 it can store addresses\r\n        // in the case of 32 byte hashes losing 2 bytes precision isn't a huge deal\r\n        // op and id take less than 1 byte each so it can be kept in 1 sstore\r\n    }\r\n\r\n    uint8 internal constant BLOCK_NUMBER_PARAM_ID = 200;\r\n    uint8 internal constant TIMESTAMP_PARAM_ID    = 201;\r\n    // 202 is unused\r\n    uint8 internal constant ORACLE_PARAM_ID       = 203;\r\n    uint8 internal constant LOGIC_OP_PARAM_ID     = 204;\r\n    uint8 internal constant PARAM_VALUE_PARAM_ID  = 205;\r\n    // TODO: Add execution times param type?\r\n\r\n    /* Hardcoded constant to save gas\r\n    bytes32 public constant EMPTY_PARAM_HASH = keccak256(uint256(0));\r\n    */\r\n    bytes32 public constant EMPTY_PARAM_HASH = 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563;\r\n    bytes32 public constant NO_PERMISSION = bytes32(0);\r\n    address public constant ANY_ENTITY = address(-1);\r\n    address public constant BURN_ENTITY = address(1); // address(0) is already used as \"no permission manager\"\r\n\r\n    uint256 internal constant ORACLE_CHECK_GAS = 30000;\r\n\r\n    string private constant ERROR_AUTH_INIT_KERNEL = \"ACL_AUTH_INIT_KERNEL\";\r\n    string private constant ERROR_AUTH_NO_MANAGER = \"ACL_AUTH_NO_MANAGER\";\r\n    string private constant ERROR_EXISTENT_MANAGER = \"ACL_EXISTENT_MANAGER\";\r\n\r\n    // Whether someone has a permission\r\n    mapping (bytes32 => bytes32) internal permissions; // permissions hash => params hash\r\n    mapping (bytes32 => Param[]) internal permissionParams; // params hash => params\r\n\r\n    // Who is the manager of a permission\r\n    mapping (bytes32 => address) internal permissionManager;\r\n\r\n    event SetPermission(address indexed entity, address indexed app, bytes32 indexed role, bool allowed);\r\n    event SetPermissionParams(address indexed entity, address indexed app, bytes32 indexed role, bytes32 paramsHash);\r\n    event ChangePermissionManager(address indexed app, bytes32 indexed role, address indexed manager);\r\n\r\n    modifier onlyPermissionManager(address _app, bytes32 _role) {\r\n        require(msg.sender == getPermissionManager(_app, _role), ERROR_AUTH_NO_MANAGER);\r\n        _;\r\n    }\r\n\r\n    modifier noPermissionManager(address _app, bytes32 _role) {\r\n        // only allow permission creation (or re-creation) when there is no manager\r\n        require(getPermissionManager(_app, _role) == address(0), ERROR_EXISTENT_MANAGER);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\r\n    * @notice Initialize an ACL instance and set `_permissionsCreator` as the entity that can create other permissions\r\n    * @param _permissionsCreator Entity that will be given permission over createPermission\r\n    */\r\n    function initialize(address _permissionsCreator) public onlyInit {\r\n        initialized();\r\n        require(msg.sender == address(kernel()), ERROR_AUTH_INIT_KERNEL);\r\n\r\n        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);\r\n    }\r\n\r\n    /**\r\n    * @dev Creates a permission that wasn't previously set and managed.\r\n    *      If a created permission is removed it is possible to reset it with createPermission.\r\n    *      This is the **ONLY** way to create permissions and set managers to permissions that don't\r\n    *      have a manager.\r\n    *      In terms of the ACL being initialized, this function implicitly protects all the other\r\n    *      state-changing external functions, as they all require the sender to be a manager.\r\n    * @notice Create a new permission granting `_entity` the ability to perform actions requiring `_role` on `_app`, setting `_manager` as the permission's manager\r\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\r\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\r\n    * @param _role Identifier for the group of actions in app given access to perform\r\n    * @param _manager Address of the entity that will be able to grant and revoke the permission further.\r\n    */\r\n    function createPermission(address _entity, address _app, bytes32 _role, address _manager)\r\n        external\r\n        auth(CREATE_PERMISSIONS_ROLE)\r\n        noPermissionManager(_app, _role)\r\n    {\r\n        _createPermission(_entity, _app, _role, _manager);\r\n    }\r\n\r\n    /**\r\n    * @dev Grants permission if allowed. This requires `msg.sender` to be the permission manager\r\n    * @notice Grant `_entity` the ability to perform actions requiring `_role` on `_app`\r\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\r\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\r\n    * @param _role Identifier for the group of actions in app given access to perform\r\n    */\r\n    function grantPermission(address _entity, address _app, bytes32 _role)\r\n        external\r\n    {\r\n        grantPermissionP(_entity, _app, _role, new uint256[](0));\r\n    }\r\n\r\n    /**\r\n    * @dev Grants a permission with parameters if allowed. This requires `msg.sender` to be the permission manager\r\n    * @notice Grant `_entity` the ability to perform actions requiring `_role` on `_app`\r\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\r\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\r\n    * @param _role Identifier for the group of actions in app given access to perform\r\n    * @param _params Permission parameters\r\n    */\r\n    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] _params)\r\n        public\r\n        onlyPermissionManager(_app, _role)\r\n    {\r\n        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;\r\n        _setPermission(_entity, _app, _role, paramsHash);\r\n    }\r\n\r\n    /**\r\n    * @dev Revokes permission if allowed. This requires `msg.sender` to be the the permission manager\r\n    * @notice Revoke from `_entity` the ability to perform actions requiring `_role` on `_app`\r\n    * @param _entity Address of the whitelisted entity to revoke access from\r\n    * @param _app Address of the app in which the role will be revoked\r\n    * @param _role Identifier for the group of actions in app being revoked\r\n    */\r\n    function revokePermission(address _entity, address _app, bytes32 _role)\r\n        external\r\n        onlyPermissionManager(_app, _role)\r\n    {\r\n        _setPermission(_entity, _app, _role, NO_PERMISSION);\r\n    }\r\n\r\n    /**\r\n    * @notice Set `_newManager` as the manager of `_role` in `_app`\r\n    * @param _newManager Address for the new manager\r\n    * @param _app Address of the app in which the permission management is being transferred\r\n    * @param _role Identifier for the group of actions being transferred\r\n    */\r\n    function setPermissionManager(address _newManager, address _app, bytes32 _role)\r\n        external\r\n        onlyPermissionManager(_app, _role)\r\n    {\r\n        _setPermissionManager(_newManager, _app, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove the manager of `_role` in `_app`\r\n    * @param _app Address of the app in which the permission is being unmanaged\r\n    * @param _role Identifier for the group of actions being unmanaged\r\n    */\r\n    function removePermissionManager(address _app, bytes32 _role)\r\n        external\r\n        onlyPermissionManager(_app, _role)\r\n    {\r\n        _setPermissionManager(address(0), _app, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Burn non-existent `_role` in `_app`, so no modification can be made to it (grant, revoke, permission manager)\r\n    * @param _app Address of the app in which the permission is being burned\r\n    * @param _role Identifier for the group of actions being burned\r\n    */\r\n    function createBurnedPermission(address _app, bytes32 _role)\r\n        external\r\n        auth(CREATE_PERMISSIONS_ROLE)\r\n        noPermissionManager(_app, _role)\r\n    {\r\n        _setPermissionManager(BURN_ENTITY, _app, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Burn `_role` in `_app`, so no modification can be made to it (grant, revoke, permission manager)\r\n    * @param _app Address of the app in which the permission is being burned\r\n    * @param _role Identifier for the group of actions being burned\r\n    */\r\n    function burnPermissionManager(address _app, bytes32 _role)\r\n        external\r\n        onlyPermissionManager(_app, _role)\r\n    {\r\n        _setPermissionManager(BURN_ENTITY, _app, _role);\r\n    }\r\n\r\n    /**\r\n     * @notice Get parameters for permission array length\r\n     * @param _entity Address of the whitelisted entity that will be able to perform the role\r\n     * @param _app Address of the app\r\n     * @param _role Identifier for a group of actions in app\r\n     * @return Length of the array\r\n     */\r\n    function getPermissionParamsLength(address _entity, address _app, bytes32 _role) external view returns (uint) {\r\n        return permissionParams[permissions[permissionHash(_entity, _app, _role)]].length;\r\n    }\r\n\r\n    /**\r\n    * @notice Get parameter for permission\r\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\r\n    * @param _app Address of the app\r\n    * @param _role Identifier for a group of actions in app\r\n    * @param _index Index of parameter in the array\r\n    * @return Parameter (id, op, value)\r\n    */\r\n    function getPermissionParam(address _entity, address _app, bytes32 _role, uint _index)\r\n        external\r\n        view\r\n        returns (uint8, uint8, uint240)\r\n    {\r\n        Param storage param = permissionParams[permissions[permissionHash(_entity, _app, _role)]][_index];\r\n        return (param.id, param.op, param.value);\r\n    }\r\n\r\n    /**\r\n    * @dev Get manager for permission\r\n    * @param _app Address of the app\r\n    * @param _role Identifier for a group of actions in app\r\n    * @return address of the manager for the permission\r\n    */\r\n    function getPermissionManager(address _app, bytes32 _role) public view returns (address) {\r\n        return permissionManager[roleHash(_app, _role)];\r\n    }\r\n\r\n    /**\r\n    * @dev Function called by apps to check ACL on kernel or to check permission statu\r\n    * @param _who Sender of the original call\r\n    * @param _where Address of the app\r\n    * @param _where Identifier for a group of actions in app\r\n    * @param _how Permission parameters\r\n    * @return boolean indicating whether the ACL allows the role or not\r\n    */\r\n    function hasPermission(address _who, address _where, bytes32 _what, bytes memory _how) public view returns (bool) {\r\n        return hasPermission(_who, _where, _what, ConversionHelpers.dangerouslyCastBytesToUintArray(_how));\r\n    }\r\n\r\n    function hasPermission(address _who, address _where, bytes32 _what, uint256[] memory _how) public view returns (bool) {\r\n        bytes32 whoParams = permissions[permissionHash(_who, _where, _what)];\r\n        if (whoParams != NO_PERMISSION && evalParams(whoParams, _who, _where, _what, _how)) {\r\n            return true;\r\n        }\r\n\r\n        bytes32 anyParams = permissions[permissionHash(ANY_ENTITY, _where, _what)];\r\n        if (anyParams != NO_PERMISSION && evalParams(anyParams, ANY_ENTITY, _where, _what, _how)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function hasPermission(address _who, address _where, bytes32 _what) public view returns (bool) {\r\n        uint256[] memory empty = new uint256[](0);\r\n        return hasPermission(_who, _where, _what, empty);\r\n    }\r\n\r\n    function evalParams(\r\n        bytes32 _paramsHash,\r\n        address _who,\r\n        address _where,\r\n        bytes32 _what,\r\n        uint256[] _how\r\n    ) public view returns (bool)\r\n    {\r\n        if (_paramsHash == EMPTY_PARAM_HASH) {\r\n            return true;\r\n        }\r\n\r\n        return _evalParam(_paramsHash, 0, _who, _where, _what, _how);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal createPermission for access inside the kernel (on instantiation)\r\n    */\r\n    function _createPermission(address _entity, address _app, bytes32 _role, address _manager) internal {\r\n        _setPermission(_entity, _app, _role, EMPTY_PARAM_HASH);\r\n        _setPermissionManager(_manager, _app, _role);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function called to actually save the permission\r\n    */\r\n    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {\r\n        permissions[permissionHash(_entity, _app, _role)] = _paramsHash;\r\n        bool entityHasPermission = _paramsHash != NO_PERMISSION;\r\n        bool permissionHasParams = entityHasPermission && _paramsHash != EMPTY_PARAM_HASH;\r\n\r\n        emit SetPermission(_entity, _app, _role, entityHasPermission);\r\n        if (permissionHasParams) {\r\n            emit SetPermissionParams(_entity, _app, _role, _paramsHash);\r\n        }\r\n    }\r\n\r\n    function _saveParams(uint256[] _encodedParams) internal returns (bytes32) {\r\n        bytes32 paramHash = keccak256(abi.encodePacked(_encodedParams));\r\n        Param[] storage params = permissionParams[paramHash];\r\n\r\n        if (params.length == 0) { // params not saved before\r\n            for (uint256 i = 0; i < _encodedParams.length; i++) {\r\n                uint256 encodedParam = _encodedParams[i];\r\n                Param memory param = Param(decodeParamId(encodedParam), decodeParamOp(encodedParam), uint240(encodedParam));\r\n                params.push(param);\r\n            }\r\n        }\r\n\r\n        return paramHash;\r\n    }\r\n\r\n    function _evalParam(\r\n        bytes32 _paramsHash,\r\n        uint32 _paramId,\r\n        address _who,\r\n        address _where,\r\n        bytes32 _what,\r\n        uint256[] _how\r\n    ) internal view returns (bool)\r\n    {\r\n        if (_paramId >= permissionParams[_paramsHash].length) {\r\n            return false; // out of bounds\r\n        }\r\n\r\n        Param memory param = permissionParams[_paramsHash][_paramId];\r\n\r\n        if (param.id == LOGIC_OP_PARAM_ID) {\r\n            return _evalLogic(param, _paramsHash, _who, _where, _what, _how);\r\n        }\r\n\r\n        uint256 value;\r\n        uint256 comparedTo = uint256(param.value);\r\n\r\n        // get value\r\n        if (param.id == ORACLE_PARAM_ID) {\r\n            value = checkOracle(IACLOracle(param.value), _who, _where, _what, _how) ? 1 : 0;\r\n            comparedTo = 1;\r\n        } else if (param.id == BLOCK_NUMBER_PARAM_ID) {\r\n            value = getBlockNumber();\r\n        } else if (param.id == TIMESTAMP_PARAM_ID) {\r\n            value = getTimestamp();\r\n        } else if (param.id == PARAM_VALUE_PARAM_ID) {\r\n            value = uint256(param.value);\r\n        } else {\r\n            if (param.id >= _how.length) {\r\n                return false;\r\n            }\r\n            value = uint256(uint240(_how[param.id])); // force lost precision\r\n        }\r\n\r\n        if (Op(param.op) == Op.RET) {\r\n            return uint256(value) > 0;\r\n        }\r\n\r\n        return compare(value, Op(param.op), comparedTo);\r\n    }\r\n\r\n    function _evalLogic(Param _param, bytes32 _paramsHash, address _who, address _where, bytes32 _what, uint256[] _how)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (Op(_param.op) == Op.IF_ELSE) {\r\n            uint32 conditionParam;\r\n            uint32 successParam;\r\n            uint32 failureParam;\r\n\r\n            (conditionParam, successParam, failureParam) = decodeParamsList(uint256(_param.value));\r\n            bool result = _evalParam(_paramsHash, conditionParam, _who, _where, _what, _how);\r\n\r\n            return _evalParam(_paramsHash, result ? successParam : failureParam, _who, _where, _what, _how);\r\n        }\r\n\r\n        uint32 param1;\r\n        uint32 param2;\r\n\r\n        (param1, param2,) = decodeParamsList(uint256(_param.value));\r\n        bool r1 = _evalParam(_paramsHash, param1, _who, _where, _what, _how);\r\n\r\n        if (Op(_param.op) == Op.NOT) {\r\n            return !r1;\r\n        }\r\n\r\n        if (r1 && Op(_param.op) == Op.OR) {\r\n            return true;\r\n        }\r\n\r\n        if (!r1 && Op(_param.op) == Op.AND) {\r\n            return false;\r\n        }\r\n\r\n        bool r2 = _evalParam(_paramsHash, param2, _who, _where, _what, _how);\r\n\r\n        if (Op(_param.op) == Op.XOR) {\r\n            return r1 != r2;\r\n        }\r\n\r\n        return r2; // both or and and depend on result of r2 after checks\r\n    }\r\n\r\n    function compare(uint256 _a, Op _op, uint256 _b) internal pure returns (bool) {\r\n        if (_op == Op.EQ)  return _a == _b;                              // solium-disable-line lbrace\r\n        if (_op == Op.NEQ) return _a != _b;                              // solium-disable-line lbrace\r\n        if (_op == Op.GT)  return _a > _b;                               // solium-disable-line lbrace\r\n        if (_op == Op.LT)  return _a < _b;                               // solium-disable-line lbrace\r\n        if (_op == Op.GTE) return _a >= _b;                              // solium-disable-line lbrace\r\n        if (_op == Op.LTE) return _a <= _b;                              // solium-disable-line lbrace\r\n        return false;\r\n    }\r\n\r\n    function checkOracle(IACLOracle _oracleAddr, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\r\n        bytes4 sig = _oracleAddr.canPerform.selector;\r\n\r\n        // a raw call is required so we can return false if the call reverts, rather than reverting\r\n        bytes memory checkCalldata = abi.encodeWithSelector(sig, _who, _where, _what, _how);\r\n        uint256 oracleCheckGas = ORACLE_CHECK_GAS;\r\n\r\n        bool ok;\r\n        assembly {\r\n            ok := staticcall(oracleCheckGas, _oracleAddr, add(checkCalldata, 0x20), mload(checkCalldata), 0, 0)\r\n        }\r\n\r\n        if (!ok) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := returndatasize }\r\n        if (size != 32) {\r\n            return false;\r\n        }\r\n\r\n        bool result;\r\n        assembly {\r\n            let ptr := mload(0x40)       // get next free memory ptr\r\n            returndatacopy(ptr, 0, size) // copy return from above `staticcall`\r\n            result := mload(ptr)         // read data at ptr and set it to result\r\n            mstore(ptr, 0)               // set pointer memory to 0 so it still is the next free ptr\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that sets management\r\n    */\r\n    function _setPermissionManager(address _newManager, address _app, bytes32 _role) internal {\r\n        permissionManager[roleHash(_app, _role)] = _newManager;\r\n        emit ChangePermissionManager(_app, _role, _newManager);\r\n    }\r\n\r\n    function roleHash(address _where, bytes32 _what) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"ROLE\", _where, _what));\r\n    }\r\n\r\n    function permissionHash(address _who, address _where, bytes32 _what) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"PERMISSION\", _who, _where, _what));\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/apm/APMNamehash.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract APMNamehash {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant APM_NODE = keccak256(abi.encodePacked(ETH_TLD_NODE, keccak256(abi.encodePacked(\"aragonpm\"))));\r\n    */\r\n    bytes32 internal constant APM_NODE = 0x9065c3e7f7b7ef1ef4e53d2d0b8e0cef02874ab020c1ece79d5f0d3d0111c0ba;\r\n\r\n    function apmNamehash(string name) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(APM_NODE, keccak256(bytes(name))));\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/apm/Repo.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/* solium-disable function-order */\r\n// Allow public initialize() to be first\r\ncontract Repo is AragonApp {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 public constant CREATE_VERSION_ROLE = keccak256(\"CREATE_VERSION_ROLE\");\r\n    */\r\n    bytes32 public constant CREATE_VERSION_ROLE = 0x1f56cfecd3595a2e6cc1a7e6cb0b20df84cdbd92eff2fee554e70e4e45a9a7d8;\r\n\r\n    string private constant ERROR_INVALID_BUMP = \"REPO_INVALID_BUMP\";\r\n    string private constant ERROR_INVALID_VERSION = \"REPO_INVALID_VERSION\";\r\n    string private constant ERROR_INEXISTENT_VERSION = \"REPO_INEXISTENT_VERSION\";\r\n\r\n    struct Version {\r\n        uint16[3] semanticVersion;\r\n        address contractAddress;\r\n        bytes contentURI;\r\n    }\r\n\r\n    uint256 internal versionsNextIndex;\r\n    mapping (uint256 => Version) internal versions;\r\n    mapping (bytes32 => uint256) internal versionIdForSemantic;\r\n    mapping (address => uint256) internal latestVersionIdForContract;\r\n\r\n    event NewVersion(uint256 versionId, uint16[3] semanticVersion);\r\n\r\n    /**\r\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\r\n    * @notice Initialize this Repo\r\n    */\r\n    function initialize() public onlyInit {\r\n        initialized();\r\n        versionsNextIndex = 1;\r\n    }\r\n\r\n    /**\r\n    * @notice Create new version with contract `_contractAddress` and content `@fromHex(_contentURI)`\r\n    * @param _newSemanticVersion Semantic version for new repo version\r\n    * @param _contractAddress address for smart contract logic for version (if set to 0, it uses last versions' contractAddress)\r\n    * @param _contentURI External URI for fetching new version's content\r\n    */\r\n    function newVersion(\r\n        uint16[3] _newSemanticVersion,\r\n        address _contractAddress,\r\n        bytes _contentURI\r\n    ) public auth(CREATE_VERSION_ROLE)\r\n    {\r\n        address contractAddress = _contractAddress;\r\n        uint256 lastVersionIndex = versionsNextIndex - 1;\r\n\r\n        uint16[3] memory lastSematicVersion;\r\n\r\n        if (lastVersionIndex > 0) {\r\n            Version storage lastVersion = versions[lastVersionIndex];\r\n            lastSematicVersion = lastVersion.semanticVersion;\r\n\r\n            if (contractAddress == address(0)) {\r\n                contractAddress = lastVersion.contractAddress;\r\n            }\r\n            // Only allows smart contract change on major version bumps\r\n            require(\r\n                lastVersion.contractAddress == contractAddress || _newSemanticVersion[0] > lastVersion.semanticVersion[0],\r\n                ERROR_INVALID_VERSION\r\n            );\r\n        }\r\n\r\n        require(isValidBump(lastSematicVersion, _newSemanticVersion), ERROR_INVALID_BUMP);\r\n\r\n        uint256 versionId = versionsNextIndex++;\r\n        versions[versionId] = Version(_newSemanticVersion, contractAddress, _contentURI);\r\n        versionIdForSemantic[semanticVersionHash(_newSemanticVersion)] = versionId;\r\n        latestVersionIdForContract[contractAddress] = versionId;\r\n\r\n        emit NewVersion(versionId, _newSemanticVersion);\r\n    }\r\n\r\n    function getLatest() public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\r\n        return getByVersionId(versionsNextIndex - 1);\r\n    }\r\n\r\n    function getLatestForContractAddress(address _contractAddress)\r\n        public\r\n        view\r\n        returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI)\r\n    {\r\n        return getByVersionId(latestVersionIdForContract[_contractAddress]);\r\n    }\r\n\r\n    function getBySemanticVersion(uint16[3] _semanticVersion)\r\n        public\r\n        view\r\n        returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI)\r\n    {\r\n        return getByVersionId(versionIdForSemantic[semanticVersionHash(_semanticVersion)]);\r\n    }\r\n\r\n    function getByVersionId(uint _versionId) public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\r\n        require(_versionId > 0 && _versionId < versionsNextIndex, ERROR_INEXISTENT_VERSION);\r\n        Version storage version = versions[_versionId];\r\n        return (version.semanticVersion, version.contractAddress, version.contentURI);\r\n    }\r\n\r\n    function getVersionsCount() public view returns (uint256) {\r\n        return versionsNextIndex - 1;\r\n    }\r\n\r\n    function isValidBump(uint16[3] _oldVersion, uint16[3] _newVersion) public pure returns (bool) {\r\n        bool hasBumped;\r\n        uint i = 0;\r\n        while (i < 3) {\r\n            if (hasBumped) {\r\n                if (_newVersion[i] != 0) {\r\n                    return false;\r\n                }\r\n            } else if (_newVersion[i] != _oldVersion[i]) {\r\n                if (_oldVersion[i] > _newVersion[i] || _newVersion[i] - _oldVersion[i] != 1) {\r\n                    return false;\r\n                }\r\n                hasBumped = true;\r\n            }\r\n            i++;\r\n        }\r\n        return hasBumped;\r\n    }\r\n\r\n    function semanticVersionHash(uint16[3] version) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(version[0], version[1], version[2]));\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/kernel/KernelStorage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\ncontract KernelStorage {\r\n    // namespace => app id => address\r\n    mapping (bytes32 => mapping (bytes32 => address)) public apps;\r\n    bytes32 public recoveryVaultAppId;\r\n}\r\n\r\n// File: @aragon/os/contracts/lib/misc/ERCProxy.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract ERCProxy {\r\n    uint256 internal constant FORWARDING = 1;\r\n    uint256 internal constant UPGRADEABLE = 2;\r\n\r\n    function proxyType() public pure returns (uint256 proxyTypeId);\r\n    function implementation() public view returns (address codeAddr);\r\n}\r\n\r\n// File: @aragon/os/contracts/common/DelegateProxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract DelegateProxy is ERCProxy, IsContract {\r\n    uint256 internal constant FWD_GAS_LIMIT = 10000;\r\n\r\n    /**\r\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\r\n    * @param _dst Destination address to perform the delegatecall\r\n    * @param _calldata Calldata for the delegatecall\r\n    */\r\n    function delegatedFwd(address _dst, bytes _calldata) internal {\r\n        require(isContract(_dst));\r\n        uint256 fwdGasLimit = FWD_GAS_LIMIT;\r\n\r\n        assembly {\r\n            let result := delegatecall(sub(gas, fwdGasLimit), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/DepositableDelegateProxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract DepositableDelegateProxy is DepositableStorage, DelegateProxy {\r\n    event ProxyDeposit(address sender, uint256 value);\r\n\r\n    function () external payable {\r\n        // send / transfer\r\n        if (gasleft() < FWD_GAS_LIMIT) {\r\n            require(msg.value > 0 && msg.data.length == 0);\r\n            require(isDepositable());\r\n            emit ProxyDeposit(msg.sender, msg.value);\r\n        } else { // all calls except for send or transfer\r\n            address target = implementation();\r\n            delegatedFwd(target, msg.data);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/apps/AppProxyBase.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AppProxyBase is AppStorage, DepositableDelegateProxy, KernelNamespaceConstants {\r\n    /**\r\n    * @dev Initialize AppProxy\r\n    * @param _kernel Reference to organization kernel for the app\r\n    * @param _appId Identifier for app\r\n    * @param _initializePayload Payload for call to be made after setup to initialize\r\n    */\r\n    constructor(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\r\n        setKernel(_kernel);\r\n        setAppId(_appId);\r\n\r\n        // Implicit check that kernel is actually a Kernel\r\n        // The EVM doesn't actually provide a way for us to make sure, but we can force a revert to\r\n        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\r\n        // it.\r\n        address appCode = getAppBase(_appId);\r\n\r\n        // If initialize payload is provided, it will be executed\r\n        if (_initializePayload.length > 0) {\r\n            require(isContract(appCode));\r\n            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\r\n            // returns ending execution context and halts contract deployment\r\n            require(appCode.delegatecall(_initializePayload));\r\n        }\r\n    }\r\n\r\n    function getAppBase(bytes32 _appId) internal view returns (address) {\r\n        return kernel().getApp(KERNEL_APP_BASES_NAMESPACE, _appId);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/apps/AppProxyUpgradeable.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract AppProxyUpgradeable is AppProxyBase {\r\n    /**\r\n    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\r\n    * @param _kernel Reference to organization kernel for the app\r\n    * @param _appId Identifier for app\r\n    * @param _initializePayload Payload for call to be made after setup to initialize\r\n    */\r\n    constructor(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\r\n        AppProxyBase(_kernel, _appId, _initializePayload)\r\n        public // solium-disable-line visibility-first\r\n    {\r\n        // solium-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n     * @dev ERC897, the address the proxy would delegate calls to\r\n     */\r\n    function implementation() public view returns (address) {\r\n        return getAppBase(appId());\r\n    }\r\n\r\n    /**\r\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\r\n     */\r\n    function proxyType() public pure returns (uint256 proxyTypeId) {\r\n        return UPGRADEABLE;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/apps/AppProxyPinned.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract AppProxyPinned is IsContract, AppProxyBase {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    // keccak256(\"aragonOS.appStorage.pinnedCode\")\r\n    bytes32 internal constant PINNED_CODE_POSITION = 0xdee64df20d65e53d7f51cb6ab6d921a0a6a638a91e942e1d8d02df28e31c038e;\r\n\r\n    /**\r\n    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\r\n    * @param _kernel Reference to organization kernel for the app\r\n    * @param _appId Identifier for app\r\n    * @param _initializePayload Payload for call to be made after setup to initialize\r\n    */\r\n    constructor(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\r\n        AppProxyBase(_kernel, _appId, _initializePayload)\r\n        public // solium-disable-line visibility-first\r\n    {\r\n        setPinnedCode(getAppBase(_appId));\r\n        require(isContract(pinnedCode()));\r\n    }\r\n\r\n    /**\r\n     * @dev ERC897, the address the proxy would delegate calls to\r\n     */\r\n    function implementation() public view returns (address) {\r\n        return pinnedCode();\r\n    }\r\n\r\n    /**\r\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\r\n     */\r\n    function proxyType() public pure returns (uint256 proxyTypeId) {\r\n        return FORWARDING;\r\n    }\r\n\r\n    function setPinnedCode(address _pinnedCode) internal {\r\n        PINNED_CODE_POSITION.setStorageAddress(_pinnedCode);\r\n    }\r\n\r\n    function pinnedCode() internal view returns (address) {\r\n        return PINNED_CODE_POSITION.getStorageAddress();\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/factory/AppProxyFactory.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract AppProxyFactory {\r\n    event NewAppProxy(address proxy, bool isUpgradeable, bytes32 appId);\r\n\r\n    /**\r\n    * @notice Create a new upgradeable app instance on `_kernel` with identifier `_appId`\r\n    * @param _kernel App's Kernel reference\r\n    * @param _appId Identifier for app\r\n    * @return AppProxyUpgradeable\r\n    */\r\n    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\r\n        return newAppProxy(_kernel, _appId, new bytes(0));\r\n    }\r\n\r\n    /**\r\n    * @notice Create a new upgradeable app instance on `_kernel` with identifier `_appId` and initialization payload `_initializePayload`\r\n    * @param _kernel App's Kernel reference\r\n    * @param _appId Identifier for app\r\n    * @return AppProxyUpgradeable\r\n    */\r\n    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\r\n        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\r\n        emit NewAppProxy(address(proxy), true, _appId);\r\n        return proxy;\r\n    }\r\n\r\n    /**\r\n    * @notice Create a new pinned app instance on `_kernel` with identifier `_appId`\r\n    * @param _kernel App's Kernel reference\r\n    * @param _appId Identifier for app\r\n    * @return AppProxyPinned\r\n    */\r\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\r\n        return newAppProxyPinned(_kernel, _appId, new bytes(0));\r\n    }\r\n\r\n    /**\r\n    * @notice Create a new pinned app instance on `_kernel` with identifier `_appId` and initialization payload `_initializePayload`\r\n    * @param _kernel App's Kernel reference\r\n    * @param _appId Identifier for app\r\n    * @param _initializePayload Proxy initialization payload\r\n    * @return AppProxyPinned\r\n    */\r\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\r\n        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\r\n        emit NewAppProxy(address(proxy), false, _appId);\r\n        return proxy;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/kernel/Kernel.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// solium-disable-next-line max-len\r\ncontract Kernel is IKernel, KernelStorage, KernelAppIds, KernelNamespaceConstants, Petrifiable, IsContract, VaultRecoverable, AppProxyFactory, ACLSyntaxSugar {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 public constant APP_MANAGER_ROLE = keccak256(\"APP_MANAGER_ROLE\");\r\n    */\r\n    bytes32 public constant APP_MANAGER_ROLE = 0xb6d92708f3d4817afc106147d969e229ced5c46e65e0a5002a0d391287762bd0;\r\n\r\n    string private constant ERROR_APP_NOT_CONTRACT = \"KERNEL_APP_NOT_CONTRACT\";\r\n    string private constant ERROR_INVALID_APP_CHANGE = \"KERNEL_INVALID_APP_CHANGE\";\r\n    string private constant ERROR_AUTH_FAILED = \"KERNEL_AUTH_FAILED\";\r\n\r\n    /**\r\n    * @dev Constructor that allows the deployer to choose if the base instance should be petrified immediately.\r\n    * @param _shouldPetrify Immediately petrify this instance so that it can never be initialized\r\n    */\r\n    constructor(bool _shouldPetrify) public {\r\n        if (_shouldPetrify) {\r\n            petrify();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\r\n    * @notice Initialize this kernel instance along with its ACL and set `_permissionsCreator` as the entity that can create other permissions\r\n    * @param _baseAcl Address of base ACL app\r\n    * @param _permissionsCreator Entity that will be given permission over createPermission\r\n    */\r\n    function initialize(IACL _baseAcl, address _permissionsCreator) public onlyInit {\r\n        initialized();\r\n\r\n        // Set ACL base\r\n        _setApp(KERNEL_APP_BASES_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID, _baseAcl);\r\n\r\n        // Create ACL instance and attach it as the default ACL app\r\n        IACL acl = IACL(newAppProxy(this, KERNEL_DEFAULT_ACL_APP_ID));\r\n        acl.initialize(_permissionsCreator);\r\n        _setApp(KERNEL_APP_ADDR_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID, acl);\r\n\r\n        recoveryVaultAppId = KERNEL_DEFAULT_VAULT_APP_ID;\r\n    }\r\n\r\n    /**\r\n    * @dev Create a new instance of an app linked to this kernel\r\n    * @notice Create a new upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`\r\n    * @param _appId Identifier for app\r\n    * @param _appBase Address of the app's base implementation\r\n    * @return AppProxy instance\r\n    */\r\n    function newAppInstance(bytes32 _appId, address _appBase)\r\n        public\r\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\r\n        returns (ERCProxy appProxy)\r\n    {\r\n        return newAppInstance(_appId, _appBase, new bytes(0), false);\r\n    }\r\n\r\n    /**\r\n    * @dev Create a new instance of an app linked to this kernel and set its base\r\n    *      implementation if it was not already set\r\n    * @notice Create a new upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`. `_setDefault ? 'Also sets it as the default app instance.':''`\r\n    * @param _appId Identifier for app\r\n    * @param _appBase Address of the app's base implementation\r\n    * @param _initializePayload Payload for call made by the proxy during its construction to initialize\r\n    * @param _setDefault Whether the app proxy app is the default one.\r\n    *        Useful when the Kernel needs to know of an instance of a particular app,\r\n    *        like Vault for escape hatch mechanism.\r\n    * @return AppProxy instance\r\n    */\r\n    function newAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)\r\n        public\r\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\r\n        returns (ERCProxy appProxy)\r\n    {\r\n        _setAppIfNew(KERNEL_APP_BASES_NAMESPACE, _appId, _appBase);\r\n        appProxy = newAppProxy(this, _appId, _initializePayload);\r\n        // By calling setApp directly and not the internal functions, we make sure the params are checked\r\n        // and it will only succeed if sender has permissions to set something to the namespace.\r\n        if (_setDefault) {\r\n            setApp(KERNEL_APP_ADDR_NAMESPACE, _appId, appProxy);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Create a new pinned instance of an app linked to this kernel\r\n    * @notice Create a new non-upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`.\r\n    * @param _appId Identifier for app\r\n    * @param _appBase Address of the app's base implementation\r\n    * @return AppProxy instance\r\n    */\r\n    function newPinnedAppInstance(bytes32 _appId, address _appBase)\r\n        public\r\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\r\n        returns (ERCProxy appProxy)\r\n    {\r\n        return newPinnedAppInstance(_appId, _appBase, new bytes(0), false);\r\n    }\r\n\r\n    /**\r\n    * @dev Create a new pinned instance of an app linked to this kernel and set\r\n    *      its base implementation if it was not already set\r\n    * @notice Create a new non-upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`. `_setDefault ? 'Also sets it as the default app instance.':''`\r\n    * @param _appId Identifier for app\r\n    * @param _appBase Address of the app's base implementation\r\n    * @param _initializePayload Payload for call made by the proxy during its construction to initialize\r\n    * @param _setDefault Whether the app proxy app is the default one.\r\n    *        Useful when the Kernel needs to know of an instance of a particular app,\r\n    *        like Vault for escape hatch mechanism.\r\n    * @return AppProxy instance\r\n    */\r\n    function newPinnedAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)\r\n        public\r\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\r\n        returns (ERCProxy appProxy)\r\n    {\r\n        _setAppIfNew(KERNEL_APP_BASES_NAMESPACE, _appId, _appBase);\r\n        appProxy = newAppProxyPinned(this, _appId, _initializePayload);\r\n        // By calling setApp directly and not the internal functions, we make sure the params are checked\r\n        // and it will only succeed if sender has permissions to set something to the namespace.\r\n        if (_setDefault) {\r\n            setApp(KERNEL_APP_ADDR_NAMESPACE, _appId, appProxy);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Set the resolving address of an app instance or base implementation\r\n    * @notice Set the resolving address of `_appId` in namespace `_namespace` to `_app`\r\n    * @param _namespace App namespace to use\r\n    * @param _appId Identifier for app\r\n    * @param _app Address of the app instance or base implementation\r\n    * @return ID of app\r\n    */\r\n    function setApp(bytes32 _namespace, bytes32 _appId, address _app)\r\n        public\r\n        auth(APP_MANAGER_ROLE, arr(_namespace, _appId))\r\n    {\r\n        _setApp(_namespace, _appId, _app);\r\n    }\r\n\r\n    /**\r\n    * @dev Set the default vault id for the escape hatch mechanism\r\n    * @param _recoveryVaultAppId Identifier of the recovery vault app\r\n    */\r\n    function setRecoveryVaultAppId(bytes32 _recoveryVaultAppId)\r\n        public\r\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_ADDR_NAMESPACE, _recoveryVaultAppId))\r\n    {\r\n        recoveryVaultAppId = _recoveryVaultAppId;\r\n    }\r\n\r\n    // External access to default app id and namespace constants to mimic default getters for constants\r\n    /* solium-disable function-order, mixedcase */\r\n    function CORE_NAMESPACE() external pure returns (bytes32) { return KERNEL_CORE_NAMESPACE; }\r\n    function APP_BASES_NAMESPACE() external pure returns (bytes32) { return KERNEL_APP_BASES_NAMESPACE; }\r\n    function APP_ADDR_NAMESPACE() external pure returns (bytes32) { return KERNEL_APP_ADDR_NAMESPACE; }\r\n    function KERNEL_APP_ID() external pure returns (bytes32) { return KERNEL_CORE_APP_ID; }\r\n    function DEFAULT_ACL_APP_ID() external pure returns (bytes32) { return KERNEL_DEFAULT_ACL_APP_ID; }\r\n    /* solium-enable function-order, mixedcase */\r\n\r\n    /**\r\n    * @dev Get the address of an app instance or base implementation\r\n    * @param _namespace App namespace to use\r\n    * @param _appId Identifier for app\r\n    * @return Address of the app\r\n    */\r\n    function getApp(bytes32 _namespace, bytes32 _appId) public view returns (address) {\r\n        return apps[_namespace][_appId];\r\n    }\r\n\r\n    /**\r\n    * @dev Get the address of the recovery Vault instance (to recover funds)\r\n    * @return Address of the Vault\r\n    */\r\n    function getRecoveryVault() public view returns (address) {\r\n        return apps[KERNEL_APP_ADDR_NAMESPACE][recoveryVaultAppId];\r\n    }\r\n\r\n    /**\r\n    * @dev Get the installed ACL app\r\n    * @return ACL app\r\n    */\r\n    function acl() public view returns (IACL) {\r\n        return IACL(getApp(KERNEL_APP_ADDR_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID));\r\n    }\r\n\r\n    /**\r\n    * @dev Function called by apps to check ACL on kernel or to check permission status\r\n    * @param _who Sender of the original call\r\n    * @param _where Address of the app\r\n    * @param _what Identifier for a group of actions in app\r\n    * @param _how Extra data for ACL auth\r\n    * @return Boolean indicating whether the ACL allows the role or not.\r\n    *         Always returns false if the kernel hasn't been initialized yet.\r\n    */\r\n    function hasPermission(address _who, address _where, bytes32 _what, bytes _how) public view returns (bool) {\r\n        IACL defaultAcl = acl();\r\n        return address(defaultAcl) != address(0) && // Poor man's initialization check (saves gas)\r\n            defaultAcl.hasPermission(_who, _where, _what, _how);\r\n    }\r\n\r\n    function _setApp(bytes32 _namespace, bytes32 _appId, address _app) internal {\r\n        require(isContract(_app), ERROR_APP_NOT_CONTRACT);\r\n        apps[_namespace][_appId] = _app;\r\n        emit SetApp(_namespace, _appId, _app);\r\n    }\r\n\r\n    function _setAppIfNew(bytes32 _namespace, bytes32 _appId, address _app) internal {\r\n        address app = getApp(_namespace, _appId);\r\n        if (app != address(0)) {\r\n            // The only way to set an app is if it passes the isContract check, so no need to check it again\r\n            require(app == _app, ERROR_INVALID_APP_CHANGE);\r\n        } else {\r\n            _setApp(_namespace, _appId, _app);\r\n        }\r\n    }\r\n\r\n    modifier auth(bytes32 _role, uint256[] memory _params) {\r\n        require(\r\n            hasPermission(msg.sender, address(this), _role, ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)),\r\n            ERROR_AUTH_FAILED\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/kernel/KernelProxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract KernelProxy is IKernelEvents, KernelStorage, KernelAppIds, KernelNamespaceConstants, IsContract, DepositableDelegateProxy {\r\n    /**\r\n    * @dev KernelProxy is a proxy contract to a kernel implementation. The implementation\r\n    *      can update the reference, which effectively upgrades the contract\r\n    * @param _kernelImpl Address of the contract used as implementation for kernel\r\n    */\r\n    constructor(IKernel _kernelImpl) public {\r\n        require(isContract(address(_kernelImpl)));\r\n        apps[KERNEL_CORE_NAMESPACE][KERNEL_CORE_APP_ID] = _kernelImpl;\r\n\r\n        // Note that emitting this event is important for verifying that a KernelProxy instance\r\n        // was never upgraded to a malicious Kernel logic contract over its lifespan.\r\n        // This starts the \"chain of trust\", that can be followed through later SetApp() events\r\n        // emitted during kernel upgrades.\r\n        emit SetApp(KERNEL_CORE_NAMESPACE, KERNEL_CORE_APP_ID, _kernelImpl);\r\n    }\r\n\r\n    /**\r\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\r\n     */\r\n    function proxyType() public pure returns (uint256 proxyTypeId) {\r\n        return UPGRADEABLE;\r\n    }\r\n\r\n    /**\r\n    * @dev ERC897, the address the proxy would delegate calls to\r\n    */\r\n    function implementation() public view returns (address) {\r\n        return apps[KERNEL_CORE_NAMESPACE][KERNEL_CORE_APP_ID];\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/evmscript/ScriptHelpers.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary ScriptHelpers {\r\n    function getSpecId(bytes _script) internal pure returns (uint32) {\r\n        return uint32At(_script, 0);\r\n    }\r\n\r\n    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\r\n        assembly {\r\n            result := mload(add(_data, add(0x20, _location)))\r\n        }\r\n    }\r\n\r\n    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\r\n        uint256 word = uint256At(_data, _location);\r\n\r\n        assembly {\r\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\r\n            0x1000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\r\n        uint256 word = uint256At(_data, _location);\r\n\r\n        assembly {\r\n            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\r\n            0x100000000000000000000000000000000000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\r\n        assembly {\r\n            result := add(_data, add(0x20, _location))\r\n        }\r\n    }\r\n\r\n    function toBytes(bytes4 _sig) internal pure returns (bytes) {\r\n        bytes memory payload = new bytes(4);\r\n        assembly { mstore(add(payload, 0x20), _sig) }\r\n        return payload;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/evmscript/EVMScriptRegistry.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* solium-disable function-order */\r\n// Allow public initialize() to be first\r\ncontract EVMScriptRegistry is IEVMScriptRegistry, EVMScriptRegistryConstants, AragonApp {\r\n    using ScriptHelpers for bytes;\r\n\r\n    /* Hardcoded constants to save gas\r\n    bytes32 public constant REGISTRY_ADD_EXECUTOR_ROLE = keccak256(\"REGISTRY_ADD_EXECUTOR_ROLE\");\r\n    bytes32 public constant REGISTRY_MANAGER_ROLE = keccak256(\"REGISTRY_MANAGER_ROLE\");\r\n    */\r\n    bytes32 public constant REGISTRY_ADD_EXECUTOR_ROLE = 0xc4e90f38eea8c4212a009ca7b8947943ba4d4a58d19b683417f65291d1cd9ed2;\r\n    // WARN: Manager can censor all votes and the like happening in an org\r\n    bytes32 public constant REGISTRY_MANAGER_ROLE = 0xf7a450ef335e1892cb42c8ca72e7242359d7711924b75db5717410da3f614aa3;\r\n\r\n    uint256 internal constant SCRIPT_START_LOCATION = 4;\r\n\r\n    string private constant ERROR_INEXISTENT_EXECUTOR = \"EVMREG_INEXISTENT_EXECUTOR\";\r\n    string private constant ERROR_EXECUTOR_ENABLED = \"EVMREG_EXECUTOR_ENABLED\";\r\n    string private constant ERROR_EXECUTOR_DISABLED = \"EVMREG_EXECUTOR_DISABLED\";\r\n    string private constant ERROR_SCRIPT_LENGTH_TOO_SHORT = \"EVMREG_SCRIPT_LENGTH_TOO_SHORT\";\r\n\r\n    struct ExecutorEntry {\r\n        IEVMScriptExecutor executor;\r\n        bool enabled;\r\n    }\r\n\r\n    uint256 private executorsNextIndex;\r\n    mapping (uint256 => ExecutorEntry) public executors;\r\n\r\n    event EnableExecutor(uint256 indexed executorId, address indexed executorAddress);\r\n    event DisableExecutor(uint256 indexed executorId, address indexed executorAddress);\r\n\r\n    modifier executorExists(uint256 _executorId) {\r\n        require(_executorId > 0 && _executorId < executorsNextIndex, ERROR_INEXISTENT_EXECUTOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Initialize the registry\r\n    */\r\n    function initialize() public onlyInit {\r\n        initialized();\r\n        // Create empty record to begin executor IDs at 1\r\n        executorsNextIndex = 1;\r\n    }\r\n\r\n    /**\r\n    * @notice Add a new script executor with address `_executor` to the registry\r\n    * @param _executor Address of the IEVMScriptExecutor that will be added to the registry\r\n    * @return id Identifier of the executor in the registry\r\n    */\r\n    function addScriptExecutor(IEVMScriptExecutor _executor) external auth(REGISTRY_ADD_EXECUTOR_ROLE) returns (uint256 id) {\r\n        uint256 executorId = executorsNextIndex++;\r\n        executors[executorId] = ExecutorEntry(_executor, true);\r\n        emit EnableExecutor(executorId, _executor);\r\n        return executorId;\r\n    }\r\n\r\n    /**\r\n    * @notice Disable script executor with ID `_executorId`\r\n    * @param _executorId Identifier of the executor in the registry\r\n    */\r\n    function disableScriptExecutor(uint256 _executorId)\r\n        external\r\n        authP(REGISTRY_MANAGER_ROLE, arr(_executorId))\r\n    {\r\n        // Note that we don't need to check for an executor's existence in this case, as only\r\n        // existing executors can be enabled\r\n        ExecutorEntry storage executorEntry = executors[_executorId];\r\n        require(executorEntry.enabled, ERROR_EXECUTOR_DISABLED);\r\n        executorEntry.enabled = false;\r\n        emit DisableExecutor(_executorId, executorEntry.executor);\r\n    }\r\n\r\n    /**\r\n    * @notice Enable script executor with ID `_executorId`\r\n    * @param _executorId Identifier of the executor in the registry\r\n    */\r\n    function enableScriptExecutor(uint256 _executorId)\r\n        external\r\n        authP(REGISTRY_MANAGER_ROLE, arr(_executorId))\r\n        executorExists(_executorId)\r\n    {\r\n        ExecutorEntry storage executorEntry = executors[_executorId];\r\n        require(!executorEntry.enabled, ERROR_EXECUTOR_ENABLED);\r\n        executorEntry.enabled = true;\r\n        emit EnableExecutor(_executorId, executorEntry.executor);\r\n    }\r\n\r\n    /**\r\n    * @dev Get the script executor that can execute a particular script based on its first 4 bytes\r\n    * @param _script EVMScript being inspected\r\n    */\r\n    function getScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\r\n        require(_script.length >= SCRIPT_START_LOCATION, ERROR_SCRIPT_LENGTH_TOO_SHORT);\r\n        uint256 id = _script.getSpecId();\r\n\r\n        // Note that we don't need to check for an executor's existence in this case, as only\r\n        // existing executors can be enabled\r\n        ExecutorEntry storage entry = executors[id];\r\n        return entry.enabled ? entry.executor : IEVMScriptExecutor(0);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/evmscript/executors/BaseEVMScriptExecutor.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\ncontract BaseEVMScriptExecutor is IEVMScriptExecutor, Autopetrified {\r\n    uint256 internal constant SCRIPT_START_LOCATION = 4;\r\n}\r\n\r\n// File: @aragon/os/contracts/evmscript/executors/CallsScript.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n// Inspired by https://github.com/reverendus/tx-manager\r\n\r\n\r\n\r\n\r\ncontract CallsScript is BaseEVMScriptExecutor {\r\n    using ScriptHelpers for bytes;\r\n\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant EXECUTOR_TYPE = keccak256(\"CALLS_SCRIPT\");\r\n    */\r\n    bytes32 internal constant EXECUTOR_TYPE = 0x2dc858a00f3e417be1394b87c07158e989ec681ce8cc68a9093680ac1a870302;\r\n\r\n    string private constant ERROR_BLACKLISTED_CALL = \"EVMCALLS_BLACKLISTED_CALL\";\r\n    string private constant ERROR_INVALID_LENGTH = \"EVMCALLS_INVALID_LENGTH\";\r\n\r\n    /* This is manually crafted in assembly\r\n    string private constant ERROR_CALL_REVERTED = \"EVMCALLS_CALL_REVERTED\";\r\n    */\r\n\r\n    event LogScriptCall(address indexed sender, address indexed src, address indexed dst);\r\n\r\n    /**\r\n    * @notice Executes a number of call scripts\r\n    * @param _script [ specId (uint32) ] many calls with this structure ->\r\n    *    [ to (address: 20 bytes) ] [ calldataLength (uint32: 4 bytes) ] [ calldata (calldataLength bytes) ]\r\n    * @param _blacklist Addresses the script cannot call to, or will revert.\r\n    * @return Always returns empty byte array\r\n    */\r\n    function execScript(bytes _script, bytes, address[] _blacklist) external isInitialized returns (bytes) {\r\n        uint256 location = SCRIPT_START_LOCATION; // first 32 bits are spec id\r\n        while (location < _script.length) {\r\n            // Check there's at least address + calldataLength available\r\n            require(_script.length - location >= 0x18, ERROR_INVALID_LENGTH);\r\n\r\n            address contractAddress = _script.addressAt(location);\r\n            // Check address being called is not blacklist\r\n            for (uint256 i = 0; i < _blacklist.length; i++) {\r\n                require(contractAddress != _blacklist[i], ERROR_BLACKLISTED_CALL);\r\n            }\r\n\r\n            // logged before execution to ensure event ordering in receipt\r\n            // if failed entire execution is reverted regardless\r\n            emit LogScriptCall(msg.sender, address(this), contractAddress);\r\n\r\n            uint256 calldataLength = uint256(_script.uint32At(location + 0x14));\r\n            uint256 startOffset = location + 0x14 + 0x04;\r\n            uint256 calldataStart = _script.locationOf(startOffset);\r\n\r\n            // compute end of script / next location\r\n            location = startOffset + calldataLength;\r\n            require(location <= _script.length, ERROR_INVALID_LENGTH);\r\n\r\n            bool success;\r\n            assembly {\r\n                success := call(\r\n                    sub(gas, 5000),       // forward gas left - 5000\r\n                    contractAddress,      // address\r\n                    0,                    // no value\r\n                    calldataStart,        // calldata start\r\n                    calldataLength,       // calldata length\r\n                    0,                    // don't write output\r\n                    0                     // don't write output\r\n                )\r\n\r\n                switch success\r\n                case 0 {\r\n                    let ptr := mload(0x40)\r\n\r\n                    switch returndatasize\r\n                    case 0 {\r\n                        // No error data was returned, revert with \"EVMCALLS_CALL_REVERTED\"\r\n                        // See remix: doing a `revert(\"EVMCALLS_CALL_REVERTED\")` always results in\r\n                        // this memory layout\r\n                        mstore(ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\r\n                        mstore(add(ptr, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\r\n                        mstore(add(ptr, 0x24), 0x0000000000000000000000000000000000000000000000000000000000000016) // reason length\r\n                        mstore(add(ptr, 0x44), 0x45564d43414c4c535f43414c4c5f524556455254454400000000000000000000) // reason\r\n\r\n                        revert(ptr, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\r\n                    }\r\n                    default {\r\n                        // Forward the full error data\r\n                        returndatacopy(ptr, 0, returndatasize)\r\n                        revert(ptr, returndatasize)\r\n                    }\r\n                }\r\n                default { }\r\n            }\r\n        }\r\n        // No need to allocate empty bytes for the return as this can only be called via an delegatecall\r\n        // (due to the isInitialized modifier)\r\n    }\r\n\r\n    function executorType() external pure returns (bytes32) {\r\n        return EXECUTOR_TYPE;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/factory/EVMScriptRegistryFactory.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract EVMScriptRegistryFactory is EVMScriptRegistryConstants {\r\n    EVMScriptRegistry public baseReg;\r\n    IEVMScriptExecutor public baseCallScript;\r\n\r\n    /**\r\n    * @notice Create a new EVMScriptRegistryFactory.\r\n    */\r\n    constructor() public {\r\n        baseReg = new EVMScriptRegistry();\r\n        baseCallScript = IEVMScriptExecutor(new CallsScript());\r\n    }\r\n\r\n    /**\r\n    * @notice Install a new pinned instance of EVMScriptRegistry on `_dao`.\r\n    * @param _dao Kernel\r\n    * @return Installed EVMScriptRegistry\r\n    */\r\n    function newEVMScriptRegistry(Kernel _dao) public returns (EVMScriptRegistry reg) {\r\n        bytes memory initPayload = abi.encodeWithSelector(reg.initialize.selector);\r\n        reg = EVMScriptRegistry(_dao.newPinnedAppInstance(EVMSCRIPT_REGISTRY_APP_ID, baseReg, initPayload, true));\r\n\r\n        ACL acl = ACL(_dao.acl());\r\n\r\n        acl.createPermission(this, reg, reg.REGISTRY_ADD_EXECUTOR_ROLE(), this);\r\n\r\n        reg.addScriptExecutor(baseCallScript);     // spec 1 = CallsScript\r\n\r\n        // Clean up the permissions\r\n        acl.revokePermission(this, reg, reg.REGISTRY_ADD_EXECUTOR_ROLE());\r\n        acl.removePermissionManager(reg, reg.REGISTRY_ADD_EXECUTOR_ROLE());\r\n\r\n        return reg;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/factory/DAOFactory.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DAOFactory {\r\n    IKernel public baseKernel;\r\n    IACL public baseACL;\r\n    EVMScriptRegistryFactory public regFactory;\r\n\r\n    event DeployDAO(address dao);\r\n    event DeployEVMScriptRegistry(address reg);\r\n\r\n    /**\r\n    * @notice Create a new DAOFactory, creating DAOs with Kernels proxied to `_baseKernel`, ACLs proxied to `_baseACL`, and new EVMScriptRegistries created from `_regFactory`.\r\n    * @param _baseKernel Base Kernel\r\n    * @param _baseACL Base ACL\r\n    * @param _regFactory EVMScriptRegistry factory\r\n    */\r\n    constructor(IKernel _baseKernel, IACL _baseACL, EVMScriptRegistryFactory _regFactory) public {\r\n        // No need to init as it cannot be killed by devops199\r\n        if (address(_regFactory) != address(0)) {\r\n            regFactory = _regFactory;\r\n        }\r\n\r\n        baseKernel = _baseKernel;\r\n        baseACL = _baseACL;\r\n    }\r\n\r\n    /**\r\n    * @notice Create a new DAO with `_root` set as the initial admin\r\n    * @param _root Address that will be granted control to setup DAO permissions\r\n    * @return Newly created DAO\r\n    */\r\n    function newDAO(address _root) public returns (Kernel) {\r\n        Kernel dao = Kernel(new KernelProxy(baseKernel));\r\n\r\n        if (address(regFactory) == address(0)) {\r\n            dao.initialize(baseACL, _root);\r\n        } else {\r\n            dao.initialize(baseACL, this);\r\n\r\n            ACL acl = ACL(dao.acl());\r\n            bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\r\n            bytes32 appManagerRole = dao.APP_MANAGER_ROLE();\r\n\r\n            acl.grantPermission(regFactory, acl, permRole);\r\n\r\n            acl.createPermission(regFactory, dao, appManagerRole, this);\r\n\r\n            EVMScriptRegistry reg = regFactory.newEVMScriptRegistry(dao);\r\n            emit DeployEVMScriptRegistry(address(reg));\r\n\r\n            // Clean up permissions\r\n            // First, completely reset the APP_MANAGER_ROLE\r\n            acl.revokePermission(regFactory, dao, appManagerRole);\r\n            acl.removePermissionManager(dao, appManagerRole);\r\n\r\n            // Then, make root the only holder and manager of CREATE_PERMISSIONS_ROLE\r\n            acl.revokePermission(regFactory, acl, permRole);\r\n            acl.revokePermission(this, acl, permRole);\r\n            acl.grantPermission(_root, acl, permRole);\r\n            acl.setPermissionManager(_root, acl, permRole);\r\n        }\r\n\r\n        emit DeployDAO(address(dao));\r\n\r\n        return dao;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/lib/ens/AbstractENS.sol\r\n\r\n// See https://github.com/ensdomains/ens/blob/7e377df83f/contracts/AbstractENS.sol\r\n\r\npragma solidity ^0.4.15;\r\n\r\n\r\ninterface AbstractENS {\r\n    function owner(bytes32 _node) public constant returns (address);\r\n    function resolver(bytes32 _node) public constant returns (address);\r\n    function ttl(bytes32 _node) public constant returns (uint64);\r\n    function setOwner(bytes32 _node, address _owner) public;\r\n    function setSubnodeOwner(bytes32 _node, bytes32 label, address _owner) public;\r\n    function setResolver(bytes32 _node, address _resolver) public;\r\n    function setTTL(bytes32 _node, uint64 _ttl) public;\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed _node, bytes32 indexed _label, address _owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed _node, address _owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed _node, address _resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed _node, uint64 _ttl);\r\n}\r\n\r\n// File: @aragon/os/contracts/lib/ens/ENS.sol\r\n\r\n// See https://github.com/ensdomains/ens/blob/7e377df83f/contracts/ENS.sol\r\n\r\npragma solidity ^0.4.0;\r\n\r\n\r\n/**\r\n * The ENS registry contract.\r\n */\r\ncontract ENS is AbstractENS {\r\n    struct Record {\r\n        address owner;\r\n        address resolver;\r\n        uint64 ttl;\r\n    }\r\n\r\n    mapping(bytes32=>Record) records;\r\n\r\n    // Permits modifications only by the owner of the specified node.\r\n    modifier only_owner(bytes32 node) {\r\n        if (records[node].owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructs a new ENS registrar.\r\n     */\r\n    function ENS() public {\r\n        records[0].owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Returns the address that owns the specified node.\r\n     */\r\n    function owner(bytes32 node) public constant returns (address) {\r\n        return records[node].owner;\r\n    }\r\n\r\n    /**\r\n     * Returns the address of the resolver for the specified node.\r\n     */\r\n    function resolver(bytes32 node) public constant returns (address) {\r\n        return records[node].resolver;\r\n    }\r\n\r\n    /**\r\n     * Returns the TTL of a node, and any records associated with it.\r\n     */\r\n    function ttl(bytes32 node) public constant returns (uint64) {\r\n        return records[node].ttl;\r\n    }\r\n\r\n    /**\r\n     * Transfers ownership of a node to a new address. May only be called by the current\r\n     * owner of the node.\r\n     * @param node The node to transfer ownership of.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setOwner(bytes32 node, address owner) only_owner(node) public {\r\n        Transfer(node, owner);\r\n        records[node].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * Transfers ownership of a subnode keccak256(node, label) to a new address. May only be\r\n     * called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) only_owner(node) public {\r\n        var subnode = keccak256(node, label);\r\n        NewOwner(node, label, owner);\r\n        records[subnode].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolver address for the specified node.\r\n     * @param node The node to update.\r\n     * @param resolver The address of the resolver.\r\n     */\r\n    function setResolver(bytes32 node, address resolver) only_owner(node) public {\r\n        NewResolver(node, resolver);\r\n        records[node].resolver = resolver;\r\n    }\r\n\r\n    /**\r\n     * Sets the TTL for the specified node.\r\n     * @param node The node to update.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setTTL(bytes32 node, uint64 ttl) only_owner(node) public {\r\n        NewTTL(node, ttl);\r\n        records[node].ttl = ttl;\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/lib/ens/PublicResolver.sol\r\n\r\n// See https://github.com/ensdomains/ens/blob/7e377df83f/contracts/PublicResolver.sol\r\n\r\npragma solidity ^0.4.0;\r\n\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract PublicResolver {\r\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\r\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\r\n    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\r\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\r\n    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\r\n    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\r\n    event NameChanged(bytes32 indexed node, string name);\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    struct Record {\r\n        address addr;\r\n        bytes32 content;\r\n        string name;\r\n        PublicKey pubkey;\r\n        mapping(string=>string) text;\r\n        mapping(uint256=>bytes) abis;\r\n    }\r\n\r\n    AbstractENS ens;\r\n    mapping(bytes32=>Record) records;\r\n\r\n    modifier only_owner(bytes32 node) {\r\n        if (ens.owner(node) != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The ENS registrar contract.\r\n     */\r\n    function PublicResolver(AbstractENS ensAddr) public {\r\n        ens = ensAddr;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID ||\r\n               interfaceID == CONTENT_INTERFACE_ID ||\r\n               interfaceID == NAME_INTERFACE_ID ||\r\n               interfaceID == ABI_INTERFACE_ID ||\r\n               interfaceID == PUBKEY_INTERFACE_ID ||\r\n               interfaceID == TEXT_INTERFACE_ID ||\r\n               interfaceID == INTERFACE_META_ID;\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public constant returns (address ret) {\r\n        ret = records[node].addr;\r\n    }\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) only_owner(node) public {\r\n        records[node].addr = addr;\r\n        AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Returns the content hash associated with an ENS node.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The ENS node to query.\r\n     * @return The associated content hash.\r\n     */\r\n    function content(bytes32 node) public constant returns (bytes32 ret) {\r\n        ret = records[node].content;\r\n    }\r\n\r\n    /**\r\n     * Sets the content hash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The node to update.\r\n     * @param hash The content hash to set\r\n     */\r\n    function setContent(bytes32 node, bytes32 hash) only_owner(node) public {\r\n        records[node].content = hash;\r\n        ContentChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) public constant returns (string ret) {\r\n        ret = records[node].name;\r\n    }\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string name) only_owner(node) public {\r\n        records[node].name = name;\r\n        NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) public constant returns (uint256 contentType, bytes data) {\r\n        var record = records[node];\r\n        for(contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\r\n                data = record.abis[contentType];\r\n                return;\r\n            }\r\n        }\r\n        contentType = 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes data) only_owner(node) public {\r\n        // Content types must be powers of 2\r\n        if (((contentType - 1) & contentType) != 0) throw;\r\n\r\n        records[node].abis[contentType] = data;\r\n        ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) public constant returns (bytes32 x, bytes32 y) {\r\n        return (records[node].pubkey.x, records[node].pubkey.y);\r\n    }\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) only_owner(node) public {\r\n        records[node].pubkey = PublicKey(x, y);\r\n        PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string key) public constant returns (string ret) {\r\n        ret = records[node].text[key];\r\n    }\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string key, string value) only_owner(node) public {\r\n        records[node].text[key] = value;\r\n        TextChanged(node, key, key);\r\n    }\r\n}\r\n\r\n// File: @autarklabs/apps-whitelist-oracle/contracts/WhitelistOracle.sol\r\n\r\n/*\r\n * SPDX-License-Identifier:    GPL-3.0-or-later\r\n */\r\n\r\n/* solium-disable function-order */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\ninterface ITransferOracle {\r\n    function getTransferability(address _from, address _to, uint256 _amount) external returns (bool);\r\n}\r\n\r\n\r\ncontract WhitelistOracle is AragonApp, ITransferOracle {\r\n\r\n    /*\r\n    bytes32 public constant ADD_SENDER_ROLE = keccak256(\"ADD_SENDER_ROLE\");\r\n    bytes32 public constant REMOVE_SENDER_ROLE = keccak256(\"REMOVE_SENDER_ROLE\");\r\n    */\r\n\r\n    bytes32 public constant ADD_SENDER_ROLE = 0x649896fce4266201ed0200f1f18d2316c4c0be48c949b18cccd5ef15621249e3;\r\n    bytes32 public constant REMOVE_SENDER_ROLE = 0x9d7a040f5c6540f643d8a175f70736671ffabd35f3de2e4176cfcbbe9cd71acb;\r\n\r\n    string private constant ERROR_SENDER_ALREADY_ADDED = \"WO_ERROR_SENDER_ALREADY_ADDED\";\r\n    string private constant ERROR_SENDER_NOT_EXIST = \"WO_ERROR_SENDER_NOT_EXIST\";\r\n    event ValidSenderAdded(address _sender);\r\n    event ValidSenderRemoved(address _sender);\r\n\r\n    mapping(address => bool) validSender;\r\n\r\n    function initialize(address[] _senders) external onlyInit {\r\n        initialized();\r\n        for (uint256 i = 0; i < _senders.length; i++) {\r\n            validSender[_senders[i]] = true;\r\n        }\r\n    }\r\n\r\n    function addSender(address _sender) external auth(ADD_SENDER_ROLE) {\r\n        require(!validSender[_sender], ERROR_SENDER_ALREADY_ADDED);\r\n        validSender[_sender] = true;\r\n        emit ValidSenderAdded(_sender);\r\n    }\r\n\r\n    function removeSender(address _sender) external auth(REMOVE_SENDER_ROLE) {\r\n        require(validSender[_sender], ERROR_SENDER_NOT_EXIST);\r\n        validSender[_sender] = false;\r\n        emit ValidSenderRemoved(_sender);\r\n    }\r\n\r\n    function getTransferability(address _from, address /*_to*/, uint256 /*_amount*/) external returns (bool) {\r\n        return validSender[_from];\r\n    }\r\n\r\n}\r\n\r\n// File: @autarklabs/apps-token-manager-custom/contracts/TokenManager.sol\r\n\r\n/*\r\n * SPDX-License-Identifier:    GPL-3.0-or-later\r\n */\r\n\r\n/* solium-disable function-order */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenManager is ITokenController, IForwarder, AragonApp {\r\n    using SafeMath for uint256;\r\n    /*\r\n    bytes32 public constant MINT_ROLE = keccak256(\"MINT_ROLE\");\r\n    bytes32 public constant ISSUE_ROLE = keccak256(\"ISSUE_ROLE\");\r\n    bytes32 public constant ASSIGN_ROLE = keccak256(\"ASSIGN_ROLE\");\r\n    bytes32 public constant REVOKE_VESTINGS_ROLE = keccak256(\"REVOKE_VESTINGS_ROLE\");\r\n    bytes32 public constant BURN_ROLE = keccak256(\"BURN_ROLE\");\r\n    bytes32 public constant SET_ORACLE = keccak256(\"SET_ORACLE\");\r\n    */\r\n    bytes32 public constant MINT_ROLE = 0x154c00819833dac601ee5ddded6fda79d9d8b506b911b3dbd54cdb95fe6c3686;\r\n    bytes32 public constant ISSUE_ROLE = 0x2406f1e99f79cea012fb88c5c36566feaeefee0f4b98d3a376b49310222b53c4;\r\n    bytes32 public constant ASSIGN_ROLE = 0xf5a08927c847d7a29dc35e105208dbde5ce951392105d712761cc5d17440e2ff;\r\n    bytes32 public constant REVOKE_VESTINGS_ROLE = 0x95ffc68daedf1eb334cfcd22ee24a5eeb5a8e58aa40679f2ad247a84140f8d6e;\r\n    bytes32 public constant BURN_ROLE = 0xe97b137254058bd94f28d2f3eb79e2d34074ffb488d042e3bc958e0a57d2fa22;\r\n    bytes32 public constant SET_ORACLE = 0x11eba3f259e2be865238d718fd308257e3874ad4b3a642ea3af386a4eea190bd;\r\n\r\n    uint256 public constant MAX_VESTINGS_PER_ADDRESS = 50;\r\n\r\n    string private constant ERROR_CALLER_NOT_TOKEN = \"TM_CALLER_NOT_TOKEN\";\r\n    string private constant ERROR_NO_VESTING = \"TM_NO_VESTING\";\r\n    string private constant ERROR_TOKEN_CONTROLLER = \"TM_TOKEN_CONTROLLER\";\r\n    string private constant ERROR_MINT_RECEIVER_IS_TM = \"TM_MINT_RECEIVER_IS_TM\";\r\n    string private constant ERROR_VESTING_TO_TM = \"TM_VESTING_TO_TM\";\r\n    string private constant ERROR_TOO_MANY_VESTINGS = \"TM_TOO_MANY_VESTINGS\";\r\n    string private constant ERROR_WRONG_CLIFF_DATE = \"TM_WRONG_CLIFF_DATE\";\r\n    string private constant ERROR_VESTING_NOT_REVOKABLE = \"TM_VESTING_NOT_REVOKABLE\";\r\n    string private constant ERROR_REVOKE_TRANSFER_FROM_REVERTED = \"TM_REVOKE_TRANSFER_FROM_REVERTED\";\r\n    string private constant ERROR_CAN_NOT_FORWARD = \"TM_CAN_NOT_FORWARD\";\r\n    string private constant ERROR_BALANCE_INCREASE_NOT_ALLOWED = \"TM_BALANCE_INC_NOT_ALLOWED\";\r\n    string private constant ERROR_ASSIGN_TRANSFER_FROM_REVERTED = \"TM_ASSIGN_TRANSFER_FROM_REVERTED\";\r\n\r\n    struct TokenVesting {\r\n        uint256 amount;\r\n        uint64 start;\r\n        uint64 cliff;\r\n        uint64 vesting;\r\n        bool revokable;\r\n    }\r\n\r\n    // Note that we COMPLETELY trust this MiniMeToken to not be malicious for proper operation of this contract\r\n    MiniMeToken public token;\r\n    ITransferOracle public oracle;\r\n    uint256 public maxAccountTokens;\r\n\r\n    // We are mimicking an array in the inner mapping, we use a mapping instead to make app upgrade more graceful\r\n    mapping (address => mapping (uint256 => TokenVesting)) internal vestings;\r\n    mapping (address => uint256) public vestingsLengths;\r\n\r\n    // Other token specific events can be watched on the token address directly (avoids duplication)\r\n    event NewVesting(address indexed receiver, uint256 vestingId, uint256 amount);\r\n    event RevokeVesting(address indexed receiver, uint256 vestingId, uint256 nonVestedAmount);\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == address(token), ERROR_CALLER_NOT_TOKEN);\r\n        _;\r\n    }\r\n\r\n    modifier vestingExists(address _holder, uint256 _vestingId) {\r\n        require(_vestingId < vestingsLengths[_holder], ERROR_NO_VESTING);\r\n        require(vestings[_holder][_vestingId].amount != 0, ERROR_NO_VESTING);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Initialize Token Manager for `_token.symbol(): string`, whose tokens are `_transferable ? '' : 'not'` transferable`_maxAccountTokens > 0 ? ' and limited to a maximum of ' + @tokenAmount(_token, _maxAccountTokens, false) + ' per account' : ''`\r\n    * @param _token MiniMeToken address for the managed token (Token Manager instance must be already set as the token controller)\r\n    * @param _transferable whether the token can be transferred by holders\r\n    * @param _maxAccountTokens Maximum amount of tokens an account can have (0 for infinite tokens)\r\n    */\r\n    function initialize(\r\n        MiniMeToken _token,\r\n        bool _transferable,\r\n        uint256 _maxAccountTokens\r\n    )\r\n        external\r\n        onlyInit\r\n    {\r\n        initialized();\r\n\r\n        require(_token.controller() == address(this), ERROR_TOKEN_CONTROLLER);\r\n\r\n        token = _token;\r\n        maxAccountTokens = _maxAccountTokens == 0 ? uint256(-1) : _maxAccountTokens;\r\n\r\n        if (token.transfersEnabled() != _transferable) {\r\n            token.enableTransfers(_transferable);\r\n        }\r\n    }\r\n\r\n    function setOracle(address _oracle) external auth(SET_ORACLE) {\r\n        oracle = ITransferOracle(_oracle);\r\n    }\r\n\r\n    /**\r\n    * @notice Mint `@tokenAmount(self.token(): address, _amount, false)` tokens for `_receiver`\r\n    * @param _receiver The address receiving the tokens, cannot be the Token Manager itself (use `issue()` instead)\r\n    * @param _amount Number of tokens minted\r\n    */\r\n    function mint(address _receiver, uint256 _amount) external authP(MINT_ROLE, arr(_receiver, _amount)) {\r\n        require(_receiver != address(this), ERROR_MINT_RECEIVER_IS_TM);\r\n        _mint(_receiver, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Mint `@tokenAmount(self.token(): address, _amount, false)` tokens for the Token Manager\r\n    * @param _amount Number of tokens minted\r\n    */\r\n    function issue(uint256 _amount) external authP(ISSUE_ROLE, arr(_amount)) {\r\n        _mint(address(this), _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Assign `@tokenAmount(self.token(): address, _amount, false)` tokens to `_receiver` from the Token Manager's holdings\r\n    * @param _receiver The address receiving the tokens\r\n    * @param _amount Number of tokens transferred\r\n    */\r\n    function assign(address _receiver, uint256 _amount) external authP(ASSIGN_ROLE, arr(_receiver, _amount)) {\r\n        _assign(_receiver, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Burn `@tokenAmount(self.token(): address, _amount, false)` tokens from `_holder`\r\n    * @param _holder Holder of tokens being burned\r\n    * @param _amount Number of tokens being burned\r\n    */\r\n    function burn(address _holder, uint256 _amount) external authP(BURN_ROLE, arr(_holder, _amount)) {\r\n        // minime.destroyTokens() never returns false, only reverts on failure\r\n        token.destroyTokens(_holder, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Assign `@tokenAmount(self.token(): address, _amount, false)` tokens to `_receiver` from the Token Manager's holdings with a `_revokable : 'revokable' : ''` vesting starting at `@formatDate(_start)`, cliff at `@formatDate(_cliff)` (first portion of tokens transferable), and completed vesting at `@formatDate(_vested)` (all tokens transferable)\r\n    * @param _receiver The address receiving the tokens, cannot be Token Manager itself\r\n    * @param _amount Number of tokens vested\r\n    * @param _start Date the vesting calculations start\r\n    * @param _cliff Date when the initial portion of tokens are transferable\r\n    * @param _vested Date when all tokens are transferable\r\n    * @param _revokable Whether the vesting can be revoked by the Token Manager\r\n    */\r\n    function assignVested(\r\n        address _receiver,\r\n        uint256 _amount,\r\n        uint64 _start,\r\n        uint64 _cliff,\r\n        uint64 _vested,\r\n        bool _revokable\r\n    )\r\n        external\r\n        authP(ASSIGN_ROLE, arr(_receiver, _amount))\r\n        returns (uint256)\r\n    {\r\n        require(_receiver != address(this), ERROR_VESTING_TO_TM);\r\n        require(vestingsLengths[_receiver] < MAX_VESTINGS_PER_ADDRESS, ERROR_TOO_MANY_VESTINGS);\r\n        require(_start <= _cliff && _cliff <= _vested, ERROR_WRONG_CLIFF_DATE);\r\n\r\n        uint256 vestingId = vestingsLengths[_receiver]++;\r\n        vestings[_receiver][vestingId] = TokenVesting({\r\n            amount: _amount,\r\n            start: _start,\r\n            cliff: _cliff,\r\n            vesting: _vested,\r\n            revokable: _revokable\r\n        });\r\n\r\n        _assign(_receiver, _amount);\r\n\r\n        emit NewVesting(_receiver, vestingId, _amount);\r\n\r\n        return vestingId;\r\n    }\r\n\r\n    /**\r\n    * @notice Revoke vesting #`_vestingId` from `_holder`, returning unvested tokens to the Token Manager\r\n    * @param _holder Address whose vesting to revoke\r\n    * @param _vestingId Numeric id of the vesting\r\n    */\r\n    function revokeVesting(address _holder, uint256 _vestingId)\r\n        external\r\n        authP(REVOKE_VESTINGS_ROLE, arr(_holder))\r\n        vestingExists(_holder, _vestingId)\r\n    {\r\n        TokenVesting memory v = vestings[_holder][_vestingId];\r\n        require(v.revokable, ERROR_VESTING_NOT_REVOKABLE);\r\n\r\n        uint256 nonVested = _calculateNonVestedTokens(\r\n            v.amount,\r\n            getTimestamp(),\r\n            v.start,\r\n            v.cliff,\r\n            v.vesting\r\n        );\r\n\r\n        // To make vestingIds immutable over time, we just zero out the revoked vesting\r\n        // Clearing this out also allows the token transfer back to the Token Manager to succeed\r\n        delete vestings[_holder][_vestingId];\r\n\r\n        // transferFrom always works as controller\r\n        // onTransfer hook always allows if transferring to token controller\r\n        require(token.transferFrom(_holder, address(this), nonVested), ERROR_REVOKE_TRANSFER_FROM_REVERTED);\r\n\r\n        emit RevokeVesting(_holder, _vestingId, nonVested);\r\n    }\r\n\r\n    // ITokenController fns\r\n    // `onTransfer()`, `onApprove()`, and `proxyPayment()` are callbacks from the MiniMe token\r\n    // contract and are only meant to be called through the managed MiniMe token that gets assigned\r\n    // during initialization.\r\n\r\n    /*\r\n    * @dev Notifies the controller about a token transfer allowing the controller to decide whether\r\n    *      to allow it or react if desired (only callable from the token).\r\n    *      Initialization check is implicitly provided by `onlyToken()`.\r\n    * @param _from The origin of the transfer\r\n    * @param _to The destination of the transfer\r\n    * @param _amount The amount of the transfer\r\n    * @return False if the controller does not authorize the transfer\r\n    */\r\n    function onTransfer(address _from, address _to, uint256 _amount) external onlyToken returns (bool) {\r\n        bool transferability = true;\r\n        if (_from != address(this) && address(oracle) != address(0x0)) {\r\n            transferability = oracle.getTransferability(_from, _to, _amount);\r\n        }\r\n        bool balanceIncreaseAllowed = _isBalanceIncreaseAllowed(_to, _amount) && _transferableBalance(_from, getTimestamp()) >= _amount;\r\n        return transferability && balanceIncreaseAllowed;\r\n    }\r\n\r\n    /**\r\n    * @dev Notifies the controller about an approval allowing the controller to react if desired\r\n    *      Initialization check is implicitly provided by `onlyToken()`.\r\n    * @return False if the controller does not authorize the approval\r\n    */\r\n    function onApprove(address, address, uint) external onlyToken returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Called when ether is sent to the MiniMe Token contract\r\n    *      Initialization check is implicitly provided by `onlyToken()`.\r\n    * @return True if the ether is accepted, false for it to throw\r\n    */\r\n    function proxyPayment(address) external payable onlyToken returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    // Forwarding fns\r\n\r\n    function isForwarder() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Execute desired action as a token holder\r\n    * @dev IForwarder interface conformance. Forwards any token holder action.\r\n    * @param _evmScript Script being executed\r\n    */\r\n    function forward(bytes _evmScript) public {\r\n        require(canForward(msg.sender, _evmScript), ERROR_CAN_NOT_FORWARD);\r\n        bytes memory input = new bytes(0); // TODO: Consider input for this\r\n\r\n        // Add the managed token to the blacklist to disallow a token holder from executing actions\r\n        // on the token controller's (this contract) behalf\r\n        address[] memory blacklist = new address[](1);\r\n        blacklist[0] = address(token);\r\n\r\n        runScript(_evmScript, input, blacklist);\r\n    }\r\n\r\n    function canForward(address _sender, bytes) public view returns (bool) {\r\n        return hasInitialized() && token.balanceOf(_sender) > 0;\r\n    }\r\n\r\n    // Getter fns\r\n\r\n    function getVesting(\r\n        address _recipient,\r\n        uint256 _vestingId\r\n    )\r\n        public\r\n        view\r\n        vestingExists(_recipient, _vestingId)\r\n        returns (\r\n            uint256 amount,\r\n            uint64 start,\r\n            uint64 cliff,\r\n            uint64 vesting,\r\n            bool revokable\r\n        )\r\n    {\r\n        TokenVesting memory tokenVesting = vestings[_recipient][_vestingId];\r\n        amount = tokenVesting.amount;\r\n        start = tokenVesting.start;\r\n        cliff = tokenVesting.cliff;\r\n        vesting = tokenVesting.vesting;\r\n        revokable = tokenVesting.revokable;\r\n    }\r\n\r\n    function spendableBalanceOf(address _holder) public view isInitialized returns (uint256) {\r\n        return _transferableBalance(_holder, getTimestamp());\r\n    }\r\n\r\n    function transferableBalance(address _holder, uint256 _time) public view isInitialized returns (uint256) {\r\n        return _transferableBalance(_holder, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Disable recovery escape hatch for own token,\r\n    *      as the it has the concept of issuing tokens without assigning them\r\n    */\r\n    function allowRecoverability(address _token) public view returns (bool) {\r\n        return _token != address(token);\r\n    }\r\n\r\n    // Internal fns\r\n\r\n    function _assign(address _receiver, uint256 _amount) internal {\r\n        require(_isBalanceIncreaseAllowed(_receiver, _amount), ERROR_BALANCE_INCREASE_NOT_ALLOWED);\r\n        // Must use transferFrom() as transfer() does not give the token controller full control\r\n        require(token.transferFrom(address(this), _receiver, _amount), ERROR_ASSIGN_TRANSFER_FROM_REVERTED);\r\n    }\r\n\r\n    function _mint(address _receiver, uint256 _amount) internal {\r\n        require(_isBalanceIncreaseAllowed(_receiver, _amount), ERROR_BALANCE_INCREASE_NOT_ALLOWED);\r\n        token.generateTokens(_receiver, _amount); // minime.generateTokens() never returns false\r\n    }\r\n\r\n    function _isBalanceIncreaseAllowed(address _receiver, uint256 _inc) internal view returns (bool) {\r\n        // Max balance doesn't apply to the token manager itself\r\n        if (_receiver == address(this)) {\r\n            return true;\r\n        }\r\n        return token.balanceOf(_receiver).add(_inc) <= maxAccountTokens;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate amount of non-vested tokens at a specific time\r\n    * @param tokens The total amount of tokens vested\r\n    * @param time The time at which to check\r\n    * @param start The date vesting started\r\n    * @param cliff The cliff period\r\n    * @param vested The fully vested date\r\n    * @return The amount of non-vested tokens of a specific grant\r\n    *  transferableTokens\r\n    *   |                         _/--------   vestedTokens rect\r\n    *   |                       _/\r\n    *   |                     _/\r\n    *   |                   _/\r\n    *   |                 _/\r\n    *   |                /\r\n    *   |              .|\r\n    *   |            .  |\r\n    *   |          .    |\r\n    *   |        .      |\r\n    *   |      .        |\r\n    *   |    .          |\r\n    *   +===+===========+---------+----------> time\r\n    *      Start       Cliff    Vested\r\n    */\r\n    function _calculateNonVestedTokens(\r\n        uint256 tokens,\r\n        uint256 time,\r\n        uint256 start,\r\n        uint256 cliff,\r\n        uint256 vested\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Shortcuts for before cliff and after vested cases.\r\n        if (time >= vested) {\r\n            return 0;\r\n        }\r\n        if (time < cliff) {\r\n            return tokens;\r\n        }\r\n\r\n        // Interpolate all vested tokens.\r\n        // As before cliff the shortcut returns 0, we can just calculate a value\r\n        // in the vesting rect (as shown in above's figure)\r\n\r\n        // vestedTokens = tokens * (time - start) / (vested - start)\r\n        // In assignVesting we enforce start <= cliff <= vested\r\n        // Here we shortcut time >= vested and time < cliff,\r\n        // so no division by 0 is possible\r\n        uint256 vestedTokens = tokens.mul(time.sub(start)) / vested.sub(start);\r\n\r\n        // tokens - vestedTokens\r\n        return tokens.sub(vestedTokens);\r\n    }\r\n\r\n    function _transferableBalance(address _holder, uint256 _time) internal view returns (uint256) {\r\n        uint256 transferable = token.balanceOf(_holder);\r\n\r\n        // This check is not strictly necessary for the current version of this contract, as\r\n        // Token Managers now cannot assign vestings to themselves.\r\n        // However, this was a possibility in the past, so in case there were vestings assigned to\r\n        // themselves, this will still return the correct value (entire balance, as the Token\r\n        // Manager does not have a spending limit on its own balance).\r\n        if (_holder != address(this)) {\r\n            uint256 vestingsCount = vestingsLengths[_holder];\r\n            for (uint256 i = 0; i < vestingsCount; i++) {\r\n                TokenVesting memory v = vestings[_holder][i];\r\n                uint256 nonTransferable = _calculateNonVestedTokens(\r\n                    v.amount,\r\n                    _time,\r\n                    v.start,\r\n                    v.cliff,\r\n                    v.vesting\r\n                );\r\n                transferable = transferable.sub(nonTransferable);\r\n            }\r\n        }\r\n\r\n        return transferable;\r\n    }\r\n}\r\n\r\n// File: contracts/BaseTemplate.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Custom Autark Apps\r\n\r\n\r\n\r\n\r\ncontract BaseTemplate is APMNamehash, IsContract {\r\n    using Uint256Helpers for uint256;\r\n\r\n// Hard-coded constants to save gas\r\n    // bytes32 constant internal AGENT_APP_ID = apmNamehash(\"agent\");                            // agent.aragonpm.eth\r\n    // bytes32 constant internal FINANCE_APP_ID = apmNamehash(\"finance\");                        // finance.aragonpm.eth\r\n    // bytes32 constant internal PAYROLL_APP_ID = apmNamehash(\"payroll\");                        // payroll.aragonpm.eth\r\n    // bytes32 constant internal SURVEY_APP_ID = apmNamehash(\"survey\");                          // survey.aragonpm.eth\r\n    // bytes32 constant internal TOKEN_MANAGER_APP_ID = apmNamehash(\"token-manager.hatch\");     // token-manager.hatch.aragonpm.eth\r\n    // bytes32 constant internal VAULT_APP_ID = apmNamehash(\"vault\");                            // vault.aragonpm.eth\r\n    // bytes32 constant internal VOTING_APP_ID = apmNamehash(\"voting\");                          // voting.aragonpm.eth\r\n    // bytes32 constant internal WHITELIST_ORACLE_APP_ID = apmNamehash(\"whitelist-oracle.hatch\");      // whitelist-oracle.hatch.aragonpm.eth\r\n    bytes32 constant internal AGENT_APP_ID = 0x9ac98dc5f995bf0211ed589ef022719d1487e5cb2bab505676f0d084c07cf89a;\r\n    bytes32 constant internal FINANCE_APP_ID = 0xbf8491150dafc5dcaee5b861414dca922de09ccffa344964ae167212e8c673ae;\r\n    bytes32 constant internal PAYROLL_APP_ID = 0x463f596a96d808cb28b5d080181e4a398bc793df2c222f6445189eb801001991;\r\n    bytes32 constant internal SURVEY_APP_ID = 0x030b2ab880b88e228f2da5a3d19a2a31bc10dbf91fb1143776a6de489389471e;\r\n    bytes32 constant internal TOKEN_MANAGER_APP_ID = 0xc568f11b5218b4d75fdc69c471ebdcffcb59025cc9119abfb35ed6d0efcbc4ff;\r\n    bytes32 constant internal VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\r\n    bytes32 constant internal VOTING_APP_ID = 0x9fa3927f639745e587912d4b0fea7ef9013bf93fb907d29faeab57417ba6e1d4;\r\n    bytes32 constant internal WHITELIST_ORACLE_APP_ID = 0x32ceb944f61770acf9d24fe42fd7ad630d08049a3b80b1475b120ab23569ba92;\r\n\r\n    string constant private ERROR_ARAGON_ID_NOT_CONTRACT = \"TEMPLATE_ARAGON_ID_NOT_CONTRACT\";\r\n    string constant private ERROR_ARAGON_ID_NOT_PROVIDED = \"TEMPLATE_ARAGON_ID_NOT_PROVIDED\";\r\n    string constant private ERROR_CANNOT_CAST_VALUE_TO_ADDRESS = \"TEMPLATE_CANNOT_CAST_VALUE_TO_ADDRESS\";\r\n    string constant private ERROR_DAO_FACTORY_NOT_CONTRACT = \"TEMPLATE_DAO_FAC_NOT_CONTRACT\";\r\n    string constant private ERROR_ENS_NOT_CONTRACT = \"TEMPLATE_ENS_NOT_CONTRACT\";\r\n    string constant private ERROR_INVALID_ID = \"TEMPLATE_INVALID_ID\";\r\n    string constant private ERROR_MINIME_FACTORY_NOT_CONTRACT = \"TEMPLATE_MINIME_FAC_NOT_CONTRACT\";\r\n    string constant private ERROR_MINIME_FACTORY_NOT_PROVIDED = \"TEMPLATE_MINIME_FAC_NOT_PROVIDED\";\r\n\r\n    DAOFactory internal daoFactory;\r\n    ENS internal ens;\r\n    IFIFSResolvingRegistrar internal aragonID;\r\n    MiniMeTokenFactory internal miniMeFactory;\r\n\r\n    event DeployDao(address dao);\r\n    event DeployToken(address token);\r\n    event InstalledApp(address appProxy, bytes32 appId);\r\n    event SetupDao(address dao);\r\n\r\n    constructor(DAOFactory _daoFactory, ENS _ens, MiniMeTokenFactory _miniMeFactory, IFIFSResolvingRegistrar _aragonID) public {\r\n        require(isContract(address(_daoFactory)), ERROR_DAO_FACTORY_NOT_CONTRACT);\r\n        require(isContract(address(_ens)), ERROR_ENS_NOT_CONTRACT);\r\n\r\n        aragonID = _aragonID;\r\n        daoFactory = _daoFactory;\r\n        ens = _ens;\r\n        miniMeFactory = _miniMeFactory;\r\n    }\r\n\r\n    /**\r\n    * @dev Create a DAO using the DAO Factory and grant the template root permissions so it has full\r\n    *      control during setup. Once the DAO setup has finished, it is recommended to call the\r\n    *      `_transferRootPermissionsFromTemplateAndFinalizeDAO()` helper to transfer the root\r\n    *      permissions to the end entity in control of the organization.\r\n    */\r\n    function _createDAO() internal returns (Kernel dao, ACL acl) {\r\n        dao = daoFactory.newDAO(this);\r\n        emit DeployDao(address(dao));\r\n        acl = ACL(dao.acl());\r\n        _createPermissionForTemplate(acl, dao, dao.APP_MANAGER_ROLE());\r\n    }\r\n\r\n    /* ACL */\r\n\r\n    function _createPermissions(ACL _acl, address[] memory _grantees, address _app, bytes32 _permission, address _manager) internal {\r\n        _acl.createPermission(_grantees[0], _app, _permission, address(this));\r\n        for (uint256 i = 1; i < _grantees.length; i++) {\r\n            _acl.grantPermission(_grantees[i], _app, _permission);\r\n        }\r\n        _acl.revokePermission(address(this), _app, _permission);\r\n        _acl.setPermissionManager(_manager, _app, _permission);\r\n    }\r\n\r\n    function _createPermissionForTemplate(ACL _acl, address _app, bytes32 _permission) internal {\r\n        _acl.createPermission(address(this), _app, _permission, address(this));\r\n    }\r\n\r\n    function _removePermissionFromTemplate(ACL _acl, address _app, bytes32 _permission) internal {\r\n        _acl.revokePermission(address(this), _app, _permission);\r\n        _acl.removePermissionManager(_app, _permission);\r\n    }\r\n\r\n    function _transferRootPermissionsFromTemplateAndFinalizeDAO(Kernel _dao, address _to) internal {\r\n        _transferRootPermissionsFromTemplateAndFinalizeDAO(_dao, _to, _to);\r\n    }\r\n\r\n    function _transferRootPermissionsFromTemplateAndFinalizeDAO(Kernel _dao, address _to, address _manager) internal {\r\n        ACL _acl = ACL(_dao.acl());\r\n        _transferPermissionFromTemplate(_acl, _dao, _to, _dao.APP_MANAGER_ROLE(), _manager);\r\n        _transferPermissionFromTemplate(_acl, _acl, _to, _acl.CREATE_PERMISSIONS_ROLE(), _manager);\r\n        emit SetupDao(_dao);\r\n    }\r\n\r\n    function _transferPermissionFromTemplate(ACL _acl, address _app, address _to, bytes32 _permission, address _manager) internal {\r\n        _acl.grantPermission(_to, _app, _permission);\r\n        _acl.revokePermission(address(this), _app, _permission);\r\n        _acl.setPermissionManager(_manager, _app, _permission);\r\n    }\r\n\r\n    /* AGENT */\r\n\r\n    function _installDefaultAgentApp(Kernel _dao) internal returns (Agent) {\r\n        bytes memory initializeData = abi.encodeWithSelector(Agent(0).initialize.selector);\r\n        Agent agent = Agent(_installDefaultApp(_dao, AGENT_APP_ID, initializeData));\r\n        // We assume that installing the Agent app as a default app means the DAO should have its\r\n        // Vault replaced by the Agent. Thus, we also set the DAO´s recovery app to the Agent.\r\n        _dao.setRecoveryVaultAppId(AGENT_APP_ID);\r\n        return agent;\r\n    }\r\n\r\n    function _installNonDefaultAgentApp(Kernel _dao) internal returns (Agent) {\r\n        bytes memory initializeData = abi.encodeWithSelector(Agent(0).initialize.selector);\r\n        return Agent(_installNonDefaultApp(_dao, AGENT_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createAgentPermissions(ACL _acl, Agent _agent, address _grantee, address _manager) internal {\r\n        _acl.createPermission(_grantee, _agent, _agent.EXECUTE_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _agent, _agent.RUN_SCRIPT_ROLE(), _manager);\r\n    }\r\n\r\n    /* VAULT */\r\n\r\n    function _installVaultApp(Kernel _dao) internal returns (Vault) {\r\n        bytes memory initializeData = abi.encodeWithSelector(Vault(0).initialize.selector);\r\n        return Vault(_installDefaultApp(_dao, VAULT_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createVaultPermissions(ACL _acl, Vault _vault, address _grantee, address _manager) internal {\r\n        _acl.createPermission(_grantee, _vault, _vault.TRANSFER_ROLE(), _manager);\r\n    }\r\n\r\n    /* VOTING */\r\n\r\n    function _installVotingApp(Kernel _dao, MiniMeToken _token, uint64[3] memory _votingSettings) internal returns (Voting) {\r\n        return _installVotingApp(_dao, _token, _votingSettings[0], _votingSettings[1], _votingSettings[2]);\r\n    }\r\n\r\n    function _installVotingApp(\r\n        Kernel _dao,\r\n        MiniMeToken _token,\r\n        uint64 _support,\r\n        uint64 _acceptance,\r\n        uint64 _duration\r\n    )\r\n        internal returns (Voting)\r\n    {\r\n        bytes memory initializeData = abi.encodeWithSelector(Voting(0).initialize.selector, _token, _support, _acceptance, _duration);\r\n        return Voting(_installNonDefaultApp(_dao, VOTING_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createVotingPermissions(\r\n        ACL _acl,\r\n        Voting _voting,\r\n        address _settingsGrantee,\r\n        address _createVotesGrantee,\r\n        address _manager\r\n    )\r\n        internal\r\n    {\r\n        _acl.createPermission(_settingsGrantee, _voting, _voting.MODIFY_QUORUM_ROLE(), _manager);\r\n        _acl.createPermission(_settingsGrantee, _voting, _voting.MODIFY_SUPPORT_ROLE(), _manager);\r\n        _acl.createPermission(_createVotesGrantee, _voting, _voting.CREATE_VOTES_ROLE(), _manager);\r\n    }\r\n\r\n    /* SURVEY */\r\n\r\n    function _installSurveyApp(Kernel _dao, MiniMeToken _token, uint64 _minParticipationPct, uint64 _surveyTime) internal returns (Survey) {\r\n        bytes memory initializeData = abi.encodeWithSelector(Survey(0).initialize.selector, _token, _minParticipationPct, _surveyTime);\r\n        return Survey(_installNonDefaultApp(_dao, SURVEY_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createSurveyPermissions(ACL _acl, Survey _survey, address _grantee, address _manager) internal {\r\n        _acl.createPermission(_grantee, _survey, _survey.CREATE_SURVEYS_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _survey, _survey.MODIFY_PARTICIPATION_ROLE(), _manager);\r\n    }\r\n\r\n    /* PAYROLL */\r\n\r\n    function _installPayrollApp(\r\n        Kernel _dao,\r\n        Finance _finance,\r\n        address _denominationToken,\r\n        IFeed _priceFeed,\r\n        uint64 _rateExpiryTime\r\n    )\r\n        internal returns (Payroll)\r\n    {\r\n        bytes memory initializeData = abi.encodeWithSelector(\r\n            Payroll(0).initialize.selector,\r\n            _finance,\r\n            _denominationToken,\r\n            _priceFeed,\r\n            _rateExpiryTime\r\n        );\r\n        return Payroll(_installNonDefaultApp(_dao, PAYROLL_APP_ID, initializeData));\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to configure payroll permissions. Note that we allow defining different managers for\r\n    *      payroll since it may be useful to have one control the payroll settings (rate expiration, price feed,\r\n    *      and allowed tokens), and another one to control the employee functionality (bonuses, salaries,\r\n    *      reimbursements, employees, etc).\r\n    * @param _acl ACL instance being configured\r\n    * @param _acl Payroll app being configured\r\n    * @param _employeeManager Address that will receive permissions to handle employee payroll functionality\r\n    * @param _settingsManager Address that will receive permissions to manage payroll settings\r\n    * @param _permissionsManager Address that will be the ACL manager for the payroll permissions\r\n    */\r\n    function _createPayrollPermissions(\r\n        ACL _acl,\r\n        Payroll _payroll,\r\n        address _employeeManager,\r\n        address _settingsManager,\r\n        address _permissionsManager\r\n    )\r\n        internal\r\n    {\r\n        _acl.createPermission(_employeeManager, _payroll, _payroll.ADD_BONUS_ROLE(), _permissionsManager);\r\n        _acl.createPermission(_employeeManager, _payroll, _payroll.ADD_EMPLOYEE_ROLE(), _permissionsManager);\r\n        _acl.createPermission(_employeeManager, _payroll, _payroll.ADD_REIMBURSEMENT_ROLE(), _permissionsManager);\r\n        _acl.createPermission(_employeeManager, _payroll, _payroll.TERMINATE_EMPLOYEE_ROLE(), _permissionsManager);\r\n        _acl.createPermission(_employeeManager, _payroll, _payroll.SET_EMPLOYEE_SALARY_ROLE(), _permissionsManager);\r\n\r\n        _acl.createPermission(_settingsManager, _payroll, _payroll.MODIFY_PRICE_FEED_ROLE(), _permissionsManager);\r\n        _acl.createPermission(_settingsManager, _payroll, _payroll.MODIFY_RATE_EXPIRY_ROLE(), _permissionsManager);\r\n        _acl.createPermission(_settingsManager, _payroll, _payroll.MANAGE_ALLOWED_TOKENS_ROLE(), _permissionsManager);\r\n    }\r\n\r\n    function _unwrapPayrollSettings(\r\n        uint256[4] memory _payrollSettings\r\n    )\r\n        internal pure returns (address denominationToken, IFeed priceFeed, uint64 rateExpiryTime, address employeeManager)\r\n    {\r\n        denominationToken = _toAddress(_payrollSettings[0]);\r\n        priceFeed = IFeed(_toAddress(_payrollSettings[1]));\r\n        rateExpiryTime = _payrollSettings[2].toUint64();\r\n        employeeManager = _toAddress(_payrollSettings[3]);\r\n    }\r\n\r\n    /* FINANCE */\r\n\r\n    function _installFinanceApp(Kernel _dao, Vault _vault, uint64 _periodDuration) internal returns (Finance) {\r\n        bytes memory initializeData = abi.encodeWithSelector(Finance(0).initialize.selector, _vault, _periodDuration);\r\n        return Finance(_installNonDefaultApp(_dao, FINANCE_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createFinancePermissions(ACL _acl, Finance _finance, address _grantee, address _manager) internal {\r\n        _acl.createPermission(_grantee, _finance, _finance.EXECUTE_PAYMENTS_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _finance, _finance.MANAGE_PAYMENTS_ROLE(), _manager);\r\n    }\r\n\r\n    function _createFinanceCreatePaymentsPermission(ACL _acl, Finance _finance, address _grantee, address _manager) internal {\r\n        _acl.createPermission(_grantee, _finance, _finance.CREATE_PAYMENTS_ROLE(), _manager);\r\n    }\r\n\r\n    function _grantCreatePaymentPermission(ACL _acl, Finance _finance, address _to) internal {\r\n        _acl.grantPermission(_to, _finance, _finance.CREATE_PAYMENTS_ROLE());\r\n    }\r\n\r\n    function _transferCreatePaymentManagerFromTemplate(ACL _acl, Finance _finance, address _manager) internal {\r\n        _acl.setPermissionManager(_manager, _finance, _finance.CREATE_PAYMENTS_ROLE());\r\n    }\r\n\r\n    /* TOKEN MANAGER */\r\n\r\n    function _installTokenManagerApp(\r\n        Kernel _dao,\r\n        MiniMeToken _token,\r\n        bool _transferable,\r\n        uint256 _maxAccountTokens\r\n    )\r\n        internal returns (TokenManager)\r\n    {\r\n        TokenManager tokenManager = TokenManager(_installNonDefaultApp(_dao, TOKEN_MANAGER_APP_ID));\r\n        _token.changeController(tokenManager);\r\n        tokenManager.initialize(_token, _transferable, _maxAccountTokens);\r\n        return tokenManager;\r\n    }\r\n\r\n    function _createTokenManagerPermissions(ACL _acl, TokenManager _tokenManager, address _grantee, address _manager) internal {\r\n        _acl.createPermission(_grantee, _tokenManager, _tokenManager.MINT_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _tokenManager, _tokenManager.BURN_ROLE(), _manager);\r\n    }\r\n\r\n    function _mintTokens(ACL _acl, TokenManager _tokenManager, address[] memory _holders, uint256[] memory _stakes) internal {\r\n        _createPermissionForTemplate(_acl, _tokenManager, _tokenManager.MINT_ROLE());\r\n        for (uint256 i = 0; i < _holders.length; i++) {\r\n            _tokenManager.mint(_holders[i], _stakes[i]);\r\n        }\r\n        _removePermissionFromTemplate(_acl, _tokenManager, _tokenManager.MINT_ROLE());\r\n    }\r\n\r\n    function _mintTokens(ACL _acl, TokenManager _tokenManager, address[] memory _holders, uint256 _stake) internal {\r\n        _createPermissionForTemplate(_acl, _tokenManager, _tokenManager.MINT_ROLE());\r\n        for (uint256 i = 0; i < _holders.length; i++) {\r\n            _tokenManager.mint(_holders[i], _stake);\r\n        }\r\n        _removePermissionFromTemplate(_acl, _tokenManager, _tokenManager.MINT_ROLE());\r\n    }\r\n\r\n    function _mintTokens(ACL _acl, TokenManager _tokenManager, address _holder, uint256 _stake) internal {\r\n        _createPermissionForTemplate(_acl, _tokenManager, _tokenManager.MINT_ROLE());\r\n        _tokenManager.mint(_holder, _stake);\r\n        _removePermissionFromTemplate(_acl, _tokenManager, _tokenManager.MINT_ROLE());\r\n    }\r\n\r\n    function _setOracle(ACL _acl, TokenManager _tokenManager, address _whitelistOracle) internal {\r\n        _createPermissionForTemplate(_acl, _tokenManager, _tokenManager.SET_ORACLE());\r\n        _tokenManager.setOracle(_whitelistOracle);\r\n        _removePermissionFromTemplate(_acl, _tokenManager, _tokenManager.SET_ORACLE());\r\n    }\r\n\r\n    /* WHITELIST ORACLE */\r\n\r\n    function _installWhitelistOracleApp(Kernel _dao) internal returns (WhitelistOracle) {\r\n        return WhitelistOracle(_installNonDefaultApp(_dao, WHITELIST_ORACLE_APP_ID));\r\n    }\r\n\r\n    function _createWhitelistPermissions(ACL _acl, WhitelistOracle _whitelist, address _grantee, address _manager) internal {\r\n        _acl.createPermission(_grantee, _whitelist, _whitelist.ADD_SENDER_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _whitelist, _whitelist.REMOVE_SENDER_ROLE(), _manager);\r\n    }\r\n\r\n    /* EVM SCRIPTS */\r\n\r\n    function _createEvmScriptsRegistryPermissions(ACL _acl, address _grantee, address _manager) internal {\r\n        EVMScriptRegistry registry = EVMScriptRegistry(_acl.getEVMScriptRegistry());\r\n        _acl.createPermission(_grantee, registry, registry.REGISTRY_MANAGER_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, registry, registry.REGISTRY_ADD_EXECUTOR_ROLE(), _manager);\r\n    }\r\n\r\n    /* APPS */\r\n\r\n    function _installNonDefaultApp(Kernel _dao, bytes32 _appId) internal returns (address) {\r\n        return _installNonDefaultApp(_dao, _appId, new bytes(0));\r\n    }\r\n\r\n    function _installNonDefaultApp(Kernel _dao, bytes32 _appId, bytes memory _initializeData) internal returns (address) {\r\n        return _installApp(_dao, _appId, _initializeData, false);\r\n    }\r\n\r\n    function _installDefaultApp(Kernel _dao, bytes32 _appId) internal returns (address) {\r\n        return _installDefaultApp(_dao, _appId, new bytes(0));\r\n    }\r\n\r\n    function _installDefaultApp(Kernel _dao, bytes32 _appId, bytes memory _initializeData) internal returns (address) {\r\n        return _installApp(_dao, _appId, _initializeData, true);\r\n    }\r\n\r\n    function _installApp(Kernel _dao, bytes32 _appId, bytes memory _initializeData, bool _setDefault) internal returns (address) {\r\n        address latestBaseAppAddress = _latestVersionAppBase(_appId);\r\n        address instance = address(_dao.newAppInstance(_appId, latestBaseAppAddress, _initializeData, _setDefault));\r\n        emit InstalledApp(instance, _appId);\r\n        return instance;\r\n    }\r\n\r\n    function _latestVersionAppBase(bytes32 _appId) internal view returns (address base) {\r\n        Repo repo = Repo(PublicResolver(ens.resolver(_appId)).addr(_appId));\r\n        (,base,) = repo.getLatest();\r\n    }\r\n\r\n    /* TOKEN */\r\n\r\n    function _createToken(string memory _name, string memory _symbol, uint8 _decimals) internal returns (MiniMeToken) {\r\n        require(address(miniMeFactory) != address(0), ERROR_MINIME_FACTORY_NOT_PROVIDED);\r\n        MiniMeToken token = miniMeFactory.createCloneToken(MiniMeToken(address(0)), 0, _name, _decimals, _symbol, true);\r\n        emit DeployToken(address(token));\r\n        return token;\r\n    }\r\n\r\n    function _ensureMiniMeFactoryIsValid(address _miniMeFactory) internal view {\r\n        require(isContract(address(_miniMeFactory)), ERROR_MINIME_FACTORY_NOT_CONTRACT);\r\n    }\r\n\r\n    /* IDS */\r\n\r\n    function _validateId(string memory _id) internal pure {\r\n        require(bytes(_id).length > 0, ERROR_INVALID_ID);\r\n    }\r\n\r\n    function _registerID(string memory _name, address _owner) internal {\r\n        require(address(aragonID) != address(0), ERROR_ARAGON_ID_NOT_PROVIDED);\r\n        aragonID.register(keccak256(abi.encodePacked(_name)), _owner);\r\n    }\r\n\r\n    function _ensureAragonIdIsValid(address _aragonID) internal view {\r\n        require(isContract(address(_aragonID)), ERROR_ARAGON_ID_NOT_CONTRACT);\r\n    }\r\n\r\n    /* HELPERS */\r\n\r\n    function _toAddress(uint256 _value) private pure returns (address) {\r\n        require(_value <= uint160(-1), ERROR_CANNOT_CAST_VALUE_TO_ADDRESS);\r\n        return address(_value);\r\n    }\r\n}\r\n\r\n// File: @tps/test-helpers/contracts/evmscript/DynamicScriptHelpers.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\nlibrary DynamicScriptHelpers {\r\n    // To test with JS and compare with actual encoder. Maintaining for reference.\r\n    // t = function() { return IEVMScriptExecutor.at('0x4bcdd59d6c77774ee7317fc1095f69ec84421e49').contract.execScript.getData(...[].slice.call(arguments)).slice(10).match(/.{1,64}/g) }\r\n    // run = function() { return ScriptHelpers.new().then(sh => { sh.abiEncode.call(...[].slice.call(arguments)).then(a => console.log(a.slice(2).match(/.{1,64}/g)) ) }) }\r\n    // This is truly not beautiful but lets no daydream to the day solidity gets reflection features\r\n\r\n    function abiEncode(bytes _a, bytes _b, address[] _c) public pure returns (bytes d) {\r\n        return encode(_a, _b, _c);\r\n    }\r\n\r\n    function encode(bytes memory _a, bytes memory _b, address[] memory _c) internal pure returns (bytes memory d) {\r\n        // A is positioned after the 3 position words\r\n        uint256 aPosition = 0x60;\r\n        uint256 bPosition = aPosition + 32 * abiLength(_a);\r\n        uint256 cPosition = bPosition + 32 * abiLength(_b);\r\n        uint256 length = cPosition + 32 * abiLength(_c);\r\n\r\n        d = new bytes(length);\r\n        assembly {\r\n            // Store positions\r\n            mstore(add(d, 0x20), aPosition)\r\n            mstore(add(d, 0x40), bPosition)\r\n            mstore(add(d, 0x60), cPosition)\r\n        }\r\n\r\n        // Copy memory to correct position\r\n        copy(d, getPtr(_a), aPosition, _a.length);\r\n        copy(d, getPtr(_b), bPosition, _b.length);\r\n        copy(d, getPtr(_c), cPosition, _c.length * 32); // 1 word per address\r\n    }\r\n\r\n    function abiLength(bytes memory _a) internal pure returns (uint256) {\r\n        // 1 for length +\r\n        // memory words + 1 if not divisible for 32 to offset word\r\n        return 1 + (_a.length / 32) + (_a.length % 32 > 0 ? 1 : 0);\r\n    }\r\n\r\n    function abiLength(address[] _a) internal pure returns (uint256) {\r\n        // 1 for length + 1 per item\r\n        return 1 + _a.length;\r\n    }\r\n\r\n    function copy(bytes _d, uint256 _src, uint256 _pos, uint256 _length) internal pure {\r\n        uint dest;\r\n        assembly {\r\n            dest := add(add(_d, 0x20), _pos)\r\n        }\r\n        memcpy(dest, _src, _length);\r\n    }\r\n\r\n    function getPtr(bytes memory _x) internal pure returns (uint256 ptr) {\r\n        assembly {\r\n            ptr := _x\r\n        }\r\n    }\r\n\r\n    function getPtr(address[] memory _x) internal pure returns (uint256 ptr) {\r\n        assembly {\r\n            ptr := _x\r\n        }\r\n    }\r\n\r\n    function getSpecId(bytes _script) internal pure returns (uint32) {\r\n        return uint32At(_script, 0);\r\n    }\r\n\r\n    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\r\n        assembly {\r\n            result := mload(add(_data, add(0x20, _location)))\r\n        }\r\n    }\r\n\r\n    function bytes32At(bytes _data, uint256 _location) internal pure returns (bytes32 result) {\r\n        assembly {\r\n            result := mload(add(_data, add(0x20, _location)))\r\n        }\r\n    }\r\n\r\n    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\r\n        uint256 word = uint256At(_data, _location);\r\n\r\n        assembly {\r\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\r\n            0x1000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\r\n        uint256 word = uint256At(_data, _location);\r\n\r\n        assembly {\r\n            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\r\n            0x100000000000000000000000000000000000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\r\n        assembly {\r\n            result := add(_data, add(0x20, _location))\r\n        }\r\n    }\r\n\r\n    function toBytes(bytes4 _sig) internal pure returns (bytes) {\r\n        bytes memory payload = new bytes(4);\r\n        assembly { mstore(add(payload, 0x20), _sig) }\r\n        return payload;\r\n    }\r\n\r\n    function memcpy(uint _dest, uint _src, uint _len) internal pure {\r\n        uint256 src = _src;\r\n        uint256 dest = _dest;\r\n        uint256 len = _len;\r\n\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: @tps/test-helpers/contracts/common/ADynamicForwarder.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n// TODO: Use @aragon/os/contracts/ version when it gets merged\r\n\r\n// TODO: Research why using the @aragon/os version breaks coverage\r\n\r\n\r\n/**\r\n  * @title ADynamicForwarder App\r\n  * @author Autark\r\n  * @dev This serves as an abstract contract to facilitate any voting pattern where dynamic\r\n  *     results must be passed out of the contract. It provides options for the voting contract\r\n  *     to then act upon and helpers to parce and encode evmScripts from/to options.\r\n  */\r\n\r\n\r\ncontract ADynamicForwarder is IForwarder {\r\n    using DynamicScriptHelpers for bytes;\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n\r\n    uint256 constant public OPTION_ADDR_PARAM_LOC = 1;\r\n    uint256 constant public OPTION_SUPPORT_PARAM_LOC = 2;\r\n    uint256 constant public INDICIES_PARAM_LOC = 3;\r\n    uint256 constant public OPTION_INFO_PARAM_LOC = 4;\r\n    uint256 constant public DESCRIPTION_PARAM_LOC = 5;\r\n    uint256 constant public EX_ID1_PARAM_LOC = 6;\r\n    uint256 constant public EX_ID2_PARAM_LOC = 7;\r\n    uint256 constant public TOTAL_DYNAMIC_PARAMS = 7;\r\n\r\n    struct Action {\r\n        uint256 externalId;\r\n        string description;\r\n        uint256 infoStringLength;\r\n        bytes executionScript;\r\n        bool executed;\r\n        bytes32[] optionKeys;\r\n        mapping (bytes32 => OptionState) options;\r\n    }\r\n\r\n    struct OptionState {\r\n        bool added;\r\n        string metadata;\r\n        uint8 keyArrayIndex;\r\n        uint256 actionSupport;\r\n        bytes32 externalId1;\r\n        bytes32 externalId2;\r\n    }\r\n\r\n    mapping (bytes32 => address ) optionAddresses;\r\n    mapping (uint256 => Action) actions;\r\n    uint256 actionsLength = 0;\r\n\r\n    event AddOption(uint256 actionId, address optionAddress, uint256 optionQty);\r\n    event OptionQty(uint256 qty);\r\n    event Address(address currentOption);\r\n    event OrigScript(bytes script);\r\n\r\n    /**\r\n    * @notice `getOption` serves as a basic getter using the description\r\n    *         to return the struct data.\r\n    * @param _actionId id for action structure this 'ballot action' is connected to\r\n    * @param _optionIndex The option descrciption of the option.\r\n    */\r\n    function getOption(uint256 _actionId, uint256 _optionIndex) // solium-disable-line function-order\r\n    external view returns(address optionAddress, uint256 actionSupport, string metadata, bytes32 externalId1, bytes32 externalId2)\r\n    {\r\n        Action storage actionInstance = actions[_actionId];\r\n        OptionState storage option = actionInstance.options[actionInstance.optionKeys[_optionIndex]];\r\n        optionAddress = optionAddresses[actionInstance.optionKeys[_optionIndex]];\r\n        actionSupport = option.actionSupport;\r\n        metadata = option.metadata;\r\n        externalId1 = option.externalId1;\r\n        externalId2 = option.externalId2;\r\n    }\r\n\r\n    /**\r\n    * @notice `getOptionLength` returns the total number of options for\r\n    *         a given action.\r\n    * @param _actionId The ID of the Action struct in the `actions` array\r\n    */\r\n    function getOptionLength(uint256 _actionId) public view returns\r\n    ( uint totalOptions ) { // solium-disable-line lbrace\r\n        totalOptions = actions[_actionId].optionKeys.length;\r\n    }\r\n\r\n    /**\r\n    * @notice `addOption` allows internal addition of options\r\n    *         (or options) to the current action.\r\n    * @param _actionId id for action structure this 'ballot action' is connected to\r\n    * @param _metadata Any additional information about the option.\r\n    *        Base implementation does not use this parameter.\r\n    * @param _description This is the string that will be displayed along the\r\n    *        option when voting\r\n    */\r\n    function addOption(uint256 _actionId, string _metadata, address _description, bytes32 eId1, bytes32 eId2)\r\n    internal\r\n    {\r\n        // Get action and option into storage\r\n        Action storage actionInstance = actions[_actionId];\r\n        bytes32[] storage keys = actionInstance.optionKeys;\r\n        bytes32 cKey = keccak256(abi.encodePacked(_description));\r\n        OptionState storage option = actionInstance.options[cKey];\r\n        // Make sure that this option has not already been added\r\n        require(option.added == false); // solium-disable-line error-reason\r\n        // ensure there is no potential for truncation when keys.length gets converted from uint256 to uint8\r\n        require(keys.length < uint8(-1)); // solium-disable-line error-reason\r\n        // Set all data for the option\r\n        option.added = true;\r\n        option.keyArrayIndex = uint8(keys.length);\r\n        option.metadata = _metadata;\r\n        option.externalId1 = eId1;\r\n        option.externalId2 = eId2;\r\n        // double check\r\n        optionAddresses[cKey] = _description;\r\n        keys.push(cKey);\r\n        actionInstance.infoStringLength += bytes(_metadata).length;\r\n        emit AddOption(_actionId, optionAddresses[cKey], actionInstance.optionKeys.length);\r\n    }\r\n\r\n    function addDynamicElements(\r\n        bytes script,\r\n        uint256 offset,\r\n        uint256 numberOfOptions,\r\n        uint256 strLength,\r\n        uint256 desLength\r\n    ) internal pure returns(bytes)\r\n    {\r\n        uint256 secondDynamicElementLocation = 32 + offset + (numberOfOptions * 32);\r\n        uint256 thirdDynamicElementLocation = secondDynamicElementLocation + 32 + (numberOfOptions * 32);\r\n        uint256 fourthDynamicElementLocation = thirdDynamicElementLocation + 32 + (numberOfOptions * 32);\r\n        uint256 fifthDynamicElementLocation = fourthDynamicElementLocation + (strLength / 32) * 32 + (strLength % 32 == 0 ? 32 : 64);\r\n        uint256 sixthDynamicElementLocation = fifthDynamicElementLocation + (desLength / 32) * 32 + (desLength % 32 == 0 ? 32 : 64);\r\n        uint256 seventhDynamicElementLocation = sixthDynamicElementLocation + 32 + (numberOfOptions * 32);\r\n\r\n        assembly {\r\n            mstore(add(script, 96), secondDynamicElementLocation)\r\n            mstore(add(script, 128), thirdDynamicElementLocation)\r\n            mstore(add(script, 160), fourthDynamicElementLocation)\r\n            mstore(add(script, 192), fifthDynamicElementLocation)\r\n            mstore(add(script, 224), sixthDynamicElementLocation)\r\n            mstore(add(script, 256), seventhDynamicElementLocation)\r\n        }\r\n\r\n        return script;\r\n    }\r\n\r\n    function _goToParamOffset(uint256 _paramNum, bytes _executionScript) internal pure returns(uint256 paramOffset) {\r\n        /*\r\n        param numbers and what they map to:\r\n        1. option addresses\r\n        2. Supports values\r\n        3. Info String indexes\r\n        4. Info String length\r\n        5. Description\r\n        6. Level 1 external references\r\n        7. level 2 external references\r\n        */\r\n        paramOffset = _executionScript.uint256At(0x20 + (0x20 * (_paramNum - 1) )) + 0x20;\r\n\r\n    }\r\n\r\n    function substring(\r\n        bytes strBytes,\r\n        uint startIndex,\r\n        uint endIndex\r\n    ) internal pure returns (string)\r\n    {\r\n        // first char is at location 0\r\n        //IPFS addresses span from 0 (startindex) to 46 (endIndex)\r\n        bytes memory result = new bytes(endIndex-startIndex);\r\n        for (uint i = startIndex; i < endIndex; i++) {\r\n            result[i-startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function _iterateExtraction(uint256 _actionId, bytes _executionScript, uint256 _currentOffset, uint256 _optionLength) internal {\r\n        uint256 currentOffset = _currentOffset;\r\n        address currentOption;\r\n        string memory info;\r\n        uint256 infoEnd;\r\n        bytes32 externalId1;\r\n        bytes32 externalId2;\r\n        uint256 idOffset;\r\n        uint256 infoStart = _goToParamOffset(OPTION_INFO_PARAM_LOC,_executionScript) + 0x20;\r\n        //Location(infoStart);\r\n        emit OptionQty(_optionLength);\r\n        for (uint256 i = 0 ; i < _optionLength; i++) {\r\n            currentOption = _executionScript.addressAt(currentOffset + 0x0C);\r\n            emit Address(currentOption);\r\n            //find the end of the infoString using the relative arg positions\r\n            infoEnd = infoStart + _executionScript.uint256At(currentOffset + (0x20 * 2 * (_optionLength + 1) ));\r\n            info = substring(_executionScript, infoStart, infoEnd);\r\n            //Metadata(info);\r\n            //Location(infoEnd);\r\n            currentOffset = currentOffset + 0x20;\r\n            // update the index for the next iteration\r\n            infoStart = infoEnd;\r\n            // store option external IDs\r\n            idOffset = _goToParamOffset(EX_ID1_PARAM_LOC, _executionScript) + 0x20 * (i + 1);\r\n            externalId1 = bytes32(_executionScript.uint256At(idOffset));\r\n            idOffset = _goToParamOffset(EX_ID2_PARAM_LOC, _executionScript) + 0x20 * (i + 1);\r\n            externalId2 = bytes32(_executionScript.uint256At(idOffset));\r\n\r\n            addOption(_actionId, info, currentOption, externalId1, externalId2);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev This function parses the option quantity\r\n    *      and passes it into _iterateExtraction to parse the option details\r\n    *\r\n    */\r\n    function _extractOptions(bytes _executionScript, uint256 _actionId) internal {\r\n        Action storage actionInstance = actions[_actionId];\r\n        // in order to find out the total length of our call data we take the 3rd\r\n        // relevent byte chunk (after the specid and the target address)\r\n        uint256 calldataLength = uint256(_executionScript.uint32At(0x4 + 0x14));\r\n        // Since the calldataLength is 4 bytes the start offset is\r\n        uint256 startOffset = 0x04 + 0x14 + 0x04;\r\n        // The first parameter is located at a byte depth indicated by the first\r\n        // word in the calldata (which is located at the startOffset + 0x04 for the function signature)\r\n        // so we have:\r\n        // start offset (spec id + address + calldataLength) + param offset + function signature\r\n        // note:function signature length (0x04) added in both contexts: grabbing the offset value and the outer offset calculation\r\n        uint256 firstParamOffset = _goToParamOffset(OPTION_ADDR_PARAM_LOC, _executionScript);\r\n        uint256 fifthParamOffset = _goToParamOffset(DESCRIPTION_PARAM_LOC, _executionScript);\r\n        uint256 currentOffset = firstParamOffset;\r\n        // compute end of script / next location and ensure there's no\r\n        // shenanigans\r\n        require(startOffset + calldataLength == _executionScript.length); // solium-disable-line error-reason\r\n        // The first word in the param slot is the length of the array\r\n        // obtain the beginning index of the infoString\r\n        uint256 optionLength = _executionScript.uint256At(currentOffset);\r\n        currentOffset = currentOffset + 0x20;\r\n        // This has the potential to be too gas expensive to ever happen.\r\n        // Upper limit of options should be checked against this function\r\n        _iterateExtraction(_actionId, _executionScript, currentOffset, optionLength);\r\n        uint256 descriptionStart = fifthParamOffset + 0x20;\r\n        uint256 descriptionEnd = descriptionStart + (_executionScript.uint256At(fifthParamOffset));\r\n        actionInstance.description = substring(_executionScript, descriptionStart, descriptionEnd);\r\n        // Skip the next param since it's also determined by this contract\r\n        // In order to do this we move the offset one word for the length of the param\r\n        // and we move the offset one word for each param.\r\n        //currentOffset = currentOffset.add(_executionScript.uint256At(currentOffset).mul(0x20));\r\n        //currentOffset = fifthParamOffset;\r\n        // The offset represents the data we've already accounted for; the rest is what will later\r\n        // need to be copied over.\r\n        //calldataLength = calldataLength.sub(currentOffset);\r\n    }\r\n\r\n    function addAddressesAndActions(\r\n        uint256 _actionId,\r\n        bytes script,\r\n        uint256 numberOfOptions,\r\n        uint256 dynamicOffset\r\n        ) internal view returns(uint256 offset)\r\n        {\r\n                // Set the initial offest after the static parameters\r\n        offset = 64 + dynamicOffset;\r\n\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            mstore(add(script, offset), numberOfOptions)\r\n        }\r\n\r\n        offset += 32;\r\n\r\n        // Copy all option addresses\r\n        for (uint256 i = 0; i < numberOfOptions; i++) {\r\n            bytes32 canKey = actions[_actionId].optionKeys[i];\r\n            uint256 optionData = uint256(optionAddresses[canKey]);\r\n            assembly {\r\n                mstore(add(script, offset), optionData)\r\n            }\r\n            offset += 32;\r\n        }\r\n\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            mstore(add(script, offset), numberOfOptions)\r\n        }\r\n\r\n        offset += 32;\r\n\r\n        // Copy all support data\r\n        for (i = 0; i < numberOfOptions; i++) {\r\n            uint256 supportsData = actions[_actionId].options[actions[_actionId].optionKeys[i]].actionSupport;\r\n\r\n            assembly { // solium-disable-line security/no-inline-assembly\r\n                mstore(add(script, offset), supportsData)\r\n            }\r\n            offset += 32;\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    function addInfoString(\r\n        uint256 _actionId,\r\n        bytes script,\r\n        uint256 numberOfOptions,\r\n        uint256 _offset)\r\n        internal view returns (uint256 newOffset)\r\n    {\r\n        Action storage actionInstance = actions[_actionId];\r\n        uint256 infoStringLength = actionInstance.infoStringLength;\r\n        bytes memory infoString = new bytes(infoStringLength);\r\n        bytes memory optionMetaData;\r\n        uint256 metaDataLength;\r\n        uint256 strOffset = 0;\r\n        newOffset = _offset;\r\n        // Add number of options for array size of \"infoIndicies\"\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            mstore(add(script, newOffset), numberOfOptions)\r\n        }\r\n        // Offset \"infoIndicies\" size\r\n        newOffset += 32;\r\n\r\n        for (uint256 i = 0; i < numberOfOptions; i++) {\r\n            bytes32 canKey = actionInstance.optionKeys[i];\r\n            optionMetaData = bytes(actionInstance.options[canKey].metadata);\r\n            infoString.copy(optionMetaData.getPtr() + 32, strOffset, optionMetaData.length);\r\n            strOffset += optionMetaData.length;\r\n            metaDataLength = optionMetaData.length;\r\n\r\n            assembly { // solium-disable-line security/no-inline-assembly\r\n                mstore(add(script, newOffset), metaDataLength)\r\n            }\r\n\r\n            newOffset += 32;\r\n        }\r\n\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n                mstore(add(script, newOffset), infoStringLength)\r\n        }\r\n\r\n\r\n        script.copy(infoString.getPtr() + 32, newOffset, infoStringLength);\r\n\r\n        newOffset += (infoStringLength / 32) * 32 + (infoStringLength % 32 == 0 ? 0 : 32);\r\n    }\r\n\r\n    function addExternalIds(\r\n        uint256 _actionId,\r\n        bytes script,\r\n        uint256 numberOfOptions,\r\n        uint256 _offset\r\n        ) internal view returns(uint256 offset)\r\n        {\r\n        offset = _offset;\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            mstore(add(script, offset), numberOfOptions)\r\n        }\r\n\r\n        offset += 32;\r\n\r\n        // Copy all option addresses\r\n        for (uint256 i = 0; i < numberOfOptions; i++) {\r\n            //bytes32 canKey = actions[_actionId].optionKeys[i];\r\n            bytes32 externalId1 = actions[_actionId].options[actions[_actionId].optionKeys[i]].externalId1;\r\n            assembly {\r\n                mstore(add(script, offset), externalId1)\r\n            }\r\n            offset += 32;\r\n\r\n        }\r\n\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            mstore(add(script, offset), numberOfOptions)\r\n        }\r\n\r\n        offset += 32;\r\n\r\n        // Copy all support data\r\n        for (i = 0; i < numberOfOptions; i++) {\r\n            bytes32 externalId2 = actions[_actionId].options[actions[_actionId].optionKeys[i]].externalId2;\r\n\r\n            assembly { // solium-disable-line security/no-inline-assembly\r\n                mstore(add(script, offset), externalId2)\r\n            }\r\n            offset += 32;\r\n\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    function memcpyshort(uint _dest, uint _src, uint _len) internal pure {\r\n        uint256 src = _src;\r\n        uint256 dest = _dest;\r\n        uint256 len = _len;\r\n\r\n        // this line is unnecessary since the _len passed in is hard-coded\r\n        //require(_len < 32, \"_len should be less than 32\");\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function encodeInput(uint256 _actionId) internal returns(bytes) {\r\n        Action storage action = actions[_actionId];\r\n        uint256 optionsLength = action.optionKeys.length;\r\n\r\n        // initialize the pointer for the originally parsed script\r\n        bytes memory origExecScript = new bytes(32);\r\n        // set the pointer to the original script\r\n        origExecScript = action.executionScript;\r\n        // dynmaicOffset: The bytevalue in the script where the\r\n        // dynamic-length parameters will be encoded\r\n        // This can probably be hard-coded now that we're nailing down this specification\r\n        uint256 dynamicOffset = origExecScript.uint256At(32);\r\n        // The total length of the new script will be two 32 byte spaces\r\n        // for each candidate (one for support one for address)\r\n        // as well as 3 32 byte spaces for\r\n        // the header (specId 0x4, target address 0x14, calldata 0x4, function hash 0x4)\r\n        // and the two dynamic param locations\r\n        // as well as additional space for the staticParameters\r\n        uint256 infoStrLength = action.infoStringLength;\r\n        uint256 desStrLength = bytes(action.description).length;\r\n        // Calculate the total length of the call script to be encoded\r\n        // 228: The words needed to specify lengths of the various dynamic params\r\n        //      There are  7 dynamic params in this spec so 7 * 32 + function hash = 228\r\n        // dynamicOffset: the byte number where the first parameter's data area begins\r\n        //      This number accounts for the size of the initial parameter locations\r\n        // optionsLength: The quantity of options in the action script multiplied by 160\r\n        //      aince each option will require 5 words for it's data (160 = 32 * 5)\r\n        uint256 callDataLength = 228 + dynamicOffset + optionsLength * 160;\r\n        // add the length of the info and description strings to the total length\r\n        // string lengths that aren't cleanly divisible by 32 require an extra word\r\n        callDataLength += (infoStrLength / 32) * 32 + (infoStrLength % 32 == 0 ? 0 : 32);\r\n        callDataLength += (desStrLength / 32) * 32 + (desStrLength % 32 == 0 ? 0 : 32);\r\n        // initialize a location in memory to copy in the call data length\r\n        bytes memory callDataLengthMem = new bytes(32);\r\n        // copy the call data length into the memory location\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            mstore(add(callDataLengthMem, 32), callDataLength)\r\n        }\r\n        // initialize the script with 28 extra bytes to account for header info:\r\n        //  1. specId (4 bytes)\r\n        //  2. target address (20 bytes)\r\n        //  3. callDataLength itself (4 bytes)\r\n        bytes memory script = new bytes(callDataLength + 28);\r\n        // copy the header info plus the dynamicOffset entry into the first param\r\n        // since it doesn't change\r\n        script.copy(origExecScript.getPtr() + 32,0, 96); // 64 + 32 = 96\r\n        // copy the calldatalength stored in memory into the new script\r\n        memcpyshort((script.getPtr() + 56), callDataLengthMem.getPtr() + 60, 4);\r\n        // calculate and copy in the locations for all dynamic elements\r\n        addDynamicElements(script, dynamicOffset, optionsLength, infoStrLength, desStrLength);\r\n        // copy over remaining static parameters\r\n        script.copy(origExecScript.getPtr() + 288, 256, dynamicOffset - 224); // -256 + 32 = 224\r\n        // add option addresses and option values\r\n        // keep track of current location in the script using offset\r\n        uint256 offset = addAddressesAndActions(_actionId, script, optionsLength, dynamicOffset);\r\n\r\n        offset = _goToParamOffset(INDICIES_PARAM_LOC, script) + 0x20;\r\n        // Copy in the composite info string for all options,\r\n        // along with the indices for each options substring\r\n        offset = addInfoString(_actionId, script, optionsLength, offset);\r\n        //Copy over Description\r\n        offset = _goToParamOffset(DESCRIPTION_PARAM_LOC, script) + 0x20;\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n                mstore(add(script, offset), desStrLength)\r\n        }\r\n        script.copy(bytes(action.description).getPtr() + 32, offset, desStrLength);\r\n        // Copy over External References\r\n        offset = _goToParamOffset(EX_ID1_PARAM_LOC, script) + 0x20;\r\n        addExternalIds(_actionId, script, optionsLength, offset);\r\n        emit OrigScript(origExecScript);\r\n        return script;\r\n    }\r\n\r\n    function parseScript(bytes _executionScript) internal returns(uint256 actionId) {\r\n        actionId = actionsLength++;\r\n        Action storage actionInstance = actions[actionId];\r\n        actionInstance.executionScript = _executionScript;\r\n        actionInstance.infoStringLength = 0;\r\n        // Spec ID must be 1\r\n        require(_executionScript.uint32At(0x0) == 1); // solium-disable-line error-reason\r\n        if (_executionScript.length != 4) {\r\n            _extractOptions(_executionScript, actionId);\r\n        }\r\n        // First Static Parameter in script parsed for the externalId\r\n        actionInstance.externalId = _goToParamOffset(TOTAL_DYNAMIC_PARAMS + 1, _executionScript) - 0x20;\r\n        emit OrigScript(_executionScript);\r\n    }\r\n}\r\n\r\n// File: @tps/apps-dot-voting/contracts/DotVoting.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer: GPL-3.0-or-later\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n// TODO: Revert import path when changes get merged into aragon/os\r\n// import \"@aragon/os/contracts/common/ADynamicForwarder.sol\";\r\n\r\n\r\n\r\ncontract DotVoting is ADynamicForwarder, AragonApp {\r\n\r\n    MiniMeToken public token;\r\n    uint256 public globalCandidateSupportPct;\r\n    uint256 public globalMinQuorum;\r\n    uint64 public voteTime;\r\n    uint256 voteLength;\r\n\r\n    uint256 constant public PCT_BASE = 10 ** 18; // 0% = 0; 1% = 10^16; 100% = 10^18\r\n\r\n\r\n    // bytes32 constant public ROLE_ADD_CANDIDATES = keccak256(\"ROLE_ADD_CANDIDATES\");\r\n    bytes32 constant public ROLE_ADD_CANDIDATES = 0xa71d8ae250b03a7b4831d7ee658104bf1ee3193c61256a07e2008fdfb75c5fa9;\r\n    // bytes32 constant public ROLE_CREATE_VOTES = keccak256(\"ROLE_CREATE_VOTES\");\r\n    bytes32 constant public ROLE_CREATE_VOTES = 0x59036cbdc6597a5655363d74de8211c9fcba4dd9204c466ef593666e56a6e574;\r\n    // bytes32 constant public ROLE_MODIFY_QUORUM = keccak256(\"ROLE_MODIFY_QUORUM\");\r\n    bytes32 constant public ROLE_MODIFY_QUORUM = 0xaa42a0cff9103a0165dffb0f5652f3a480d3fb6edf2c364f5e2110629719a5a7;\r\n    // bytes32 constant public ROLE_MODIFY_CANDIDATE_SUPPORT = keccak256(\"ROLE_MODIFY_CANDIDATE_SUPPORT\");\r\n    bytes32 constant public ROLE_MODIFY_CANDIDATE_SUPPORT = 0xbd671bb523f136ed8ffc557fe00fbb016a7f9f856a4b550bb6366d356dcb8c74;\r\n\r\n    string private constant ERROR_CAN_VOTE = \"ERROR_CAN_VOTE\";\r\n    string private constant ERROR_MIN_QUORUM = \"ERROR_MIN_QUORUM\";\r\n    string private constant ERROR_VOTE_LENGTH = \"ERROR_VOTE_LENGTH\";\r\n\r\n    struct Vote {\r\n        string metadata;\r\n        address creator;\r\n        uint64 startDate;\r\n        uint256 snapshotBlock;\r\n        uint256 candidateSupportPct;\r\n        uint256 minQuorum;\r\n        uint256 totalVoters;\r\n        uint256 totalParticipation;\r\n        mapping (address => uint256[]) voters;\r\n        uint256 actionId;\r\n    }\r\n\r\n    mapping (uint256 => Vote) votes;\r\n\r\n    event StartVote(uint256 indexed voteId);\r\n    event CastVote(uint256 indexed voteId);\r\n    event UpdateCandidateSupport(string indexed candidateKey, uint256 support);\r\n    event ExecuteVote(uint256 indexed voteId);\r\n    event ExecutionScript(bytes script, uint256 data);\r\n    // Add hash info\r\n    event ExternalContract(uint256 indexed voteId, address addr, bytes32 funcSig);\r\n    event AddCandidate(uint256 voteId, address candidate, uint length);\r\n    event Metadata(string metadata);\r\n    event Location(uint256 currentLocation);\r\n    event Address(address candidate);\r\n    event CandidateQty(uint256 numberOfCandidates);\r\n    event UpdateQuorum(uint256 quorum);\r\n    event UpdateMinimumSupport(uint256 minSupport);\r\n\r\n////////////////\r\n// Constructor\r\n////////////////\r\n\r\n   /**\r\n    * @notice Initializes DotVoting app with `_token.symbol(): string` for\r\n    *         governance, minimum quorum of\r\n    *         `(_minQuorum - _minQuorum % 10^14)\r\n    *         / 10^16`, minimal candidate acceptance of\r\n    *         `(_candidateSupportPct - _candidateSupportPct % 10^14) / 10^16`\r\n    *         and vote duations of `(_voteTime - _voteTime % 86400) / 86400`\r\n    *         day `_voteTime >= 172800 ? 's' : ''`\r\n    * @param _token MiniMeToken address that will be used as governance token\r\n    * @param _minQuorum Percentage of voters that must participate in\r\n    *        a dot vote for it to succeed (expressed as a 10^18 percentage,\r\n    *        (eg 10^16 = 1%, 10^18 = 100%)\r\n    * @param _candidateSupportPct Percentage of votes cast that must\r\n    *        support a voting option for it to be valid (expressed as a 10^18\r\n    *        percentage, (eg 10^16 = 1%, 10^18 = 100%)\r\n    * @param _voteTime Seconds that a vote will be open for tokenholders to\r\n    *        vote (unless it is impossible for the fate of the vote to change)\r\n    */\r\n    function initialize(\r\n        MiniMeToken _token,\r\n        uint256 _minQuorum,\r\n        uint256 _candidateSupportPct,\r\n        uint64 _voteTime\r\n    ) external onlyInit\r\n    {\r\n        initialized();\r\n        require(_minQuorum > 0, ERROR_MIN_QUORUM);\r\n        require(_minQuorum <= PCT_BASE, ERROR_MIN_QUORUM);\r\n        require(_minQuorum >= _candidateSupportPct, ERROR_MIN_QUORUM);\r\n        token = _token;\r\n        globalMinQuorum = _minQuorum;\r\n        globalCandidateSupportPct = _candidateSupportPct;\r\n        voteTime = _voteTime;\r\n        voteLength = 1;\r\n    }\r\n\r\n///////////////////////\r\n// Voting functions\r\n///////////////////////\r\n\r\n\r\n    /**\r\n    * @notice Create a new dot vote for \"`_metadata`\". \r\n    * @param _executionScript EVM script to be executed on approval\r\n    * @param _metadata Vote metadata\r\n    * @return voteId Id for newly created vote\r\n    */\r\n    function newVote(bytes _executionScript, string _metadata)\r\n        external auth(ROLE_CREATE_VOTES) returns (uint256 voteId)\r\n    {\r\n        voteId = _newVote(_executionScript, _metadata);\r\n    }\r\n\r\n    /**\r\n    * @notice Cast a dot vote.\r\n    * @param _voteId id for vote structure this 'ballot action' is connected to\r\n    * @param _supports Array of support weights in order of their order in\r\n    *                  `votes[_voteId].candidateKeys`, sum of all supports\r\n    *                  must be less than `token.balance[msg.sender]`.\r\n    */\r\n    function vote(uint256 _voteId, uint256[] _supports)  external isInitialized {\r\n        require(canVote(_voteId, msg.sender), ERROR_CAN_VOTE);\r\n        _vote(_voteId, _supports, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Execute dot vote #`_voteId`.\r\n    * @param _voteId Id for vote\r\n    */\r\n    function executeVote(uint256 _voteId) external isInitialized {\r\n        require(canExecute(_voteId), ERROR_CAN_VOTE);\r\n        _executeVote(_voteId);\r\n    }\r\n\r\n    /**\r\n    * @notice `getCandidate` serves as a basic getter using the description\r\n    *         to return the struct data.\r\n    * @param _voteId id for vote structure this 'ballot action' is connected to\r\n    * @param _candidateIndex The candidate descrciption of the candidate.\r\n    */\r\n    function getCandidate(uint256 _voteId, uint256 _candidateIndex)\r\n    external view isInitialized returns(address candidateAddress, uint256 voteSupport, string metadata, bytes32 externalId1, bytes32 externalId2)\r\n    {\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH); // \"Vote ID outside of current vote range\");\r\n        uint256 actionId = votes[_voteId].actionId;\r\n        Action storage action = actions[actionId];\r\n        uint256 candidateLength = action.optionKeys.length;\r\n        require(_candidateIndex < candidateLength); // solium-disable-line error-reason\r\n        OptionState storage candidate = action.options[action.optionKeys[_candidateIndex]];\r\n        candidateAddress = optionAddresses[action.optionKeys[_candidateIndex]];\r\n        voteSupport = candidate.actionSupport;\r\n        metadata = candidate.metadata;\r\n        externalId1 = candidate.externalId1;\r\n        externalId2 = candidate.externalId2;\r\n    }\r\n\r\n    /**\r\n    * @notice Global parameter change: A dot voting option will require at least `@formatPct(_globalCandidateSupportPct)`% of the votes for it to be considered valid.\r\n    * @param _globalCandidateSupportPct Percentage of votes cast that must support\r\n    *        a voting option for it to be valid (expressed as a 10^18 percentage,\r\n    *        e.g. 10^16 = 1%, 10^18 = 100%)\r\n    */\r\n    function setglobalCandidateSupportPct(uint256 _globalCandidateSupportPct)\r\n    external auth(ROLE_MODIFY_CANDIDATE_SUPPORT)\r\n    {\r\n        require(globalMinQuorum >= _globalCandidateSupportPct); // solium-disable-line error-reason\r\n        globalCandidateSupportPct = _globalCandidateSupportPct;\r\n        emit UpdateMinimumSupport(globalCandidateSupportPct);\r\n    }\r\n\r\n    /**\r\n    * @notice Global parameter change: A dot vote will require a minimum participation from `@formatPct(_minQuorum)`% of the total token supply for the proposal to be considered valid.\r\n    * @param _minQuorum Percentage of voters that must participate in a vote for it\r\n    *        to be considered valid (expressed as a 10^18 percentage, e.g. 10^16 = 1%,\r\n    *        10^18 = 100%)\r\n    */\r\n    function setGlobalQuorum(uint256 _minQuorum)\r\n    external auth(ROLE_MODIFY_QUORUM)\r\n    {\r\n        require(_minQuorum > 0); // solium-disable-line error-reason\r\n        require(_minQuorum <= PCT_BASE); // solium-disable-line error-reason\r\n        require(_minQuorum >= globalCandidateSupportPct); // solium-disable-line error-reason\r\n        globalMinQuorum = _minQuorum;\r\n        emit UpdateQuorum(globalMinQuorum);\r\n    }\r\n\r\n    /**\r\n    * @dev `addCandidate` allows the `ROLE_ADD_CANDIDATES` to add candidates\r\n    *      (aka voting options) to an open dot vote.\r\n    * @notice Add voting option \"`_description`\" to dot vote #`_voteId` for the purpose of `_metadata`.\r\n    * @param _voteId id for vote structure this 'ballot action' is connected to\r\n    * @param _metadata Any additional information about the candidate.\r\n    *        Base implementation does not use this parameter.\r\n    * @param _description This is the address that will be displayed along the\r\n    *        option when voting\r\n    * @param _eId1 External ID 1, can be used for basic candidate information\r\n    * @param _eId2 External ID 2, can be used for basic candidate information\r\n    */\r\n    function addCandidate(uint256 _voteId, string _metadata, address _description, bytes32 _eId1, bytes32 _eId2)\r\n    public auth(ROLE_ADD_CANDIDATES)\r\n    {\r\n        Vote storage voteInstance = votes[_voteId];\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        require(_isVoteOpen(voteInstance)); // solium-disable-line error-reason\r\n        addOption(votes[_voteId].actionId, _metadata, _description, _eId1, _eId2);\r\n    }\r\n\r\n///////////////////////\r\n// IForwarder functions\r\n///////////////////////\r\n\r\n    /**\r\n    * @notice `isForwarder` is a basic helper function used to determine\r\n    *         if a function implements the IForwarder interface\r\n    * @dev IForwarder interface conformance\r\n    * @return always returns true\r\n    */\r\n    function isForwarder() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Used to ensure that the permissions are being handled properly\r\n    *         for the dot vote forwarding\r\n    * @dev IForwarder interface conformance\r\n    * @param _sender Address of the entity trying to forward\r\n    * @return True is `_sender` has correct permissions\r\n    */\r\n    function canForward(address _sender, bytes /*_evmCallScript*/) public view returns (bool) {\r\n        return canPerform(_sender, ROLE_CREATE_VOTES, arr());\r\n    }\r\n\r\n    // * @param _evmCallScript Not used in this implementation\r\n\r\n        /**\r\n    * @notice Creates a vote to execute the desired action\r\n    * @dev IForwarder interface conformance\r\n    * @param _evmScript Start vote with script\r\n    */\r\n    function forward(bytes _evmScript) public { // solium-disable-line function-order\r\n        require(canForward(msg.sender, _evmScript)); // solium-disable-line error-reason\r\n        _newVote(_evmScript, \"\");\r\n    }\r\n\r\n///////////////////////\r\n// View state functions\r\n///////////////////////\r\n\r\n    /**\r\n    * @notice `canVote` is used to check whether an address is elligible to\r\n    *         cast a dot vote in a given dot vote action.\r\n    * @param _voteId The ID of the Vote on which the vote would be cast.\r\n    * @param _voter The address of the entity trying to vote\r\n    * @return True is `_voter` has a vote token balance and vote is open\r\n    */\r\n    function canVote(uint256 _voteId, address _voter) public view isInitialized returns (bool) {\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        Vote storage voteInstance = votes[_voteId];\r\n        return _isVoteOpen(voteInstance) && token.balanceOfAt(_voter, voteInstance.snapshotBlock) > 0;\r\n    }\r\n\r\n    /**\r\n    * @notice `canExecute` is used to check that the participation has been met\r\n    *         and the vote has reached it's end before the execute function is\r\n    *         called.\r\n    * @param _voteId id for vote structure this 'ballot action' is connected to\r\n    * @return True if the vote is elligible for execution.\r\n    */\r\n    function canExecute(uint256 _voteId) public view isInitialized returns (bool) {\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        Vote storage voteInstance = votes[_voteId];\r\n        Action storage action = actions[voteInstance.actionId];\r\n        if (action.executed)\r\n            return false;\r\n         // vote ended?\r\n        if (_isVoteOpen(voteInstance))\r\n          return false;\r\n         // has minimum participation threshold been reached?\r\n        if (!_isValuePct(voteInstance.totalParticipation, voteInstance.totalVoters, voteInstance.minQuorum))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice `getVote` splits all of the data elements out of a vote\r\n    *         struct and returns the individual values.\r\n    * @param _voteId The ID of the Vote struct in the `votes` array\r\n    */\r\n    function getVote(uint256 _voteId) public view isInitialized returns\r\n    (\r\n        bool open,\r\n        address creator,\r\n        uint64 startDate,\r\n        uint256 snapshotBlock,\r\n        uint256 candidateSupport,\r\n        uint256 totalVoters,\r\n        uint256 totalParticipation,\r\n        uint256 externalId,\r\n        bytes executionScript, // script,\r\n        bool executed,\r\n        string voteDescription\r\n    ) { // solium-disable-line lbrace\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        Vote storage voteInstance = votes[_voteId];\r\n        Action memory action = actions[voteInstance.actionId];\r\n        open = _isVoteOpen(voteInstance);\r\n        creator = voteInstance.creator;\r\n        startDate = voteInstance.startDate;\r\n        snapshotBlock = voteInstance.snapshotBlock;\r\n        candidateSupport = voteInstance.candidateSupportPct;\r\n        totalVoters = voteInstance.totalVoters;\r\n        totalParticipation = voteInstance.totalParticipation;\r\n        executionScript = action.executionScript;\r\n        executed = action.executed;\r\n        externalId = action.externalId;\r\n        voteDescription = action.description;\r\n    }\r\n\r\n        /**\r\n    * @notice `getCandidateLength` returns the total number of voting options for\r\n    *         a given dot vote.\r\n    * @param _voteId The ID of the Vote struct in the `votes` array\r\n    */\r\n    function getCandidateLength(uint256 _voteId) public view isInitialized returns\r\n    ( uint totalCandidates ) { // solium-disable-line lbrace\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        uint256 actionId = votes[_voteId].actionId;\r\n        totalCandidates = actions[actionId].optionKeys.length;\r\n    }\r\n\r\n    /**\r\n    * @notice `getVoteMetadata` returns the vote metadata for a given dot vote.\r\n    * @param _voteId The ID of the Vote struct in the `votes` array\r\n    */\r\n    function getVoteMetadata(uint256 _voteId) public view isInitialized returns (string) {\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        return votes[_voteId].metadata;\r\n    }\r\n\r\n    /**\r\n    * @notice `getVoterState` returns the voting power for a given voter.\r\n    * @param _voteId The ID of the Vote struct in the `votes` array.\r\n    * @param _voter The voter whose weights will be returned\r\n    */\r\n    function getVoterState(uint256 _voteId, address _voter) public view isInitialized returns (uint256[]) {\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        return votes[_voteId].voters[_voter];\r\n    }\r\n\r\n///////////////////////\r\n// Internal functions\r\n///////////////////////\r\n\r\n    /**\r\n    * @notice `_newVote` starts a new vote and adds it to the votes array.\r\n    *         votes are not started with a vote from the caller, as candidates\r\n    *         and candidate weights need to be supplied.\r\n    * @param _executionScript The script that will be executed when\r\n    *        this vote closes. Script is of the following form:\r\n    *            [ specId (uint32: 4 bytes) ] many calls with this structure ->\r\n    *            [ to (address: 20 bytes) ]\r\n    *            [calldataLength (uint32: 4 bytes) ]\r\n    *            [ function hash (uint32: 4 bytes) ]\r\n    *            [ calldata (calldataLength bytes) ]\r\n    *        In order to work with a dot vote the execution script must contain\r\n    *        Arrays as its first six parameters. Non-string array lengths must all equal candidateLength\r\n    *        The first Array is generally a list of identifiers (address)\r\n    *        The second array will be composed of support value (uint256).\r\n    *        The third array will be end index for each candidates Information within the infoString (optional uint256)\r\n    *        The fourth array is a string of concatenated candidate information, the infoString (optional string)\r\n    *        The fifth array is used for description params (optional string)\r\n    *        The sixth array is an array of identification keys (optional uint256)\r\n    *        The seventh array is a second array of identification keys, usually mapping to a second level (optional uint256)\r\n    *        The eigth parameter is used as the identifier for this vote. (uint256)\r\n    *        See ExecutionTarget.sol in the test folder for an example  forwarded function (setSignal)\r\n    * @param _metadata The metadata or vote information attached to the vote.\r\n    * @return voteId The ID(or index) of this vote in the votes array.\r\n    */\r\n    function _newVote(bytes _executionScript, string _metadata) internal\r\n    isInitialized returns (uint256 voteId)\r\n    {\r\n        require(_executionScript.uint32At(0x0) == 1); // solium-disable-line error-reason\r\n        uint256 actionId = parseScript(_executionScript);\r\n        voteId = voteLength++;\r\n        Vote storage voteInstance = votes[voteId];\r\n        voteInstance.creator = msg.sender;\r\n        voteInstance.metadata = _metadata;\r\n        voteInstance.actionId = actionId;\r\n        voteInstance.startDate = uint64(block.timestamp); // solium-disable-line security/no-block-members\r\n        voteInstance.snapshotBlock = getBlockNumber() - 1; // avoid double voting in this very block\r\n        voteInstance.totalVoters = token.totalSupplyAt(voteInstance.snapshotBlock);\r\n        voteInstance.candidateSupportPct = globalCandidateSupportPct;\r\n        voteInstance.minQuorum = globalMinQuorum;\r\n        // First Static Parameter in script parsed for the externalId\r\n        emit ExternalContract(voteId, _executionScript.addressAt(0x4),_executionScript.bytes32At(0x0));\r\n        emit StartVote(voteId);\r\n        emit ExecutionScript(_executionScript, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev `_vote` is the internal function that allows a token holder to\r\n    *         caste a vote on the current options.\r\n    * @param _voteId id for vote structure this 'ballot action' is connected to\r\n    * @param _supports Array of support weights in order of their order in\r\n    *        `votes[_voteId].candidateKeys`, sum of all supports must be less\r\n    *        than `token.balance[msg.sender]`.\r\n    * @param _voter The address of the entity \"casting\" this vote action.\r\n    */\r\n    function _vote(\r\n        uint256 _voteId,\r\n        uint256[] _supports,\r\n        address _voter\r\n    ) internal\r\n    {\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        Vote storage voteInstance = votes[_voteId];\r\n        Action storage action = actions[voteInstance.actionId];\r\n\r\n        // this could re-enter, though we can asume the\r\n        // governance token is not maliciuous\r\n        uint256 voterStake = token.balanceOfAt(_voter, voteInstance.snapshotBlock);\r\n        uint256 totalSupport = 0;\r\n\r\n        emit CastVote(_voteId);\r\n\r\n\r\n        uint256 voteSupport;\r\n        uint256[] storage oldVoteSupport = voteInstance.voters[msg.sender];\r\n        bytes32[] storage cKeys = action.optionKeys;\r\n        uint256 supportsLength = _supports.length;\r\n        uint256 oldSupportLength = oldVoteSupport.length;\r\n        uint256 totalParticipation = voteInstance.totalParticipation;\r\n        require(cKeys.length == supportsLength); // solium-disable-line error-reason\r\n        require(oldSupportLength <= supportsLength); // solium-disable-line error-reason\r\n        _checkTotalSupport(_supports, voterStake);\r\n        uint256 i = 0;\r\n        // This is going to cost a lot of gas... it'd be cool if there was\r\n        // a better way to do this.\r\n        //totalParticipation = _syncOldSupports(oldSupportLength, )\r\n        for (i; i < oldSupportLength; i++) {\r\n            voteSupport = action.options[cKeys[i]].actionSupport;\r\n            totalParticipation = totalParticipation.sub(oldVoteSupport[i]);\r\n            voteSupport = voteSupport.sub(oldVoteSupport[i]);\r\n            voteSupport = voteSupport.add(_supports[i]);\r\n            totalParticipation = totalParticipation.add(_supports[i]);\r\n            action.options[cKeys[i]].actionSupport = voteSupport;\r\n        }\r\n        for (i; i < supportsLength; i++) {\r\n            voteSupport = action.options[cKeys[i]].actionSupport;\r\n            voteSupport = voteSupport.add(_supports[i]);\r\n            totalParticipation = totalParticipation.add(_supports[i]);\r\n            action.options[cKeys[i]].actionSupport = voteSupport;\r\n        }\r\n        voteInstance.totalParticipation = totalParticipation;\r\n        voteInstance.voters[msg.sender] = _supports;\r\n    }\r\n\r\n    function _checkTotalSupport(uint256[] _supports, uint256 _voterStake) internal {\r\n        uint256 totalSupport;\r\n        for (uint64 i = 0; i < _supports.length; i++) {\r\n            totalSupport = totalSupport.add(_supports[i]);\r\n        }\r\n        require(totalSupport <= _voterStake); // solium-disable-line error-reason\r\n    }\r\n\r\n    /**\r\n    * @notice `_pruneVotes` trims out options that don't meet the minimum support pct.\r\n    */\r\n    function _pruneVotes(uint256 _voteId, uint256 _candidateSupportPct) internal {\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        Vote storage voteInstance = votes[_voteId];\r\n        uint256 actionId = voteInstance.actionId;\r\n        Action storage action = actions[actionId];\r\n        bytes32[] memory candidateKeys = actions[actionId].optionKeys;\r\n        uint256 candidateLength = candidateKeys.length;\r\n        for (uint256 i = 0; i < candidateLength; i++) {\r\n            bytes32 key = candidateKeys[i];\r\n            OptionState storage candidateState = action.options[key];\r\n            if (!_isValuePct(candidateState.actionSupport, voteInstance.totalParticipation, voteInstance.candidateSupportPct)) {\r\n                voteInstance.totalParticipation -= candidateState.actionSupport;\r\n                candidateState.actionSupport = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice `_executeVote` executes the provided script for this vote and\r\n    *         passes along the candidate data to the next function.\r\n    * @return voteId The ID(or index) of this vote in the votes array.\r\n    */\r\n    function _executeVote(uint256 _voteId) internal {\r\n        require(_voteId < voteLength, ERROR_VOTE_LENGTH);\r\n        Vote storage voteInstance = votes[_voteId];\r\n        uint256 actionId = voteInstance.actionId;\r\n        Action storage action = actions[actionId];\r\n        uint256 candidateSupportPct = voteInstance.candidateSupportPct;\r\n        if (candidateSupportPct > 0) {\r\n            _pruneVotes(_voteId, candidateSupportPct);\r\n        }\r\n        bytes memory script = encodeInput(voteInstance.actionId);\r\n        emit ExecutionScript(script, 0);\r\n        action.executed = true;\r\n        runScript(script, new bytes(0), new address[](0));\r\n        emit ExecuteVote(_voteId);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks whether vote time has passed and whether vote has executed\r\n    */\r\n    function _isVoteOpen(Vote storage voteArg) internal view returns (bool) {\r\n        bool voteWithinTime = uint64(block.timestamp) < (voteArg.startDate.add(voteTime)); // solium-disable-line security/no-block-members\r\n        return voteWithinTime && !actions[voteArg.actionId].executed;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates whether `_value` is at least a percentage `_pct` of `_total`\r\n    */\r\n    function _isValuePct(uint256 _value, uint256 _total, uint256 _pct)\r\n        internal pure returns (bool)\r\n    {\r\n        // if (_total == 0) {\r\n        if (_value == 0 && _total > 0)\r\n            return false;\r\n        // }\r\n\r\n        uint256 m = _total.mul(_pct);\r\n        uint256 v = m / PCT_BASE;\r\n        // uint256 computedPct = _value.mul(PCT_BASE) / _total;\r\n\r\n        // return computedPct >= _pct;\r\n\r\n        // If division is exact, allow same value,\r\n        // otherwise require value to be greater\r\n        return m % PCT_BASE == 0 ? _value >= v : _value > v;\r\n    }\r\n}\r\n\r\n// File: contracts/BaseCache.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract BaseCache is BaseTemplate {\r\n    // string constant private ERROR_MISSING_BASE_CACHE = \"TEMPLATE_MISSING_BASE_CACHE\";\r\n\r\n    struct InstalledBase {\r\n        ACL acl;\r\n        Kernel dao;\r\n        Vault vault;\r\n    }\r\n\r\n    struct InstalledTokens {\r\n        MiniMeToken token1;\r\n        MiniMeToken token2;\r\n    }\r\n\r\n    struct InstalledTokenManagers {\r\n        TokenManager tokenManager1;\r\n        TokenManager tokenManager2;\r\n        WhitelistOracle whitelist;\r\n    }\r\n\r\n    struct InstalledVotingApps {\r\n        DotVoting dotVoting;\r\n        Voting voting;\r\n        bool secondaryDot;\r\n        bool secondaryVoting;\r\n    }\r\n\r\n    mapping (address => InstalledBase) internal baseCache;\r\n    mapping (address => InstalledTokens) internal tokensCache;\r\n    mapping (address => InstalledTokenManagers) internal tokenManagersCache;\r\n    mapping (address => InstalledVotingApps) internal votingAppsCache;\r\n\r\n    constructor(address[5] _deployedSetupContracts)\r\n        BaseTemplate(\r\n            DAOFactory(_deployedSetupContracts[0]),\r\n            ENS(_deployedSetupContracts[1]),\r\n            MiniMeTokenFactory(_deployedSetupContracts[2]),\r\n            IFIFSResolvingRegistrar(_deployedSetupContracts[3])\r\n    ) {}\r\n\r\n    function _cacheBase(\r\n        ACL _acl,\r\n        Kernel _dao,\r\n        Vault _vault,\r\n        address _owner\r\n    ) internal\r\n    {\r\n        InstalledBase storage baseInstance = baseCache[_owner];\r\n        baseInstance.acl = _acl;\r\n        baseInstance.dao = _dao;\r\n        baseInstance.vault = _vault;\r\n    }\r\n\r\n    function _cacheTokens(\r\n        MiniMeToken _token1,\r\n        MiniMeToken _token2,\r\n        address _owner\r\n    ) internal\r\n    {\r\n        InstalledTokens storage tokensInstance = tokensCache[_owner];\r\n        tokensInstance.token1 = _token1;\r\n        tokensInstance.token2 = _token2;\r\n    }\r\n\r\n    function _cacheTokenManagers(\r\n        TokenManager _tokenManager1,\r\n        TokenManager _tokenManager2,\r\n        WhitelistOracle _whitelist,\r\n        address _owner\r\n    ) internal\r\n    {\r\n        InstalledTokenManagers storage tokenManagersInstance = tokenManagersCache[_owner];\r\n        tokenManagersInstance.tokenManager1 = _tokenManager1;\r\n        tokenManagersInstance.tokenManager2 = _tokenManager2;\r\n        tokenManagersInstance.whitelist = _whitelist;\r\n    }\r\n\r\n    function _cacheVotingApps(\r\n        DotVoting _dotVoting,\r\n        Voting _voting,\r\n        bool _secondaryDot,\r\n        bool _secondaryVoting,\r\n        address _owner\r\n    ) internal\r\n    {\r\n        InstalledVotingApps storage votingAppsInstance = votingAppsCache[_owner];\r\n        votingAppsInstance.dotVoting = _dotVoting;\r\n        votingAppsInstance.voting = _voting;\r\n        votingAppsInstance.secondaryDot = _secondaryDot;\r\n        votingAppsInstance.secondaryVoting = _secondaryVoting;\r\n    }\r\n\r\n    function _popBaseCache(address _owner) internal returns (ACL, Kernel, Vault) {\r\n        // require(baseCache[_owner] != address(0), ERROR_MISSING_BASE_CACHE);\r\n\r\n        InstalledBase storage baseInstance = baseCache[_owner];\r\n        ACL acl = baseInstance.acl;\r\n        Kernel dao = baseInstance.dao;\r\n        Vault vault = baseInstance.vault;\r\n\r\n        delete baseCache[_owner];\r\n        return (acl, dao, vault);\r\n    }\r\n\r\n    function _popTokensCache(address _owner) internal returns (MiniMeToken, MiniMeToken) {\r\n        InstalledTokens storage tokensInstance = tokensCache[_owner];\r\n        MiniMeToken token1 = tokensInstance.token1;\r\n        MiniMeToken token2 = tokensInstance.token2;\r\n\r\n        delete tokensCache[_owner];\r\n        return (token1, token2);\r\n    }\r\n\r\n    function _popTokenManagersCache(address _owner) internal returns (TokenManager, TokenManager, WhitelistOracle) {\r\n        InstalledTokenManagers storage tokenManagersInstance = tokenManagersCache[_owner];\r\n        TokenManager tokenManager1 = tokenManagersInstance.tokenManager1;\r\n        TokenManager tokenManager2 = tokenManagersInstance.tokenManager2;\r\n        WhitelistOracle whitelist = tokenManagersInstance.whitelist;\r\n\r\n        delete tokenManagersCache[_owner];\r\n        return (tokenManager1, tokenManager2, whitelist);\r\n    }\r\n\r\n    function _popVotingAppsCache(address _owner) internal returns (DotVoting, Voting, bool, bool) {\r\n        InstalledVotingApps storage votingAppsInstance = votingAppsCache[_owner];\r\n        DotVoting dotVoting = votingAppsInstance.dotVoting;\r\n        Voting voting = votingAppsInstance.voting;\r\n        bool secondaryDot = votingAppsInstance.secondaryDot;\r\n        bool secondaryVoting = votingAppsInstance.secondaryVoting;\r\n\r\n        delete votingAppsCache[_owner];\r\n        return (dotVoting, voting, secondaryDot, secondaryVoting);\r\n    }\r\n}\r\n\r\n// File: contracts/BaseOEApps.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BaseOEApps is BaseCache {\r\n// Hard-coded constants to save gas\r\n    // bytes32 constant internal ADDRESS_BOOK_APP_ID = apmNamehash(\"address-book\");              // address-book.aragonpm.eth\r\n    // bytes32 constant internal ALLOCATIONS_APP_ID = apmNamehash(\"allocations\");              // allocations.aragonpm.eth;\r\n    // bytes32 constant internal DISCUSSIONS_APP_ID = apmNamehash(\"discussions\");            // discussions.aragonpm.eth;\r\n    // bytes32 constant internal DOT_VOTING_APP_ID = apmNamehash(\"dot-voting\");            // dot-voting.aragonpm.eth;\r\n    // bytes32 constant internal PROJECTS_APP_ID = apmNamehash(\"projects\");              // projects.aragonpm.eth;\r\n    // bytes32 constant internal REWARDS_APP_ID = apmNamehash(\"rewards\");              // rewards.aragonpm.eth;\r\n    bytes32 constant internal ADDRESS_BOOK_APP_ID = 0x32ec8cc9f3136797e0ae30e7bf3740905b0417b81ff6d4a74f6100f9037425de;\r\n    bytes32 constant internal ALLOCATIONS_APP_ID = 0x370ef8036e8769f293a3d9c1362d0e21bdfa4e0465d2cd9cf196ebd4ba75aa8b;\r\n    bytes32 constant internal DISCUSSIONS_APP_ID = 0xf8c9b8210902c14e71192ea564edd090c1659cbef1384e362fb508d396d72a38;\r\n    bytes32 constant internal DOT_VOTING_APP_ID = 0x6bf2b7dbfbb51844d0d6fdc211b014638011261157487ccfef5c2e4fb26b1d7e;\r\n    bytes32 constant internal PROJECTS_APP_ID = 0xac5c7cc8f4ed07bb3543b5a4152c4f1a045e1be68bd86e2cf6720b680d1d14f3;\r\n    bytes32 constant internal REWARDS_APP_ID = 0x3ca69801a60916e9222ceb2fa3089b3f66b4e1b3fc49f4a562043d9ec1e5a00b;\r\n\r\n    string constant private ERROR_BOUNTIES_NOT_CONTRACT = \"BOUNTIES_REGISTRY_NOT_CONTRACT\";\r\n    address constant internal ANY_ENTITY = address(-1);\r\n    Bounties internal bountiesRegistry;\r\n    address[] private whiteListed = [address(0), address(0), address(0)];\r\n\r\n    /**\r\n    * @dev Constructor for Open Enterprise Apps DAO\r\n    * @param _deployedSetupContracts Array of [DaoFactory, ENS, MiniMeTokenFactory, AragonID, StandardBounties]\r\n    *       required pre-deployed contracts to set up the organization\r\n    */\r\n    constructor(address[5] _deployedSetupContracts)\r\n        BaseCache(_deployedSetupContracts)\r\n        // internal // TODO: This makes the contract abstract\r\n        public\r\n    {\r\n        _ensureAragonIdIsValid(_deployedSetupContracts[3]);\r\n        _ensureMiniMeFactoryIsValid(_deployedSetupContracts[2]);\r\n        require(isContract(address(_deployedSetupContracts[4])), ERROR_BOUNTIES_NOT_CONTRACT);\r\n\r\n        bountiesRegistry = Bounties(_deployedSetupContracts[4]);\r\n        whiteListed[1] = address(bountiesRegistry);\r\n    }\r\n\r\n/* ADDRESS-BOOK */\r\n\r\n    function _installAddressBookApp(Kernel _dao) internal returns (AddressBook) {\r\n        bytes memory initializeData = abi.encodeWithSelector(AddressBook(0).initialize.selector);\r\n        return AddressBook(_installNonDefaultApp(_dao, ADDRESS_BOOK_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createAddressBookPermissions(ACL _acl, AddressBook _addressBook, address _grantee, address _manager) internal {\r\n        _acl.createPermission(_grantee, _addressBook, _addressBook.ADD_ENTRY_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _addressBook, _addressBook.REMOVE_ENTRY_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _addressBook, _addressBook.UPDATE_ENTRY_ROLE(), _manager);\r\n    }\r\n\r\n/* ALLOCATIONS */\r\n\r\n    function _installAllocationsApp(Kernel _dao, Vault _vault, uint64 _periodDuration) internal returns (Allocations) {\r\n        bytes memory initializeData = abi.encodeWithSelector(Allocations(0).initialize.selector, _vault, _periodDuration);\r\n        return Allocations(_installNonDefaultApp(_dao, ALLOCATIONS_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createAllocationsPermissions(\r\n        ACL _acl,\r\n        Allocations _allocations,\r\n        address _createAllocationsGrantee,\r\n        address _createAccountsGrantee,\r\n        address _manager\r\n    )\r\n        internal\r\n    {\r\n        _acl.createPermission(_createAccountsGrantee, _allocations, _allocations.CREATE_ACCOUNT_ROLE(), _manager);\r\n        _acl.createPermission(_createAccountsGrantee, _allocations, _allocations.CHANGE_BUDGETS_ROLE(), _manager);\r\n        _acl.createPermission(_createAllocationsGrantee, _allocations, _allocations.CREATE_ALLOCATION_ROLE(), _manager);\r\n        _acl.createPermission(ANY_ENTITY, _allocations, _allocations.EXECUTE_ALLOCATION_ROLE(), _manager);\r\n        _acl.createPermission(ANY_ENTITY, _allocations, _allocations.EXECUTE_PAYOUT_ROLE(), _manager);\r\n    }\r\n\r\n/* DOT-VOTING */\r\n\r\n    /**\r\n     * @param _dotVotingSettings Array of [minQuorum, candidateSupportPct, voteDuration] to set up the dot voting app of the organization\r\n     **/\r\n    function _installDotVotingApp(Kernel _dao, MiniMeToken _token, uint64[3] memory _dotVotingSettings) internal returns (DotVoting) {\r\n        return _installDotVotingApp(_dao, _token, _dotVotingSettings[0], _dotVotingSettings[1], _dotVotingSettings[2]);\r\n    }\r\n\r\n    function _installDotVotingApp(\r\n        Kernel _dao,\r\n        MiniMeToken _token,\r\n        uint64 _quorum,\r\n        uint64 _support,\r\n        uint64 _duration\r\n    )\r\n        internal returns (DotVoting)\r\n    {\r\n        bytes memory initializeData = abi.encodeWithSelector(DotVoting(0).initialize.selector, _token, _quorum, _support, _duration);\r\n        return DotVoting(_installNonDefaultApp(_dao, DOT_VOTING_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createDotVotingPermissions(\r\n        ACL _acl,\r\n        DotVoting _dotVoting,\r\n        address _grantee,\r\n        address _manager\r\n    )\r\n        internal\r\n    {\r\n        _acl.createPermission(_grantee, _dotVoting, _dotVoting.ROLE_CREATE_VOTES(), _manager);\r\n    }\r\n\r\n/* DISCUSSIONS */\r\n\r\n    function _installDiscussionsApp(Kernel _dao) internal returns (DiscussionApp) {\r\n        bytes memory initializeData = abi.encodeWithSelector(DiscussionApp(0).initialize.selector);\r\n        return DiscussionApp(_installNonDefaultApp(_dao, DISCUSSIONS_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createDiscussionsPermissions(ACL _acl, DiscussionApp _discussions, address _grantee, address _manager) internal {\r\n        _acl.createPermission(_grantee, _discussions, _discussions.EMPTY_ROLE(), _manager);\r\n    }\r\n\r\n/* PROJECTS */\r\n\r\n    function _installProjectsApp(Kernel _dao, Vault _vault) internal returns (Projects) {\r\n        bytes memory initializeData = abi.encodeWithSelector(Projects(0).initialize.selector, bountiesRegistry, _vault);\r\n        return Projects(_installNonDefaultApp(_dao, PROJECTS_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createProjectsPermissions(\r\n        ACL _acl,\r\n        Projects _projects,\r\n        address _curator,\r\n        address _grantee,\r\n        address _manager\r\n    )\r\n        internal\r\n    {\r\n        _acl.createPermission(_curator, _projects, _projects.CURATE_ISSUES_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _projects, _projects.FUND_ISSUES_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _projects, _projects.REMOVE_ISSUES_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _projects, _projects.FUND_OPEN_ISSUES_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _projects, _projects.UPDATE_BOUNTIES_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _projects, _projects.ADD_REPO_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _projects, _projects.CHANGE_SETTINGS_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _projects, _projects.REMOVE_REPO_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _projects, _projects.REVIEW_APPLICATION_ROLE(), _manager);\r\n        _acl.createPermission(_grantee, _projects, _projects.WORK_REVIEW_ROLE(), _manager);\r\n    }\r\n\r\n/* REWARDS */\r\n\r\n    function _installRewardsApp(Kernel _dao, Vault _vault) internal returns (Rewards) {\r\n        bytes memory initializeData = abi.encodeWithSelector(Rewards(0).initialize.selector, _vault);\r\n        return Rewards(_installNonDefaultApp(_dao, REWARDS_APP_ID, initializeData));\r\n    }\r\n\r\n    function _createRewardsPermissions(\r\n        ACL _acl,\r\n        Rewards _rewards,\r\n        address _grantee,\r\n        address _manager\r\n    )\r\n        internal\r\n    {\r\n        _acl.createPermission(_grantee, _rewards, _rewards.ADD_REWARD_ROLE(), _manager);\r\n    }\r\n\r\n/* WHITELIST-ORACLE */\r\n\r\n    function _initializeWhitelistOracleApp(WhitelistOracle _whitelist, address _vault, address _finance) internal {\r\n        whiteListed[0] = _vault;\r\n        whiteListed[2] = _finance;\r\n        _whitelist.initialize(whiteListed);\r\n    }\r\n\r\n/* OPEN ENTERPRISE SPECIFIC VAULT PERMISSIONS */\r\n\r\n    function _grantVaultPermissions(ACL _acl, Vault _vault, Allocations _allocations, Projects _projects, Rewards _rewards) internal {\r\n        _acl.grantPermission(_allocations, _vault, _vault.TRANSFER_ROLE());\r\n        _acl.grantPermission(_projects, _vault, _vault.TRANSFER_ROLE());\r\n        _acl.grantPermission(_rewards, _vault, _vault.TRANSFER_ROLE());\r\n    }\r\n\r\n    /**\r\n     * @dev Overloaded from BaseTemplate to remove granted permissions, not needed for Open Enterprise\r\n     */\r\n    function _transferPermissionFromTemplate(ACL _acl, address _app, bytes32 _permission, address _manager) internal {\r\n        _acl.revokePermission(address(this), _app, _permission);\r\n        _acl.setPermissionManager(_manager, _app, _permission);\r\n    }\r\n}\r\n\r\n// File: contracts/OpenEnterpriseTemplate.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract OpenEnterpriseTemplate is BaseOEApps {\r\n    string constant private ERROR_MISSING_MEMBERS = \"OPEN_ENTERPRISE_MISSING_MEMBERS\";\r\n    string constant private ERROR_BAD_VOTE_SETTINGS = \"OPEN_ENTERPRISE_BAD_VOTE_SETTINGS\";\r\n    string constant private ERROR_BAD_DOT_VOTE_SETTINGS = \"OPEN_ENTERPRISE_BAD_DOT_VOTE_SETTINGS\";\r\n    string constant private ERROR_BAD_MEMBERS_STAKES_LEN = \"OPEN_ENTERPRISE_BAD_MEMBER_STAKES_LEN\";\r\n\r\n    uint64 constant private DEFAULT_PERIOD = uint64(30 days);\r\n    uint8 constant private TOKEN_DECIMALS = uint8(18);\r\n    uint256 constant private UNLIMITED_TOKENS = uint256(0);\r\n    uint256 constant private ONE_TOKEN = uint256(1e18);\r\n\r\n    /**\r\n     * @dev Constructor for Open Enterprise Apps DAO\r\n     * @param _deployedSetupContracts Array of [DaoFactory, ENS, MiniMeTokenFactory, AragonID, StandardBounties]\r\n     *       required pre-deployed contracts to set up the organization\r\n    */\r\n    constructor(address[5] _deployedSetupContracts) BaseOEApps(_deployedSetupContracts) public {}\r\n\r\n    /**\r\n     * @dev Create a new MiniMe token and deploy a Open Enterprise DAO.\r\n     * @param _id String with the name for org, will assign `[id].aragonid.eth`\r\n    */\r\n    function newTokensAndInstance(\r\n        string _id,\r\n        string _name1,\r\n        string _symbol1,\r\n        string _name2,\r\n        string _symbol2,\r\n        uint64[6] _votingSettings,\r\n        bool[2] _votingBools,\r\n        bool _useAgentAsVault\r\n    )\r\n        external\r\n    {\r\n        (MiniMeToken token1, MiniMeToken token2) = newTokens(_name1, _symbol1, _name2, _symbol2);\r\n        _newInstance(_id, _votingSettings, _votingBools, token1, token2, _useAgentAsVault);\r\n    }\r\n\r\n    /**\r\n     * @dev Install and configure TokenManager apps for previously created tokens\r\n     * @param _tokenBools Array of [fixedStake1?, transferable1?, fixedStake2?, transferable2?]\r\n     *       related to the tokens settings\r\n     */\r\n    function newTokenManagers(\r\n        address[] _members1,\r\n        uint256[] _stakes1,\r\n        address[] _members2,\r\n        uint256[] _stakes2,\r\n        bool[4] _tokenBools\r\n    ) public\r\n    {\r\n        _validateTokenSettings(_members1, _stakes1);\r\n        _validateTokenSettings(_members2, _stakes2);\r\n        (ACL acl, Kernel dao, Vault agentOrVault) = _popBaseCache(msg.sender);\r\n        (MiniMeToken token1, MiniMeToken token2) = _popTokensCache(msg.sender);\r\n        TokenManager tokenManager2 = TokenManager(0);\r\n        WhitelistOracle whitelist = WhitelistOracle(0);\r\n\r\n        // Token 1 setup\r\n        TokenManager tokenManager1 = _installTokenManagerApp(\r\n            dao,\r\n            token1,\r\n            true, // it always needs to be transferable\r\n            _tokenBools[0] ? ONE_TOKEN : UNLIMITED_TOKENS\r\n        );\r\n\r\n        // Token 1 quasi-transferable\r\n        if (!_tokenBools[1]) { // token1 transferable?\r\n            if (address(whitelist) == address(0)) {\r\n                whitelist = _installWhitelistOracleApp(dao);\r\n                _setOracle(acl, tokenManager1, whitelist);\r\n            }\r\n        }\r\n\r\n        // If token2 is set\r\n        if (address(token2) != address(0)) {\r\n            tokenManager2 = _installTokenManagerApp(dao, token2, true, _tokenBools[2] ? ONE_TOKEN : UNLIMITED_TOKENS);\r\n            _mintTokens(acl, tokenManager2, _members2, _stakes2);\r\n            if (!_tokenBools[3]) { // token2 transferable?\r\n                whitelist = _installWhitelistOracleApp(dao);\r\n                _setOracle(acl, tokenManager2, whitelist);\r\n            }\r\n        }\r\n\r\n        _mintTokens(acl, tokenManager1, _members1, _stakes1);\r\n        _cacheBase(acl, dao, agentOrVault, msg.sender);\r\n        _cacheTokenManagers(tokenManager1, tokenManager2, whitelist, msg.sender);\r\n    }\r\n\r\n    function finalizeDao(\r\n        uint64[2] _periods,\r\n        bool _useDiscussions\r\n    ) public\r\n    {\r\n        (ACL acl, Kernel dao, Vault agentOrVault) = _popBaseCache(msg.sender);\r\n        AddressBook addressBook = _installAddressBookApp(dao);\r\n        Allocations allocations = _installAllocationsApp(dao, agentOrVault, _periods[0] == 0 ? DEFAULT_PERIOD : _periods[0]);\r\n        Finance finance = _installFinanceApp(dao, agentOrVault, _periods[1] == 0 ? DEFAULT_PERIOD : _periods[1]);\r\n        Projects projects = _installProjectsApp(dao, agentOrVault);\r\n        Rewards rewards = _installRewardsApp(dao, agentOrVault);\r\n        DiscussionApp discussions = DiscussionApp(0);\r\n        if (_useDiscussions) {\r\n            discussions = _installDiscussionsApp(dao);\r\n        }\r\n        _setupPermissions(\r\n            acl,\r\n            dao,\r\n            addressBook,\r\n            allocations,\r\n            discussions,\r\n            finance,\r\n            projects,\r\n            rewards,\r\n            agentOrVault\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new MiniMe token and cache it for the user\r\n     * @param _name1 String with the name for the primary token used by share holders in the organization\r\n     * @param _name2 String with the name for the reputation token used in the organization\r\n     * @param _symbol1 String with the symbol for the primary token used by share holders in the organization\r\n     * @param _symbol2 String with the symbol for the reputation token used in the organization\r\n    */\r\n    function newTokens(\r\n        string _name1,\r\n        string _symbol1,\r\n        string _name2,\r\n        string _symbol2\r\n    )\r\n    public returns (MiniMeToken, MiniMeToken)\r\n    {\r\n        MiniMeToken token1 = _createToken(_name1, _symbol1, TOKEN_DECIMALS);\r\n        MiniMeToken token2 = MiniMeToken(0);\r\n        if (keccak256(abi.encodePacked(_symbol2)) != keccak256(abi.encodePacked(\"\"))) {\r\n            token2 = _createToken(_name2, _symbol2, TOKEN_DECIMALS);\r\n        }\r\n        _cacheTokens(token1, token2, msg.sender);\r\n\r\n        return (token1, token2);\r\n    }\r\n\r\n    /**\r\n     * @dev Deploy a Open Enterprise DAO using a previously cached MiniMe token\r\n     * @param _id String with the name for org, will assign `[id].aragonid.eth`\r\n     * @param _votingBools Array of 2 booleans to select reference for apps:\r\n     *                     [DotVotingToken, VotingToken] true will select token2 as controller\r\n    */\r\n    function _newInstance(\r\n        string _id,\r\n        uint64[6] memory _votingSettings,\r\n        bool[2] memory _votingBools,\r\n        MiniMeToken _token1,\r\n        MiniMeToken _token2,\r\n        bool _useAgentAsVault\r\n    )\r\n        internal\r\n    {\r\n        _validateId(_id);\r\n        _validateVotingSettings(_votingSettings);\r\n\r\n        (Kernel dao, ACL acl) = _createDAO();\r\n        Vault agentOrVault = _useAgentAsVault ? _installDefaultAgentApp(dao) : _installVaultApp(dao);\r\n        DotVoting dotVoting = _installDotVotingApp(\r\n            dao,\r\n            _votingBools[0] ? _token2 : _token1,\r\n            _votingSettings[0],\r\n            _votingSettings[1],\r\n            _votingSettings[2]\r\n        );\r\n        Voting voting = _installVotingApp(dao, _votingBools[1] ? _token2 : _token1, _votingSettings[3], _votingSettings[4], _votingSettings[5]);\r\n\r\n        if (_useAgentAsVault) {\r\n            _createAgentPermissions(acl, Agent(agentOrVault), voting, voting);\r\n        }\r\n        _cacheVotingApps(dotVoting, voting, _votingBools[0], _votingBools[1], msg.sender);\r\n        _cacheBase(acl, dao, agentOrVault, msg.sender);\r\n        _registerID(_id, dao);\r\n    }\r\n\r\n    function _setupPermissions(\r\n        ACL _acl,\r\n        Kernel _dao,\r\n        AddressBook _addressBook,\r\n        Allocations _allocations,\r\n        DiscussionApp _discussions,\r\n        Finance _finance,\r\n        Projects _projects,\r\n        Rewards _rewards,\r\n        Vault _agentOrVault\r\n    ) internal\r\n    {\r\n        _setupTokenPermissions(_acl, _dao, _finance, _agentOrVault);\r\n        (DotVoting dotVoting, Voting voting, , ) = _popVotingAppsCache(msg.sender);\r\n\r\n        if (address(_discussions) != address(0)) {\r\n            _createDiscussionsPermissions(_acl, _discussions, ANY_ENTITY, voting);\r\n        }\r\n        _createAddressBookPermissions(_acl, _addressBook, voting, voting);\r\n        _createAllocationsPermissions(_acl, _allocations, dotVoting, voting, voting);\r\n        _createEvmScriptsRegistryPermissions(_acl, voting, voting);\r\n        _createFinancePermissions(_acl, _finance, voting, voting);\r\n        _createFinanceCreatePaymentsPermission(_acl, _finance, voting, voting);\r\n        _createProjectsPermissions(_acl, _projects, dotVoting, voting, voting);\r\n        _createRewardsPermissions(_acl, _rewards, voting, voting);\r\n        _createVaultPermissions(_acl, _agentOrVault, _finance, address(this));\r\n        _grantVaultPermissions(_acl, _agentOrVault, _allocations, _projects, _rewards);\r\n\r\n        //Return permissions from the template\r\n        //_transferCreatePaymentManagerFromTemplate(_acl, _finance, voting);\r\n        _transferPermissionFromTemplate(_acl, _agentOrVault, _agentOrVault.TRANSFER_ROLE(), voting);\r\n        _transferRootPermissionsFromTemplateAndFinalizeDAO(_dao, voting);\r\n    }\r\n\r\n    function _setupTokenPermissions(\r\n        ACL _acl,\r\n        Kernel _dao,\r\n        Finance _finance,\r\n        Vault _vault\r\n    ) internal\r\n    {\r\n        (DotVoting dotVoting, Voting voting, bool secondaryDot, bool secondaryVoting) = _popVotingAppsCache(msg.sender);\r\n        (TokenManager tokenManager1, TokenManager tokenManager2, WhitelistOracle whitelist) = _popTokenManagersCache(msg.sender);\r\n        if (address(tokenManager2) != address(0)) {\r\n            _createTokenManagerPermissions(_acl, tokenManager2, voting, voting);\r\n        }\r\n        if (address(whitelist) != address(0)) {\r\n            _initializeWhitelistOracleApp(whitelist, _vault, _finance);\r\n            _createWhitelistPermissions(_acl, whitelist, voting, voting);\r\n        }\r\n        _createDotVotingPermissions(_acl, dotVoting, secondaryDot ? tokenManager2 : tokenManager1, voting);\r\n        _createTokenManagerPermissions(_acl, tokenManager1, voting, voting);\r\n        _createVotingPermissions(_acl, voting, voting, secondaryVoting ? tokenManager2 : tokenManager1, voting);\r\n\r\n        _cacheVotingApps(dotVoting, voting, secondaryDot, secondaryVoting, msg.sender);\r\n    }\r\n\r\n    function _validateVotingSettings(uint64[6] memory _votingSettings) private pure {\r\n        require(_votingSettings.length == 6, ERROR_BAD_VOTE_SETTINGS);\r\n    }\r\n\r\n    function _validateTokenSettings(address[] memory _members, uint256[] memory _stakes) private pure {\r\n        require(_members.length > 0, ERROR_MISSING_MEMBERS);\r\n        require(_members.length == _stakes.length, ERROR_BAD_MEMBERS_STAKES_LEN);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_name1\",\"type\":\"string\"},{\"name\":\"_symbol1\",\"type\":\"string\"},{\"name\":\"_name2\",\"type\":\"string\"},{\"name\":\"_symbol2\",\"type\":\"string\"}],\"name\":\"newTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_members1\",\"type\":\"address[]\"},{\"name\":\"_stakes1\",\"type\":\"uint256[]\"},{\"name\":\"_members2\",\"type\":\"address[]\"},{\"name\":\"_stakes2\",\"type\":\"uint256[]\"},{\"name\":\"_tokenBools\",\"type\":\"bool[4]\"}],\"name\":\"newTokenManagers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"string\"},{\"name\":\"_name1\",\"type\":\"string\"},{\"name\":\"_symbol1\",\"type\":\"string\"},{\"name\":\"_name2\",\"type\":\"string\"},{\"name\":\"_symbol2\",\"type\":\"string\"},{\"name\":\"_votingSettings\",\"type\":\"uint64[6]\"},{\"name\":\"_votingBools\",\"type\":\"bool[2]\"},{\"name\":\"_useAgentAsVault\",\"type\":\"bool\"}],\"name\":\"newTokensAndInstance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_periods\",\"type\":\"uint64[2]\"},{\"name\":\"_useDiscussions\",\"type\":\"bool\"}],\"name\":\"finalizeDao\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_deployedSetupContracts\",\"type\":\"address[5]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"DeployDao\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"DeployToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"appProxy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"appId\",\"type\":\"bytes32\"}],\"name\":\"InstalledApp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"SetupDao\",\"type\":\"event\"}]","ContractName":"OpenEnterpriseTemplate","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b9da44c051c6cc9e04b7e0f95e95d69c6a6d8031000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b000000000000000000000000909d05f384d0663ed4be59863815ab43b4f347ec000000000000000000000000546aa2eae2514494eeadb7bbb35243348983c59d0000000000000000000000006e77f91ba0ae5278763ec3f044a1f0e5f85fac0a","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://c4e2220e61e28429bb41db0e2ea6f9b1d8d519fdc2204a11d308737663b9844b"}]}