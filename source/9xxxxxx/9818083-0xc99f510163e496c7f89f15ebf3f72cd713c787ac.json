{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.6.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n  /**\\r\\n   * @dev Returns true if `account` is a contract.\\r\\n   *\\r\\n   * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n   * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n   * not containing a contract.\\r\\n   *\\r\\n   * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n   * function returns false is an externally-owned account (EOA) and not a\\r\\n   * contract.\\r\\n   */\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    // This method relies in extcodesize, which returns 0 for contracts in\\r\\n    // construction, since the code is only stored at the end of the\\r\\n    // constructor execution.\\r\\n\\r\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n    // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n    bytes32 codehash;\\r\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n    // solhint-disable-next-line no-inline-assembly\\r\\n    assembly {codehash := extcodehash(account)}\\r\\n    return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Converts an `address` into `address payable`. Note that this is\\r\\n   * simply a type cast: the actual underlying value is not changed.\\r\\n   *\\r\\n   * _Available since v2.4.0._\\r\\n   */\\r\\n  function toPayable(address account) internal pure returns (address payable) {\\r\\n    return address(uint160(account));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n   * `recipient`, forwarding all available gas and reverting on errors.\\r\\n   *\\r\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n   * imposed by `transfer`, making them unable to receive funds via\\r\\n   * `transfer`. {sendValue} removes this limitation.\\r\\n   *\\r\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n   *\\r\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n   * taken to not create reentrancy vulnerabilities. Consider using\\r\\n   * {ReentrancyGuard} or the\\r\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n   *\\r\\n   * _Available since v2.4.0._\\r\\n   */\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    // solhint-disable-next-line avoid-call-value\\r\\n    (bool success,) = recipient.call.value(amount)(\\\"\\\");\\r\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n  }\\r\\n}\\r\\n\"},\"CreatorRole.sol\":{\"content\":\"pragma solidity ^0.6.1;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract CreatorRole {\\n  using Roles for Roles.Role;\\n\\n  event CreatorAdded(address indexed account);\\n  event CreatorRemoved(address indexed account);\\n\\n  Roles.Role private _creators;\\n\\n  constructor () internal {\\n    _addCreator(msg.sender);\\n  }\\n\\n  modifier onlyCreator() {\\n    require(isCreator(msg.sender), \\\"CreatorRole: caller does not have the Creator role\\\");\\n    _;\\n  }\\n\\n  function isCreator(address account) public view returns (bool) {\\n    return _creators.has(account);\\n  }\\n\\n  function addCreator(address account) public onlyCreator {\\n    _addCreator(account);\\n  }\\n\\n  function renounceCreator() public {\\n    _removeCreator(msg.sender);\\n  }\\n\\n  function _addCreator(address account) internal {\\n    _creators.add(account);\\n    emit CreatorAdded(account);\\n  }\\n\\n  function _removeCreator(address account) internal {\\n    _creators.remove(account);\\n    emit CreatorRemoved(account);\\n  }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.1;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"PaymentContract.sol\":{\"content\":\"pragma solidity ^0.6.1;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * Contract that will forward any incoming Ether to the recipient\\r\\n */\\r\\ncontract PaymentContract {\\r\\n\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  // Address to which any funds sent to this contract will be forwarded to\\r\\n  address payable private _recipient;\\r\\n\\r\\n  event ForwarderDeposited(address from, uint256 value, bytes data);\\r\\n  event TokensFlushed(address receiveAddress, uint256 value, address tokenContractAddress);\\r\\n\\r\\n  /**\\r\\n   * Create the contract, and sets the destination address to that of the creator\\r\\n   */\\r\\n  constructor(address payable recipient) public payable {\\r\\n    _recipient = recipient;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Modifier that will execute internal code block only if the sender is the recipient address\\r\\n   */\\r\\n  modifier onlyReceipent {\\r\\n    require(msg.sender == _recipient, \\\"Sender is not the recipient address\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  receive() external payable {\\r\\n    // throws on failure\\r\\n    _recipient.transfer(msg.value);\\r\\n\\r\\n    // Fire off the deposited event if we can forward it\\r\\n    emit ForwarderDeposited(msg.sender, msg.value, msg.data);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Default function; Gets called when Ether is deposited, and forwards it to the recipient address\\r\\n   */\\r\\n  // fallback() external payable {\\r\\n  //   // throws on failure\\r\\n  //   _recipient.transfer(msg.value);\\r\\n\\r\\n  //   // Fire off the deposited event if we can forward it\\r\\n  //   emit ForwarderDeposited(msg.sender, msg.value, msg.data);\\r\\n  // }\\r\\n\\r\\n  function changeReceipent(address payable newReceipent) public onlyReceipent {\\r\\n      _recipient = newReceipent;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Execute a token transfer of the full balance from the forwarder token to the recipient address\\r\\n   * @param tokenContractAddress the address of the erc20 token contract\\r\\n   */\\r\\n  function flushTokens(address tokenContractAddress) public {\\r\\n    IERC20 instance = IERC20(tokenContractAddress);\\r\\n    uint256 balance = instance.balanceOf(address(this));\\r\\n\\r\\n    require(balance \\u003e 0, \\\"Token balance is zero\\\");\\r\\n\\r\\n    // require(instance.transfer(_recipient, balance), \\\"Transfer token failed\\\");\\r\\n    instance.safeTransfer(_recipient, balance);\\r\\n\\r\\n    // fire of an event just for the record!\\r\\n    emit TokensFlushed(_recipient, balance, tokenContractAddress);\\r\\n  }\\r\\n}\\r\\n\\r\\n\"},\"PaymentCreator.sol\":{\"content\":\"pragma solidity ^0.6.1;\\r\\n\\r\\n\\r\\nimport \\\"./PaymentContract.sol\\\";\\r\\nimport \\\"./CreatorRole.sol\\\";\\r\\n\\r\\n// This is a test target for a Forwarder.\\r\\n// It contains a public function with a side-effect.\\r\\ncontract PaymentCreator is CreatorRole {\\r\\n\\r\\n  event NewPayment(address indexed paymentAddress);\\r\\n\\r\\n  /**\\r\\n   * Requirements:\\r\\n   * - the caller must have the `CreatorRole`.\\r\\n   *\\r\\n   * return new payment address.\\r\\n   */\\r\\n  function createPayment(address payable recipient) public onlyCreator returns (address) {\\r\\n    // create new stake\\r\\n    PaymentContract payment = new PaymentContract(recipient);\\r\\n\\r\\n    emit NewPayment(address(payment));\\r\\n\\r\\n    return address(payment);\\r\\n  }\\r\\n\\r\\n}\\r\\n\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.6.1;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n  struct Role {\\n    mapping(address =\\u003e bool) bearer;\\n  }\\n\\n  /**\\n   * @dev Give an account access to this role.\\n   */\\n  function add(Role storage role, address account) internal {\\n    require(!has(role, account), \\\"Roles: account already has role\\\");\\n    role.bearer[account] = true;\\n  }\\n\\n  /**\\n   * @dev Remove an account\\u0027s access to this role.\\n   */\\n  function remove(Role storage role, address account) internal {\\n    require(has(role, account), \\\"Roles: account does not have role\\\");\\n    role.bearer[account] = false;\\n  }\\n\\n  /**\\n   * @dev Check if an account has this role.\\n   * @return bool\\n   */\\n  function has(Role storage role, address account) internal view returns (bool) {\\n    require(account != address(0), \\\"Roles: account is the zero address\\\");\\n    return role.bearer[account];\\n  }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.6.1;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n  using SafeMath for uint256;\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n    // safeApprove should only be called when setting an initial allowance,\\r\\n    // or when resetting it to zero. To increase and decrease it, use\\r\\n    // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n    // solhint-disable-next-line max-line-length\\r\\n    require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n    );\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n   * @param token The token targeted by the call.\\r\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n   */\\r\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n    // we\\u0027re implementing it ourselves.\\r\\n\\r\\n    // A Solidity high level call has three parts:\\r\\n    //  1. The target address is checked to verify it contains contract code\\r\\n    //  2. The call itself is made, and success asserted\\r\\n    //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n    // solhint-disable-next-line max-line-length\\r\\n    require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n    // solhint-disable-next-line avoid-low-level-calls\\r\\n    (bool success, bytes memory returndata) = address(token).call(data);\\r\\n    require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n    if (returndata.length \\u003e 0) {// Return data is optional\\r\\n      // solhint-disable-next-line max-line-length\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.1;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   *\\n   * _Available since v2.4.0._\\n   */\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b \\u003c= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, \\\"SafeMath: division by zero\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   *\\n   * _Available since v2.4.0._\\n   */\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b \\u003e 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   *\\n   * _Available since v2.4.0._\\n   */\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"CreatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"CreatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"}],\"name\":\"NewPayment\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"createPayment\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isCreator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PaymentCreator","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://cf39614deba434f2843d4c8d1f8c19c4dc0922a8e88423846dfac8f9ca67a03e"}]}