{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.3; contract AENfileCertifier {  address private root; struct LedgerRecord {  uint _unixCertified;  bytes32 _sha256hash;  bytes16 _md5hash;  uint _filesize;  string _fileName;  string _issueDate;  string _title;  string _office;  address _owner;  }  LedgerRecord private buf;  mapping (bytes32 => LedgerRecord) private ledger;   event WriteRecord (address indexed from, bytes32 indexed sha256crc, string fileName, string issueDate, string title, string office); event EditRecord (address indexed from, bytes32 indexed sha256crc, string fileName, string issueDate, string title, string office); event OpenLedger (address indexed from); event WrongCall (address indexed from, bytes callsequence); function writeLedger(bytes32 sha256crc, bytes16 MD5crc, uint filesize, string memory fileName, string memory issueDate, string memory title, string memory office) public {  require(sha256crc != bytes32(0) && MD5crc != bytes32(0) && filesize != uint(0), \"Error: missing data in the record.\" );  require(ledger[sha256crc]._unixCertified == uint (0x0), \"Error: this record is already present!\");  buf._unixCertified = block.timestamp; buf._fileName = fileName; buf._issueDate = issueDate; buf._title = title; buf._office = office; buf._sha256hash = sha256crc; buf._md5hash = MD5crc; buf._filesize = filesize; buf._owner = msg.sender;  ledger[sha256crc] = buf;  emit WriteRecord(msg.sender, sha256crc, fileName, issueDate, title, office); } function readLedger(bytes32 sha256crc) view public returns (uint unixCertified, string memory certifiedUTCdate, bytes16 MD5crc, uint filesize, string memory fileName, string memory issueDate, string memory title, string memory office) { if(ledger[sha256crc]._unixCertified == uint (0x0)){  string memory error = \"Error: requested record does not exist.\"; unixCertified = 0; certifiedUTCdate= error; MD5crc = 0; filesize = 0; fileName = error; issueDate = error; title = error; office = error; } else { unixCertified = ledger[sha256crc]._unixCertified; certifiedUTCdate= string(abi.encodePacked(u2s(getDay(unixCertified)), \"/\", u2s(getMonth(unixCertified)), \"/\", u2s(getYear(unixCertified)), \", \", u2s(getHour(unixCertified)), \":\", u2s(getMinute(unixCertified)), \":\", u2s(getSecond(unixCertified)), \" UTC\")); MD5crc = ledger[sha256crc]._md5hash; filesize = ledger[sha256crc]._filesize; fileName = ledger[sha256crc]._fileName; issueDate = ledger[sha256crc]._issueDate; title = ledger[sha256crc]._title; office = ledger[sha256crc]._office; } } function checkOwner(bytes32 sha256crc) public view returns(address owner, string memory title, bool success) { if(ledger[sha256crc]._unixCertified == uint (0x0)){  owner = address(0x0); title = \"Error: requested record does not exist.\"; success = false; } else { owner = ledger[sha256crc]._owner; title = ledger[sha256crc]._title; success = true; } } function editLedger(bytes32 sha256crc, string memory fileName, string memory issueDate, string memory title, string memory office) public { require(msg.sender == root, \"Error: insufficient privileges.\");  require(ledger[sha256crc]._unixCertified != uint (0x0), \"Error: requested record does not exist!\");  ledger[sha256crc]._fileName = fileName; ledger[sha256crc]._issueDate = issueDate; ledger[sha256crc]._title = title; ledger[sha256crc]._office = office;  emit EditRecord(msg.sender, sha256crc, fileName, issueDate, title, office); } constructor () public { root = msg.sender; emit OpenLedger(root); } receive() external payable { revert(\"Ethers are not accepted!\");  } fallback() external { emit WrongCall (msg.sender, msg.data);  } struct _DateTime {uint16 year;uint8 month;uint8 day;uint8 hour;uint8 minute;uint8 second;uint8 weekday;} uint constant YEAR_IN_SECONDS=31536000;uint constant LEAP_YEAR_IN_SECONDS=31622400;uint constant DAY_IN_SECONDS=86400;uint16 constant ORIGIN_YEAR=1970; function getYear(uint timestamp)internal pure returns(uint16 year){uint secondsAccountedFor=0;uint numLeapYears;year=uint16(ORIGIN_YEAR+timestamp/YEAR_IN_SECONDS);numLeapYears=leapYearsBefore(year)-leapYearsBefore(ORIGIN_YEAR);secondsAccountedFor+=LEAP_YEAR_IN_SECONDS*numLeapYears;secondsAccountedFor+=YEAR_IN_SECONDS*(year-ORIGIN_YEAR-numLeapYears);while(secondsAccountedFor>timestamp){if(isLeapYear(uint16(year-1))){secondsAccountedFor-=LEAP_YEAR_IN_SECONDS;}else{secondsAccountedFor-=YEAR_IN_SECONDS;}year-= 1;}return year;} function getMonth(uint timestamp)internal pure returns(uint8){return parseTimestamp(timestamp).month;} function getDay(uint timestamp)internal pure returns (uint8){return parseTimestamp(timestamp).day;} function getHour(uint timestamp)internal pure returns(uint8){return uint8((timestamp/60/60)%24);} function getMinute(uint timestamp)internal pure returns(uint8){return uint8((timestamp/60)%60);} function getSecond(uint timestamp)internal pure returns(uint8){return uint8(timestamp%60);} function getWeekday(uint timestamp)internal pure returns(uint8){return uint8((timestamp/DAY_IN_SECONDS+4)%7);} function parseTimestamp(uint timestamp)internal pure returns(_DateTime memory dt){uint secondsAccountedFor=0;uint _buf;uint8 i;dt.year=getYear(timestamp);_buf=leapYearsBefore(dt.year)-leapYearsBefore(ORIGIN_YEAR);secondsAccountedFor+=LEAP_YEAR_IN_SECONDS*_buf;secondsAccountedFor+=YEAR_IN_SECONDS*(dt.year-ORIGIN_YEAR-_buf);uint secondsInMonth;for(i=1;i<=12;i++){secondsInMonth=DAY_IN_SECONDS*getDaysInMonth(i,dt.year);if(secondsInMonth+secondsAccountedFor>timestamp){dt.month=i;break;} secondsAccountedFor+=secondsInMonth;}for(i=1;i<=getDaysInMonth(dt.month,dt.year);i++){if(DAY_IN_SECONDS+secondsAccountedFor>timestamp){dt.day=i;break;}secondsAccountedFor+=DAY_IN_SECONDS;}dt.hour=getHour(timestamp);dt.minute=getMinute(timestamp);dt.second=getSecond(timestamp);dt.weekday=getWeekday(timestamp);} function isLeapYear(uint16 year)internal pure returns(bool){if(year%4!=0)return false;if(year%100!=0)return true;if(year%400!=0)return false;return true;} function leapYearsBefore(uint year)internal pure returns(uint){year-=1;return year/4-year/100+year/400;} function getDaysInMonth(uint8 month,uint16 year)internal pure returns(uint8){if(month==1||month==3||month==5||month==7||month==8||month==10||month==12){return 31;}else if(month==4||month==6||month==9||month==11){return 30;}else if(isLeapYear(year)){return 29;}else{return 28;}} function u2s(uint v)internal pure returns(string memory){bytes32 ret;uint vl=v;if(v==0){ret='0';}else{while(v>0){ret=bytes32(uint(ret)/(2**8));ret|=bytes32(((v%10)+48)*2**(8*31));v/=10;}}bytes memory bytesString=new bytes(32);for(uint j=0;j<32;j++){byte char=byte(bytes32(uint(ret)*2**(8*j)));if(char!=0){bytesString[j]=char;}}if(vl<10)bytesString=abi.encodePacked(\"0\",bytesString);return string(bytesString);} }","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sha256crc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"fileName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"issueDate\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"office\",\"type\":\"string\"}],\"name\":\"EditRecord\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"OpenLedger\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sha256crc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"fileName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"issueDate\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"office\",\"type\":\"string\"}],\"name\":\"WriteRecord\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callsequence\",\"type\":\"bytes\"}],\"name\":\"WrongCall\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sha256crc\",\"type\":\"bytes32\"}],\"name\":\"checkOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sha256crc\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"fileName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"issueDate\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"office\",\"type\":\"string\"}],\"name\":\"editLedger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sha256crc\",\"type\":\"bytes32\"}],\"name\":\"readLedger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unixCertified\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"certifiedUTCdate\",\"type\":\"string\"},{\"internalType\":\"bytes16\",\"name\":\"MD5crc\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"filesize\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"fileName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"issueDate\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"office\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sha256crc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes16\",\"name\":\"MD5crc\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"filesize\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"fileName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"issueDate\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"office\",\"type\":\"string\"}],\"name\":\"writeLedger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"AENfileCertifier","CompilerVersion":"v0.6.3+commit.8dda9521","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://2a69d0688f0dcd732e6dd5854f5c6effee16dfb321a80de0320796e0ef6ddd1f"}]}