{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\ninterface IFaceValue {\r\n\tusing SafeMath for uint256;\r\n\tusing FixidityLib for int256;\r\n\tusing ExponentLib for int256;\r\n\r\n\tfunction getFixedInitialValue() external view returns (int256);\r\n\r\n\tfunction getFixedFaceValue(uint256 currentTimestamp) external view returns (int256);\r\n}\r\n\r\ninterface ILoanToValueAggregator {\r\n\tusing SafeMath for uint256;\r\n\tusing FixidityLib for int256;\r\n\tusing ExponentLib for int256;\r\n\r\n\tfunction name() external view returns (string memory);\r\n\r\n\tfunction setAppraisedCapitalValue(uint256 value) external;\r\n\r\n\tfunction getFixedAppraisedCapitalValue() external view returns (int256);\r\n\r\n\tfunction setOffChainLoanValue(uint256 offChainLoanValue) external;\r\n\r\n\tfunction getFixedOffChainLoanValue() external view returns (int256);\r\n\r\n\tfunction getFixedOnChainLoanValue() external view returns (int256);\r\n\r\n\tfunction calculateFixedLtV() external view returns (int256);\r\n\r\n\tfunction getFixedTokenisedRatio() external view returns (int256);\r\n\r\n\tfunction addToken(address tokenAddr) external;\r\n\r\n\tfunction removeToken(address tokenAddr) external;\r\n\r\n\tfunction fixedDecimalDigits() external pure returns (int256);\r\n\r\n\tfunction Destroy() external returns (bool);\r\n}\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract LoanToValueDebtAggregator is Ownable, ILoanToValueAggregator {\r\n\tstring private _name;\r\n\r\n\tFaceValueDebt[] private _trackedTokens;\r\n\r\n\tint256 private _f_appraisedCapitalValue = 0;\r\n\tint256 private _f_offChainLoanValue = 0;\r\n\r\n\tconstructor(string memory name, uint256 appriasedCapitalValue, uint256 offChainLoanValue)\r\n\t\tpublic\r\n\t{\r\n\t\tsetAppraisedCapitalValue(appriasedCapitalValue);\r\n\t\tsetOffChainLoanValue(offChainLoanValue);\r\n\t\t_name = name;\r\n\t}\r\n\r\n\tfunction name() public view returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction setAppraisedCapitalValue(uint256 value) public onlyOwner {\r\n\t\t_f_appraisedCapitalValue = int256(value).newFixed();\r\n\t}\r\n\r\n\tfunction getFixedAppraisedCapitalValue() public view returns (int256) {\r\n\t\treturn _f_appraisedCapitalValue;\r\n\t}\r\n\r\n\tfunction setOffChainLoanValue(uint256 offChainLoanValue) public onlyOwner {\r\n\t\t_f_offChainLoanValue = int256(offChainLoanValue).newFixed();\r\n\t}\r\n\r\n\tfunction getFixedOffChainLoanValue() public view returns (int256) {\r\n\t\treturn _f_offChainLoanValue;\r\n\t}\r\n\r\n\tfunction getFixedOnChainLoanValue() public view returns (int256) {\r\n\t\trequire(_trackedTokens.length > 0, \"No tracked tokens\");\r\n\t\tint256 f_onChainLoanValue = int256(0).newFixed();\r\n\t\tfor (uint256 i = 0; i < _trackedTokens.length; i++) {\r\n\t\t\tf_onChainLoanValue = f_onChainLoanValue.add(\r\n\t\t\t\t_trackedTokens[i].getFixedInitialValue().multiply(\r\n\t\t\t\t\tint256(_trackedTokens[i].totalSupply()).newFixed()\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn f_onChainLoanValue;\r\n\t}\r\n\r\n\tfunction calculateFixedLtV() public view returns (int256) {\r\n\t\trequire(_f_appraisedCapitalValue != 0, \"Appraised Capital value = 0\");\r\n\t\tint256 f_loanAmmount = _f_offChainLoanValue + getFixedOnChainLoanValue();\r\n\t\treturn f_loanAmmount.divide(_f_appraisedCapitalValue);\r\n\t}\r\n\r\n\tfunction getFixedTokenisedRatio() public view returns (int256) {\r\n\t\treturn\r\n\t\t\t_f_offChainLoanValue.add(getFixedOnChainLoanValue()).divide(_f_appraisedCapitalValue);\r\n\t}\r\n\r\n\tfunction addToken(address tokenAddr) public onlyOwner {\r\n\t\t_trackedTokens.push(FaceValueDebt(tokenAddr));\r\n\t}\r\n\r\n\tfunction removeToken(address tokenAddr) public onlyOwner {\r\n\t\trequire(_trackedTokens.length > 0, \"No tokens tracked by this aggregator.\");\r\n\t\tuint256 i = 0;\r\n\t\tif (_trackedTokens.length != 1) {\r\n\t\t\ti = findTokenIndexByAddress(tokenAddr);\r\n\t\t}\r\n\t\tif (i != _trackedTokens.length - 1) {\r\n\t\t\t// If not in last position, overwrite deleted token with last token\r\n\t\t\t_trackedTokens[i] = _trackedTokens[_trackedTokens.length - 1];\r\n\t\t}\r\n\t\t_trackedTokens.pop();\r\n\t}\r\n\r\n\tfunction findTokenIndexByAddress(address tokenAddr) private view returns (uint256) {\r\n\t\tfor (uint256 i = 0; i < _trackedTokens.length; i++) {\r\n\t\t\tif (address(_trackedTokens[i]) == tokenAddr) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\trevert(\"Token not found.\");\r\n\t}\r\n\r\n\tfunction fixedDecimalDigits() public pure returns (int256) {\r\n\t\treturn FixidityLib.digits();\r\n\t}\r\n\r\n\t/**\r\n    * @dev Destroy the contract\r\n    */\r\n\tfunction Destroy() public onlyOwner returns (bool) {\r\n\t\tselfdestruct(msg.sender);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\ncontract Debt is ERC20, Ownable {\r\n\tstring private _name;\r\n\tstring private _symbol;\r\n\tuint8 private _decimals;\r\n\tstring private _contractHash;\r\n\tstring private _contractUrl;\r\n\tuint32 private _interestBPS;\r\n\tstring private _maturityDate;\r\n\r\n\tconstructor(\r\n\t\tstring memory name,\r\n\t\tstring memory symbol,\r\n\t\tuint8 decimals,\r\n\t\tstring memory contractHash,\r\n\t\tstring memory contractUrl,\r\n\t\tuint32 interestBPS,\r\n\t\tstring memory maturityDate\r\n\t) public {\r\n\t\t_name = name;\r\n\t\t_symbol = symbol;\r\n\t\t_decimals = decimals;\r\n\t\t_contractHash = contractHash;\r\n\t\t_contractUrl = contractUrl;\r\n\t\t_interestBPS = interestBPS;\r\n\t\t_maturityDate = maturityDate;\r\n\t}\r\n\r\n\t/**\r\n     * @return the name of the token.\r\n     */\r\n\tfunction name() public view returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\t/**\r\n     * @return the symbol of the token.\r\n     */\r\n\tfunction symbol() public view returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\t/**\r\n     * @return the number of decimals of the token.\r\n     */\r\n\tfunction decimals() public view returns (uint8) {\r\n\t\treturn _decimals;\r\n\t}\r\n\r\n\t/**\r\n     * @return the contractHash\r\n     */\r\n\tfunction contractHash() public view returns (string memory) {\r\n\t\treturn _contractHash;\r\n\t}\r\n\r\n\t/**\r\n     * @return the contractUrl\r\n     */\r\n\tfunction contractUrl() public view returns (string memory) {\r\n\t\treturn _contractUrl;\r\n\t}\r\n\r\n\t/**\r\n     * @return the interest rate in Basis Points (BPS).\r\n     */\r\n\tfunction interestBPS() public view returns (uint32) {\r\n\t\treturn _interestBPS;\r\n\t}\r\n\r\n\t/**\r\n     * @return the maturity date\r\n     */\r\n\tfunction maturityDate() public view returns (string memory) {\r\n\t\treturn _maturityDate;\r\n\t}\r\n\r\n\t/**\r\n     * @return set the contractUrl\r\n     */\r\n\tfunction setContractUrl(string memory url) public onlyOwner returns (bool) {\r\n\t\t_contractUrl = url;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n    * @dev Destroy the contract\r\n    */\r\n\tfunction Destroy() public onlyOwner returns (bool) {\r\n\t\tselfdestruct(msg.sender);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n    * @dev sudo Transfer tokens\r\n    * @param from The address to transfer from.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n\tfunction sudoTransfer(address from, address to, uint256 value) public onlyOwner returns (bool) {\r\n\t\t_transfer(from, to, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n    * @dev Mint tokens\r\n    * @param to The address to mint in.\r\n    * @param value The amount to be minted.\r\n    */\r\n\tfunction Mint(address to, uint256 value) public onlyOwner returns (bool) {\r\n\t\t_mint(to, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n    * @dev Burn tokens\r\n    * @param from The address to burn in.\r\n    * @param value The amount to be burned.\r\n    */\r\n\tfunction Burn(address from, uint256 value) public onlyOwner returns (bool) {\r\n\t\t_burn(from, value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract FaceValueDebt is Debt, IFaceValue {\r\n\tint256 private _f_initialValue;\r\n\tint256 private _f_nominalInterest;\r\n\tuint256 private _compoundingPeriod; // In Seconds\r\n\tuint256 private _commencementDateTimestamp;\r\n\tuint256 private _maturityDateTimestamp;\r\n\tint256 private _f_numberOfCompoundingPeriods;\r\n\r\n\tconstructor(\r\n\t\t// DEBT\r\n\t\tstring memory name,\r\n\t\tstring memory symbol,\r\n\t\tuint8 decimals,\r\n\t\tstring memory contractHash,\r\n\t\tstring memory contractUrl,\r\n\t\tuint32 interestBPS,\r\n\t\tstring memory maturityDate,\r\n\t\t// FACEVALUE\r\n\t\tuint256 initialValue,\r\n\t\tint256 f_nominalInterestBPS,\r\n\t\tuint256 compoundingPeriod, // In Seconds\r\n\t\tuint256 commencementDateTimestamp, // In Seconds\r\n\t\tuint256 maturityDateTimestamp\r\n\t) public Debt(name, symbol, decimals, contractHash, contractUrl, interestBPS, maturityDate) {\r\n\t\tsetFixedInitialValue(initialValue);\r\n\t\tsetFixedNominalInterest(f_nominalInterestBPS);\r\n\t\t_compoundingPeriod = compoundingPeriod;\r\n\t\t_commencementDateTimestamp = commencementDateTimestamp;\r\n\t\t_maturityDateTimestamp = maturityDateTimestamp;\r\n\t\tsetFixedNumberOfCompoundingPeriods(\r\n\t\t\tcompoundingPeriod,\r\n\t\t\tmaturityDateTimestamp,\r\n\t\t\tcommencementDateTimestamp\r\n\t\t);\r\n\t}\r\n\r\n\tfunction setFixedNominalInterest(int256 f_nominalInterestBPS) private {\r\n\t\t_f_nominalInterest = f_nominalInterestBPS.divide(10000 * FixidityLib.fixed1());\r\n\t}\r\n\r\n\tfunction setFixedNumberOfCompoundingPeriods(\r\n\t\tuint256 compoundingPeriod,\r\n\t\tuint256 maturityDateTimestamp,\r\n\t\tuint256 commencementDateTimestamp\r\n\t) private {\r\n\t\t_f_numberOfCompoundingPeriods = int256(\r\n\t\t\tmaturityDateTimestamp.sub(commencementDateTimestamp).div(compoundingPeriod)\r\n\t\t)\r\n\t\t\t.newFixed();\r\n\t}\r\n\r\n\tfunction getFixedElapisedPeriods(uint256 currentTimestamp) private view returns (int256) {\r\n\t\t// We want this initial part to be integer division\r\n\t\treturn\r\n\t\t\tint256(currentTimestamp.sub(_commencementDateTimestamp).div(_compoundingPeriod))\r\n\t\t\t\t.newFixed();\r\n\t}\r\n\r\n\tfunction setFixedInitialValue(uint256 initialValue) private {\r\n\t\t_f_initialValue = int256(initialValue).newFixed();\r\n\t}\r\n\r\n\tfunction getFixedInitialValue() public view returns (int256) {\r\n\t\treturn _f_initialValue;\r\n\t}\r\n\r\n\tfunction getFixedFaceValue(uint256 currentTimestamp) public view returns (int256) {\r\n\t\tif (currentTimestamp <= _commencementDateTimestamp) {\r\n\t\t\treturn getFixedInitialValue();\r\n\t\t} else if (currentTimestamp > _maturityDateTimestamp) {\r\n\t\t\treturn getFixedFaceValue(_maturityDateTimestamp);\r\n\t\t}\r\n\t\treturn\r\n\t\t\t_f_nominalInterest\r\n\t\t\t\t.divide(_f_numberOfCompoundingPeriods)\r\n\t\t\t\t.add(FixidityLib.fixed1())\r\n\t\t\t\t.powerAny(getFixedElapisedPeriods(currentTimestamp))\r\n\t\t\t\t.multiply(_f_initialValue);\r\n\t}\r\n}\r\n\r\nlibrary ExponentLib {\r\n\r\n    function fixedExp10() internal pure returns(int256) {\r\n        return 22026465794806716516957900645;\r\n    }\r\n\r\n    /**\r\n     * @notice Not fully tested anymore.\r\n     */\r\n    function powerE(int256 _x) \r\n        internal \r\n        pure \r\n        returns (int256) \r\n    {\r\n        assert(_x < 172 * FixidityLib.fixed1());\r\n        int256 x = _x;\r\n        int256 r = FixidityLib.fixed1();\r\n        while (x >= 10 * FixidityLib.fixed1()) {\r\n            x -= 10 * FixidityLib.fixed1();\r\n            r = FixidityLib.multiply(r, fixedExp10());\r\n        }\r\n        if (x == FixidityLib.fixed1()) {\r\n            return FixidityLib.multiply(r, LogarithmLib.fixedE());\r\n        } else if (x == 0) {\r\n            return r;\r\n        }\r\n        int256 tr = 1 * FixidityLib.fixed1();\r\n        int256 d = tr;\r\n        for (uint8 i = 1; i <= 2 * FixidityLib.digits(); i++) {\r\n            d = (d * x) / (FixidityLib.fixed1() * i);\r\n            tr += d;\r\n        }\r\n        return FixidityLib.multiply(tr, r);\r\n    }\r\n\r\n    function powerAny(int256 a, int256 b) \r\n        internal \r\n        pure \r\n        returns (int256) \r\n    {\r\n        return powerE(FixidityLib.multiply(LogarithmLib.ln(a), b));\r\n    }\r\n\r\n    function rootAny(int256 a, int256 b) \r\n        internal \r\n        pure \r\n        returns (int256) \r\n    {\r\n        return powerAny(a, FixidityLib.reciprocal(b));\r\n    }\r\n\r\n    function rootN(int256 a, uint8 n) \r\n        internal \r\n        pure \r\n        returns (int256) \r\n    {\r\n        return powerE(FixidityLib.divide(LogarithmLib.ln(a), FixidityLib.fixed1() * n));\r\n    }\r\n\r\n    // solium-disable-next-line mixedcase\r\n    function round_off(int256 _v, uint8 digits) \r\n        internal \r\n        pure \r\n        returns (int256) \r\n    {\r\n        int256 t = int256(uint256(10) ** uint256(digits));\r\n        int8 sign = 1;\r\n        int256 v = _v;\r\n        if (v < 0) {\r\n            sign = -1;\r\n            v = 0 - v;\r\n        }\r\n        if (v % t >= t / 2) v = v + t - v % t;\r\n        return v * sign;\r\n    }\r\n\r\n    // solium-disable-next-line mixedcase\r\n    function trunc_digits(int256 v, uint8 digits) \r\n        internal \r\n        pure \r\n        returns (int256) \r\n    {\r\n        if (digits <= 0) return v;\r\n        return round_off(v, digits) / FixidityLib.fixed1();\r\n    }\r\n}\r\n\r\nlibrary FixidityLib {\r\n\r\n    /**\r\n     * @notice Number of positions that the comma is shifted to the right.\r\n     */\r\n    function digits() internal pure returns(uint8) {\r\n        return 24;\r\n    }\r\n    \r\n    /**\r\n     * @notice This is 1 in the fixed point units used in this library.\r\n     * @dev Test fixed1() equals 10^digits()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function fixed1() internal pure returns(int256) {\r\n        return 1000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice The amount of decimals lost on each multiplication operand.\r\n     * @dev Test mulPrecision() equals sqrt(fixed1)\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function mulPrecision() internal pure returns(int256) {\r\n        return 1000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be represented in an int256\r\n     * @dev Test maxInt256() equals 2^255 -1\r\n     */\r\n    function maxInt256() internal pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\r\n    }\r\n\r\n    /**\r\n     * @notice Minimum value that can be represented in an int256\r\n     * @dev Test minInt256 equals (2^255) * (-1)\r\n     */\r\n    function minInt256() internal pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be converted to fixed point. Optimize for\r\n     * @dev deployment. \r\n     * Test maxNewFixed() equals maxInt256() / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxNewFixed() internal pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be converted to fixed point. Optimize for\r\n     * deployment. \r\n     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function minNewFixed() internal pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as an addition operator.\r\n     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\r\n     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \r\n     */\r\n    function maxFixedAdd() internal pure returns(int256) {\r\n        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum negative value that can be safely in a subtraction.\r\n     * @dev Test maxFixedSub() equals minInt256() / 2\r\n     */\r\n    function maxFixedSub() internal pure returns(int256) {\r\n        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a multiplication operator.\r\n     * @dev Calculated as sqrt(maxInt256()*fixed1()). \r\n     * Be careful with your sqrt() implementation. I couldn't find a calculator\r\n     * that would give the exact square root of maxInt256*fixed1 so this number\r\n     * is below the real number by no more than 3*10**28. It is safe to use as\r\n     * a limit for your multiplications, although powers of two of numbers over\r\n     * this value might still work.\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \r\n     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\r\n     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedMul() internal pure returns(int256) {\r\n        return 240615969168004498257251713877715648331380787511296;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a dividend.\r\n     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\r\n     * Test maxFixedDiv() equals maxInt256()/fixed1()\r\n     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDiv() internal pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a divisor.\r\n     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDivisor() internal pure returns(int256) {\r\n        return 1000000000000000000000000000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 to fixed point units, equivalent to multiplying\r\n     * by 10^digits().\r\n     * @dev Test newFixed(0) returns 0\r\n     * Test newFixed(1) returns fixed1()\r\n     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\r\n     * Test newFixed(maxNewFixed()+1) fails\r\n     */\r\n    function newFixed(int256 x)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(x <= maxNewFixed());\r\n        assert(x >= minNewFixed());\r\n        return x * fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a non decimal. All decimal digits will be truncated.\r\n     */\r\n    function fromFixed(int256 x)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return x / fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to a different fixed precision representation.\r\n     * Both the origin and destination precisions must be 38 or less digits.\r\n     * Origin values with a precision higher than the destination precision\r\n     * will be truncated accordingly.\r\n     * @dev \r\n     * Test convertFixed(1,0,0) returns 1;\r\n     * Test convertFixed(1,1,1) returns 1;\r\n     * Test convertFixed(1,1,0) returns 0;\r\n     * Test convertFixed(1,0,1) returns 10;\r\n     * Test convertFixed(10,1,0) returns 1;\r\n     * Test convertFixed(10,0,1) returns 100;\r\n     * Test convertFixed(100,1,0) returns 10;\r\n     * Test convertFixed(100,0,1) returns 1000;\r\n     * Test convertFixed(1000,2,0) returns 10;\r\n     * Test convertFixed(1000,0,2) returns 100000;\r\n     * Test convertFixed(1000,2,1) returns 100;\r\n     * Test convertFixed(1000,1,2) returns 10000;\r\n     * Test convertFixed(maxInt256,1,0) returns maxInt256/10;\r\n     * Test convertFixed(maxInt256,0,1) throws\r\n     * Test convertFixed(maxInt256,38,0) returns maxInt256/(10**38);\r\n     * Test convertFixed(1,0,38) returns 10**38;\r\n     * Test convertFixed(maxInt256,39,0) throws\r\n     * Test convertFixed(1,0,39) throws\r\n     */\r\n    function convertFixed(int256 x, uint8 _originDigits, uint8 _destinationDigits)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(_originDigits <= 38 && _destinationDigits <= 38);\r\n        \r\n        uint8 decimalDifference;\r\n        if ( _originDigits > _destinationDigits ){\r\n            decimalDifference = _originDigits - _destinationDigits;\r\n            return x/(uint128(10)**uint128(decimalDifference));\r\n        }\r\n        else if ( _originDigits < _destinationDigits ){\r\n            decimalDifference = _destinationDigits - _originDigits;\r\n            // Cast uint8 -> uint128 is safe\r\n            // Exponentiation is safe:\r\n            //     _originDigits and _destinationDigits limited to 38 or less\r\n            //     decimalDifference = abs(_destinationDigits - _originDigits)\r\n            //     decimalDifference < 38\r\n            //     10**38 < 2**128-1\r\n            assert(x <= maxInt256()/uint128(10)**uint128(decimalDifference));\r\n            assert(x >= minInt256()/uint128(10)**uint128(decimalDifference));\r\n            return x*(uint128(10)**uint128(decimalDifference));\r\n        }\r\n        // _originDigits == digits()) \r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to that of this library. The _originDigits parameter is the\r\n     * precision of x. Values with a precision higher than FixidityLib.digits()\r\n     * will be truncated accordingly.\r\n     */\r\n    function newFixedFromDigits(int256 x, uint8 _originDigits)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, _originDigits, digits());\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a different representation. The _destinationDigits parameter is the\r\n     * precision of the output x. Values with a precision below than \r\n     * FixidityLib.digits() will be truncated accordingly.\r\n     */\r\n    function fromFixedToDigits(int256 x, uint8 _destinationDigits)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, digits(), _destinationDigits);\r\n    }\r\n\r\n    /**\r\n     * @notice Converts two int256 representing a fraction to fixed point units,\r\n     * equivalent to multiplying dividend and divisor by 10^digits().\r\n     * @dev \r\n     * Test newFixedFraction(maxFixedDiv()+1,1) fails\r\n     * Test newFixedFraction(1,maxFixedDiv()+1) fails\r\n     * Test newFixedFraction(1,0) fails     \r\n     * Test newFixedFraction(0,1) returns 0\r\n     * Test newFixedFraction(1,1) returns fixed1()\r\n     * Test newFixedFraction(maxFixedDiv(),1) returns maxFixedDiv()*fixed1()\r\n     * Test newFixedFraction(1,fixed1()) returns 1\r\n     * Test newFixedFraction(1,fixed1()-1) returns 0\r\n     */\r\n    function newFixedFraction(\r\n        int256 numerator, \r\n        int256 denominator\r\n        )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(numerator <= maxNewFixed());\r\n        assert(denominator <= maxNewFixed());\r\n        assert(denominator != 0);\r\n        int256 convertedNumerator = newFixed(numerator);\r\n        int256 convertedDenominator = newFixed(denominator);\r\n        return divide(convertedNumerator, convertedDenominator);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the integer part of a fixed point number.\r\n     * @dev \r\n     * Test integer(0) returns 0\r\n     * Test integer(fixed1()) returns fixed1()\r\n     * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test integer(-fixed1()) returns -fixed1()\r\n     * Test integer(newFixed(-maxNewFixed())) returns -maxNewFixed()*fixed1()\r\n     */\r\n    function integer(int256 x) internal pure returns (int256) {\r\n        return (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the fractional part of a fixed point number. \r\n     * In the case of a negative number the fractional is also negative.\r\n     * @dev \r\n     * Test fractional(0) returns 0\r\n     * Test fractional(fixed1()) returns 0\r\n     * Test fractional(fixed1()-1) returns 10^24-1\r\n     * Test fractional(-fixed1()) returns 0\r\n     * Test fractional(-fixed1()+1) returns -10^24-1\r\n     */\r\n    function fractional(int256 x) internal pure returns (int256) {\r\n        return x - (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Converts to positive if negative.\r\n     * Due to int256 having one more negative number than positive numbers \r\n     * abs(minInt256) reverts.\r\n     * @dev \r\n     * Test abs(0) returns 0\r\n     * Test abs(fixed1()) returns -fixed1()\r\n     * Test abs(-fixed1()) returns fixed1()\r\n     * Test abs(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test abs(newFixed(minNewFixed())) returns -minNewFixed()*fixed1()\r\n     */\r\n    function abs(int256 x) internal pure returns (int256) {\r\n        if (x >= 0) {\r\n            return x;\r\n        } else {\r\n            int256 result = -x;\r\n            assert (result > 0);\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice x+y. If any operator is higher than maxFixedAdd() it \r\n     * might overflow.\r\n     * In solidity maxInt256 + 1 = minInt256 and viceversa.\r\n     * @dev \r\n     * Test add(maxFixedAdd(),maxFixedAdd()) returns maxInt256()-1\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\r\n     * Test add(-maxFixedSub(),-maxFixedSub()) returns minInt256()\r\n     * Test add(-maxFixedSub()-1,-maxFixedSub()-1) fails\r\n     * Test add(maxInt256(),maxInt256()) fails\r\n     * Test add(minInt256(),minInt256()) fails\r\n     */\r\n    function add(int256 x, int256 y) internal pure returns (int256) {\r\n        int256 z = x + y;\r\n        if (x > 0 && y > 0) assert(z > x && z > y);\r\n        if (x < 0 && y < 0) assert(z < x && z < y);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n     * @notice x-y. You can use add(x,-y) instead. \r\n     * @dev Tests covered by add(x,y)\r\n     */\r\n    function subtract(int256 x, int256 y) internal pure returns (int256) {\r\n        return add(x,-y);\r\n    }\r\n\r\n    /**\r\n     * @notice x*y. If any of the operators is higher than maxFixedMul() it \r\n     * might overflow.\r\n     * @dev \r\n     * Test multiply(0,0) returns 0\r\n     * Test multiply(maxFixedMul(),0) returns 0\r\n     * Test multiply(0,maxFixedMul()) returns 0\r\n     * Test multiply(maxFixedMul(),fixed1()) returns maxFixedMul()\r\n     * Test multiply(fixed1(),maxFixedMul()) returns maxFixedMul()\r\n     * Test all combinations of (2,-2), (2, 2.5), (2, -2.5) and (0.5, -0.5)\r\n     * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\r\n     * Test multiply(maxFixedMul()-1,maxFixedMul()) equals multiply(maxFixedMul(),maxFixedMul()-1)\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) returns maxInt256() // Probably not to the last digits\r\n     * Test multiply(maxFixedMul()+1,maxFixedMul()) fails\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) fails\r\n     */\r\n    function multiply(int256 x, int256 y) internal pure returns (int256) {\r\n        if (x == 0 || y == 0) return 0;\r\n        if (y == fixed1()) return x;\r\n        if (x == fixed1()) return y;\r\n\r\n        // Separate into integer and fractional parts\r\n        // x = x1 + x2, y = y1 + y2\r\n        int256 x1 = integer(x) / fixed1();\r\n        int256 x2 = fractional(x);\r\n        int256 y1 = integer(y) / fixed1();\r\n        int256 y2 = fractional(y);\r\n        \r\n        // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\r\n        int256 x1y1 = x1 * y1;\r\n        if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1\r\n        \r\n        // x1y1 needs to be multiplied back by fixed1\r\n        // solium-disable-next-line mixedcase\r\n        int256 fixed_x1y1 = x1y1 * fixed1();\r\n        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed1()); // Overflow x1y1 * fixed1\r\n        x1y1 = fixed_x1y1;\r\n\r\n        int256 x2y1 = x2 * y1;\r\n        if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1\r\n\r\n        int256 x1y2 = x1 * y2;\r\n        if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2\r\n\r\n        x2 = x2 / mulPrecision();\r\n        y2 = y2 / mulPrecision();\r\n        int256 x2y2 = x2 * y2;\r\n        if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2\r\n\r\n        // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\r\n        int256 result = x1y1;\r\n        result = add(result, x2y1); // Add checks for overflow\r\n        result = add(result, x1y2); // Add checks for overflow\r\n        result = add(result, x2y2); // Add checks for overflow\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * @notice 1/x\r\n     * @dev \r\n     * Test reciprocal(0) fails\r\n     * Test reciprocal(fixed1()) returns fixed1()\r\n     * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\r\n     * Test reciprocal(2*fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\r\n     */\r\n    function reciprocal(int256 x) internal pure returns (int256) {\r\n        assert(x != 0);\r\n        return (fixed1()*fixed1()) / x; // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice x/y. If the dividend is higher than maxFixedDiv() it \r\n     * might overflow. You can use multiply(x,reciprocal(y)) instead.\r\n     * There is a loss of precision on division for the lower mulPrecision() decimals.\r\n     * @dev \r\n     * Test divide(fixed1(),0) fails\r\n     * Test divide(maxFixedDiv(),1) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,1) throws\r\n     * Test divide(maxFixedDiv(),maxFixedDiv()) returns fixed1()\r\n     */\r\n    function divide(int256 x, int256 y) internal pure returns (int256) {\r\n        if (y == fixed1()) return x;\r\n        assert(y != 0);\r\n        assert(y <= maxFixedDivisor());\r\n        return multiply(x, reciprocal(y));\r\n    }\r\n}\r\n\r\nlibrary LogarithmLib {\r\n\r\n    /**\r\n     * @notice This is e in the fixed point units used in this library.\r\n     * @dev 27182818284590452353602874713526624977572470936999595749669676277240766303535/fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function fixedE() internal pure returns(int256) {\r\n        return 2718281828459045235360287;\r\n    }\r\n\r\n    /**\r\n     * @notice ln(1.5), hardcoded with the comma 24 positions to the right.\r\n     */\r\n    // solium-disable-next-line mixedcase\r\n    function fixedLn1_5() internal pure returns(int256) {\r\n        return 405465108108164381978013;\r\n    }\r\n\r\n    /**\r\n     * @notice ln(10), hardcoded with the comma 24 positions to the right.\r\n     */\r\n    function fixedLn10() internal pure returns(int256) {\r\n        return 2302585092994045684017991;\r\n    }\r\n\r\n    /**\r\n     * @notice ln(x)\r\n     * This function has a 1/50 deviation close to ln(-1), \r\n     * 1/maxFixedMul() deviation at fixedE()**2, but diverges to 10x \r\n     * deviation at maxNewFixed().\r\n     * @dev \r\n     * Test ln(0) fails\r\n     * Test ln(-fixed1()) fails\r\n     * Test ln(fixed1()) returns 0\r\n     * Test ln(fixedE()) returns fixed1()\r\n     * Test ln(fixedE()*fixedE()) returns ln(fixedE())+ln(fixedE())\r\n     * Test ln(maxInt256) returns 176752531042786059920093411119162458112\r\n     * Test ln(1) returns -82\r\n     */\r\n    function ln(int256 value) internal pure returns (int256) {\r\n        assert(value >= 0);\r\n        int256 v = value;\r\n        int256 r = 0;\r\n        while (v <= FixidityLib.fixed1() / 10) {\r\n            v = v * 10;\r\n            r -= fixedLn10();\r\n        }\r\n        while (v >= 10 * FixidityLib.fixed1()) {\r\n            v = v / 10;\r\n            r += fixedLn10();\r\n        }\r\n        while (v < FixidityLib.fixed1()) {\r\n            v = FixidityLib.multiply(v, fixedE());\r\n            r -= FixidityLib.fixed1();\r\n        }\r\n        while (v > fixedE()) {\r\n            v = FixidityLib.divide(v, fixedE());\r\n            r += FixidityLib.fixed1();\r\n        }\r\n        if (v == FixidityLib.fixed1()) {\r\n            return r;\r\n        }\r\n        if (v == fixedE()) {\r\n            return FixidityLib.fixed1() + r;\r\n        }\r\n\r\n        v = v - 3 * FixidityLib.fixed1() / 2;\r\n        r = r + fixedLn1_5();\r\n        int256 m = FixidityLib.fixed1() * v / (v + 3 * FixidityLib.fixed1());\r\n        r = r + 2 * m;\r\n        // solium-disable-next-line mixedcase\r\n        int256 m_2 = m * m / FixidityLib.fixed1();\r\n        uint8 i = 3;\r\n        while (true) {\r\n            m = m * m_2 / FixidityLib.fixed1();\r\n            r = r + 2 * m / int256(i);\r\n            i += 2;\r\n            if (i >= 3 + 2 * FixidityLib.digits()) break;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * @notice log_b(x).\r\n     * *param int256 b Base in fixed point representation.\r\n     * @dev Tests covered by ln(x) and divide(a,b)\r\n     */\r\n    // solium-disable-next-line mixedcase\r\n    function log_b(int256 b, int256 x) internal pure returns (int256) {\r\n        if (b == FixidityLib.fixed1()*10)\r\n            return FixidityLib.divide(ln(x), fixedLn10());\r\n        return FixidityLib.divide(ln(x), ln(b));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"appriasedCapitalValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offChainLoanValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"Destroy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateFixedLtV\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fixedDecimalDigits\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFixedAppraisedCapitalValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFixedOffChainLoanValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFixedOnChainLoanValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFixedTokenisedRatio\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setAppraisedCapitalValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offChainLoanValue\",\"type\":\"uint256\"}],\"name\":\"setOffChainLoanValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LoanToValueDebtAggregator","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000037302c80000000000000000000000000000000000000000000000000000000001a2f20000000000000000000000000000000000000000000000000000000000000000134d4952495320415320477265656e20426f6e6400000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://6ac0082b086a1b26bf29017574465234f30dfe9c22bfad7c2979bf52935fff26"}]}