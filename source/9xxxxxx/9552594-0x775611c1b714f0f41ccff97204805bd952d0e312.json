{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nlibrary Address {\\r\\n \\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"},\"AuthModule.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ncontract AuthModule {\\r\\n\\r\\n    address primaryAdmin;\\r\\n    address primaryIssuer;\\r\\n    address primaryExchange;\\r\\n\\r\\n    event JobshipTransferred(\\r\\n        string  strType,\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner,\\r\\n        address indexed caller\\r\\n      );\\r\\n\\r\\n    constructor(\\r\\n        address _admin, \\r\\n        address _issuer, \\r\\n        address _exchange\\r\\n    ) \\r\\n        public \\r\\n    {\\r\\n        primaryAdmin = _admin;\\r\\n        primaryIssuer = _issuer;\\r\\n        primaryExchange = _exchange;\\r\\n    }\\r\\n\\r\\n    function isAdmin(address _admin) public view returns (bool) {\\r\\n        return primaryAdmin == _admin;\\r\\n    }\\r\\n\\r\\n    function isIssuer(address _issuer) public view returns (bool) {\\r\\n        return primaryIssuer == _issuer;\\r\\n    }\\r\\n\\r\\n    function isExchange(address _exchange) public view returns (bool) {\\r\\n        return primaryExchange == _exchange;\\r\\n    }\\r\\n\\r\\n    function transferIssuer(address _addr) public returns (bool) {\\r\\n        require (_addr != address(0) \\u0026\\u0026 _addr != primaryIssuer, \\\"_addr invalid\\\");\\r\\n        require (isIssuer(msg.sender) || isAdmin(msg.sender), \\\"only issuer or admin\\\");\\r\\n\\r\\n        emit JobshipTransferred(\\\"issuer\\\", primaryIssuer, _addr, msg.sender);\\r\\n        primaryIssuer = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferExchange(address _addr) public returns(bool) {\\r\\n        require (_addr != address(0) \\u0026\\u0026 _addr != primaryExchange, \\\"_addr invalid\\\");\\r\\n        require (isExchange(msg.sender) || isAdmin(msg.sender), \\\"only exchange or admin\\\");\\r\\n\\r\\n        emit JobshipTransferred(\\\"exchange\\\", primaryExchange, _addr, msg.sender);\\r\\n        primaryExchange = _addr;\\r\\n        return true;\\r\\n    }\\r\\n}\"},\"Authorization.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport \\\"./ContractBase.sol\\\";\\r\\nimport \\\"./Pausable.sol\\\";\\r\\nimport \\\"./AuthModule.sol\\\";\\r\\n\\r\\ncontract Authorization is ContractBase, Pausable{\\r\\n    \\r\\n    constructor(address _proxy) public ContractBase(_proxy) {\\r\\n\\r\\n    }\\r\\n\\r\\n    modifier onlyInside(address _sender) {\\r\\n        require(proxy.isInsideContract(_sender), \\\"Can only be called inside\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyIssuer(address _sender) {\\r\\n        AuthModule auth = AuthModule(proxy.getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isIssuer(_sender), \\\"Need to be issuer\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin(address _sender) {\\r\\n        AuthModule auth = AuthModule(proxy.getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isAdmin(_sender), \\\"Need to be admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyExchange(address _sender) {\\r\\n        AuthModule auth = AuthModule(proxy.getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isExchange(_sender), \\\"Need to be exchange\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyIssuerOrExchange(address _sender) {\\r\\n        AuthModule auth = AuthModule(proxy.getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isIssuer(_sender) || auth.isExchange(_sender), \\\"Need to be issuer or exchange\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyTokenModule(address _sender) {\\r\\n        require(_sender == proxy.getModule(\\\"TokenModule\\\"), \\\"Need to be tokenModule\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function unpause() public onlyAdmin(msg.sender)  {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    function pause() public onlyAdmin(msg.sender) {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n}\"},\"ComplianceModule.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"Proxy.sol\\\";\\r\\nimport \\\"StorageModule.sol\\\";\\r\\nimport \\\"TokenModule.sol\\\";\\r\\nimport \\\"Authorization.sol\\\";\\r\\nimport \\\"ICompliance.sol\\\";\\r\\n\\r\\ncontract ComplianceModule is Authorization {\\r\\n\\r\\n    mapping (bytes32 =\\u003e ICompliance[] ) public nationalCompliances;\\r\\n    ICompliance[] generalCompliances;\\r\\n\\r\\n    event UpdateNationalCompliance(bytes32 _country, address _compliance);\\r\\n    event RemoveNationalCompliance(bytes32 _country, address _compliance);\\r\\n    event UpdateGeneralCompliance(address _compliance);\\r\\n    event RemoveGeneralCompliance(address _compliance);\\r\\n\\r\\n    constructor(address _proxy) public Authorization(_proxy) {\\r\\n        \\r\\n    }\\r\\n\\r\\n    function mintCheck(address[] _investors, uint256[] _amounts) public view returns (bool) {\\r\\n        StorageModule sm = StorageModule(proxy.getModule(\\\"StorageModule\\\"));\\r\\n        \\r\\n        if(sm.shareholderExceeded(_investors.length) || sm.isTXFrozen())\\r\\n            return false;\\r\\n        for(uint i = 0; i\\u003c_investors.length; i++) \\r\\n        {\\r\\n            if(sm.isInvestorInWhitelist(_investors[i]) == false || sm.isInBlacklist(_investors[i]))\\r\\n                return false;\\r\\n\\r\\n            // general compliance\\r\\n            for(uint j = 0; j\\u003c generalCompliances.length; j++) \\r\\n            {\\r\\n                if(generalCompliances[j] != address(0) \\u0026\\u0026 generalCompliances[j].mintCheck(_investors[i], _amounts[i]) == false)\\r\\n                    return false;\\r\\n            }\\r\\n\\r\\n            // national compliance\\r\\n            bytes32 country = sm.getInvestorCountry(_investors[i]);\\r\\n            for(j = 0; j\\u003c nationalCompliances[country].length; j++) \\r\\n            {\\r\\n                if(nationalCompliances[country][j] != address(0) \\u0026\\u0026 nationalCompliances[country][j].mintCheck(_investors[i], _amounts[i]) == false)\\r\\n                    return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // TODO: should return result code not bool\\r\\n    // will be called while mint, burn and transaction\\r\\n    function txCheck(\\r\\n        address _from, \\r\\n        address _to, \\r\\n        uint256 _amount\\r\\n    ) \\r\\n        public \\r\\n        view\\r\\n        whenNotPaused \\r\\n        returns (bool) \\r\\n    {\\r\\n        StorageModule sm = StorageModule(proxy.getModule(\\\"StorageModule\\\"));\\r\\n        if(sm.isInvestorInWhitelist(_to) == false || sm.isInBlacklist(_from) || sm.isInBlacklist(_to) || sm.isTXFrozen())\\r\\n            return false;\\r\\n\\r\\n        // general compliance\\r\\n        for(uint i = 0; i\\u003c generalCompliances.length; i++) \\r\\n        {\\r\\n            if(generalCompliances[i] != address(0) \\u0026\\u0026 generalCompliances[i].txCheck(_to, _amount) == false)\\r\\n                return false;\\r\\n        }\\r\\n\\r\\n        // national compliance\\r\\n        bytes32 country = sm.getInvestorCountry(_to);\\r\\n        \\r\\n        for( i = 0; i\\u003c nationalCompliances[country].length; i++) \\r\\n        {\\r\\n            if(nationalCompliances[country][i] != address(0) \\u0026\\u0026 nationalCompliances[country][i].txCheck(_to, _amount) == false)\\r\\n                return false;\\r\\n        }\\r\\n            \\r\\n        if(sm.shareholderExceeded(1) == false) \\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n        else \\r\\n        {\\r\\n            TokenModule token = TokenModule(proxy.getModule(\\\"TokenModule\\\"));\\r\\n            uint256 balance = token.balanceOf(_from);\\r\\n            if(balance == _amount) {\\r\\n                // if the balance of _from is 0 after transaction, the new shareholder can swap out _from\\r\\n                // even if there is no available quota for new shareholder.\\r\\n                return true;    \\r\\n            }         \\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateNationalCompliance\\r\\n    (\\r\\n        bytes32 _country,\\r\\n        address _compliance\\r\\n    )\\r\\n        public\\r\\n        whenNotPaused\\r\\n        onlyAdmin(msg.sender)\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint length = nationalCompliances[_country].length;\\r\\n        uint firstAvaiPlace = length;\\r\\n        for(uint i = 0; i\\u003c length; i++) \\r\\n        {\\r\\n            if(nationalCompliances[_country][i] == _compliance) // just return\\r\\n            {\\r\\n                return false;\\r\\n            }\\r\\n            if (nationalCompliances[_country][i] == address(0) \\u0026\\u0026 firstAvaiPlace == length)\\r\\n            {\\r\\n                firstAvaiPlace = i;\\r\\n            }\\r\\n        }\\r\\n        if (firstAvaiPlace \\u003c length) \\r\\n        {\\r\\n            nationalCompliances[_country][firstAvaiPlace] = ICompliance(_compliance);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            nationalCompliances[_country].push(ICompliance(_compliance));\\r\\n        }\\r\\n        emit UpdateNationalCompliance(_country, _compliance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeNationalCompliance\\r\\n    (\\r\\n        bytes32 _country,\\r\\n        address _compliance\\r\\n    )\\r\\n        public\\r\\n        whenNotPaused\\r\\n        onlyAdmin(msg.sender)\\r\\n        returns(bool result)\\r\\n    {\\r\\n        uint length = nationalCompliances[_country].length;\\r\\n\\r\\n        for(uint i = 0; i\\u003c length; i++) \\r\\n        {\\r\\n            if(nationalCompliances[_country][i] == _compliance)\\r\\n            {\\r\\n                delete nationalCompliances[_country][i];\\r\\n                emit RemoveNationalCompliance(_country, _compliance);\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function updateGeneralCompliance\\r\\n    (\\r\\n        address _compliance\\r\\n    )\\r\\n        public\\r\\n        whenNotPaused\\r\\n        onlyAdmin(msg.sender)\\r\\n        returns(bool result)\\r\\n    {\\r\\n        uint length = generalCompliances.length;\\r\\n        uint firstAvaiPlace = length;\\r\\n        for(uint i = 0; i \\u003c length; i++) \\r\\n        {\\r\\n            if(generalCompliances[i] == _compliance)\\r\\n            {\\r\\n                return false;\\r\\n            }\\r\\n            if (generalCompliances[i] == address(0) \\u0026\\u0026 firstAvaiPlace == length)\\r\\n            {\\r\\n                firstAvaiPlace = i;\\r\\n            }\\r\\n        }\\r\\n        if (firstAvaiPlace \\u003c length)\\r\\n        {\\r\\n            generalCompliances[firstAvaiPlace] = ICompliance(_compliance);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            generalCompliances.push(ICompliance(_compliance));\\r\\n        }\\r\\n        \\r\\n        emit UpdateGeneralCompliance(_compliance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeGeneralCompliance\\r\\n    (\\r\\n        address _compliance\\r\\n    )\\r\\n        public\\r\\n        whenNotPaused\\r\\n        onlyAdmin(msg.sender)\\r\\n        returns(bool result)\\r\\n    {\\r\\n        uint length = generalCompliances.length;\\r\\n\\r\\n        for(uint i = 0; i \\u003c length; i++) \\r\\n        {\\r\\n            if(generalCompliances[i] == _compliance)\\r\\n            {\\r\\n                delete generalCompliances[i];\\r\\n                emit RemoveGeneralCompliance(_compliance);\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n}\"},\"ContractBase.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport \\\"Proxy.sol\\\";\\r\\n\\r\\ncontract ContractBase {\\r\\n    \\r\\n    Proxy proxy;\\r\\n\\r\\n    constructor(address _proxy) public {\\r\\n        proxy = Proxy(_proxy);\\r\\n    }\\r\\n    \\r\\n}\"},\"DubaiCompliance.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"./ICompliance.sol\\\";\\r\\nimport \\\"./ContractBase.sol\\\";\\r\\nimport \\\"./StorageModule.sol\\\";\\r\\n\\r\\ncontract DubaiCompliance is ICompliance, ContractBase {\\r\\n\\r\\n    constructor(address _proxy) public ContractBase(_proxy) {\\r\\n    }\\r\\n\\r\\n    function mintCheck(address _investor, uint _amount) external view returns(bool result) {\\r\\n        return investorCheck(_investor) || denominationCheck(_amount);\\r\\n    }\\r\\n\\r\\n    function txCheck(address _investor, uint256 _amount) external view returns(bool result) {\\r\\n        return investorCheck(_investor) || denominationCheck(_amount);\\r\\n    }\\r\\n\\r\\n    function investorCheck(address _investor) internal view returns(bool result) {\\r\\n        StorageModule sm = StorageModule(proxy.getModule(\\\"StorageModule\\\"));\\r\\n        if(sm.isProfessionalInvestor(_investor))\\r\\n            return true;\\r\\n\\r\\n        uint retailInvestorNo = sm.getRetailInvestor(_investor);\\r\\n        if(retailInvestorNo != 0 \\u0026\\u0026 retailInvestorNo \\u003c= 50 )\\r\\n            return true;\\r\\n        \\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function denominationCheck(uint256 _amount) internal pure returns(bool result) {\\r\\n\\r\\n        if(_amount  \\u003e= 100 * 1000)\\r\\n            return true;\\r\\n        \\r\\n        return false;\\r\\n    }\\r\\n}\"},\"ICompliance.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ninterface ICompliance {\\r\\n    function mintCheck(address _investor, uint _amount) external view returns(bool result);\\r\\n    function txCheck(address _from, uint256 _amount) external view returns(bool result);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n    external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function approve(address spender, uint256 value)\\r\\n    external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value)\\r\\n    external returns (bool);\\r\\n\\r\\n    event Transfer(\\r\\n    address indexed from,\\r\\n    address indexed to,\\r\\n    uint256 value\\r\\n    );\\r\\n\\r\\n    event Approval(\\r\\n    address indexed owner,\\r\\n    address indexed spender,\\r\\n    uint256 value\\r\\n    );\\r\\n}\\r\\n\"},\"IERC20Burnable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ninterface IERC20Burnable {\\r\\n    function burn(address[] _receiver, uint256[] _value, uint256[] _timestamp) external;\\r\\n    function burnAll(address[] _receiver) external;\\r\\n}\"},\"IERC20ImplUpgradeable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ninterface IERC20ImplUpgradeable {\\r\\n    function getImplAddress() view external returns(address);\\r\\n    function getMintBurnAddress() view external returns(address);\\r\\n    function isImplAddress(address) view external returns(bool);\\r\\n}\"},\"IERC20Mintable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ninterface IERC20Mintable {\\r\\n    function mint(address[] _receiver, uint256[] _value, uint256[] _timestamp) external;\\r\\n}\"},\"IOracle.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ninterface IOracle {\\r\\n\\r\\n    /**\\r\\n    * @notice Returns address of oracle currency (0x0 for ETH)\\r\\n    */\\r\\n    function getCurrencyAddress() external view returns(address);\\r\\n\\r\\n    /**\\r\\n    * @notice Returns symbol of oracle currency (0x0 for ETH)\\r\\n    */\\r\\n    function getCurrencySymbol() external view returns(bytes32);\\r\\n\\r\\n    /**\\r\\n    * @notice Returns denomination of price\\r\\n    */\\r\\n    function getCurrencyDenominated() external view returns(bytes32);\\r\\n\\r\\n    /**\\r\\n    * @notice Returns price - should throw if not valid\\r\\n    */\\r\\n    function getPrice(uint _amount) external view returns(uint256);\\r\\n\\r\\n}\\r\\n\"},\"ItMapUintAddress.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nlibrary ItMapUintAddress\\r\\n{\\r\\n    struct MapUintAddress\\r\\n    {\\r\\n        mapping(uint =\\u003e MapValue) data;\\r\\n        KeyFlag[] keys;\\r\\n        uint size;\\r\\n    }\\r\\n\\r\\n    struct MapValue { uint keyIndex; address value; }\\r\\n\\r\\n    struct KeyFlag { uint key; bool deleted; }\\r\\n\\r\\n    function add(MapUintAddress storage self, uint key, address value) public returns (bool replaced)\\r\\n    {\\r\\n        uint keyIndex = self.data[key].keyIndex;\\r\\n        self.data[key].value = value;\\r\\n        if (keyIndex \\u003e 0)\\r\\n            return true;\\r\\n        else\\r\\n        {\\r\\n            self.keys.push(KeyFlag(key, false));\\r\\n            self.data[key].keyIndex = self.keys.length;\\r\\n            self.size++;\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function remove(MapUintAddress storage self, uint key) public returns (bool success)\\r\\n    {\\r\\n        uint keyIndex = self.data[key].keyIndex;\\r\\n        if (keyIndex == 0)\\r\\n            return false;\\r\\n        delete self.data[key];\\r\\n        self.keys[keyIndex - 1].deleted = true;\\r\\n        self.size --;\\r\\n    }\\r\\n\\r\\n    function contain(MapUintAddress storage self, uint key) public view returns (bool)\\r\\n    {\\r\\n        return self.data[key].keyIndex \\u003e 0;\\r\\n    }\\r\\n\\r\\n    function startIndex(MapUintAddress storage self) public view returns (uint keyIndex)\\r\\n    {\\r\\n        return nextIndex(self, uint(-1));\\r\\n    }\\r\\n\\r\\n    function validIndex(MapUintAddress storage self, uint keyIndex) public view returns (bool)\\r\\n    {\\r\\n        return keyIndex \\u003c self.keys.length;\\r\\n    }\\r\\n\\r\\n    function nextIndex(MapUintAddress storage self, uint _keyIndex) public view returns (uint)\\r\\n    {\\r\\n        uint keyIndex = _keyIndex;\\r\\n        keyIndex++;\\r\\n        while (keyIndex \\u003c self.keys.length \\u0026\\u0026 self.keys[keyIndex].deleted)\\r\\n            keyIndex++;\\r\\n        return keyIndex;\\r\\n    }\\r\\n\\r\\n    function getByIndex(MapUintAddress storage self, uint keyIndex) public view returns (address value)\\r\\n    {\\r\\n        uint key = self.keys[keyIndex].key;\\r\\n        value = self.data[key].value;\\r\\n    }\\r\\n\\r\\n    function getByKey(MapUintAddress storage self, uint key) public view returns (address value) {\\r\\n        return self.data[key].value;\\r\\n    }\\r\\n}\"},\"LibMapAddressBool.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nlibrary LibMapAddressBool {\\r\\n\\r\\n    struct MapAddressBool {\\r\\n        mapping(address =\\u003e MapValue) data;  // do not modify this variable outside\\r\\n        uint256 length;\\r\\n    }\\r\\n\\r\\n    struct MapValue {\\r\\n        bool value;\\r\\n        bool inited;\\r\\n    }\\r\\n\\r\\n    function add(MapAddressBool storage self, address _key, bool _val) public returns (bool newAdded) {\\r\\n        if(!self.data[_key].inited) {\\r\\n            self.data[_key].inited = true;\\r\\n            self.length++;\\r\\n            newAdded = true;\\r\\n        }\\r\\n        self.data[_key].value = _val;\\r\\n    }\\r\\n\\r\\n    function remove(MapAddressBool storage self, address _key) public returns (bool removed) {\\r\\n        if(self.data[_key].inited) {\\r\\n            self.data[_key].inited = false;\\r\\n            // self.data[_key].value = false;  // no need to reset value here\\r\\n            self.length--;\\r\\n            removed = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function contain(MapAddressBool storage self, address _key) public view returns (bool) {\\r\\n        return self.data[_key].inited;\\r\\n    }\\r\\n\\r\\n    function get(MapAddressBool storage self, address _key) public view returns (bool) {\\r\\n        if(!self.data[_key].inited)\\r\\n            return false;\\r\\n        return self.data[_key].value; \\r\\n    }\\r\\n\\r\\n    // function getLength(AddressBool storage self) public view returns (uint) {\\r\\n    //     return self.length;\\r\\n    // }\\r\\n}\\r\\n\\r\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ncontract Pausable {\\r\\n\\r\\n    event Pause();\\r\\n    event Unpause();\\r\\n\\r\\n    bool public paused = false;\\r\\n\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused, \\\"Contract is paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier whenPaused() {\\r\\n        require(paused, \\\"Contract is not paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _pause() internal whenNotPaused {\\r\\n        paused = true;\\r\\n        emit Pause();\\r\\n    }\\r\\n\\r\\n    function _unpause() internal whenPaused {\\r\\n        paused = false;\\r\\n        emit Unpause();\\r\\n    }\\r\\n\\r\\n}\\r\\n\"},\"Proxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport { AuthModule } from \\\"./AuthModule.sol\\\";\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\ncontract Proxy {\\r\\n    using Address for address;\\r\\n\\r\\n    mapping(string =\\u003e address) moduleMap;\\r\\n    mapping(address =\\u003e bool) insideContracts;   // all internal contract address, used to make sure only called from inside\\r\\n\\r\\n    event AddInsideContract(address _contract);\\r\\n    event AddInsideContracts(address[] _contracts);\\r\\n    event RemoveInsideContract(address _contract);\\r\\n    event UpdateModule(string _moduleName, address _preModule, address _newModule);\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        AuthModule auth = AuthModule(getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isAdmin(msg.sender), \\\"Need be admin\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    constructor(address authModule) public {\\r\\n        _updateModule(\\\"AuthModule\\\", authModule, true);\\r\\n    }\\r\\n\\r\\n    function addInsideContract(address _contract) public onlyAdmin {\\r\\n        _addInsideContract(_contract);\\r\\n    }\\r\\n\\r\\n    function _addInsideContract(address _contract) private {\\r\\n        // require(insideContracts[_contract] == false, \\\"Inside contract already exists\\\");\\r\\n        insideContracts[_contract] = true;\\r\\n        emit AddInsideContract(_contract);\\r\\n    }\\r\\n    \\r\\n    function addInsideContracts(address[] _contracts) public onlyAdmin {\\r\\n        for(uint i = 0; i \\u003c _contracts.length; i++) {\\r\\n            // require(insideContracts[_contracts[i]] == false, \\\"Inside contract already exists\\\");\\r\\n            insideContracts[_contracts[i]] = true;\\r\\n        }\\r\\n        emit AddInsideContracts(_contracts);\\r\\n    }\\r\\n\\r\\n    function removeInsideContract(address _contract) public onlyAdmin {\\r\\n        _removeInsideContract(_contract);\\r\\n    }\\r\\n\\r\\n    function _removeInsideContract(address _contract) private {\\r\\n        delete insideContracts[_contract];\\r\\n        emit RemoveInsideContract(_contract);\\r\\n    }\\r\\n\\r\\n    // TODO: need to check if the address is a contract\\r\\n    function isInsideContract(address _contract) public view returns (bool) {\\r\\n        return _contract.isContract() \\u0026\\u0026 insideContracts[_contract] == true;\\r\\n    }\\r\\n\\r\\n    function updateModule(string _moduleName, address _module, bool _insideContract) public onlyAdmin {\\r\\n        _updateModule(_moduleName, _module, _insideContract);\\r\\n    }\\r\\n\\r\\n    function _updateModule(string _moduleName, address _module, bool _insideContract) private {\\r\\n        address preModule = moduleMap[_moduleName];\\r\\n        if(preModule != address(0))\\r\\n            _removeInsideContract(preModule);\\r\\n        moduleMap[_moduleName] = _module;\\r\\n        if(_insideContract \\u0026\\u0026 _module != address(0))\\r\\n            _addInsideContract(_module);\\r\\n        emit UpdateModule(_moduleName, preModule, _module);\\r\\n    }\\r\\n\\r\\n    function getModule(string _moduleName) public view returns (address) {\\r\\n        return moduleMap[_moduleName];\\r\\n    } \\r\\n    \\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"StorageModule.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"Proxy.sol\\\";\\r\\nimport \\\"./AuthModule.sol\\\";\\r\\nimport \\\"./TokenModule.sol\\\";\\r\\nimport \\\"./Authorization.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./LibMapAddressBool.sol\\\";\\r\\nimport \\\"./StringUtils.sol\\\";\\r\\n\\r\\n\\r\\ncontract StorageModule is Authorization {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using LibMapAddressBool for LibMapAddressBool.MapAddressBool;\\r\\n    using StringUtils for string;\\r\\n\\r\\n    LibMapAddressBool.MapAddressBool shareholders;\\r\\n    mapping(address =\\u003e bool) investorWhitelist;\\r\\n    mapping(address =\\u003e bool) investorBlacklist;\\r\\n    mapping(address =\\u003e InvestorInfo) investorInfo;\\r\\n    mapping(address =\\u003e InvestorDocument) investorDocuments;\\r\\n    mapping(uint =\\u003e address) usedHashid;\\r\\n\\r\\n    mapping(bytes32 =\\u003e uint256) retailInvestorCounts;\\r\\n    mapping(bytes32 =\\u003e mapping(address =\\u003e uint256)) retailInvestors;\\r\\n    \\r\\n    bool public isTXFrozen;\\r\\n    uint256 public shareholderMaxAmount;\\r\\n    string[] public allowCountrys;\\r\\n\\r\\n    event AddInvestorToWhitelist(address _investor);\\r\\n    event AddInvestorsToWhitelist(address[] _investors);\\r\\n    event RemoveInvestorFromWhitelist(address _investor);\\r\\n    event UpdateBlacklist(address[] _investors, bool _black);\\r\\n    event SetShareholderMaxAmount(uint _oldValue, uint _newValue);\\r\\n    event InitShareholders(address[] _shareholders, bool _original);\\r\\n    event AddShareholder(address _shareholder, uint _balance);\\r\\n    event RemoveShareholder(address _shareholder, uint _balance);\\r\\n    // event AddInvestorInfo(address _investor, uint hashid, string _country, bool _kyc, uint _validDate);\\r\\n    event UpdateInvestorInfo(address _investor, uint hashid, string _country, bool _kyc, uint _validDate, bool _pi);\\r\\n    // event AddDocument(address _investor, string _url, uint _hash);\\r\\n    event UpdateDocument(address _investor, string _url, uint _hash);\\r\\n\\r\\n    struct Shareholder {\\r\\n        bool inited;\\r\\n        bool original;\\r\\n    }\\r\\n\\r\\n    //专业投资者 Pi,合规投资者,前x名合规投资者\\r\\n    struct InvestorInfo {\\r\\n        bool inited;\\r\\n        uint hashid; //是投资者所有资料串在一起的hash值\\r\\n        string country;//地区\\r\\n        bool kyc;// 合规投资者认证\\r\\n        uint validDate;\\r\\n        bool pi; //is professional, pi和kyc必须要有一个是true\\r\\n    }\\r\\n\\r\\n    struct InvestorDocument {\\r\\n        string url;\\r\\n        uint hash;\\r\\n    }\\r\\n\\r\\n    constructor(address _proxy) public Authorization(_proxy) {\\r\\n        \\r\\n    }\\r\\n\\r\\n    function freezeTX(bool _freeze) public onlyAdmin(msg.sender) whenNotPaused {\\r\\n        isTXFrozen = _freeze;\\r\\n    }\\r\\n\\r\\n    function addInvestorToWhitelist(address _investor) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        investorWhitelist[_investor] = true;\\r\\n        emit AddInvestorToWhitelist(_investor);\\r\\n    }\\r\\n\\r\\n    function addInvestorsToWhitelist(address[] _investors) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        for(uint i = 0; i \\u003c _investors.length; i++) {\\r\\n            investorWhitelist[_investors[i]] = true;\\r\\n        }\\r\\n        emit AddInvestorsToWhitelist(_investors);\\r\\n    }\\r\\n\\r\\n    function updateBlacklist(address[] _investors, bool _black) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        for(uint i = 0; i \\u003c _investors.length; i++) {\\r\\n            investorBlacklist[_investors[i]] = _black;\\r\\n        }\\r\\n        emit UpdateBlacklist(_investors, _black);\\r\\n    }\\r\\n\\r\\n    function removeInvestorFromWhitelist(address _investor) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        delete investorWhitelist[_investor];\\r\\n        emit RemoveInvestorFromWhitelist(_investor);\\r\\n    }\\r\\n\\r\\n    function addRetailInvestor(address _investor) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        bytes32 _country= getInvestorCountry(_investor);\\r\\n        if(retailInvestors[_country][_investor] != 0)\\r\\n            return;\\r\\n        retailInvestors[_country][_investor] = ++retailInvestorCounts[_country];\\r\\n    }\\r\\n\\r\\n    function getRetailInvestorCount(bytes32 _country) external view returns (uint256) {\\r\\n        return retailInvestorCounts[_country];\\r\\n    }\\r\\n\\r\\n    function getRetailInvestor(address _investor) external view returns (uint256) {\\r\\n        bytes32 _country= getInvestorCountry(_investor);\\r\\n        return retailInvestors[_country][_investor];\\r\\n    }\\r\\n\\r\\n    function isInvestorInWhitelist(address _investor) external view returns (bool) {\\r\\n        return investorWhitelist[_investor];\\r\\n    }\\r\\n\\r\\n    function isInBlacklist(address _investor) external view returns (bool) {\\r\\n        return investorBlacklist[_investor];\\r\\n    }\\r\\n\\r\\n    function isProfessionalInvestor(address _investor) external view returns (bool) {\\r\\n        return investorInfo[_investor].pi;\\r\\n    }\\r\\n\\r\\n    function setShareholderMaxAmount(uint256 _shareholderMaxAmount) public onlyIssuer(msg.sender) whenNotPaused {\\r\\n        uint256 preValue = shareholderMaxAmount;\\r\\n        shareholderMaxAmount = _shareholderMaxAmount;\\r\\n        emit SetShareholderMaxAmount(preValue, shareholderMaxAmount);\\r\\n    }\\r\\n\\r\\n    // called after mint\\r\\n    function initShareholders(address[] _shareholders, bool _original) public onlyInside(msg.sender) whenNotPaused {\\r\\n        for(uint i = 0; i \\u003c _shareholders.length; i++) {\\r\\n            shareholders.add(_shareholders[i], _original);\\r\\n        }\\r\\n        emit InitShareholders(_shareholders, _original);\\r\\n    }\\r\\n\\r\\n    // called after transaction or burn\\r\\n    function updateShareholders(address _from, address _to) public onlyInside(msg.sender) whenNotPaused {\\r\\n        TokenModule token = TokenModule(proxy.getModule(\\\"TokenModule\\\"));\\r\\n        uint balanceFrom = token.balanceOf(_from);\\r\\n        uint balanceTo = token.balanceOf(_to);\\r\\n        if(balanceFrom == 0)\\r\\n            removeShareholder(_from, 0);\\r\\n        // no need to check investors amount here, cause ComplicanceModule will do the job.\\r\\n        // _to will be 0 while burn\\r\\n        if(_to != address(0))\\r\\n            addShareholder(_to, balanceTo); \\r\\n    }  \\r\\n\\r\\n    function addShareholder(address _shareholder, uint _balance) private {\\r\\n        bool newAdded = shareholders.add(_shareholder, false);\\r\\n        if(newAdded)\\r\\n            emit AddShareholder(_shareholder, _balance);\\r\\n    }\\r\\n\\r\\n    function removeShareholder(address _shareholder, uint _balance) private {\\r\\n        bool removed = shareholders.remove(_shareholder);\\r\\n        if(removed)\\r\\n            emit RemoveShareholder(_shareholder, _balance);\\r\\n    }\\r\\n\\r\\n    function shareholderAmount() public view returns (uint256) {\\r\\n        return shareholders.length;\\r\\n    }\\r\\n\\r\\n    function isShareholder(address _address) public view returns (bool) {\\r\\n        return shareholders.contain(_address);\\r\\n    }\\r\\n    \\r\\n    function shareholderExceeded(uint amount) public view returns (bool) {\\r\\n        return shareholders.length + amount \\u003e shareholderMaxAmount;\\r\\n    }\\r\\n\\r\\n    function getInvestorCountry(address _address) public view returns (bytes32 result) {\\r\\n        string memory country = investorInfo[_address].country;\\r\\n        assembly {\\r\\n            result := mload(add(country, 32))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // function addInvestorInfo(\\r\\n    //     address _investor, \\r\\n    //     uint _investorHash,\\r\\n    //     string _country, \\r\\n    //     bool _kyc, \\r\\n    //     uint _validDate\\r\\n    // ) \\r\\n    //     external \\r\\n    //     onlyIssuerOrExchange(msg.sender) \\r\\n    // {\\r\\n    //     require(investorInfo[_investor].inited == false, \\\"Investor already exists\\\");\\r\\n    //     investorInfo[_investor] = InvestorInfo(true, _investorHash, _country, _kyc, _validDate);\\r\\n    //     emit AddInvestorInfo(_investor, _investorHash, _country, _kyc, _validDate);\\r\\n    // }\\r\\n\\r\\n    function updateInvestorInfo(\\r\\n        address _investor, \\r\\n        uint _hashid,\\r\\n        string _country, \\r\\n        bool _kyc, \\r\\n        uint _validDate ,\\r\\n        bool _pi\\r\\n    ) \\r\\n        external \\r\\n        onlyIssuerOrExchange(msg.sender) \\r\\n        whenNotPaused\\r\\n        returns(bool)\\r\\n    {\\r\\n        // require(investorInfo[_investor].inited == true, \\\"Investor do not exist\\\");\\r\\n        bool temp_pi = true; //temp_pi = _pi; // force set all guys is professional.\\r\\n        require (_kyc || temp_pi, \\\"require _kyc or _pi at less one be true\\\");\\r\\n        require (isAllowCountry(_country), \\\"country not allow\\\");\\r\\n        require (_hashid != 0);\\r\\n        require (usedHashid[_hashid] == address(0) || usedHashid[_hashid] == _investor);\\r\\n        \\r\\n        //uint oldhashid = investorInfo[_investor].hashid;\\r\\n        investorInfo[_investor] = InvestorInfo(true, _hashid, _country, _kyc, _validDate, temp_pi);\\r\\n        usedHashid[_hashid] = _investor;\\r\\n        //if (oldhashid != _hashid) //\\r\\n        //    delete usedHashid[oldhashid];\\r\\n        emit UpdateInvestorInfo(_investor, _hashid, _country, _kyc, _validDate, temp_pi);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getInvestorInfo(address _investor) public view returns (uint, string, bool, uint, bool) {\\r\\n        InvestorInfo storage info = investorInfo[_investor];\\r\\n        return (info.hashid, info.country, info.kyc, info.validDate, info.pi);\\r\\n    }\\r\\n\\r\\n    // function addDocument(\\r\\n    //     address _investor, \\r\\n    //     string _url, \\r\\n    //     uint _hash\\r\\n    // ) \\r\\n    //     external \\r\\n    //     onlyIssuerOrExchange(msg.sender) \\r\\n    // {\\r\\n    //     InvestorDocument storage doc = investorDocuments[_investor];\\r\\n    //     require(doc.hash == 0, \\\"Investor document already exists\\\");\\r\\n    //     investorDocuments[_investor] = InvestorDocument(_url, _hash);\\r\\n    //     emit AddDocument(_investor, _url, _hash);\\r\\n    // }\\r\\n\\r\\n    function updateDocument(\\r\\n        address _investor, \\r\\n        string _url, \\r\\n        uint _hash\\r\\n    ) \\r\\n        external \\r\\n        onlyIssuerOrExchange(msg.sender) \\r\\n        whenNotPaused\\r\\n    {\\r\\n        // InvestorDocument storage doc = investorDocuments[_investor];\\r\\n        // require(doc.hash != 0, \\\"Investor document do not exists\\\");\\r\\n        investorDocuments[_investor] = InvestorDocument(_url, _hash);\\r\\n        emit UpdateDocument(_investor, _url, _hash);\\r\\n    }\\r\\n\\r\\n    function getDocument(address _investor) external view returns (string, uint) {\\r\\n        InvestorDocument storage doc = investorDocuments[_investor];\\r\\n        return (doc.url, doc.hash);\\r\\n    }\\r\\n\\r\\n    function addAllowCountrys(string _country)\\r\\n        external \\r\\n        onlyIssuerOrExchange(msg.sender)\\r\\n        returns (bool)\\r\\n    {\\r\\n        bytes memory strmemct = bytes(_country);\\r\\n        require (strmemct.length \\u003e 0, \\\"country can not empty\\\");\\r\\n\\r\\n        uint aclen = allowCountrys.length;\\r\\n        uint firstEmptyPlace = aclen;\\r\\n        for (uint i=0; i \\u003c aclen; i++)\\r\\n        {\\r\\n            if (allowCountrys[i].equal(_country))\\r\\n                return false;\\r\\n            bytes memory strmem = bytes(allowCountrys[i]);\\r\\n            if (strmem.length == 0 \\u0026\\u0026 firstEmptyPlace == aclen)\\r\\n                firstEmptyPlace = i;\\r\\n        }\\r\\n        if (firstEmptyPlace != aclen)\\r\\n            allowCountrys[firstEmptyPlace] = _country;\\r\\n        else\\r\\n            allowCountrys.push(_country);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeAllowCountrys(string _country) \\r\\n        external\\r\\n        onlyIssuerOrExchange(msg.sender)\\r\\n        returns (bool) \\r\\n    {\\r\\n        uint aclen = allowCountrys.length;\\r\\n        for (uint i=0; i \\u003c aclen; i++)\\r\\n        {\\r\\n            if (allowCountrys[i].equal(_country))\\r\\n            {\\r\\n                delete allowCountrys[i];\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function isAllowCountry(string _country)\\r\\n        public\\r\\n        returns(bool)\\r\\n    {\\r\\n        uint aclen = allowCountrys.length;\\r\\n        for (uint i=0; i \\u003c aclen; i++)\\r\\n        {\\r\\n            if (allowCountrys[i].equal(_country)) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n}\"},\"StringUtils.sol\":{\"content\":\"library StringUtils {\\r\\n    /// @dev Does a byte-by-byte lexicographical comparison of two strings.\\r\\n    /// @return a negative number if `_a` is smaller, zero if they are equal\\r\\n    /// and a positive numbe if `_b` is smaller.\\r\\n    function compare(string _a, string _b) returns (int) {\\r\\n        bytes memory a = bytes(_a);\\r\\n        bytes memory b = bytes(_b);\\r\\n        uint minLength = a.length;\\r\\n        if (b.length \\u003c minLength) minLength = b.length;\\r\\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\\r\\n        for (uint i = 0; i \\u003c minLength; i ++)\\r\\n            if (a[i] \\u003c b[i])\\r\\n                return -1;\\r\\n            else if (a[i] \\u003e b[i])\\r\\n                return 1;\\r\\n        if (a.length \\u003c b.length)\\r\\n            return -1;\\r\\n        else if (a.length \\u003e b.length)\\r\\n            return 1;\\r\\n        else\\r\\n            return 0;\\r\\n    }\\r\\n    /// @dev Compares two strings and returns true iff they are equal.\\r\\n    function equal(string _a, string _b) returns (bool) {\\r\\n        return compare(_a, _b) == 0;\\r\\n    }\\r\\n    /// @dev Finds the index of the first occurrence of _needle in _haystack\\r\\n    function indexOf(string _haystack, string _needle) returns (int)\\r\\n    {\\r\\n    \\tbytes memory h = bytes(_haystack);\\r\\n    \\tbytes memory n = bytes(_needle);\\r\\n    \\tif(h.length \\u003c 1 || n.length \\u003c 1 || (n.length \\u003e h.length)) \\r\\n    \\t\\treturn -1;\\r\\n    \\telse if(h.length \\u003e (2**128 -1)) // since we have to be able to return -1 (if the char isn\\u0027t found or input error), this function must return an \\\"int\\\" type with a max length of (2^128 - 1)\\r\\n    \\t\\treturn -1;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n    \\telse\\r\\n    \\t{\\r\\n    \\t\\tuint subindex = 0;\\r\\n    \\t\\tfor (uint i = 0; i \\u003c h.length; i ++)\\r\\n    \\t\\t{\\r\\n    \\t\\t\\tif (h[i] == n[0]) // found the first char of b\\r\\n    \\t\\t\\t{\\r\\n    \\t\\t\\t\\tsubindex = 1;\\r\\n    \\t\\t\\t\\twhile(subindex \\u003c n.length \\u0026\\u0026 (i + subindex) \\u003c h.length \\u0026\\u0026 h[i + subindex] == n[subindex]) // search until the chars don\\u0027t match or until we reach the end of a or b\\r\\n    \\t\\t\\t\\t{\\r\\n    \\t\\t\\t\\t\\tsubindex++;\\r\\n    \\t\\t\\t\\t}\\t\\r\\n    \\t\\t\\t\\tif(subindex == n.length)\\r\\n    \\t\\t\\t\\t\\treturn int(i);\\r\\n    \\t\\t\\t}\\r\\n    \\t\\t}\\r\\n    \\t\\treturn -1;\\r\\n    \\t}\\t\\r\\n    }\\r\\n}\"},\"TokenModule.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport { Proxy } from \\\"Proxy.sol\\\";\\r\\nimport { StorageModule } from \\\"./StorageModule.sol\\\";\\r\\nimport { AuthModule } from \\\"./AuthModule.sol\\\";\\r\\nimport \\\"./ItMapUintAddress.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IERC20Mintable.sol\\\";\\r\\nimport \\\"./IERC20Burnable.sol\\\";\\r\\nimport \\\"./IERC20ImplUpgradeable.sol\\\";\\r\\nimport \\\"./Authorization.sol\\\";\\r\\n\\r\\ncontract TokenModule is Authorization {\\r\\n    \\r\\n    using ItMapUintAddress for ItMapUintAddress.MapUintAddress;\\r\\n\\r\\n    ItMapUintAddress.MapUintAddress tokenMap;\\r\\n\\r\\n    event UpdateToken(uint _tag, address _old, address _new);\\r\\n\\r\\n    constructor(address _proxy) public Authorization(_proxy) {\\r\\n       \\r\\n    }\\r\\n\\r\\n    function addToken(uint _tag, address _token) external whenNotPaused onlyAdmin(msg.sender) {\\r\\n        require(tokenMap.data[_tag].value == address(0), \\\"Token already exists\\\");\\r\\n        tokenMap.add(_tag, _token);\\r\\n        emit UpdateToken(_tag, address(0), _token);\\r\\n    }\\r\\n\\r\\n    function updateToken(uint _tag, address _token) external whenNotPaused onlyAdmin(msg.sender) {\\r\\n        require(tokenMap.data[_tag].value != address(0), \\\"Token not exists\\\");\\r\\n        address _old = tokenMap.data[_tag].value;\\r\\n        tokenMap.add(_tag, _token);\\r\\n        emit UpdateToken(_tag, _old, _token);\\r\\n    }\\r\\n\\r\\n    function getToken(uint _tag) external view returns (address) {\\r\\n        return tokenMap.getByKey(_tag);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _from) external view returns (uint256 sum) {\\r\\n        for(uint i = tokenMap.startIndex(); tokenMap.validIndex(i); i = tokenMap.nextIndex(i)) {\\r\\n            IERC20 _token = IERC20(tokenMap.getByIndex(i));\\r\\n            if(_token != address(0))\\r\\n                sum += _token.balanceOf(_from);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mint(uint _tokenTag, address[] _investors, uint[] _balances, uint[] _timestamps, bool _originals) external whenNotPaused onlyIssuer(msg.sender) {\\r\\n        IERC20ImplUpgradeable token = IERC20ImplUpgradeable(tokenMap.getByKey(_tokenTag));\\r\\n        IERC20Mintable impl = IERC20Mintable(token.getMintBurnAddress());\\r\\n        require(impl != address(0), \\\"mint impl require not 0\\\");\\r\\n\\r\\n        impl.mint(_investors, _balances, _timestamps);\\r\\n\\r\\n        StorageModule sm = StorageModule(proxy.getModule(\\\"StorageModule\\\"));\\r\\n        sm.initShareholders(_investors, _originals);\\r\\n    }\\r\\n\\r\\n    function burn(uint _tokenTag, address[] _investors, uint256[] _values, uint256[] _timestamps) external whenNotPaused onlyIssuer(msg.sender) {\\r\\n        IERC20ImplUpgradeable token = IERC20ImplUpgradeable(tokenMap.getByKey(_tokenTag));\\r\\n        IERC20Burnable impl = IERC20Burnable(token.getMintBurnAddress());\\r\\n        require(impl != address(0), \\\"burn impl require not 0\\\");\\r\\n        impl.burn(_investors, _values, _timestamps);\\r\\n    }\\r\\n\\r\\n    function burnAll(uint _tokenTag, address[] _investors) external whenNotPaused onlyIssuer(msg.sender) {\\r\\n        IERC20ImplUpgradeable token = IERC20ImplUpgradeable(tokenMap.getByKey(_tokenTag));\\r\\n        IERC20Burnable impl = IERC20Burnable(token.getMintBurnAddress());\\r\\n        require(impl != address(0), \\\"burn impl require not 0\\\");\\r\\n        impl.burnAll(_investors);\\r\\n    }\\r\\n\\r\\n    function getTokenTags() external view returns(uint[] tags){\\r\\n        tags = new uint[](tokenMap.size);\\r\\n        uint j = 0;\\r\\n        for(uint i = tokenMap.startIndex(); tokenMap.validIndex(i); i = tokenMap.nextIndex(i)) {\\r\\n            tags[j] = tokenMap.keys[i].key;\\r\\n            ++j;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintCheck\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"txCheck\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DubaiCompliance","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002be753dd5f5400f5ffc896d6cad195b5db56f857","Library":"","LicenseType":"None","SwarmSource":"bzzr://922f84499d8112790ead0ea488e8edc160dbcb6ae81346c9efd3e63107a5c05c"}]}