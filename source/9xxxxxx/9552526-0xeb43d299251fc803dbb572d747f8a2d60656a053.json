{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 /* is ERC165 */ {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n// File: contracts/roles/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"role already has the account\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"role dosen't have the account\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/erc/ERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-165 Standard Interface Detection\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-165\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: contracts/erc/ERC173.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\ninterface IERC173 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return The address of the owner.\r\n    function owner() external view returns (address);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\ncontract ERC173 is IERC173, ERC165  {\r\n    address private _owner;\r\n\r\n    constructor() public {\r\n        _registerInterface(0x7f5828d0);\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner(), \"Must be owner\");\r\n        _;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner() {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address _newOwner) internal {\r\n        address previousOwner = owner();\r\n\t_owner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/roles/Operatable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract Operatable is ERC173 {\r\n    using Roles for Roles.Role;\r\n\r\n    event OperatorAdded(address indexed account);\r\n    event OperatorRemoved(address indexed account);\r\n\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n    Roles.Role private operators;\r\n\r\n    constructor() public {\r\n        operators.add(msg.sender);\r\n        _paused = false;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(isOperator(msg.sender), \"Must be operator\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOperator() {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function isOperator(address account) public view returns (bool) {\r\n        return operators.has(account);\r\n    }\r\n\r\n    function addOperator(address account) public onlyOperator() {\r\n        operators.add(account);\r\n        emit OperatorAdded(account);\r\n    }\r\n\r\n    function removeOperator(address account) public onlyOperator() {\r\n        operators.remove(account);\r\n        emit OperatorRemoved(account);\r\n    }\r\n\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function pause() public onlyOperator() whenNotPaused() {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function unpause() public onlyOperator() whenPaused() {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n\r\n    function withdrawEther() public onlyOperator() {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Holder.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(address, address, uint256, bytes memory) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n// File: contracts/erc721converter.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract ERC721Converter is ERC721Holder, Operatable {\r\n  IERC721 Alice;\r\n  IERC721 Bob;\r\n\r\n  address public aliceContract;\r\n  address public bobContract;\r\n\r\n  mapping (uint256 => uint256) private _idMapAliceToBob;\r\n  mapping (uint256 => uint256) private _idMapBobToAlice;\r\n\r\n  constructor(address _alice, address _bob) public {\r\n    aliceContract = _alice;\r\n    bobContract = _bob;\r\n    Alice = IERC721(aliceContract);\r\n    Bob = IERC721(bobContract);\r\n  }\r\n\r\n  function updateAlice(address _newAlice) external onlyOperator() {\r\n    aliceContract = _newAlice;\r\n    Alice = IERC721(_newAlice);\r\n  }\r\n\r\n  function updateBob(address _newBob) external onlyOperator() {\r\n    bobContract = _newBob;\r\n    Bob = IERC721(_newBob);\r\n  }\r\n\r\n  function draftAliceTokens(uint256[] memory _aliceTokenIds, uint256[] memory _bobTokenIds) public onlyOperator() {\r\n    require(_aliceTokenIds.length == _bobTokenIds.length);\r\n    for (uint256 i = 0; i < _aliceTokenIds.length; i++) {\r\n      draftAliceToken(_aliceTokenIds[i], _bobTokenIds[i]);\r\n    }\r\n  }\r\n\r\n  function draftBobTokens(uint256[] memory _bobTokenIds, uint256[] memory _aliceTokenIds) public onlyOperator() {\r\n    require(_aliceTokenIds.length == _bobTokenIds.length);\r\n    for (uint256 i = 0; i < _aliceTokenIds.length; i++) {\r\n      draftBobToken(_bobTokenIds[i], _aliceTokenIds[i]);\r\n    }\r\n  }\r\n\r\n  function draftAliceToken(uint256 _aliceTokenId, uint256 _bobTokenId) public onlyOperator() {\r\n    require(Alice.ownerOf(_aliceTokenId) == address(this), \"_aliceTokenId is not owned\");\r\n    require(_idMapAliceToBob[_aliceTokenId] == 0, \"_aliceTokenId is already assignd\");\r\n    require(_idMapBobToAlice[_bobTokenId] == 0, \"_bobTokenId is already assignd\");\r\n\r\n    _idMapAliceToBob[_aliceTokenId] = _bobTokenId;\r\n    _idMapBobToAlice[_bobTokenId] = _aliceTokenId;\r\n  }\r\n\r\n  function draftBobToken(uint256 _bobTokenId, uint256 _aliceTokenId) public onlyOperator() {\r\n    require(Bob.ownerOf(_bobTokenId) == address(this), \"_bobTokenId is not owned\");\r\n    require(_idMapBobToAlice[_bobTokenId] == 0, \"_bobTokenId is already assignd\");\r\n    require(_idMapAliceToBob[_aliceTokenId] == 0, \"_aliceTokenId is already assignd\");\r\n\r\n    _idMapBobToAlice[_bobTokenId] = _aliceTokenId;\r\n    _idMapAliceToBob[_aliceTokenId] = _bobTokenId;\r\n  }\r\n\r\n  function getBobTokenID(uint256 _aliceTokenId) public view returns(uint256) {\r\n    return _idMapAliceToBob[_aliceTokenId];\r\n  }\r\n\r\n  function getAliceTokenID(uint256 _bobTokenId) public view returns(uint256) {\r\n    return _idMapBobToAlice[_bobTokenId];\r\n  }\r\n\r\n  function convertFromAliceToBob(uint256 _tokenId) external whenNotPaused() {\r\n    Alice.safeTransferFrom(msg.sender, address(this), _tokenId);\r\n    Bob.safeTransferFrom(address(this), msg.sender, getBobTokenID(_tokenId));\r\n  }\r\n\r\n  function convertFromBobToAlice(uint256 _tokenId) external whenNotPaused() {\r\n    Bob.safeTransferFrom(msg.sender, address(this), _tokenId);\r\n    Alice.safeTransferFrom(address(this), msg.sender, getAliceTokenID(_tokenId));\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aliceTokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_bobTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"draftAliceTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bobTokenId\",\"type\":\"uint256\"}],\"name\":\"getAliceTokenID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAlice\",\"type\":\"address\"}],\"name\":\"updateAlice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"convertFromBobToAlice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bobTokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_aliceTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"draftBobTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBob\",\"type\":\"address\"}],\"name\":\"updateBob\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_aliceTokenId\",\"type\":\"uint256\"}],\"name\":\"getBobTokenID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"convertFromAliceToBob\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bobTokenId\",\"type\":\"uint256\"},{\"name\":\"_aliceTokenId\",\"type\":\"uint256\"}],\"name\":\"draftBobToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bobContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aliceContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aliceTokenId\",\"type\":\"uint256\"},{\"name\":\"_bobTokenId\",\"type\":\"uint256\"}],\"name\":\"draftAliceToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_alice\",\"type\":\"address\"},{\"name\":\"_bob\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ERC721Converter","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"00000000000000000000000067cbbb366a51fff9ad869d027e496ba49f5f6d55000000000000000000000000e5dd92b6110e58ff46cfb174bc190bd9c1166998","Library":"","LicenseType":"None","SwarmSource":"bzzr://467e3bf08fba3ec0297030d6c6ad975083cd77e4cd846715c48525258bc3a79b"}]}