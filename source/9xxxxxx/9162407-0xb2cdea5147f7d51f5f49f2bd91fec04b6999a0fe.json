{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        require(b > 0);\r\n        uint c = a / b;\r\n        require(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint a, uint b) internal pure returns (uint) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ninterface GeneralERC20 {\r\n\tfunction transfer(address to, uint256 value) external;\r\n\tfunction transferFrom(address from, address to, uint256 value) external;\r\n\tfunction approve(address spender, uint256 value) external;\r\n\tfunction balanceOf(address spender) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\tfunction checkSuccess()\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\tuint256 returnValue = 0;\r\n\r\n\t\tassembly {\r\n\t\t\t// check number of bytes returned from last function call\r\n\t\t\tswitch returndatasize\r\n\r\n\t\t\t// no bytes returned: assume success\r\n\t\t\tcase 0x0 {\r\n\t\t\t\treturnValue := 1\r\n\t\t\t}\r\n\r\n\t\t\t// 32 bytes returned: check if non-zero\r\n\t\t\tcase 0x20 {\r\n\t\t\t\t// copy 32 bytes into scratch space\r\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\r\n\r\n\t\t\t\t// load those bytes into returnValue\r\n\t\t\t\treturnValue := mload(0x0)\r\n\t\t\t}\r\n\r\n\t\t\t// not sure what was returned: don't mark as success\r\n\t\t\tdefault { }\r\n\t\t}\r\n\r\n\t\treturn returnValue != 0;\r\n\t}\r\n\r\n\tfunction transfer(address token, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transfer(to, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n\r\n\tfunction transferFrom(address token, address from, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transferFrom(from, to, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n\r\n\tfunction approve(address token, address spender, uint256 amount) internal {\r\n\t\tGeneralERC20(token).approve(spender, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n}\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n// AIP: https://github.com/AdExNetwork/aips/issues/18\r\n// Quick overview:\r\n// - it's divided into pools, each pool may represent a validator; it may represent something else too (for example, we may launch staking for publishers to prove their legitimacy)\r\n// - the slasherAddr will be a multisig that will be controlled by the AdEx team - and later full control of the multisig will be given to a bridge to Polkadot, where we'll run the full on-chain slashing mechanism\r\n//   - we will clearly communicate this migration path to our community and stakers\r\n// - reward distribution is off-chain: depending on the pool, it may be done either via OUTPACE, via the Polkadot parachain, or via an auxilary contract that implements round-based reward distribution (you check into each round, the SC confirms you have a bond on Staking.sol, and you can withdraw your pro-rata earnings for the round)\r\n// - each bond will be slashed relative to the time it bonded/unbonded; e.g. if the pool is slashed 12%, you bonded, then the pool was slashed 2%, then you unbonded, you'd only suffer a 2% slash\r\n\r\nlibrary BondLibrary {\r\n\tstruct Bond {\r\n\t\tuint amount;\r\n\t\tbytes32 poolId;\r\n\t\tuint nonce;\r\n\t}\r\n\r\n\tfunction hash(Bond memory bond, address sender)\r\n\t\tinternal\r\n\t\tview\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encode(\r\n\t\t\taddress(this),\r\n\t\t\tsender,\r\n\t\t\tbond.amount,\r\n\t\t\tbond.poolId,\r\n\t\t\tbond.nonce\r\n\t\t));\r\n\t}\r\n}\r\n\r\ncontract Staking {\r\n\tusing SafeMath for uint;\r\n\tusing BondLibrary for BondLibrary.Bond;\r\n\r\n\tstruct BondState {\r\n\t\tbool active;\r\n\t\tuint64 slashedAtStart;\r\n\t\tuint64 willUnlock;\r\n\t}\r\n\r\n\t// Events\r\n\tevent LogBond(address indexed owner, uint amount, bytes32 poolId, uint nonce);\r\n\tevent LogUnbondRequested(address indexed owner, bytes32 bondId, uint64 willUnlock);\r\n\tevent LogUnbonded(address indexed owner, bytes32 bondId);\r\n\r\n\t// could be 2**64 too, since we use uint64\r\n\tuint constant MAX_SLASH = 10 ** 18;\r\n\tuint constant TIME_TO_UNBOND = 30 days;\r\n\taddress constant BURN_ADDR = address(0xaDbeEF0000000000000000000000000000000000);\r\n\r\n\taddress public tokenAddr;\r\n\taddress public slasherAddr;\r\n\t// Addressed by poolId\r\n\tmapping (bytes32 => uint) public slashPoints;\r\n\t// Addressed by bondId\r\n\tmapping (bytes32 => BondState) public bonds;\r\n\r\n\tconstructor(address token, address slasher) public {\r\n   \t\ttokenAddr = token;\r\n   \t\tslasherAddr = slasher;\r\n\t}\r\n\r\n\tfunction slash(bytes32 poolId, uint pts) external {\r\n\t\trequire(msg.sender == slasherAddr, 'ONLY_SLASHER');\r\n\t\tuint newSlashPts = slashPoints[poolId].add(pts);\r\n\t\trequire(newSlashPts <= MAX_SLASH, 'PTS_TOO_HIGH');\r\n\t\tslashPoints[poolId] = newSlashPts;\r\n\t}\r\n\r\n\tfunction addBond(BondLibrary.Bond memory bond) public {\r\n\t\tbytes32 id = bond.hash(msg.sender);\r\n\t\trequire(!bonds[id].active, 'BOND_ALREADY_ACTIVE');\r\n\t\trequire(slashPoints[bond.poolId] < MAX_SLASH, 'POOL_SLASHED');\r\n\t\tbonds[id] = BondState({\r\n\t\t\tactive: true,\r\n\t\t\tslashedAtStart: uint64(slashPoints[bond.poolId]),\r\n\t\t\twillUnlock: 0\r\n\t\t});\r\n\t\tSafeERC20.transferFrom(tokenAddr, msg.sender, address(this), bond.amount);\r\n\t\temit LogBond(msg.sender, bond.amount, bond.poolId, bond.nonce);\r\n\t}\r\n\r\n\tfunction requestUnbond(BondLibrary.Bond memory bond) public {\r\n\t\tbytes32 id = bond.hash(msg.sender);\r\n\t\tBondState storage bondState = bonds[id];\r\n\t\trequire(bondState.active && bondState.willUnlock == 0, 'BOND_NOT_ACTIVE');\r\n\t\tbondState.willUnlock = uint64(now + TIME_TO_UNBOND);\r\n\t\temit LogUnbondRequested(msg.sender, id, bondState.willUnlock);\r\n\t}\r\n\r\n\tfunction unbond(BondLibrary.Bond memory bond) public {\r\n\t\tbytes32 id = bond.hash(msg.sender);\r\n\t\tBondState storage bondState = bonds[id];\r\n\t\trequire(bondState.willUnlock > 0 && now > bondState.willUnlock, 'BOND_NOT_UNLOCKED');\r\n\t\tuint amount = calcWithdrawAmount(bond, uint(bondState.slashedAtStart));\r\n\t\tuint toBurn = bond.amount - amount;\r\n\t\tdelete bonds[id];\r\n\t\tSafeERC20.transfer(tokenAddr, msg.sender, amount);\r\n\t\tSafeERC20.transfer(tokenAddr, BURN_ADDR, toBurn);\r\n\t\temit LogUnbonded(msg.sender, id);\r\n\t}\r\n\r\n\tfunction getWithdrawAmount(address owner, BondLibrary.Bond memory bond) public view returns (uint) {\r\n\t\tBondState storage bondState = bonds[bond.hash(owner)];\r\n\t\tif (!bondState.active) return 0;\r\n\t\treturn calcWithdrawAmount(bond, uint(bondState.slashedAtStart));\r\n\t}\r\n\r\n\tfunction calcWithdrawAmount(BondLibrary.Bond memory bond, uint slashedAtStart) internal view returns (uint) {\r\n\t\treturn bond.amount\r\n\t\t\t.mul(MAX_SLASH.sub(slashPoints[bond.poolId]))\r\n\t\t\t.div(MAX_SLASH.sub(slashedAtStart));\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"slasher\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"LogBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"bondId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"willUnlock\",\"type\":\"uint64\"}],\"name\":\"LogUnbondRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"bondId\",\"type\":\"bytes32\"}],\"name\":\"LogUnbonded\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct BondLibrary.Bond\",\"name\":\"bond\",\"type\":\"tuple\"}],\"name\":\"addBond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"bonds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"slashedAtStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"willUnlock\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct BondLibrary.Bond\",\"name\":\"bond\",\"type\":\"tuple\"}],\"name\":\"getWithdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct BondLibrary.Bond\",\"name\":\"bond\",\"type\":\"tuple\"}],\"name\":\"requestUnbond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"pts\",\"type\":\"uint256\"}],\"name\":\"slash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"slashPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"slasherAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct BondLibrary.Bond\",\"name\":\"bond\",\"type\":\"tuple\"}],\"name\":\"unbond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004470bb87d77b963a013db939be332f927f2b992e00000000000000000000000023c2c34f38ce66ccc10e71e9bb2a06532d52c5e9","Library":"","LicenseType":"None","SwarmSource":"bzzr://d432c085d5d10a9e707622f2a08b0e5553bd249615cfb25aae6688fab723e94a"}]}