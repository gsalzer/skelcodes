{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IContractRegistry.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/interfaces/IERC20Token.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {}\r\n    function symbol() public view returns (string) {}\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/interfaces/IPegSettings.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\ncontract IPegSettings {\r\n\r\n    function authorized(address _address) public view returns (bool) { _address; }\r\n    \r\n    function authorize(address _address, bool _auth) public;\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IVault.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract IVault {\r\n\r\n    function registry() public view returns (IContractRegistry);\r\n\r\n    function auctions(address _borrower) public view returns (address) { _borrower; }\r\n    function vaultExists(address _vault) public view returns (bool) { _vault; }\r\n    function totalBorrowed(address _vault) public view returns (uint256) { _vault; }\r\n    function rawBalanceOf(address _vault) public view returns (uint256) { _vault; }\r\n    function rawDebt(address _vault) public view returns (uint256) { _vault; }\r\n    function rawTotalBalance() public view returns (uint256);\r\n    function rawTotalDebt() public view returns (uint256);\r\n    function collateralBorrowedRatio() public view returns (uint256);\r\n    function amountMinted() public view returns (uint256);\r\n\r\n    function debtScalePrevious() public view returns (uint256);\r\n    function debtScaleTimestamp() public view returns (uint256);\r\n    function debtScaleRate() public view returns (int256);\r\n    function balScalePrevious() public view returns (uint256);\r\n    function balScaleTimestamp() public view returns (uint256);\r\n    function balScaleRate() public view returns (int256);\r\n    \r\n    function liquidationRatio() public view returns (uint32);\r\n    function maxBorrowLTV() public view returns (uint32);\r\n\r\n    function borrowingEnabled() public view returns (bool);\r\n    function biddingTime() public view returns (uint);\r\n\r\n    function setType(bool _type) public;\r\n    function create(address _vault) public;\r\n    function setCollateralBorrowedRatio(uint _newRatio) public;\r\n    function setAmountMinted(uint _amountMinted) public;\r\n    function setLiquidationRatio(uint32 _liquidationRatio) public;\r\n    function setMaxBorrowLTV(uint32 _maxBorrowLTV) public;\r\n    function setDebtScalingRate(int256 _debtScalingRate) public;\r\n    function setBalanceScalingRate(int256 _balanceScalingRate) public;\r\n    function setBiddingTime(uint _biddingTime) public;\r\n    function setRawTotalDebt(uint _rawTotalDebt) public;\r\n    function setRawTotalBalance(uint _rawTotalBalance) public;\r\n    function setRawBalanceOf(address _borrower, uint _rawBalance) public;\r\n    function setRawDebt(address _borrower, uint _rawDebt) public;\r\n    function setTotalBorrowed(address _borrower, uint _totalBorrowed) public;\r\n    function debtScalingFactor() public view returns (uint256);\r\n    function balanceScalingFactor() public view returns (uint256);\r\n    function debtRawToActual(uint256 _raw) public view returns (uint256);\r\n    function debtActualToRaw(uint256 _actual) public view returns (uint256);\r\n    function balanceRawToActual(uint256 _raw) public view returns (uint256);\r\n    function balanceActualToRaw(uint256 _actual) public view returns (uint256);\r\n    function getVaults(address _vault, uint256 _balanceOf) public view returns(address[]);\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public;\r\n    function oracleValue() public view returns(uint256);\r\n    function emitBorrow(address _borrower, uint256 _amount) public;\r\n    function emitRepay(address _borrower, uint256 _amount) public;\r\n    function emitDeposit(address _borrower, uint256 _amount) public;\r\n    function emitWithdraw(address _borrower, address _to, uint256 _amount) public;\r\n    function emitLiquidate(address _borrower) public;\r\n    function emitAuctionStarted(address _borrower) public;\r\n    function emitAuctionEnded(address _borrower, address _highestBidder, uint256 _highestBid) public;\r\n    function setAuctionAddress(address _borrower, address _auction) public;\r\n}\r\n\r\n// File: contracts/interfaces/IPegOracle.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract IPegOracle {\r\n    function getValue() public view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/IOwned.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n    function setOwner(address _newOwner) public;\r\n}\r\n\r\n// File: contracts/interfaces/ISmartToken.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/interfaces/IPegLogic.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\ncontract IPegLogic {\r\n\r\n    function adjustCollateralBorrowingRate() public;\r\n    function isInsolvent(IVault _vault, address _borrower) public view returns (bool);\r\n    function actualDebt(IVault _vault, address _address) public view returns(uint256);\r\n    function excessCollateral(IVault _vault, address _borrower) public view returns (int256);\r\n    function availableCredit(IVault _vault, address _borrower) public view returns (int256);\r\n    function getCollateralToken(IVault _vault) public view returns(IERC20Token);\r\n    function getDebtToken(IVault _vault) public view returns(ISmartToken);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IAuctionActions.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\ncontract IAuctionActions {\r\n\r\n    function startAuction(IVault _vault, address _borrower) public;\r\n    function endAuction(IVault _vault, address _borrower) public;\r\n\r\n}\r\n\r\n// File: contracts/ContractIds.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract ContractIds {\r\n    bytes32 public constant STABLE_TOKEN = \"StableToken\";\r\n    bytes32 public constant COLLATERAL_TOKEN = \"CollateralToken\";\r\n\r\n    bytes32 public constant PEGUSD_TOKEN = \"PEGUSD\";\r\n\r\n    bytes32 public constant VAULT_A = \"VaultA\";\r\n    bytes32 public constant VAULT_B = \"VaultB\";\r\n\r\n    bytes32 public constant PEG_LOGIC = \"PegLogic\";\r\n    bytes32 public constant PEG_LOGIC_ACTIONS = \"LogicActions\";\r\n    bytes32 public constant AUCTION_ACTIONS = \"AuctionActions\";\r\n\r\n    bytes32 public constant PEG_SETTINGS = \"PegSettings\";\r\n    bytes32 public constant ORACLE = \"Oracle\";\r\n    bytes32 public constant FEE_RECIPIENT = \"StabilityFeeRecipient\";\r\n}\r\n\r\n// File: contracts/Helpers.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Helpers is ContractIds {\r\n\r\n    IContractRegistry public registry;\r\n\r\n    constructor(IContractRegistry _registry) public {\r\n        registry = _registry;\r\n    }\r\n\r\n    modifier authOnly() {\r\n        require(settings().authorized(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier validate(IVault _vault, address _borrower) {\r\n        require(address(_vault) == registry.addressOf(ContractIds.VAULT_A) || address(_vault) == registry.addressOf(ContractIds.VAULT_B));\r\n        _vault.create(_borrower);\r\n        _;\r\n    }\r\n\r\n    function stableToken() internal returns(ISmartToken) {\r\n        return ISmartToken(registry.addressOf(ContractIds.STABLE_TOKEN));\r\n    }\r\n\r\n    function collateralToken() internal returns(ISmartToken) {\r\n        return ISmartToken(registry.addressOf(ContractIds.COLLATERAL_TOKEN));\r\n    }\r\n\r\n    function PEGUSD() internal returns(IERC20Token) {\r\n        return IERC20Token(registry.addressOf(ContractIds.PEGUSD_TOKEN));\r\n    }\r\n\r\n    function vaultA() internal returns(IVault) {\r\n        return IVault(registry.addressOf(ContractIds.VAULT_A));\r\n    }\r\n\r\n    function vaultB() internal returns(IVault) {\r\n        return IVault(registry.addressOf(ContractIds.VAULT_B));\r\n    }\r\n\r\n    function oracle() internal returns(IPegOracle) {\r\n        return IPegOracle(registry.addressOf(ContractIds.ORACLE));\r\n    }\r\n\r\n    function settings() internal returns(IPegSettings) {\r\n        return IPegSettings(registry.addressOf(ContractIds.PEG_SETTINGS));\r\n    }\r\n\r\n    function pegLogic() internal returns(IPegLogic) {\r\n        return IPegLogic(registry.addressOf(ContractIds.PEG_LOGIC));\r\n    }\r\n\r\n    function auctionActions() internal returns(IAuctionActions) {\r\n        return IAuctionActions(registry.addressOf(ContractIds.AUCTION_ACTIONS));\r\n    }\r\n\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public authOnly {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IAuction.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract IAuction {\r\n\r\n    function highestBidder() public view returns (address);\r\n    function highestBid() public view returns (uint256);\r\n    function lowestBidRelay() public view returns (uint256);\r\n\r\n    function bid(uint256 _amount) public;\r\n    function auctionEnd() public;\r\n\r\n    function hasEnded() public view returns (bool);\r\n\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IBancorConverter.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\ncontract IBancorConverter {\r\n    function token() public view returns (ISmartToken) {}\r\n}\r\n\r\n// File: contracts/interfaces/ILogicActions.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\ncontract ILogicActions {\r\n\r\n    function deposit(IVault _vault, uint256 _amount) public;\r\n    function withdraw(IVault _vault, address _to, uint256 _amount) public;\r\n    function borrow(IVault _vault, uint256 _amount) public;\r\n    function repay(IVault _vault, address _borrower, uint256 _amount) public;\r\n    function repayAuction(IVault _vault, address _borrower, uint256 _amount) public;\r\n    function repayAll(IVault _vault, address _borrower) public;\r\n\r\n}\r\n\r\n// File: contracts/Auction.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Auction is ContractIds {\r\n    address public borrower;\r\n    IVault public vault;\r\n    IContractRegistry public registry;\r\n    uint public auctionEndTime;\r\n    uint public auctionStartTime;\r\n    address public highestBidder;\r\n    uint256 public highestBid;\r\n    uint256 public lowestBidRelay;\r\n    uint256 public amountToPay;\r\n    bool ended;\r\n\r\n    event HighestBidIncreased(address indexed _bidder, uint256 _amount, uint256 _amountRelay);\r\n\r\n    constructor(IContractRegistry _registry, IVault _vault, address _borrower) public {\r\n        registry = _registry;\r\n        borrower = _borrower;\r\n        vault = _vault;\r\n    }\r\n\r\n    modifier authOnly() {\r\n        require(IPegSettings(registry.addressOf(ContractIds.PEG_SETTINGS)).authorized(msg.sender), \"Unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function validateBid(uint256 _amount, uint256 _amountRelay) internal {\r\n        if(auctionEndTime > 0)\r\n            require(now <= auctionEndTime, \"Auction has already ended\");\r\n        else {\r\n            auctionStartTime = now;\r\n            auctionEndTime = now + vault.biddingTime();\r\n        }\r\n        require(_amount == 0 || _amountRelay == 0, \"Can't refund collateral and mint relay tokens\");\r\n        if(highestBidder != address(0))\r\n            require(_amount > highestBid || _amountRelay < lowestBidRelay, \"There already is a higher bid\");\r\n        require(vault.balanceActualToRaw(_amount) <= vault.rawBalanceOf(address(this)), \"Can't refund more than 100%\");\r\n    }\r\n\r\n    function bid(uint256 _amount, uint256 _amountRelay) public {\r\n        validateBid(_amount, _amountRelay);\r\n        if(_amountRelay > 0)\r\n            auctionEndTime = auctionStartTime + 172800; // extends to 48 hours auction\r\n        IPegLogic pegLogic = IPegLogic(registry.addressOf(ContractIds.PEG_LOGIC));\r\n        if(amountToPay == 0) amountToPay = pegLogic.actualDebt(vault, address(this));\r\n        IERC20Token token = pegLogic.getDebtToken(vault);\r\n        token.transferFrom(msg.sender, address(this), amountToPay);\r\n        if (highestBidder != address(0)) {\r\n            require(token.transfer(highestBidder, amountToPay), \"Error transferring token to last highest bidder.\");\r\n        } else {\r\n            ILogicActions logicActions = ILogicActions(registry.addressOf(ContractIds.PEG_LOGIC_ACTIONS));\r\n            if (address(vault) == registry.addressOf(ContractIds.VAULT_B))\r\n                token.approve(address(logicActions), amountToPay);\r\n            logicActions.repayAuction(vault, borrower, amountToPay);\r\n        }\r\n        highestBidder = msg.sender;\r\n        highestBid = _amount;\r\n        lowestBidRelay = _amountRelay;\r\n        emit HighestBidIncreased(msg.sender, _amount, _amountRelay);\r\n    }\r\n\r\n    function auctionEnd() public authOnly {\r\n        require(auctionEndTime > 0, \"Bidding has not started yet\");\r\n        require(now >= auctionEndTime, \"Auction end time is in the future\");\r\n        require(!ended, \"Auction already ended\");\r\n        ended = true;\r\n    }\r\n\r\n    function canEnd() public view returns (bool) {\r\n        return auctionEndTime > 0 && now >= auctionEndTime;\r\n    }\r\n\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public authOnly {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n}\r\n\r\n// File: contracts/library/SafeMath.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n    function plus(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n\r\n    function plus(int256 _a, int256 _b) internal pure returns (int256) {\r\n        int256 c = _a + _b;\r\n        assert((_b >= 0 && c >= _a) || (_b < 0 && c < _a));\r\n        return c;\r\n    }\r\n\r\n    function minus(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_a >= _b);\r\n        return _a - _b;\r\n    }\r\n\r\n    function minus(int256 _a, int256 _b) internal pure returns (int256) {\r\n        int256 c = _a - _b;\r\n        assert((_b >= 0 && c <= _a) || (_b < 0 && c > _a));\r\n        return c;\r\n    }\r\n\r\n    function times(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function times(int256 _a, int256 _b) internal pure returns (int256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        int256 c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function toInt256(uint256 _a) internal pure returns (int256) {\r\n        assert(_a <= 2 ** 255);\r\n        return int256(_a);\r\n    }\r\n\r\n    function toUint256(int256 _a) internal pure returns (uint256) {\r\n        assert(_a >= 0);\r\n        return uint256(_a);\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n\r\n    function div(int256 _a, int256 _b) internal pure returns (int256) {\r\n        return _a / _b;\r\n    }\r\n}\r\n\r\n// File: contracts/AuctionActions.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AuctionActions is Helpers {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n\r\n    IContractRegistry public registry;\r\n\r\n    constructor(IContractRegistry _registry) public Helpers(_registry) {\r\n        registry = _registry;\r\n    }\r\n\r\n    function startAuction(IVault _vault, address _borrower) public validate(_vault, _borrower) returns(address) {\r\n        require(_vault.vaultExists(_borrower), \"Invalid vault\");\r\n        address auctionAddress = _vault.auctions(_borrower);\r\n        require(auctionAddress == address(0), \"Vault is already on auction state\");\r\n        IPegLogic ipegLogic = pegLogic();\r\n        require(ipegLogic.actualDebt(_vault, _borrower) > 0, \"Vault has no debt\");\r\n        require(ipegLogic.isInsolvent(_vault, _borrower), \"Vault is not eligible for liquidation\");\r\n        Auction auction = new Auction(registry, _vault, _borrower);\r\n        _vault.setAuctionAddress(_borrower, address(auction));\r\n        _vault.setRawBalanceOf(address(auction), _vault.rawBalanceOf(_borrower));\r\n        _vault.setRawDebt(address(auction), _vault.rawDebt(_borrower));\r\n        _vault.setTotalBorrowed(address(auction), _vault.totalBorrowed(_borrower));\r\n        _vault.setRawBalanceOf(_borrower, 0);\r\n        _vault.setRawDebt(_borrower, 0);\r\n        _vault.setTotalBorrowed(_borrower, 0);\r\n        _vault.emitAuctionStarted(_borrower);\r\n        return address(auction);\r\n    }\r\n\r\n    function endAuction(IVault _vault, address _borrower) public validate(_vault, _borrower) {\r\n        require(_vault.vaultExists(_borrower), \"Invalid vault\");\r\n        address auctionAddress = _vault.auctions(_borrower);\r\n        require(auctionAddress != address(0), \"Vault is not on auction state\");\r\n        IAuction auction = IAuction(auctionAddress);\r\n        auction.auctionEnd();\r\n        address highestBidder = auction.highestBidder();\r\n        uint256 highestBid = _vault.balanceActualToRaw(auction.highestBid());\r\n        _vault.setAuctionAddress(_borrower, address(0));\r\n        _vault.create(highestBidder);\r\n        _vault.setRawBalanceOf(\r\n            highestBidder,\r\n            _vault.rawBalanceOf(highestBidder).plus(_vault.rawBalanceOf(auctionAddress).minus(highestBid))\r\n        );\r\n        _vault.setRawBalanceOf(_borrower, _vault.rawBalanceOf(_borrower).plus(highestBid));\r\n        if(auction.lowestBidRelay() > 0) {\r\n            IBancorConverter converter = IBancorConverter(registry.addressOf(ContractIds.FEE_RECIPIENT));\r\n            ISmartToken relayToken = ISmartToken(converter.token());\r\n            relayToken.issue(highestBidder, auction.lowestBidRelay());\r\n        }\r\n        pegLogic().adjustCollateralBorrowingRate();\r\n        _vault.setRawBalanceOf(auctionAddress, 0);\r\n        _vault.emitAuctionEnded(_borrower, highestBidder, highestBid);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"VAULT_B\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEG_LOGIC_ACTIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORACLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"endAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VAULT_A\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STABLE_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUCTION_ACTIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEG_SETTINGS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEG_LOGIC\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_RECIPIENT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLLATERAL_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEGUSD_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"startAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"AuctionActions","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e68ebda2488c213cf4ba25a7a7da179f96ce0baf","Library":"","LicenseType":"None","SwarmSource":"bzzr://81b70005a200da8cf76dcf10b901a8b4961982a28a894eb1f75224d4d9599816"}]}