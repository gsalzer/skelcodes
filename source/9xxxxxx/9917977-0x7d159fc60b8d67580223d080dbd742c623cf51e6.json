{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\nCopyright 2020 PoolTogether Inc.\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\npragma solidity 0.5.12;\r\n\r\n/**\r\nCopyright 2020 PoolTogether Inc.\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n/**\r\n * @author Brendan Asselstine\r\n * @notice A library that uses entropy to select a random number within a bound.  Compensates for modulo bias.\r\n * @dev Thanks to https://medium.com/hownetworks/dont-waste-cycles-with-modulo-bias-35b6fdafcf94\r\n */\r\nlibrary UniformRandomNumber {\r\n  /// @notice Select a random number without modulo bias using a random seed and upper bound\r\n  /// @param _entropy The seed for randomness\r\n  /// @param _upperBound The upper bound of the desired number\r\n  /// @return A random number less than the _upperBound\r\n  function uniform(uint256 _entropy, uint256 _upperBound) internal pure returns (uint256) {\r\n    require(_upperBound > 0, \"UniformRand/min-bound\");\r\n    uint256 min = -_upperBound % _upperBound;\r\n    uint256 random = _entropy;\r\n    while (true) {\r\n      if (random >= min) {\r\n        break;\r\n      }\r\n      random = uint256(keccak256(abi.encodePacked(random)));\r\n    }\r\n    return random % _upperBound;\r\n  }\r\n}\r\n/**\r\n *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]\r\n *  @auditors: []\r\n *  @bounties: [<14 days 10 ETH max payout>]\r\n *  @deployments: []\r\n */\r\n\r\n\r\n\r\n/**\r\n *  @title SortitionSumTreeFactory\r\n *  @author Enrique Piqueras - <epiquerass@gmail.com>\r\n *  @dev A factory of trees that keep track of staked values for sortition.\r\n */\r\nlibrary SortitionSumTreeFactory {\r\n    /* Structs */\r\n\r\n    struct SortitionSumTree {\r\n        uint K; // The maximum number of childs per node.\r\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\r\n        uint[] stack;\r\n        uint[] nodes;\r\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\r\n        mapping(bytes32 => uint) IDsToNodeIndexes;\r\n        mapping(uint => bytes32) nodeIndexesToIDs;\r\n    }\r\n\r\n    /* Storage */\r\n\r\n    struct SortitionSumTrees {\r\n        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;\r\n    }\r\n\r\n    /* internal */\r\n\r\n    /**\r\n     *  @dev Create a sortition sum tree at the specified key.\r\n     *  @param _key The key of the new tree.\r\n     *  @param _K The number of children each node in the tree should have.\r\n     */\r\n    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) internal {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        require(tree.K == 0, \"Tree already exists.\");\r\n        require(_K > 1, \"K must be greater than one.\");\r\n        tree.K = _K;\r\n        tree.stack.length = 0;\r\n        tree.nodes.length = 0;\r\n        tree.nodes.push(0);\r\n    }\r\n\r\n    /**\r\n     *  @dev Set a value of a tree.\r\n     *  @param _key The key of the tree.\r\n     *  @param _value The new value.\r\n     *  @param _ID The ID of the value.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) internal {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) { // No existing node.\r\n            if (_value != 0) { // Non zero value.\r\n                // Append.\r\n                // Add node.\r\n                if (tree.stack.length == 0) { // No vacant spots.\r\n                    // Get the index and append the value.\r\n                    treeIndex = tree.nodes.length;\r\n                    tree.nodes.push(_value);\r\n\r\n                    // Potentially append a new node and make the parent a sum node.\r\n                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) { // Is first child.\r\n                        uint parentIndex = treeIndex / tree.K;\r\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\r\n                        uint newIndex = treeIndex + 1;\r\n                        tree.nodes.push(tree.nodes[parentIndex]);\r\n                        delete tree.nodeIndexesToIDs[parentIndex];\r\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\r\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\r\n                    }\r\n                } else { // Some vacant spot.\r\n                    // Pop the stack and append the value.\r\n                    treeIndex = tree.stack[tree.stack.length - 1];\r\n                    tree.stack.length--;\r\n                    tree.nodes[treeIndex] = _value;\r\n                }\r\n\r\n                // Add label.\r\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\r\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\r\n\r\n                updateParents(self, _key, treeIndex, true, _value);\r\n            }\r\n        } else { // Existing node.\r\n            if (_value == 0) { // Zero value.\r\n                // Remove.\r\n                // Remember value and set to 0.\r\n                uint value = tree.nodes[treeIndex];\r\n                tree.nodes[treeIndex] = 0;\r\n\r\n                // Push to stack.\r\n                tree.stack.push(treeIndex);\r\n\r\n                // Clear label.\r\n                delete tree.IDsToNodeIndexes[_ID];\r\n                delete tree.nodeIndexesToIDs[treeIndex];\r\n\r\n                updateParents(self, _key, treeIndex, false, value);\r\n            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.\r\n                // Set.\r\n                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\r\n                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;\r\n                tree.nodes[treeIndex] = _value;\r\n\r\n                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* internal Views */\r\n\r\n    /**\r\n     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\r\n     *  @param _key The key of the tree to get the leaves from.\r\n     *  @param _cursor The pagination cursor.\r\n     *  @param _count The number of items to return.\r\n     *  @return The index at which leaves start, the values of the returned leaves, and whether there are more for pagination.\r\n     *  `O(n)` where\r\n     *  `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function queryLeafs(\r\n        SortitionSumTrees storage self,\r\n        bytes32 _key,\r\n        uint _cursor,\r\n        uint _count\r\n    ) internal view returns(uint startIndex, uint[] memory values, bool hasMore) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        // Find the start index.\r\n        for (uint i = 0; i < tree.nodes.length; i++) {\r\n            if ((tree.K * i) + 1 >= tree.nodes.length) {\r\n                startIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Get the values.\r\n        uint loopStartIndex = startIndex + _cursor;\r\n        values = new uint[](loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);\r\n        uint valuesIndex = 0;\r\n        for (uint j = loopStartIndex; j < tree.nodes.length; j++) {\r\n            if (valuesIndex < _count) {\r\n                values[valuesIndex] = tree.nodes[j];\r\n                valuesIndex++;\r\n            } else {\r\n                hasMore = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\r\n     *  @param _key The key of the tree.\r\n     *  @param _drawnNumber The drawn number.\r\n     *  @return The drawn ID.\r\n     *  `O(k * log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) internal view returns(bytes32 ID) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = 0;\r\n        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\r\n\r\n        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.\r\n            for (uint i = 1; i <= tree.K; i++) { // Loop over children.\r\n                uint nodeIndex = (tree.K * treeIndex) + i;\r\n                uint nodeValue = tree.nodes[nodeIndex];\r\n\r\n                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\r\n                else { // Pick this child.\r\n                    treeIndex = nodeIndex;\r\n                    break;\r\n                }\r\n            }\r\n        \r\n        ID = tree.nodeIndexesToIDs[treeIndex];\r\n    }\r\n\r\n    /** @dev Gets a specified ID's associated value.\r\n     *  @param _key The key of the tree.\r\n     *  @param _ID The ID of the value.\r\n     *  @return The associated value.\r\n     */\r\n    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) internal view returns(uint value) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) value = 0;\r\n        else value = tree.nodes[treeIndex];\r\n    }\r\n\r\n   function total(SortitionSumTrees storage self, bytes32 _key) internal view returns (uint) {\r\n       SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n       if (tree.nodes.length == 0) {\r\n           return 0;\r\n       } else {\r\n           return tree.nodes[0];\r\n       }\r\n   }\r\n\r\n    /* Private */\r\n\r\n    /**\r\n     *  @dev Update all the parents of a node.\r\n     *  @param _key The key of the tree to update.\r\n     *  @param _treeIndex The index of the node to start from.\r\n     *  @param _plusOrMinus Wether to add (true) or substract (false).\r\n     *  @param _value The value to add or substract.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        uint parentIndex = _treeIndex;\r\n        while (parentIndex != 0) {\r\n            parentIndex = (parentIndex - 1) / tree.K;\r\n            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @author Brendan Asselstine\r\n * @notice Tracks committed and open balances for addresses.  Affords selection of an address by indexing all committed balances.\r\n *\r\n * Balances are tracked in Draws.  There is always one open Draw.  Deposits are always added to the open Draw.\r\n * When a new draw is opened, the previous opened draw is committed.\r\n *\r\n * The committed balance for an address is the total of their balances for committed Draws.\r\n * An address's open balance is their balance in the open Draw.\r\n */\r\nlibrary DrawManager {\r\n    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * The ID to use for the selection tree.\r\n     */\r\n    bytes32 public constant TREE_OF_DRAWS = \"TreeOfDraws\";\r\n\r\n    uint8 public constant MAX_BRANCHES_PER_NODE = 10;\r\n\r\n    /**\r\n     * Stores information for all draws.\r\n     */\r\n    struct State {\r\n        /**\r\n         * Each Draw stores it's address balances in a sortitionSumTree.  Draw trees are indexed using the Draw index.\r\n         * There is one root sortitionSumTree that stores all of the draw totals.  The root tree is indexed using the constant TREE_OF_DRAWS.\r\n         */\r\n        SortitionSumTreeFactory.SortitionSumTrees sortitionSumTrees;\r\n\r\n        /**\r\n         * Stores the consolidated draw index that an address deposited to.\r\n         */\r\n        mapping(address => uint256) consolidatedDrawIndices;\r\n\r\n        /**\r\n         * Stores the last Draw index that an address deposited to.\r\n         */\r\n        mapping(address => uint256) latestDrawIndices;\r\n\r\n        /**\r\n         * Stores a mapping of Draw index => Draw total\r\n         */\r\n        mapping(uint256 => uint256) __deprecated__drawTotals;\r\n\r\n        /**\r\n         * The current open Draw index\r\n         */\r\n        uint256 openDrawIndex;\r\n\r\n        /**\r\n         * The total of committed balances\r\n         */\r\n        uint256 __deprecated__committedSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Opens the next Draw and commits the previous open Draw (if any).\r\n     * @param self The drawState this library is attached to\r\n     * @return The index of the new open Draw\r\n     */\r\n    function openNextDraw(State storage self) public returns (uint256) {\r\n        if (self.openDrawIndex == 0) {\r\n            // If there is no previous draw, we must initialize\r\n            self.sortitionSumTrees.createTree(TREE_OF_DRAWS, MAX_BRANCHES_PER_NODE);\r\n        } else {\r\n            // else add current draw to sortition sum trees\r\n            bytes32 drawId = bytes32(self.openDrawIndex);\r\n            uint256 drawTotal = openSupply(self);\r\n            self.sortitionSumTrees.set(TREE_OF_DRAWS, drawTotal, drawId);\r\n        }\r\n        // now create a new draw\r\n        uint256 drawIndex = self.openDrawIndex.add(1);\r\n        self.sortitionSumTrees.createTree(bytes32(drawIndex), MAX_BRANCHES_PER_NODE);\r\n        self.openDrawIndex = drawIndex;\r\n\r\n        return drawIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits the given amount into the current open draw by the given user.\r\n     * @param self The DrawManager state\r\n     * @param _addr The address to deposit for\r\n     * @param _amount The amount to deposit\r\n     */\r\n    function deposit(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) onlyNonZero(_addr) {\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 openDrawIndex = self.openDrawIndex;\r\n\r\n        // update the current draw\r\n        uint256 currentAmount = self.sortitionSumTrees.stakeOf(bytes32(openDrawIndex), userId);\r\n        currentAmount = currentAmount.add(_amount);\r\n        drawSet(self, openDrawIndex, currentAmount, _addr);\r\n\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\r\n\r\n        // if this is the user's first draw, set it\r\n        if (consolidatedDrawIndex == 0) {\r\n            self.consolidatedDrawIndices[_addr] = openDrawIndex;\r\n        // otherwise, if the consolidated draw is not this draw\r\n        } else if (consolidatedDrawIndex != openDrawIndex) {\r\n            // if a second draw does not exist\r\n            if (latestDrawIndex == 0) {\r\n                // set the second draw to the current draw\r\n                self.latestDrawIndices[_addr] = openDrawIndex;\r\n            // otherwise if a second draw exists but is not the current one\r\n            } else if (latestDrawIndex != openDrawIndex) {\r\n                // merge it into the first draw, and update the second draw index to this one\r\n                uint256 consolidatedAmount = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), userId);\r\n                uint256 latestAmount = self.sortitionSumTrees.stakeOf(bytes32(latestDrawIndex), userId);\r\n                drawSet(self, consolidatedDrawIndex, consolidatedAmount.add(latestAmount), _addr);\r\n                drawSet(self, latestDrawIndex, 0, _addr);\r\n                self.latestDrawIndices[_addr] = openDrawIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits into a user's committed balance, thereby bypassing the open draw.\r\n     * @param self The DrawManager state\r\n     * @param _addr The address of the user for whom to deposit\r\n     * @param _amount The amount to deposit\r\n     */\r\n    function depositCommitted(State storage self, address _addr, uint256 _amount) public requireCommittedDraw(self) onlyNonZero(_addr) {\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n\r\n        // if they have a committed balance\r\n        if (consolidatedDrawIndex != 0 && consolidatedDrawIndex != self.openDrawIndex) {\r\n            uint256 consolidatedAmount = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), userId);\r\n            drawSet(self, consolidatedDrawIndex, consolidatedAmount.add(_amount), _addr);\r\n        } else { // they must not have any committed balance\r\n            self.latestDrawIndices[_addr] = consolidatedDrawIndex;\r\n            self.consolidatedDrawIndices[_addr] = self.openDrawIndex.sub(1);\r\n            drawSet(self, self.consolidatedDrawIndices[_addr], _amount, _addr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws a user's committed and open draws.\r\n     * @param self The DrawManager state\r\n     * @param _addr The address whose balance to withdraw\r\n     */\r\n    function withdraw(State storage self, address _addr) public requireOpenDraw(self) onlyNonZero(_addr) {\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\r\n\r\n        if (consolidatedDrawIndex != 0) {\r\n            drawSet(self, consolidatedDrawIndex, 0, _addr);\r\n            delete self.consolidatedDrawIndices[_addr];\r\n        }\r\n\r\n        if (latestDrawIndex != 0) {\r\n            drawSet(self, latestDrawIndex, 0, _addr);\r\n            delete self.latestDrawIndices[_addr];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw's from a user's open balance\r\n     * @param self The DrawManager state\r\n     * @param _addr The user to withdrawn from\r\n     * @param _amount The amount to withdraw\r\n     */\r\n    function withdrawOpen(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) onlyNonZero(_addr) {\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 openTotal = self.sortitionSumTrees.stakeOf(bytes32(self.openDrawIndex), userId);\r\n\r\n        require(_amount <= openTotal, \"DrawMan/exceeds-open\");\r\n\r\n        uint256 remaining = openTotal.sub(_amount);\r\n\r\n        drawSet(self, self.openDrawIndex, remaining, _addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw's from a user's committed balance.  Fails if the user attempts to take more than available.\r\n     * @param self The DrawManager state\r\n     * @param _addr The user to withdraw from\r\n     * @param _amount The amount to withdraw.\r\n     */\r\n    function withdrawCommitted(State storage self, address _addr, uint256 _amount) public requireCommittedDraw(self) onlyNonZero(_addr) {\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\r\n\r\n        uint256 consolidatedAmount = 0;\r\n        uint256 latestAmount = 0;\r\n        uint256 total = 0;\r\n\r\n        if (latestDrawIndex != 0 && latestDrawIndex != self.openDrawIndex) {\r\n            latestAmount = self.sortitionSumTrees.stakeOf(bytes32(latestDrawIndex), userId);\r\n            total = total.add(latestAmount);\r\n        }\r\n\r\n        if (consolidatedDrawIndex != 0 && consolidatedDrawIndex != self.openDrawIndex) {\r\n            consolidatedAmount = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), userId);\r\n            total = total.add(consolidatedAmount);\r\n        }\r\n\r\n        // If the total is greater than zero, then consolidated *must* have the committed balance\r\n        // However, if the total is zero then the consolidated balance may be the open balance\r\n        if (total == 0) {\r\n            return;\r\n        }\r\n\r\n        require(_amount <= total, \"Pool/exceed\");\r\n\r\n        uint256 remaining = total.sub(_amount);\r\n\r\n        // if there was a second amount that needs to be updated\r\n        if (remaining > consolidatedAmount) {\r\n            uint256 secondRemaining = remaining.sub(consolidatedAmount);\r\n            drawSet(self, latestDrawIndex, secondRemaining, _addr);\r\n        } else if (latestAmount > 0) { // else delete the second amount if it exists\r\n            delete self.latestDrawIndices[_addr];\r\n            drawSet(self, latestDrawIndex, 0, _addr);\r\n        }\r\n\r\n        // if the consolidated amount needs to be destroyed\r\n        if (remaining == 0) {\r\n            delete self.consolidatedDrawIndices[_addr];\r\n            drawSet(self, consolidatedDrawIndex, 0, _addr);\r\n        } else if (remaining < consolidatedAmount) {\r\n            drawSet(self, consolidatedDrawIndex, remaining, _addr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total balance for an address, including committed balances and the open balance.\r\n     */\r\n    function balanceOf(State storage drawState, address _addr) public view returns (uint256) {\r\n        return committedBalanceOf(drawState, _addr).add(openBalanceOf(drawState, _addr));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total committed balance for an address.\r\n     * @param self The DrawManager state\r\n     * @param _addr The address whose committed balance should be returned\r\n     * @return The total committed balance\r\n     */\r\n    function committedBalanceOf(State storage self, address _addr) public view returns (uint256) {\r\n        uint256 balance = 0;\r\n\r\n        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\r\n        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\r\n\r\n        if (consolidatedDrawIndex != 0 && consolidatedDrawIndex != self.openDrawIndex) {\r\n            balance = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), bytes32(uint256(_addr)));\r\n        }\r\n\r\n        if (latestDrawIndex != 0 && latestDrawIndex != self.openDrawIndex) {\r\n            balance = balance.add(self.sortitionSumTrees.stakeOf(bytes32(latestDrawIndex), bytes32(uint256(_addr))));\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the open balance for an address\r\n     * @param self The DrawManager state\r\n     * @param _addr The address whose open balance should be returned\r\n     * @return The open balance\r\n     */\r\n    function openBalanceOf(State storage self, address _addr) public view returns (uint256) {\r\n        if (self.openDrawIndex == 0) {\r\n            return 0;\r\n        } else {\r\n            return self.sortitionSumTrees.stakeOf(bytes32(self.openDrawIndex), bytes32(uint256(_addr)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the open Draw balance for the DrawManager\r\n     * @param self The DrawManager state\r\n     * @return The open draw total balance\r\n     */\r\n    function openSupply(State storage self) public view returns (uint256) {\r\n        return self.sortitionSumTrees.total(bytes32(self.openDrawIndex));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the committed balance for the DrawManager\r\n     * @param self The DrawManager state\r\n     * @return The total committed balance\r\n     */\r\n    function committedSupply(State storage self) public view returns (uint256) {\r\n        return self.sortitionSumTrees.total(TREE_OF_DRAWS);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Draw balance for an address.\r\n     * @param self The DrawManager state\r\n     * @param _drawIndex The Draw index\r\n     * @param _amount The new balance\r\n     * @param _addr The address whose balance should be updated\r\n     */\r\n    function drawSet(State storage self, uint256 _drawIndex, uint256 _amount, address _addr) internal {\r\n        bytes32 drawId = bytes32(_drawIndex);\r\n        bytes32 userId = bytes32(uint256(_addr));\r\n        uint256 oldAmount = self.sortitionSumTrees.stakeOf(drawId, userId);\r\n\r\n        if (oldAmount != _amount) {\r\n            // If the amount has changed\r\n\r\n            // Update the Draw's balance for that address\r\n            self.sortitionSumTrees.set(drawId, _amount, userId);\r\n\r\n            // if the draw is committed\r\n            if (_drawIndex != self.openDrawIndex) {\r\n                // Get the new draw total\r\n                uint256 newDrawTotal = self.sortitionSumTrees.total(drawId);\r\n\r\n                // update the draw in the committed tree\r\n                self.sortitionSumTrees.set(TREE_OF_DRAWS, newDrawTotal, drawId);\r\n            }\r\n        }\r\n    }\r\n\r\n   /**\r\n     * @notice Selects an address by indexing into the committed tokens using the passed token.\r\n     * If there is no committed supply, the zero address is returned.\r\n     * @param self The DrawManager state\r\n     * @param _token The token index to select\r\n     * @return The selected address\r\n     */\r\n    function draw(State storage self, uint256 _token) public view returns (address) {\r\n        // If there is no one to select, just return the zero address\r\n        if (committedSupply(self) == 0) {\r\n            return address(0);\r\n        }\r\n        require(_token < committedSupply(self), \"Pool/ineligible\");\r\n        bytes32 drawIndex = self.sortitionSumTrees.draw(TREE_OF_DRAWS, _token);\r\n        uint256 drawSupply = self.sortitionSumTrees.total(drawIndex);\r\n        uint256 drawToken = _token % drawSupply;\r\n        return address(uint256(self.sortitionSumTrees.draw(drawIndex, drawToken)));\r\n    }\r\n\r\n    /**\r\n     * @notice Selects an address using the entropy as an index into the committed tokens\r\n     * The entropy is passed into the UniformRandomNumber library to remove modulo bias.\r\n     * @param self The DrawManager state\r\n     * @param _entropy The random entropy to use\r\n     * @return The selected address\r\n     */\r\n    function drawWithEntropy(State storage self, bytes32 _entropy) public view returns (address) {\r\n        uint256 bound = committedSupply(self);\r\n        address selected;\r\n        if (bound == 0) {\r\n            selected = address(0);\r\n        } else {\r\n            selected = draw(self, UniformRandomNumber.uniform(uint256(_entropy), bound));\r\n        }\r\n        return selected;\r\n    }\r\n\r\n    modifier requireOpenDraw(State storage self) {\r\n        require(self.openDrawIndex > 0, \"Pool/no-open\");\r\n        _;\r\n    }\r\n\r\n    modifier requireCommittedDraw(State storage self) {\r\n        require(self.openDrawIndex > 1, \"Pool/no-commit\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNonZero(address _addr) {\r\n        require(_addr != address(0), \"Pool/not-zero\");\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BRANCHES_PER_NODE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TREE_OF_DRAWS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DrawManager","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://473604c11f1617e3de679dddb8b8f1547bc4569a3556c0b37920e8106271c515"}]}