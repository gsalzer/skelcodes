{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\ninterface GemLike {\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external;\r\n    function transferFrom(address, address, uint) external;\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface ManagerLike {\r\n    function cdpCan(address, uint, address) external view returns (uint);\r\n    function ilks(uint) external view returns (bytes32);\r\n    function owns(uint) external view returns (address);\r\n    function urns(uint) external view returns (address);\r\n    function vat() external view returns (address);\r\n    function open(bytes32, address) external returns (uint);\r\n    function give(uint, address) external;\r\n    function cdpAllow(uint, address, uint) external;\r\n    function urnAllow(address, uint) external;\r\n    function frob(uint, int, int) external;\r\n    function flux(uint, address, uint) external;\r\n    function move(uint, address, uint) external;\r\n    function exit(\r\n        address,\r\n        uint,\r\n        address,\r\n        uint\r\n    ) external;\r\n    function quit(uint, address) external;\r\n    function enter(address, uint) external;\r\n    function shift(uint, uint) external;\r\n}\r\n\r\ninterface VatLike {\r\n    function can(address, address) external view returns (uint);\r\n    function ilks(bytes32) external view returns (uint, uint, uint, uint, uint);\r\n    function dai(address) external view returns (uint);\r\n    function urns(bytes32, address) external view returns (uint, uint);\r\n    function frob(\r\n        bytes32,\r\n        address,\r\n        address,\r\n        address,\r\n        int,\r\n        int\r\n    ) external;\r\n    function hope(address) external;\r\n    function move(address, address, uint) external;\r\n    function gem(bytes32, address) external view returns (uint);\r\n\r\n}\r\n\r\ninterface GemJoinLike {\r\n    function dec() external returns (uint);\r\n    function gem() external returns (GemLike);\r\n    function join(address, uint) external payable;\r\n    function exit(address, uint) external;\r\n}\r\n\r\ninterface DaiJoinLike {\r\n    function vat() external returns (VatLike);\r\n    function dai() external returns (GemLike);\r\n    function join(address, uint) external payable;\r\n    function exit(address, uint) external;\r\n}\r\n\r\ninterface HopeLike {\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n}\r\n\r\ninterface JugLike {\r\n    function drip(bytes32) external returns (uint);\r\n}\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface PepInterface {\r\n    function peek() external returns (bytes32, bool);\r\n}\r\n\r\ninterface MakerOracleInterface {\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ninterface UniswapExchange {\r\n    function getEthToTokenOutputPrice(uint256 tokensBought) external view returns (uint256 ethSold);\r\n    function getTokenToEthOutputPrice(uint256 ethBought) external view returns (uint256 tokensSold);\r\n    function tokenToTokenSwapOutput(\r\n        uint256 tokensBought,\r\n        uint256 maxTokensSold,\r\n        uint256 maxEthSold,\r\n        uint256 deadline,\r\n        address tokenAddr\r\n        ) external returns (uint256  tokensSold);\r\n}\r\n\r\ninterface PoolInterface {\r\n    function accessToken(address[] calldata ctknAddr, uint[] calldata tknAmt, bool isCompound) external;\r\n    function paybackToken(address[] calldata ctknAddr, bool isCompound) external payable;\r\n}\r\n\r\ninterface CTokenInterface {\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalReserves() external view returns (uint);\r\n    function reserveFactorMantissa() external view returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface CERC20Interface {\r\n    function mint(uint mintAmount) external returns (uint); // For ERC20\r\n    function repayBorrow(uint repayAmount) external returns (uint); // For ERC20\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); // For ERC20\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable; // For ETH\r\n    function repayBorrow() external payable; // For ETH\r\n    function repayBorrowBehalf(address borrower) external payable; // For ETH\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n}\r\n\r\ninterface CompOracleInterface {\r\n    function getUnderlyingPrice(address) external view returns (uint);\r\n}\r\n\r\ninterface InstaMcdAddress {\r\n    function manager() external view returns (address);\r\n    function dai() external view returns (address);\r\n    function daiJoin() external view returns (address);\r\n    function vat() external view returns (address);\r\n    function jug() external view returns (address);\r\n    function ethAJoin() external view returns (address);\r\n}\r\n\r\ninterface OtcInterface {\r\n    function getPayAmount(address, address, uint) external view returns (uint);\r\n    function buyAllAmount(\r\n        address,\r\n        uint,\r\n        address,\r\n        uint\r\n    ) external;\r\n}\r\n\r\n\r\ncontract DSMath {\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        z = x - y <= x ? x - y : 0;\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0, \"int-overflow\");\r\n    }\r\n\r\n    function toRad(uint wad) internal pure returns (uint rad) {\r\n        rad = mul(wad, 10 ** 27);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helper is DSMath {\r\n\r\n    /**\r\n     * @dev get ethereum address for trade\r\n     */\r\n    function getAddressETH() public pure returns (address eth) {\r\n        eth = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n\r\n    /**\r\n     * @dev get MakerDAO MCD Address contract\r\n     */\r\n    function getMcdAddresses() public pure returns (address mcd) {\r\n        mcd = 0xF23196DF1C440345DE07feFbe556a5eF0dcD29F0;\r\n    }\r\n\r\n    /**\r\n     * @dev get InstaDApp Liquidity contract\r\n     */\r\n    function getPoolAddr() public pure returns (address poolAddr) {\r\n        poolAddr = 0x1564D040EC290C743F67F5cB11f3C1958B39872A;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() public pure returns (address troller) {\r\n        troller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev get CETH Address\r\n     */\r\n    function getCETHAddress() public pure returns (address cEth) {\r\n        cEth = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    }\r\n\r\n    /**\r\n     * @dev get DAI Address\r\n     */\r\n    function getDAIAddress() public pure returns (address dai) {\r\n        dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    }\r\n\r\n    /**\r\n     * @dev get CDAI Address\r\n     */\r\n    function getCDAIAddress() public pure returns (address cDai) {\r\n        cDai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\r\n    }\r\n\r\n    /**\r\n     * @dev setting allowance to compound contracts for the \"user proxy\" if required\r\n     */\r\n    function setApproval(address erc20, uint srcAmt, address to) internal {\r\n        TokenInterface erc20Contract = TokenInterface(erc20);\r\n        uint tokenAllowance = erc20Contract.allowance(address(this), to);\r\n        if (srcAmt > tokenAllowance) {\r\n            erc20Contract.approve(to, uint(-1));\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract InstaPoolResolver is Helper {\r\n\r\n    function accessDai(uint daiAmt, bool isCompound) internal {\r\n        address[] memory borrowAddr = new address[](1);\r\n        uint[] memory borrowAmt = new uint[](1);\r\n        borrowAddr[0] = getCDAIAddress();\r\n        borrowAmt[0] = daiAmt;\r\n        PoolInterface(getPoolAddr()).accessToken(borrowAddr, borrowAmt, isCompound);\r\n\r\n    }\r\n\r\n    function returnDai(uint daiAmt, bool isCompound) internal {\r\n        address[] memory borrowAddr = new address[](1);\r\n        borrowAddr[0] = getCDAIAddress();\r\n        require(TokenInterface(getDAIAddress()).transfer(getPoolAddr(), daiAmt), \"Not-enough-DAI\");\r\n        PoolInterface(getPoolAddr()).paybackToken(borrowAddr, isCompound);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MakerHelper is InstaPoolResolver {\r\n\r\n    event LogOpen(uint cdpNum, address owner);\r\n    event LogLock(uint cdpNum, uint amtETH, address owner);\r\n    event LogFree(uint cdpNum, uint amtETH, address owner);\r\n    event LogDraw(uint cdpNum, uint daiAmt, address owner);\r\n    event LogWipe(uint cdpNum, uint daiAmt, address owner);\r\n\r\n    /**\r\n     * @dev Allowance to Maker's contract\r\n     */\r\n    function setMakerAllowance(TokenInterface _token, address _spender) internal {\r\n        if (_token.allowance(address(this), _spender) != uint(-1)) {\r\n            _token.approve(_spender, uint(-1));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check if entered amt is valid or not (Used in makerToCompound)\r\n     */\r\n    function checkVault(uint id, uint ethAmt, uint daiAmt) internal view returns (uint ethCol, uint daiDebt) {\r\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\r\n        address urn = ManagerLike(manager).urns(id);\r\n        bytes32 ilk = ManagerLike(manager).ilks(id);\r\n        uint art = 0;\r\n        (ethCol, art) = VatLike(ManagerLike(manager).vat()).urns(ilk, urn);\r\n        (,uint rate,,,) = VatLike(ManagerLike(manager).vat()).ilks(ilk);\r\n        daiDebt = rmul(art,rate);\r\n        daiDebt = daiAmt < daiDebt ? daiAmt : daiDebt; // if DAI amount > max debt. Set max debt\r\n        ethCol = ethAmt < ethCol ? ethAmt : ethCol; // if ETH amount > max Col. Set max col\r\n    }\r\n\r\n    function joinDaiJoin(address urn, uint wad) internal {\r\n        address daiJoin = InstaMcdAddress(getMcdAddresses()).daiJoin();\r\n        // Approves adapter to take the DAI amount\r\n        DaiJoinLike(daiJoin).dai().approve(daiJoin, wad);\r\n        // Joins DAI into the vat\r\n        DaiJoinLike(daiJoin).join(urn, wad);\r\n    }\r\n\r\n    function _getDrawDart(\r\n        address vat,\r\n        address jug,\r\n        address urn,\r\n        bytes32 ilk,\r\n        uint wad\r\n    ) internal returns (int dart)\r\n    {\r\n        // Updates stability fee rate\r\n        uint rate = JugLike(jug).drip(ilk);\r\n\r\n        // Gets DAI balance of the urn in the vat\r\n        uint dai = VatLike(vat).dai(urn);\r\n\r\n        // If there was already enough DAI in the vat balance, just exits it without adding more debt\r\n        if (dai < mul(wad, RAY)) {\r\n            // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\r\n            dart = toInt(sub(mul(wad, RAY), dai) / rate);\r\n            // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\r\n            dart = mul(uint(dart), rate) < mul(wad, RAY) ? dart + 1 : dart;\r\n        }\r\n    }\r\n\r\n    function _getWipeDart(\r\n        address vat,\r\n        uint dai,\r\n        address urn,\r\n        bytes32 ilk\r\n    ) internal view returns (int dart)\r\n    {\r\n        // Gets actual rate from the vat\r\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\r\n        // Gets actual art value of the urn\r\n        (, uint art) = VatLike(vat).urns(ilk, urn);\r\n\r\n        // Uses the whole dai balance in the vat to reduce the debt\r\n        dart = toInt(dai / rate);\r\n        // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\r\n        dart = uint(dart) <= art ? - dart : - toInt(art);\r\n    }\r\n\r\n    function joinEthJoin(address urn, uint _wad) internal {\r\n        address ethJoin = InstaMcdAddress(getMcdAddresses()).ethAJoin();\r\n        // Wraps ETH in WETH\r\n        GemJoinLike(ethJoin).gem().deposit.value(_wad)();\r\n        // Approves adapter to take the WETH amount\r\n        GemJoinLike(ethJoin).gem().approve(address(ethJoin), _wad);\r\n        // Joins WETH collateral into the vat\r\n        GemJoinLike(ethJoin).join(urn, _wad);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CompoundHelper is MakerHelper {\r\n\r\n    event LogMint(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogRedeem(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogBorrow(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogRepay(address erc20, address cErc20, uint tokenAmt, address owner);\r\n\r\n    /**\r\n     * @dev Compound Enter Market which allows borrowing\r\n     */\r\n    function enterMarket(address cErc20) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory markets = troller.getAssetsIn(address(this));\r\n        bool isEntered = false;\r\n        for (uint i = 0; i < markets.length; i++) {\r\n            if (markets[i] == cErc20) {\r\n                isEntered = true;\r\n            }\r\n        }\r\n        if (!isEntered) {\r\n            address[] memory toEnter = new address[](1);\r\n            toEnter[0] = cErc20;\r\n            troller.enterMarkets(toEnter);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MakerResolver is CompoundHelper {\r\n    function flux(uint cdp, address dst, uint wad) internal {\r\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\r\n        ManagerLike(manager).flux(cdp, dst, wad);\r\n    }\r\n\r\n    function move(uint cdp, address dst, uint rad) public {\r\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\r\n        ManagerLike(manager).move(cdp, dst, rad);\r\n    }\r\n\r\n    function frob(uint cdp, int dink, int dart) internal {\r\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\r\n        ManagerLike(manager).frob(cdp, dink, dart);\r\n    }\r\n\r\n    function open() public returns (uint cdp) {\r\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\r\n        bytes32 ilk = 0x4554482d41000000000000000000000000000000000000000000000000000000;\r\n        cdp = ManagerLike(manager).open(ilk, address(this));\r\n        emit LogOpen(cdp, address(this));\r\n    }\r\n\r\n    function give(uint cdp, address usr) public {\r\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\r\n        ManagerLike(manager).give(cdp, usr);\r\n    }\r\n\r\n    function lock(uint cdp, uint _wad) internal {\r\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\r\n        // Receives ETH amount, converts it to WETH and joins it into the vat\r\n        joinEthJoin(address(this), _wad);\r\n        // Locks WETH amount into the CDP\r\n        VatLike(ManagerLike(manager).vat()).frob(\r\n            ManagerLike(manager).ilks(cdp),\r\n            ManagerLike(manager).urns(cdp),\r\n            address(this),\r\n            address(this),\r\n            toInt(_wad),\r\n            0\r\n        );\r\n        emit LogLock(cdp, _wad, address(this));\r\n    }\r\n\r\n    function free(uint cdp, uint wad) internal {\r\n        address ethJoin = InstaMcdAddress(getMcdAddresses()).ethAJoin();\r\n        // Unlocks WETH amount from the CDP\r\n        frob(\r\n            cdp,\r\n            -toInt(wad),\r\n            0\r\n        );\r\n        // Moves the amount from the CDP urn to proxy's address\r\n        flux(\r\n            cdp,\r\n            address(this),\r\n            wad\r\n        );\r\n        // Exits WETH amount to proxy address as a token\r\n        GemJoinLike(ethJoin).exit(address(this), wad);\r\n        // Converts WETH to ETH\r\n        GemJoinLike(ethJoin).gem().withdraw(wad);\r\n        emit LogFree(cdp, wad, address(this));\r\n    }\r\n\r\n    function draw(uint cdp, uint wad) internal {\r\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\r\n        address jug = InstaMcdAddress(getMcdAddresses()).jug();\r\n        address daiJoin = InstaMcdAddress(getMcdAddresses()).daiJoin();\r\n        address urn = ManagerLike(manager).urns(cdp);\r\n        address vat = ManagerLike(manager).vat();\r\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\r\n        // Generates debt in the CDP\r\n        frob(\r\n            cdp,\r\n            0,\r\n            _getDrawDart(\r\n                vat,\r\n                jug,\r\n                urn,\r\n                ilk,\r\n                wad\r\n            )\r\n        );\r\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\r\n        move(\r\n            cdp,\r\n            address(this),\r\n            toRad(wad)\r\n        );\r\n        // Allows adapter to access to proxy's DAI balance in the vat\r\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\r\n            VatLike(vat).hope(daiJoin);\r\n        }\r\n        // Exits DAI to the user's wallet as a token\r\n        DaiJoinLike(daiJoin).exit(address(this), wad);\r\n        emit LogDraw(cdp, wad, address(this));\r\n\r\n    }\r\n\r\n    function wipe(uint cdp, uint wad) internal {\r\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\r\n        address vat = ManagerLike(manager).vat();\r\n        address urn = ManagerLike(manager).urns(cdp);\r\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\r\n\r\n        address own = ManagerLike(manager).owns(cdp);\r\n        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\r\n            // Joins DAI amount into the vat\r\n            joinDaiJoin(urn, wad);\r\n            // Paybacks debt to the CDP\r\n            frob(\r\n                cdp,\r\n                0,\r\n                _getWipeDart(\r\n                    vat,\r\n                    VatLike(vat).dai(urn),\r\n                    urn,\r\n                    ilk\r\n                )\r\n            );\r\n        } else {\r\n             // Joins DAI amount into the vat\r\n            joinDaiJoin(address(this), wad);\r\n            // Paybacks debt to the CDP\r\n            VatLike(vat).frob(\r\n                ilk,\r\n                urn,\r\n                address(this),\r\n                address(this),\r\n                0,\r\n                _getWipeDart(\r\n                    vat,\r\n                    wad * RAY,\r\n                    urn,\r\n                    ilk\r\n                )\r\n            );\r\n        }\r\n        emit LogWipe(cdp, wad, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Run wipe & Free function together\r\n     */\r\n    function wipeAndFreeMaker(\r\n        uint cdpNum,\r\n        uint jam,\r\n        uint _wad,\r\n        bool isCompound\r\n    ) internal\r\n    {\r\n        accessDai(_wad, isCompound);\r\n        wipe(cdpNum, _wad);\r\n        free(cdpNum, jam);\r\n    }\r\n\r\n    /**\r\n     * @dev Run Lock & Draw function together\r\n     */\r\n    function lockAndDrawMaker(\r\n        uint cdpNum,\r\n        uint jam,\r\n        uint _wad,\r\n        bool isCompound\r\n    ) internal\r\n    {\r\n        lock(cdpNum, jam);\r\n        draw(cdpNum, _wad);\r\n        returnDai(_wad, isCompound);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CompoundResolver is MakerResolver {\r\n\r\n    /**\r\n     * @dev Deposit ETH and mint CETH\r\n     */\r\n    function mintCEth(uint tokenAmt) internal {\r\n        enterMarket(getCETHAddress());\r\n        CETHInterface cToken = CETHInterface(getCETHAddress());\r\n        cToken.mint.value(tokenAmt)();\r\n        emit LogMint(\r\n            getAddressETH(),\r\n            getCETHAddress(),\r\n            tokenAmt,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev borrow DAI\r\n     */\r\n    function borrowDAIComp(uint daiAmt, bool isCompound) internal {\r\n        enterMarket(getCDAIAddress());\r\n        require(CTokenInterface(getCDAIAddress()).borrow(daiAmt) == 0, \"got collateral?\");\r\n        // Returning Liquidity to Liquidity Contract\r\n        returnDai(daiAmt, isCompound);\r\n        emit LogBorrow(\r\n            getDAIAddress(),\r\n            getCDAIAddress(),\r\n            daiAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Pay DAI Debt\r\n     */\r\n    function repayDaiComp(uint tokenAmt, bool isCompound) internal returns (uint wipeAmt) {\r\n        CERC20Interface cToken = CERC20Interface(getCDAIAddress());\r\n        uint daiBorrowed = cToken.borrowBalanceCurrent(address(this));\r\n        wipeAmt = tokenAmt < daiBorrowed ? tokenAmt : daiBorrowed;\r\n        // Getting Liquidity from Liquidity Contract\r\n        accessDai(wipeAmt, isCompound);\r\n        setApproval(getDAIAddress(), wipeAmt, getCDAIAddress());\r\n        require(cToken.repayBorrow(wipeAmt) == 0, \"transfer approved?\");\r\n        emit LogRepay(\r\n            getDAIAddress(),\r\n            getCDAIAddress(),\r\n            wipeAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Redeem CETH\r\n     */\r\n    function redeemCETH(uint tokenAmt) internal returns(uint ethAmtReddemed) {\r\n        CTokenInterface cToken = CTokenInterface(getCETHAddress());\r\n        uint cethBal = cToken.balanceOf(address(this));\r\n        uint exchangeRate = cToken.exchangeRateCurrent();\r\n        uint cethInEth = wmul(cethBal, exchangeRate);\r\n        setApproval(getCETHAddress(), 2**128, getCETHAddress());\r\n        ethAmtReddemed = tokenAmt;\r\n        if (tokenAmt > cethInEth) {\r\n            require(cToken.redeem(cethBal) == 0, \"something went wrong\");\r\n            ethAmtReddemed = cethInEth;\r\n        } else {\r\n            require(cToken.redeemUnderlying(tokenAmt) == 0, \"something went wrong\");\r\n        }\r\n        emit LogRedeem(\r\n            getAddressETH(),\r\n            getCETHAddress(),\r\n            ethAmtReddemed,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev run mint & borrow together\r\n     */\r\n    function mintAndBorrowComp(uint ethAmt, uint daiAmt, bool isCompound) internal {\r\n        mintCEth(ethAmt);\r\n        borrowDAIComp(daiAmt, isCompound);\r\n    }\r\n\r\n    /**\r\n     * @dev run payback & redeem together\r\n     */\r\n    function paybackAndRedeemComp(uint ethCol, uint daiDebt, bool isCompound) internal returns (uint ethAmt, uint daiAmt) {\r\n        daiAmt = repayDaiComp(daiDebt, isCompound);\r\n        ethAmt = redeemCETH(ethCol);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if entered amt is valid or not (Used in makerToCompound)\r\n     */\r\n    function checkCompound(uint ethAmt, uint daiAmt) internal returns (uint ethCol, uint daiDebt) {\r\n        CTokenInterface cEthContract = CTokenInterface(getCETHAddress());\r\n        uint cEthBal = cEthContract.balanceOf(address(this));\r\n        uint ethExchangeRate = cEthContract.exchangeRateCurrent();\r\n        ethCol = wmul(cEthBal, ethExchangeRate);\r\n        ethCol = wdiv(ethCol, ethExchangeRate) <= cEthBal ? ethCol : ethCol - 1;\r\n        ethCol = ethCol <= ethAmt ? ethCol : ethAmt; // Set Max if amount is greater than the Col user have\r\n\r\n        daiDebt = CERC20Interface(getCDAIAddress()).borrowBalanceCurrent(address(this));\r\n        daiDebt = daiDebt <= daiAmt ? daiDebt : daiAmt; // Set Max if amount is greater than the Debt user have\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract BridgeResolver is CompoundResolver {\r\n\r\n    event LogVaultToCompound(uint ethAmt, uint daiAmt);\r\n    event LogCompoundToVault(uint ethAmt, uint daiAmt);\r\n\r\n    /**\r\n     * @dev convert Maker CDP into Compound Collateral\r\n     */\r\n    function makerToCompound(\r\n        uint cdpId,\r\n        uint ethQty,\r\n        uint daiQty,\r\n        bool isCompound // access Liquidity from Compound\r\n    ) external\r\n    {\r\n        // subtracting 0.00000001 ETH from initialPoolBal to solve Compound 8 decimal CETH error.\r\n        uint initialPoolBal = sub(getPoolAddr().balance, 10000000000);\r\n\r\n        (uint ethAmt, uint daiAmt) = checkVault(cdpId, ethQty, daiQty);\r\n        wipeAndFreeMaker(\r\n            cdpId,\r\n            ethAmt,\r\n            daiAmt,\r\n            isCompound\r\n        ); // Getting Liquidity inside Wipe function\r\n\r\n        enterMarket(getCETHAddress());\r\n        enterMarket(getCDAIAddress());\r\n        mintAndBorrowComp(ethAmt, daiAmt, isCompound); // Returning Liquidity inside Borrow function\r\n\r\n        uint finalPoolBal = getPoolAddr().balance;\r\n        assert(finalPoolBal >= initialPoolBal);\r\n\r\n        emit LogVaultToCompound(ethAmt, daiAmt);\r\n    }\r\n\r\n    /**\r\n     * @dev convert Compound Collateral into Maker CDP\r\n     * @param cdpId = 0, if user don't have any CDP\r\n     */\r\n    function compoundToMaker(\r\n        uint cdpId,\r\n        uint ethQty,\r\n        uint daiQty,\r\n        bool isCompound\r\n    ) external\r\n    {\r\n        // subtracting 0.00000001 ETH from initialPoolBal to solve Compound 8 decimal CETH error.\r\n        uint initialPoolBal = sub(getPoolAddr().balance, 10000000000);\r\n\r\n        uint cdpNum = cdpId > 0 ? cdpId : open();\r\n        (uint ethCol, uint daiDebt) = checkCompound(ethQty, daiQty);\r\n        (uint ethAmt, uint daiAmt) = paybackAndRedeemComp(ethCol, daiDebt, isCompound); // Getting Liquidity inside Wipe function\r\n        ethAmt = ethAmt < address(this).balance ? ethAmt : address(this).balance;\r\n        lockAndDrawMaker(\r\n            cdpNum,\r\n            ethAmt,\r\n            daiAmt,\r\n            isCompound\r\n        ); // Returning Liquidity inside Borrow function\r\n\r\n        uint finalPoolBal = getPoolAddr().balance;\r\n        assert(finalPoolBal >= initialPoolBal);\r\n\r\n        emit LogCompoundToVault(ethAmt, daiAmt);\r\n    }\r\n}\r\n\r\n\r\ncontract InstaVaultCompBridge is BridgeResolver {\r\n    function() external payable {}\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmt\",\"type\":\"uint256\"}],\"name\":\"LogCompoundToVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogDraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogFree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmt\",\"type\":\"uint256\"}],\"name\":\"LogVaultToCompound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogWipe\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethQty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daiQty\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCompound\",\"type\":\"bool\"}],\"name\":\"compoundToMaker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"eth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCDAIAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cDai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCETHAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cEth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getComptrollerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"troller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDAIAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"dai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMcdAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"mcd\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"poolAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"give\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethQty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daiQty\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCompound\",\"type\":\"bool\"}],\"name\":\"makerToCompound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rad\",\"type\":\"uint256\"}],\"name\":\"move\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"open\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"InstaVaultCompBridge","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://1ed6d1fc200e55d133aebf6d7441e204fb481a89479519e82f6c19c8b86f72f1"}]}