{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.15;\r\n\r\ninterface ERC20CompatibleToken {\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer (address to, uint tokens) external returns (bool success);\r\n    function transferFrom (address from, address to, uint tokens) external returns (bool success);\r\n}\r\n\r\n/** \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\r\n * This token factory creates customizable TokenReserve smart contracts which are used for time-based locking of any ERC20 and ERC20-compatible tokens.\r\n * The information regarding the locking smart contract itself is provided below.\r\n * Made with ♥ by DreamTeam. Find more info about this smart contract and others here: https://github.com/dreamteam-gg/smart-contracts\r\n * Anyone is free to create TokenReserve contracts using this factory.\r\n */ \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\r\ncontract TokenReserveFactory {\r\n\r\n    event ContractCreated(address tokenReserveContract);\r\n\r\n    /**\r\n     * Creates TokenReserve smart contracts.\r\n     */\r\n    function deployNewTokenReserveContract(\r\n      address tokenContractAddress, address[] memory authorizedWithdrawalAddresses, uint lockPeriod, uint bracketSize\r\n    ) public returns (address) {\r\n        if (bracketSize == 0) {\r\n            bracketSize = 30 days + 10 hours;\r\n        }\r\n        if (lockPeriod == 0) {\r\n            lockPeriod = 5 * (365 days + 6 hours);\r\n        }\r\n        TokenReserve rb = new TokenReserve(tokenContractAddress, lockPeriod, authorizedWithdrawalAddresses, bracketSize);\r\n        emit ContractCreated(address(rb));\r\n        return address(rb);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Math operations with safety checks that throw on overflows.\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"Multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div (uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"Subtraction underflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"Sum overflow\");\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Token reserve contract makes it possible to time-lock ERC20 {tokenContractAddress} tokens for {lockPeriod}, specified in the constructor.\r\n *\r\n * The time-lock is bracketed by ~30 days by default (not a calendar month). E.g. if {lockPeriod=5 years} and you lock 10 tokens multiple times during the month bracket,\r\n * you will get all tokens unlocked at a single moment after 5 years. If you lock more tokens in the next month bracket, you get them unlocked after 5 years\r\n * and 30 days via a single transaction.\r\n *\r\n * Example:\r\n * {lockPeriod = 1 year (365 days)}\r\n *  \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\r\n * Year 0  ↓ You locked 10 tokens in a single month bracket    Year 1  ↓ Those 10 tokens are unlocked here\r\n *   |    :X   :XXX :    :    :    :    :    :    :    :    :    |    :X   :X   :    :    :    :    :\r\n *              ↑↑↑ You locked 50 tokens 3 times in a month bracket         ↑ Those 50 tokens are unlocked here just once\r\n */ \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\r\ncontract TokenReserve {\r\n \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\r\n    using SafeMath for uint256;\r\n    uint public constant bracketingStartDate = 1546300800; // Tue, 01 Jan 2019 00:00:00 GMT - the beginning of a new year/month/day/hour/minute\r\n\r\n    // = 5 years, can be reassigned in constructor (see the exact number in blockchain explorer)\r\n    uint public lockPeriod = 5 * (365 days + 6 hours);\r\n    uint public bracketSize = 30 days + 10 hours; // Pretends to be the best approximation of a calendar month. Reassigned in constructor.\r\n    address public tokenContractAddress; // Assigned in constructor\r\n    mapping(address => bool) public authorizedWithdrawalAddress; // Assigned in constructor\r\n\r\n    // Linked list of unlock records bracketed by {bracketSize}\r\n    struct BracketRecord {\r\n        uint nextBracket;\r\n        uint value;\r\n    }\r\n    mapping(uint => BracketRecord) brackets;\r\n    uint firstUnlockBracket;\r\n    uint lastUnlockBracket;\r\n    uint totalValueLocked;\r\n\r\n    event TokensLocked(uint value, uint unlockTimestamp);\r\n    event TokensUnlocked(uint value, uint unlockTimestamp); // Does not include tokens accidentally sent to this smart contract\r\n    event AccountAuthorized(address account, address authorizedBy);\r\n    event AccountDeauthorized(address account);\r\n\r\n    modifier authorizedAccessOnly() {\r\n        require(authorizedWithdrawalAddress[msg.sender], \"Only authorized addresses can call this function\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _tokenContractAddress, uint _lockPeriod, address[] memory authorizedWithdrawalAddresses, uint _bracketSize) public {\r\n        require(_lockPeriod > _bracketSize, \"Lock period must be strictly more than bracket size\");\r\n        lockPeriod = _lockPeriod;\r\n        tokenContractAddress = _tokenContractAddress;\r\n        bracketSize = _bracketSize;\r\n        for (uint i = 0; i < authorizedWithdrawalAddresses.length; i++) {\r\n            authorizedWithdrawalAddress[authorizedWithdrawalAddresses[i]] = true;\r\n            emit AccountAuthorized(authorizedWithdrawalAddresses[i], address(0x0));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function takes {value} tokens from the {msg.sender} and locks them on a smart contract within the right computed bracket.\r\n     * Anyone can lock their tokens on this smart contract, but only an admin can unlock them.\r\n     * Tokens have to be approved in the token smart contract before the smart contract can take them as specified.\r\n     */\r\n    function lockTokens(uint value) public {\r\n        lockTokensInternal(msg.sender, value);\r\n    }\r\n    function lockTokensInternal(address from, uint value) internal {\r\n        ERC20CompatibleToken(tokenContractAddress).transferFrom(from, address(this), value);\r\n        uint unlockBracket = getBracketByTimestamp(block.timestamp.add(lockPeriod));\r\n        if (unlockBracket == lastUnlockBracket) {\r\n            brackets[lastUnlockBracket].value = brackets[lastUnlockBracket].value.add(value);\r\n        } else {\r\n            if (lastUnlockBracket == 0) {\r\n                firstUnlockBracket = unlockBracket;\r\n            } else {\r\n                brackets[lastUnlockBracket].nextBracket = unlockBracket;\r\n            }\r\n            brackets[lastUnlockBracket = unlockBracket] = BracketRecord({\r\n                nextBracket: 0,\r\n                value: value\r\n            });\r\n        }\r\n        totalValueLocked = totalValueLocked.add(value);\r\n        emit TokensLocked(value, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * Unlocks tokens available at the moment and sends them to message sender. Callable only by an authorized address.\r\n     * Throws an error if no tokens are available.\r\n     */\r\n    function unlockTokens() public authorizedAccessOnly {\r\n        unlockTokensInternal(msg.sender);\r\n    }\r\n    function unlockTokensInternal(address receiver) internal {\r\n        uint totalUnlocked = 0;\r\n        uint currentBracket = getBracketByTimestamp(block.timestamp);\r\n        uint limit = 0;\r\n        uint wasLocked = totalValueLocked;\r\n        // Inlined (don't uses getUnlockedValue()) because it clears the storage, making an operation cheaper + has a limit to prevent possible gas overflow\r\n        // Assuming one loop takes 30000 gas (intentially more than it takes), with an extra allowance of 300000 gas, excluding the gas refund.\r\n        while (firstUnlockBracket > 0 && firstUnlockBracket <= currentBracket && limit++ < (block.gaslimit - 300000) / 30000) {\r\n            totalUnlocked = totalUnlocked.add(brackets[firstUnlockBracket].value);\r\n            uint nextBracket = brackets[firstUnlockBracket].nextBracket;\r\n            delete brackets[firstUnlockBracket];\r\n            firstUnlockBracket = nextBracket;\r\n        }\r\n        if (firstUnlockBracket == 0) {\r\n            lastUnlockBracket = 0;\r\n        }\r\n        if (totalUnlocked != 0) {\r\n            totalValueLocked = totalValueLocked.sub(totalUnlocked);\r\n            emit TokensUnlocked(totalUnlocked, block.timestamp);\r\n        }\r\n        // Add tokens that were sent to a smart contract accidentally\r\n        if (ERC20CompatibleToken(tokenContractAddress).balanceOf(address(this)) > wasLocked) {\r\n            totalUnlocked = totalUnlocked.add(ERC20CompatibleToken(tokenContractAddress).balanceOf(address(this)).sub(wasLocked));\r\n        }\r\n        require(totalUnlocked != 0, \"Nothing to unlock\");\r\n        ERC20CompatibleToken(tokenContractAddress).transfer(receiver, totalUnlocked);\r\n    }\r\n\r\n    /**\r\n     * Any authorized address can authorize more addresses.\r\n     */\r\n    function authorizeWithdrawalAddress(address _authorizedWithdrawalAddress) public authorizedAccessOnly {\r\n        require(!authorizedWithdrawalAddress[_authorizedWithdrawalAddress], \"Account is already authorized\");\r\n        authorizedWithdrawalAddress[_authorizedWithdrawalAddress] = true;\r\n        emit AccountAuthorized(_authorizedWithdrawalAddress, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Only the withdrawal address itself can deauthorize. This prevents possible deadlock in case one of the authorized private keys leak.\r\n     */\r\n    function deauthorizeWithdrawalAddress() public authorizedAccessOnly {\r\n        require(authorizedWithdrawalAddress[msg.sender], \"Account was not authorized\");\r\n        authorizedWithdrawalAddress[msg.sender] = false;\r\n        emit AccountDeauthorized(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Public getter for blockchain explorer to show how many tokens are unlocked at the moment.\r\n     */\r\n    function getUnlockedValue() public view returns (uint) {\r\n        uint totalUnlocked = 0;\r\n        uint currentBracket = getBracketByTimestamp(block.timestamp);\r\n        uint bracket = firstUnlockBracket;\r\n        while (bracket > 0 && bracket <= currentBracket) {\r\n            totalUnlocked = totalUnlocked.add(brackets[bracket].value);\r\n            bracket = brackets[bracket].nextBracket;\r\n        }\r\n        return totalUnlocked;\r\n    }\r\n\r\n    /**\r\n     * Public getter for blockchain explorer to show when is the next unlock possible.\r\n     * Returns unix timestamp either in the past (if unlock is already available) or in the future (if not yet available)\r\n     */\r\n    function getNextUnlockTimestamp() public view returns (uint) {\r\n        return getTimestampByBracket(firstUnlockBracket);\r\n    }\r\n\r\n    function getBracketByTimestamp(uint timestamp) internal view returns (uint) {\r\n        return (timestamp - bracketingStartDate) / bracketSize;\r\n    }\r\n\r\n    function getTimestampByBracket(uint bracket) internal view returns (uint) {\r\n        return bracketingStartDate + bracket * bracketSize;\r\n    }\r\n\r\n    /**\r\n     * This function enables locking and unlocking of tokens via a single call from the token smart contract (incl. delegated calls).\r\n     * If {value} == 0, receiveApproval will try to unlock tokens.\r\n     * If {value} > 0, receiveApproval will try to lock {value} tokens.\r\n     */\r\n    function receiveApproval(address from, uint256 value, address, bytes calldata) external {\r\n        require(msg.sender == tokenContractAddress, \"Sender must be a token contract address\");\r\n        if (value == 0) {\r\n            require(authorizedWithdrawalAddress[from], \"Only authorized addresses can unlock tokens\");\r\n            unlockTokensInternal(from);\r\n        } else {\r\n            lockTokensInternal(from, value);\r\n        }\r\n    }\r\n \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenReserveContract\",\"type\":\"address\"}],\"name\":\"ContractCreated\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"authorizedWithdrawalAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"lockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bracketSize\",\"type\":\"uint256\"}],\"name\":\"deployNewTokenReserveContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenReserveFactory","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://2a0cb7b09f97f155e566203f7ed52d58df1b2de98cff6d73724561b475cd75de"}]}