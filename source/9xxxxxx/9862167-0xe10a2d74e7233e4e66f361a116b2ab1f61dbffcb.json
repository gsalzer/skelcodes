{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\n/* https://elgame.cc */\r\ncontract Context {\r\n\t// Empty internal constructor, to prevent people from mistakenly deploying\r\n\t// an instance of this contract, which should be used via inheritance.\r\n\tconstructor() internal {}\r\n\t// solhint-disable-previous-line no-empty-blocks\r\n\r\n\tfunction _msgSender() internal view returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n\t/* https://elgame.cc */\r\n\taddress private _owner;\r\n\taddress private nextOwner;\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor () internal {\r\n\t\t_owner = _msgSender();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(isOwner(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the caller is the current owner.\r\n\t */\r\n\tfunction isOwner() public view returns (bool) {\r\n\t\treturn _msgSender() == _owner;\r\n\t}\r\n\r\n\t// Standard contract ownership transfer implementation,\r\n\tfunction approveNextOwner(address _nextOwner) external onlyOwner {\r\n\t\trequire(_nextOwner != _owner, \"Cannot approve current owner.\");\r\n\t\tnextOwner = _nextOwner;\r\n\t}\r\n\r\n\tfunction acceptNextOwner() external {\r\n\t\trequire(msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n\t\t_owner = nextOwner;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n\tstruct Role {\r\n\t\tmapping(address => bool) bearer;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Give an account access to this role.\r\n\t */\r\n\tfunction add(Role storage role, address account) internal {\r\n\t\trequire(!has(role, account), \"Roles: account already has role\");\r\n\t\trole.bearer[account] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove an account's access to this role.\r\n\t */\r\n\tfunction remove(Role storage role, address account) internal {\r\n\t\trequire(has(role, account), \"Roles: account does not have role\");\r\n\t\trole.bearer[account] = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if an account has this role.\r\n\t * @return bool\r\n\t */\r\n\tfunction has(Role storage role, address account) internal view returns (bool) {\r\n\t\trequire(account != address(0), \"Roles: account is the zero address\");\r\n\t\treturn role.bearer[account];\r\n\t}\r\n}\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Context, Ownable {\r\n\t/* https://elgame.cc */\r\n\tusing Roles for Roles.Role;\r\n\r\n\tRoles.Role private _whitelistAdmins;\r\n\r\n\tconstructor () internal {\r\n\t}\r\n\r\n\tmodifier onlyWhitelistAdmin() {\r\n\t\trequire(isWhitelistAdmin(_msgSender()) || isOwner(), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction isWhitelistAdmin(address account) public view returns (bool) {\r\n\t\treturn _whitelistAdmins.has(account) || isOwner();\r\n\t}\r\n\r\n\tfunction addWhitelistAdmin(address account) public onlyOwner {\r\n\t\t_whitelistAdmins.add(account);\r\n\t}\r\n\r\n\tfunction removeWhitelistAdmin(address account) public onlyOwner {\r\n\t\t_whitelistAdmins.remove(account);\r\n\t}\r\n}\r\n\r\ncontract ELG is WhitelistAdminRole {\r\n\t/* https://elgame.cc */\r\n\tusing SafeMath for *;\r\n\tuint ethWei = 1 ether;\r\n\r\n\taddress payable private devAddr = address(0x1dACD4B4837Fa90b343F6fe97BB87Fa7b21C034C);\r\n\r\n\taddress payable private comfortAddr = address(0xC0b314fd11F79fEDfDE8318686034ed60AD309a3);\r\n\r\n\tstruct User {\r\n\t\tuint id;\r\n\t\taddress userAddress;\r\n\t\tuint userType;\r\n\t\tuint freezeAmount;\r\n\t\tuint freeAmount;\r\n\t\tuint inviteAmonut;\r\n\t\tuint shareAmount;\r\n\t\tuint bonusAmount;\r\n\t\tuint dayBonAmount;\r\n\t\tuint dayInvAmount;\r\n\t\tuint level;\r\n\t\tuint resTime;\r\n\t\tstring inviteCode;\r\n\t\tstring beCode;\r\n\t\tuint allAward;\r\n\t\tuint lastRwTime;\r\n\t\tuint investTimes;\r\n\t\tuint[] branchUid;\r\n\t\tuint staticTims;\r\n\t}\r\n\r\n\tstruct UserGlobal {\r\n\t\tuint id;\r\n\t\taddress userAddress;\r\n\t\tstring inviteCode;\r\n\t\tstring beCode;\r\n\t\tuint status;\r\n\t}\r\n\r\n\tuint startTime;\r\n\tmapping(uint => uint) rInvestCount;\r\n\tmapping(uint => uint) rInvestMoney;\r\n\tuint period = 1 days;\r\n\tuint uid = 0;\r\n\tuint rid = 1;\r\n\tmapping(uint => mapping(address => User)) userRoundMapping;\r\n\tmapping(address => UserGlobal) userMapping;\r\n\tmapping(string => address) addressMapping;\r\n\tmapping(uint => address) indexMapping;\r\n\tuint bonuslimit = 30 ether;\r\n\tuint sendLimit = 100 ether;\r\n\tuint withdrawLimit = 30 ether;\r\n\tuint canSetStartTime = 1;\r\n\tmapping(uint => uint) public maxValMapping;\r\n\r\n\tmodifier isHuman() {\r\n\t\taddress addr = msg.sender;\r\n\t\tuint codeLength;\r\n\t\tassembly {codeLength := extcodesize(addr)}\r\n\t\trequire(codeLength == 0, \"sorry, humans only\");\r\n\t\trequire(tx.origin == msg.sender, \"sorry, humans only\");\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor (address _addr, string memory inviteCode) public {\r\n\t\tregisterUser(_addr, inviteCode, \"\");\r\n\t}\r\n\r\n\tfunction() external payable {\r\n\t}\r\n\r\n\tfunction flle(uint[] calldata times, uint[] calldata values) external onlyWhitelistAdmin {\r\n\r\n\t\tfor(uint i=0; i < times.length ; i++){\r\n\t\t\tmaxValMapping[times[i]] = values[i];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction door(uint time) external onlyOwner {\r\n\t\trequire(canSetStartTime == 1, \"can not set start time again\");\r\n\t\trequire(time > now, \"invalid game start time\");\r\n\t\tstartTime = time;\r\n\t\tcanSetStartTime = 0;\r\n\t}\r\n\r\n\tfunction sorrow(address payable _dev, address payable _com) external onlyOwner {\r\n\t\tdevAddr = _dev;\r\n\t\tcomfortAddr = _com;\r\n\t}\r\n\r\n\tfunction isGameStarted() public view returns (bool) {\r\n\t\treturn startTime != 0 && now > startTime;\r\n\t}\r\n\r\n\tfunction actAllLimit(uint bonusLi, uint sendLi, uint withdrawLi) external onlyOwner {\r\n\t\trequire(bonusLi >= 30 ether && sendLi >= 100 ether && withdrawLi >= 30 ether, \"invalid amount\");\r\n\t\tbonuslimit = bonusLi;\r\n\t\tsendLimit = sendLi;\r\n\t\twithdrawLimit = withdrawLi;\r\n\t}\r\n\r\n\tfunction believe(address addr, uint status) external onlyWhitelistAdmin {\r\n\t\trequire(status == 0 || status == 1 || status == 2, \"bad parameter status\");\r\n\t\tUserGlobal storage userGlobal = userMapping[addr];\r\n\t\tuserGlobal.status = status;\r\n\t}\r\n\r\n\tfunction abide(string memory inviteCode, string memory beCode, uint userType) public isHuman() payable {\r\n\t\trequire(isGameStarted(), \"game not start\");\r\n\t\trequire(msg.value >= 1 ether,\"greater than 1\");\r\n\t\trequire(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\r\n\t\trequire(userType == 1 || userType == 2, \"invalid userType\");\r\n\t\tUserGlobal storage userGlobal = userMapping[msg.sender];\r\n\t\tif (userGlobal.id == 0) {\r\n\t\t\trequire(!UtilELG.compareStr(inviteCode, \"      \") && bytes(inviteCode).length == 6, \"invalid invite code\");\r\n\t\t\taddress beCodeAddr = addressMapping[beCode];\r\n\t\t\trequire(isUsed(beCode), \"beCode not exist\");\r\n\t\t\trequire(beCodeAddr != msg.sender, \"beCodeAddr can't be self\");\r\n\t\t\trequire(!isUsed(inviteCode), \"invite code is used\");\r\n\t\t\tregisterUser(msg.sender, inviteCode, beCode);\r\n\t\t}\r\n\r\n\t\tUser storage user = userRoundMapping[rid][msg.sender];\r\n\t\tif(userType == 1 || user.userType == 1){\r\n\t\t\trequire(user.freezeAmount.add(msg.value) <= maxValMapping[user.staticTims] * ethWei, \"No more than MaxValue\");\r\n\t\t}\r\n\t\trequire(user.freezeAmount.add(msg.value) <= 30 ether, \"No more than 30\");\r\n\t\tif (user.id != 0) {\r\n\t\t\tif (user.freezeAmount == 0) {\r\n\t\t\t\tuser.userType = userType;\r\n\t\t\t\tuser.allAward = 0;\r\n\t\t\t\tuser.resTime = now;\r\n\t\t\t\tuser.lastRwTime = now;\r\n\t\t\t}\r\n\t\t\tuser.freezeAmount = user.freezeAmount.add(msg.value);\r\n\t\t\tuser.level = UtilELG.getLevel(user.freezeAmount);\r\n\t\t} else {\r\n\t\t\tuser.id = userGlobal.id;\r\n\t\t\tuser.userAddress = msg.sender;\r\n\t\t\tuser.freezeAmount = msg.value;\r\n\t\t\tuser.level = UtilELG.getLevel(msg.value);\r\n\t\t\tuser.inviteCode = userGlobal.inviteCode;\r\n\t\t\tuser.beCode = userGlobal.beCode;\r\n\t\t\tuser.userType = userType;\r\n\t\t\tuser.resTime = now;\r\n\t\t\tuser.lastRwTime = now;\r\n\t\t\taddress beCodeAddr = addressMapping[userGlobal.beCode];\r\n\t\t\tUser storage calUser = userRoundMapping[rid][beCodeAddr];\r\n\t\t\tif (calUser.id != 0) {\r\n\t\t\t\tcalUser.branchUid.push(userGlobal.id);\r\n\t\t\t}\r\n\t\t}\r\n\t\trInvestCount[rid] = rInvestCount[rid].add(1);\r\n\t\trInvestMoney[rid] = rInvestMoney[rid].add(msg.value);\r\n\t\tventura(msg.value);\r\n\t\ttrend(user.userAddress, msg.value);\r\n\t}\r\n\r\n\tfunction astonishment() external isHuman() {\r\n\t\trequire(isGameStarted(), \"game not start\");\r\n\t\tUser storage user = userRoundMapping[rid][msg.sender];\r\n\t\trequire(user.freeAmount >= 1 ether, \"User has no freeAmount\");\r\n\t\tbool isEnough = false;\r\n\t\tuint resultMoney = 0;\r\n\r\n\t\t(isEnough, resultMoney) = isEnoughBalance(user.freeAmount);\r\n\r\n\t\tif (resultMoney > 0 && resultMoney <= withdrawLimit) {\r\n\t\t\tsendMoneyToUser(msg.sender, resultMoney);\r\n\t\t\tuser.freeAmount = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reject(uint userType) external {\r\n\t\tUser storage user = userRoundMapping[rid][msg.sender];\r\n\t\trequire(userType == 1 || userType == 2, \"invalid userType\");\r\n\t\trequire(user.userType != userType, \"Same state\");\r\n\t\trequire(user.freezeAmount > 0, \"freezeAmount must be greater than 0\");\r\n\t\tif (user.userType == 1 && userType == 2) {\r\n\t\t\tuser.userType = 2;\r\n\t\t\tuser.investTimes = 0;\r\n\t\t\tuser.resTime = now;\r\n\t\t\taddress tmpUserAddr = addressMapping[user.beCode];\r\n\t\t\tUser storage calUser = userRoundMapping[rid][tmpUserAddr];\r\n\t\t\tUserGlobal storage userGlobal = userMapping[msg.sender];\r\n\t\t\tUserGlobal storage calUserGlobal = userMapping[tmpUserAddr];\r\n\t\t\tif (calUser.freezeAmount >= 1 ether && calUser.userType == 2 && calUser.level >= user.level && userGlobal.status == 0 && calUserGlobal.status == 0) {\r\n\t\t\t\tbool isOut = false;\r\n\t\t\t\tuint resultSend = 0;\r\n\t\t\t\t(isOut, resultSend) = raid(tmpUserAddr, user.freezeAmount.div(10));\r\n\t\t\t\tsendToAddr(resultSend, tmpUserAddr);\r\n\t\t\t\tcalUser.shareAmount = calUser.shareAmount.add(resultSend);\r\n\t\t\t\tif (!isOut) {\r\n\t\t\t\t\tcalUser.allAward = calUser.allAward.add(resultSend);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (user.userType == 2 && userType == 1) {\r\n\t\t\trequire((user.allAward.add(ethWei.mul(5).div(4))) <= user.freezeAmount, \"Less reward than principal 5/4 ether\");\r\n\t\t\tuint balance = user.freezeAmount.sub(user.allAward);\r\n\t\t\trequire(balance <= 30 ether, \"invalid amount\");\r\n\t\t\tbalance = balance.mul(4).div(5);\r\n\t\t\tuser.userType = 1;\r\n\t\t\tuser.investTimes = 0;\r\n\t\t\tuser.freezeAmount = balance.div(ethWei).mul(ethWei);\r\n\t\t\tuser.level = UtilELG.getLevel(user.freezeAmount);\r\n\t\t\tuint scale = UtilELG.getScByLevel(user.level);\r\n\t\t\tuser.dayInvAmount = 0;\r\n\t\t\tuser.dayBonAmount = user.freezeAmount.mul(scale).div(1000);\r\n\t\t\tuser.allAward = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction trend(address userAddr, uint investAmount) private {\r\n\t\tUser storage user = userRoundMapping[rid][userAddr];\r\n\t\tif (user.id == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint scale = UtilELG.getScByLevel(user.level);\r\n\t\tuser.dayBonAmount = user.freezeAmount.mul(scale).div(1000);\r\n\t\tuser.investTimes = 0;\r\n\t\taddress tmpUserAddr = addressMapping[user.beCode];\r\n\t\tUser storage calUser = userRoundMapping[rid][tmpUserAddr];\r\n\t\tUserGlobal storage userGlobal = userMapping[userAddr];\r\n\t\tUserGlobal storage calUserGlobal = userMapping[tmpUserAddr];\r\n\t\tif (calUser.freezeAmount >= 1 ether && calUser.userType == 2 && user.userType == 2 && calUser.level >= user.level && userGlobal.status == 0 && calUserGlobal.status == 0) {\r\n\t\t\tbool isOut = false;\r\n\t\t\tuint resultSend = 0;\r\n\t\t\t(isOut, resultSend) = raid(calUser.userAddress, investAmount.div(10));\r\n\t\t\tsendToAddr(resultSend, calUser.userAddress);\r\n\t\t\tcalUser.shareAmount = calUser.shareAmount.add(resultSend);\r\n\t\t\tif (!isOut) {\r\n\t\t\t\tcalUser.allAward = calUser.allAward.add(resultSend);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction amuse() external isHuman {\r\n\t\tcombat(msg.sender);\r\n\t}\r\n\r\n\tfunction clarify(uint start, uint end) external onlyWhitelistAdmin {\r\n\t\tfor (uint i = end; i >= start; i--) {\r\n\t\t\taddress userAddr = indexMapping[i];\r\n\t\t\tcombat(userAddr);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction combat(address addr) private {\r\n\t\trequire(isGameStarted(), \"game not start\");\r\n\t\tUser storage user = userRoundMapping[rid][addr];\r\n\t\tUserGlobal memory userGlobal = userMapping[addr];\r\n\t\tif (isWhitelistAdmin(msg.sender)) {\r\n\t\t\tif (now.sub(user.lastRwTime) <= 23 hours.add(58 minutes) || user.id == 0 || userGlobal.id == 0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\trequire(user.id > 0, \"Users of the game are not betting in this round\");\r\n\t\t\trequire(now.sub(user.lastRwTime) >= 23 hours.add(58 minutes), \"Can only be extracted once in 24 hours\");\r\n\t\t}\r\n\t\tuser.lastRwTime = now;\r\n\t\tif (userGlobal.status == 1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint awardSend = 0;\r\n\t\tuint scale = UtilELG.getScByLevel(user.level);\r\n\t\tuint freezeAmount = user.freezeAmount;\r\n\t\tif (user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit) {\r\n\t\t\tif ((user.userType == 1 && user.investTimes < 5) || user.userType == 2) {\r\n\t\t\t\tawardSend = awardSend.add(user.dayBonAmount);\r\n\t\t\t\tuser.bonusAmount = user.bonusAmount.add(user.dayBonAmount);\r\n\t\t\t\tif (user.userType == 1) {\r\n\t\t\t\t\tuser.investTimes = user.investTimes.add(1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (user.userType == 1 && user.investTimes >= 5) {\r\n\t\t\t\tuser.freeAmount = user.freeAmount.add(user.freezeAmount);\r\n\t\t\t\tuser.freezeAmount = 0;\r\n\t\t\t\tuser.dayBonAmount = 0;\r\n\t\t\t\tuser.level = 0;\r\n\t\t\t\tuser.userType = 0;\r\n\t\t\t\tuser.staticTims +=1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (awardSend == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (userGlobal.status == 0 && user.userType == 2) {\r\n\t\t\tawardSend = awardSend.add(user.dayInvAmount);\r\n\t\t\tuser.inviteAmonut = user.inviteAmonut.add(user.dayInvAmount);\r\n\t\t}\r\n\t\tif (awardSend > 0 && awardSend <= sendLimit) {\r\n\t\t\tbool isOut = false;\r\n\t\t\tuint resultSend = 0;\r\n\t\t\t(isOut, resultSend) = raid(addr, awardSend);\r\n\t\t\tif (user.dayInvAmount > 0) {\r\n\t\t\t\tuser.dayInvAmount = 0;\r\n\t\t\t}\r\n\t\t\tsendToAddr(resultSend, addr);\r\n\t\t\tif (resultSend > 0) {\r\n\t\t\t\tif (!isOut) {\r\n\t\t\t\t\tuser.allAward = user.allAward.add(awardSend);\r\n\t\t\t\t}\r\n\t\t\t\tif(userGlobal.status == 0) {\r\n\t\t\t\t\trash(user.beCode, freezeAmount, scale, user.resTime);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction rash(string memory beCode, uint money, uint shareSc, uint userTime) private {\r\n\t\tstring memory tmpReferrer = beCode;\r\n\t\tfor (uint i = 1; i <= 20; i++) {\r\n\t\t\tif (UtilELG.compareStr(tmpReferrer, \"\")) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\taddress tmpUserAddr = addressMapping[tmpReferrer];\r\n\t\t\tUserGlobal storage userGlobal = userMapping[tmpUserAddr];\r\n\t\t\tUser storage calUser = userRoundMapping[rid][tmpUserAddr];\r\n\r\n\t\t\tif (userGlobal.status != 0 || calUser.freezeAmount == 0 || calUser.resTime > userTime || calUser.userType != 2) {\r\n\t\t\t\ttmpReferrer = userGlobal.beCode;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tuint fireSc = UtilELG.getFireScByLevel(calUser.level);\r\n\t\t\tuint recommendSc = UtilELG.getRecommendScaleByLevelAndTim(getUserLevel(tmpUserAddr), i);\r\n\t\t\tuint moneyResult = 0;\r\n\t\t\tif (money <= calUser.freezeAmount) {\r\n\t\t\t\tmoneyResult = money;\r\n\t\t\t} else {\r\n\t\t\t\tmoneyResult = calUser.freezeAmount;\r\n\t\t\t}\r\n\r\n\t\t\tif (recommendSc != 0) {\r\n\t\t\t\tuint tmpDynamicAmount = moneyResult.mul(shareSc).mul(recommendSc).mul(fireSc);\r\n\t\t\t\ttmpDynamicAmount = tmpDynamicAmount.div(1000).div(100).div(10);\r\n\t\t\t\tcalUser.dayInvAmount = calUser.dayInvAmount.add(tmpDynamicAmount);\r\n\t\t\t}\r\n\t\t\ttmpReferrer = userGlobal.beCode;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getUserLevel(address _addr) private view returns (uint) {\r\n\t\tUser storage user = userRoundMapping[rid][_addr];\r\n\t\tuint count = 0;\r\n\t\tfor (uint i = 0; i < user.branchUid.length; i++) {\r\n\t\t\taddress addr = indexMapping[user.branchUid[i]];\r\n\t\t\tif (uint(addr) != 0) {\r\n\t\t\t\tUser memory countUser = userRoundMapping[rid][addr];\r\n\t\t\t\tif (countUser.level >= 3) {\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (count >= 10) {\r\n\t\t\treturn 7;\r\n\t\t}\r\n\t\tif (count >= 5) {\r\n\t\t\treturn 6;\r\n\t\t}\r\n\t\tif (count >= 3) {\r\n\t\t\treturn 5;\r\n\t\t}\r\n\t\treturn user.level;\r\n\t}\r\n\r\n\tfunction raid(address _addr, uint sendMoney) private returns (bool isOut, uint resultSend) {\r\n\t\tUser storage user = userRoundMapping[rid][_addr];\r\n\t\tif (user.userType == 1 || user.userType == 0) {\r\n\t\t\treturn (false, sendMoney);\r\n\t\t}\r\n\t\tuint resultAmount = user.freezeAmount.mul(UtilELG.getEndTims(user.freezeAmount)).div(10);\r\n\t\tif (user.allAward.add(sendMoney) >= resultAmount) {\r\n\t\t\tisOut = true;\r\n\t\t\tif (resultAmount <= user.allAward) {\r\n\t\t\t\tresultSend = 0;\r\n\t\t\t} else {\r\n\t\t\t\tresultSend = resultAmount.sub(user.allAward);\r\n\t\t\t}\r\n\t\t\tuser.dayBonAmount = 0;\r\n\t\t\tuser.level = 0;\r\n\t\t\tuser.freezeAmount = 0;\r\n\t\t\tuser.allAward = 0;\r\n\t\t\tuser.userType = 0;\r\n\t\t\tuser.dayInvAmount = 0;\r\n\t\t\tuser.staticTims +=1;\r\n\t\t} else {\r\n\t\t\tresultSend = sendMoney;\r\n\t\t}\r\n\t\treturn (isOut, resultSend);\r\n\t}\r\n\r\n\tfunction sendToAddr(uint sendAmount, address addr) private {\r\n\t\tbool isEnough = false;\r\n\t\tuint resultMoney = 0;\r\n\t\t(isEnough, resultMoney) = isEnoughBalance(sendAmount);\r\n\t\tif (resultMoney > 0 && resultMoney <= sendLimit) {\r\n\t\t\tuint rand = uint256(keccak256(abi.encodePacked(block.number, now))).mod(16);\r\n\t\t\tuint confortMoney = resultMoney.div(100).mul(rand);\r\n\t\t\tsendMoneyToUser(comfortAddr, confortMoney);\r\n\t\t\tresultMoney = resultMoney.sub(confortMoney);\r\n\t\t\taddress payable sendAddr = address(uint160(addr));\r\n\t\t\tsendMoneyToUser(sendAddr, resultMoney);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction isEnoughBalance(uint sendMoney) private view returns (bool, uint) {\r\n\t\tif (address(this).balance >= sendMoney) {\r\n\t\t\treturn (true, sendMoney);\r\n\t\t} else {\r\n\t\t\treturn (false, address(this).balance);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getGameInfo() public view returns (uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\t\treturn (\r\n\t\trid,\r\n\t\tuid,\r\n\t\tstartTime,\r\n\t\trInvestCount[rid],\r\n\t\trInvestMoney[rid],\r\n\t\tbonuslimit,\r\n\t\tsendLimit,\r\n\t\twithdrawLimit,\r\n\t\tcanSetStartTime\r\n\t\t);\r\n\t}\r\n\r\n\tfunction paineBluff(address addr, uint roundId) public view returns (uint[17] memory info, string memory inviteCode, string memory beCode) {\r\n\t\trequire(isWhitelistAdmin(msg.sender) || msg.sender == addr, \"Permission denied for view user's privacy\");\r\n\r\n\t\tif (roundId == 0) {\r\n\t\t\troundId = rid;\r\n\t\t}\r\n\r\n\t\tUserGlobal memory userGlobal = userMapping[addr];\r\n\t\tUser memory user = userRoundMapping[roundId][addr];\r\n\t\tinfo[0] = userGlobal.id;\r\n\t\tinfo[1] = user.freezeAmount;\r\n\t\tinfo[2] = user.inviteAmonut;\r\n\t\tinfo[3] = user.bonusAmount;\r\n\t\tinfo[4] = user.dayBonAmount;\r\n\t\tinfo[5] = user.level;\r\n\t\tinfo[6] = user.dayInvAmount;\r\n\t\tinfo[7] = user.lastRwTime;\r\n\t\tinfo[8] = userGlobal.status;\r\n\t\tinfo[9] = user.allAward;\r\n\t\tinfo[10] = user.userType;\r\n\t\tinfo[11] = user.shareAmount;\r\n\t\tinfo[12] = user.freeAmount;\r\n\t\tinfo[13] = user.branchUid.length;\r\n\t\tinfo[14] = user.investTimes;\r\n\t\tinfo[15] = user.resTime;\r\n\t\tinfo[16] = user.staticTims;\r\n\t\treturn (info, userGlobal.inviteCode, userGlobal.beCode);\r\n\t}\r\n\r\n\tfunction ventura(uint amount) private {\r\n\t\tdevAddr.transfer(amount.div(10));\r\n\t}\r\n\r\n\tfunction sendMoneyToUser(address payable userAddress, uint money) private {\r\n\t\tif (money > 0) {\r\n\t\t\tuserAddress.transfer(money);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction isUsed(string memory code) public view returns (bool) {\r\n\t\taddress addr = addressMapping[code];\r\n\t\treturn uint(addr) != 0;\r\n\t}\r\n\r\n\tfunction getUserAddressByCode(string memory code) public view returns (address) {\r\n\t\trequire(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n\t\treturn addressMapping[code];\r\n\t}\r\n\r\n\tfunction registerUser(address addr, string memory inviteCode, string memory beCode) private {\r\n\t\tUserGlobal storage userGlobal = userMapping[addr];\r\n\t\tuid++;\r\n\t\tuserGlobal.id = uid;\r\n\t\tuserGlobal.userAddress = addr;\r\n\t\tuserGlobal.inviteCode = inviteCode;\r\n\t\tuserGlobal.beCode = beCode;\r\n\r\n\t\taddressMapping[inviteCode] = addr;\r\n\t\tindexMapping[uid] = addr;\r\n\t}\r\n\r\n\tfunction endRound() external onlyOwner {\r\n\t\trequire(address(this).balance < 1 ether, \"contract balance must be lower than 1 ether\");\r\n\t\trid++;\r\n\t\tstartTime = now.add(period).div(1 days).mul(1 days);\r\n\t\tcanSetStartTime = 1;\r\n\t}\r\n\r\n\tfunction getUserAddressById(uint id) public view returns (address) {\r\n\t\trequire(isWhitelistAdmin(msg.sender));\r\n\t\treturn indexMapping[id];\r\n\t}\r\n}\r\n\r\nlibrary UtilELG {\r\n    /* https://elgame.cc */\r\n\tfunction getLevel(uint value) public pure  returns (uint) {\r\n\t\tif (value >= 1 ether && value <= 5 ether) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (value >= 6 ether && value <= 10 ether) {\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t\tif (value >= 11 ether && value <= 15 ether) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\tif (value >= 16 ether && value <= 30 ether) {\r\n\t\t\treturn 4;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getScByLevel(uint level) public pure  returns (uint) {\r\n\t\tif (level == 1) {\r\n\t\t\treturn 5;\r\n\t\t}\r\n\t\tif (level == 2) {\r\n\t\t\treturn 7;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\treturn 10;\r\n\t\t}\r\n\t\tif (level == 4) {\r\n\t\t\treturn 12;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getFireScByLevel(uint level) public pure  returns (uint) {\r\n\t\tif (level == 1) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\tif (level == 2) {\r\n\t\t\treturn 5;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\treturn 7;\r\n\t\t}\r\n\t\tif (level == 4) {\r\n\t\t\treturn 10;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getRecommendScaleByLevelAndTim(uint level, uint times) public pure returns (uint) {\r\n\t\tif (level == 1 && times == 1) {\r\n\t\t\treturn 20;\r\n\t\t}\r\n\t\tif (level == 2 && times == 1) {\r\n\t\t\treturn 20;\r\n\t\t}\r\n\t\tif (level == 2 && times == 2) {\r\n\t\t\treturn 15;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\tif (times == 1) {\r\n\t\t\t\treturn 20;\r\n\t\t\t}\r\n\t\t\tif (times == 2) {\r\n\t\t\t\treturn 15;\r\n\t\t\t}\r\n\t\t\tif (times == 3) {\r\n\t\t\t\treturn 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (level == 4) {\r\n\t\t\tif (times == 1) {\r\n\t\t\t\treturn 20;\r\n\t\t\t}\r\n\t\t\tif (times == 2) {\r\n\t\t\t\treturn 15;\r\n\t\t\t}\r\n\t\t\tif (times >= 3 && times <= 5) {\r\n\t\t\t\treturn 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (level == 5) {\r\n\t\t\tif (times == 1) {\r\n\t\t\t\treturn 30;\r\n\t\t\t}\r\n\t\t\tif (times == 2) {\r\n\t\t\t\treturn 15;\r\n\t\t\t}\r\n\t\t\tif (times >= 3 && times <= 5) {\r\n\t\t\t\treturn 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (level == 6) {\r\n\t\t\tif (times == 1) {\r\n\t\t\t\treturn 50;\r\n\t\t\t}\r\n\t\t\tif (times == 2) {\r\n\t\t\t\treturn 15;\r\n\t\t\t}\r\n\t\t\tif (times >= 3 && times <= 5) {\r\n\t\t\t\treturn 10;\r\n\t\t\t}\r\n\t\t\tif (times >= 6 && times <= 10) {\r\n\t\t\t\treturn 3;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (level == 7) {\r\n\t\t\tif (times == 1) {\r\n\t\t\t\treturn 100;\r\n\t\t\t}\r\n\t\t\tif (times == 2) {\r\n\t\t\t\treturn 15;\r\n\t\t\t}\r\n\t\t\tif (times >= 3 && times <= 5) {\r\n\t\t\t\treturn 10;\r\n\t\t\t}\r\n\t\t\tif (times >= 6 && times <= 10) {\r\n\t\t\t\treturn 3;\r\n\t\t\t}\r\n\t\t\tif (times >= 11 && times <= 15) {\r\n\t\t\t\treturn 2;\r\n\t\t\t}\r\n\t\t\tif (times >= 16 && times <= 20) {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction compareStr(string memory _str, string memory str) public pure returns (bool) {\r\n\t\tif (keccak256(abi.encodePacked(_str)) == keccak256(abi.encodePacked(str))) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction getEndTims(uint value) public pure  returns (uint) {\r\n\t\tif (value >= 1 ether && value <= 5 ether) {\r\n\t\t\treturn 15;\r\n\t\t}\r\n\t\tif (value >= 6 ether && value <= 10 ether) {\r\n\t\t\treturn 20;\r\n\t\t}\r\n\t\tif (value >= 11 ether && value <= 15 ether) {\r\n\t\t\treturn 25;\r\n\t\t}\r\n\t\tif (value >= 16 ether && value <= 30 ether) {\r\n\t\t\treturn 30;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n\t/**\r\n\t* @dev Multiplies two numbers, reverts on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"mul overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b > 0, \"div zero\");\r\n\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b <= a, \"lower sub bigger\");\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, reverts on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n\t* reverts when dividing by zero.\r\n\t*/\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b != 0, \"mod zero\");\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev compare two numbers and returns the smaller one.\r\n\t*/\r\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a > b ? b : a;\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"beCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"userType\",\"type\":\"uint256\"}],\"name\":\"abide\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusLi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sendLi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawLi\",\"type\":\"uint256\"}],\"name\":\"actAllLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"amuse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"astonishment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"believe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"clarify\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"door\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"times\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"flle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getUserAddressByCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserAddressById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isGameStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"isUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxValMapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"paineBluff\",\"outputs\":[{\"internalType\":\"uint256[17]\",\"name\":\"info\",\"type\":\"uint256[17]\"},{\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"beCode\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"userType\",\"type\":\"uint256\"}],\"name\":\"reject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_dev\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_com\",\"type\":\"address\"}],\"name\":\"sorrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ELG","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000dbefe019b7373e2d7bf770977b96dec1706d2fa00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000006454c47414d450000000000000000000000000000000000000000000000000000","Library":"UtilELG:2e063ef126b6dbb5fb6fa8b49ae865a8bd3936a7","LicenseType":"None","SwarmSource":"bzzr://835848ac439a3d79211f708234a95bd434e3e12896423408e3c5a2bb1791b4cf"}]}