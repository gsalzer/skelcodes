{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.13;\n\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract Context {\n    \n    \n    constructor () internal { }\n    \n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint256 private _guardCounter;\n\n    constructor () internal {\n        \n        \n        _guardCounter = 1;\n    }\n\n    \n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\ninterface IMiniMeToken {\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function totalSupply() external view returns(uint);\n    function generateTokens(address _owner, uint _amount) external returns (bool);\n    function destroyTokens(address _owner, uint _amount) external returns (bool);\n    function totalSupplyAt(uint _blockNumber) external view returns(uint);\n    function balanceOfAt(address _holder, uint _blockNumber) external view returns (uint);\n    function transferOwnership(address newOwner) external;\n}\n\ncontract TokenController {\n  \n  \n  \n  function proxyPayment(address _owner) public payable returns(bool);\n\n  \n  \n  \n  \n  \n  \n  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n\n  \n  \n  \n  \n  \n  \n  function onApprove(address _owner, address _spender, uint _amount) public\n    returns(bool);\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    \n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        \n        \n        \n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        \n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    \n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        \n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        \n        \n        \n        \n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    \n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        \n        \n\n        \n        \n        \n        \n        \n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        \n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { \n            \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface KyberNetwork {\n  function getExpectedRate(ERC20Detailed src, ERC20Detailed dest, uint srcQty) external view\n      returns (uint expectedRate, uint slippageRate);\n\n  function tradeWithHint(\n    ERC20Detailed src, uint srcAmount, ERC20Detailed dest, address payable destAddress, uint maxDestAmount,\n    uint minConversionRate, address walletId, bytes calldata hint) external payable returns(uint);\n}\n\ninterface Dexag {\n    function approvalHandler() external view returns (address);\n}\n\ncontract Utils {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Detailed;\n\n  \n  modifier isValidToken(address _token) {\n    require(_token != address(0));\n    if (_token != address(ETH_TOKEN_ADDRESS)) {\n      require(isContract(_token));\n    }\n    _;\n  }\n\n  address public DAI_ADDR;\n  address payable public KYBER_ADDR;\n  address payable public DEXAG_ADDR;\n\n  bytes public constant PERM_HINT = \"PERM\";\n\n  ERC20Detailed internal constant ETH_TOKEN_ADDRESS = ERC20Detailed(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n  ERC20Detailed internal dai;\n  KyberNetwork internal kyber;\n\n  uint constant internal PRECISION = (10**18);\n  uint constant internal MAX_QTY   = (10**28); \n  uint constant internal ETH_DECIMALS = 18;\n  uint constant internal MAX_DECIMALS = 18;\n\n  constructor(\n    address _daiAddr,\n    address payable _kyberAddr,\n    address payable _dexagAddr\n  ) public {\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    DEXAG_ADDR = _dexagAddr;\n\n    dai = ERC20Detailed(_daiAddr);\n    kyber = KyberNetwork(_kyberAddr);\n  }\n\n  \n  function getDecimals(ERC20Detailed _token) internal view returns(uint256) {\n    if (address(_token) == address(ETH_TOKEN_ADDRESS)) {\n      return uint256(ETH_DECIMALS);\n    }\n    return uint256(_token.decimals());\n  }\n\n  \n  function getBalance(ERC20Detailed _token, address _addr) internal view returns(uint256) {\n    if (address(_token) == address(ETH_TOKEN_ADDRESS)) {\n      return uint256(_addr.balance);\n    }\n    return uint256(_token.balanceOf(_addr));\n  }\n\n  \n  function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n        internal pure returns(uint)\n  {\n    require(srcAmount <= MAX_QTY);\n    require(destAmount <= MAX_QTY);\n\n    if (dstDecimals >= srcDecimals) {\n      require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n      return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n    } else {\n      require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n      return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n    }\n  }\n\n  \n  function __kyberTrade(ERC20Detailed _srcToken, uint256 _srcAmount, ERC20Detailed _destToken)\n    internal\n    returns(\n      uint256 _destPriceInSrc,\n      uint256 _srcPriceInDest,\n      uint256 _actualDestAmount,\n      uint256 _actualSrcAmount\n    )\n  {\n    require(_srcToken != _destToken);\n\n    uint256 beforeSrcBalance = getBalance(_srcToken, address(this));\n    uint256 msgValue;\n    if (_srcToken != ETH_TOKEN_ADDRESS) {\n      msgValue = 0;\n      _srcToken.safeApprove(KYBER_ADDR, 0);\n      _srcToken.safeApprove(KYBER_ADDR, _srcAmount);\n    } else {\n      msgValue = _srcAmount;\n    }\n    _actualDestAmount = kyber.tradeWithHint.value(msgValue)(\n      _srcToken,\n      _srcAmount,\n      _destToken,\n      toPayableAddr(address(this)),\n      MAX_QTY,\n      1,\n      0x332D87209f7c8296389C307eAe170c2440830A47,\n      PERM_HINT\n    );\n    _actualSrcAmount = beforeSrcBalance.sub(getBalance(_srcToken, address(this)));\n    require(_actualDestAmount > 0 && _actualSrcAmount > 0);\n    _destPriceInSrc = calcRateFromQty(_actualDestAmount, _actualSrcAmount, getDecimals(_destToken), getDecimals(_srcToken));\n    _srcPriceInDest = calcRateFromQty(_actualSrcAmount, _actualDestAmount, getDecimals(_srcToken), getDecimals(_destToken));\n  }\n\n  \n  function __dexagTrade(ERC20Detailed _srcToken, uint256 _srcAmount, ERC20Detailed _destToken, bytes memory _calldata)\n    internal\n    returns(\n      uint256 _destPriceInSrc,\n      uint256 _srcPriceInDest,\n      uint256 _actualDestAmount,\n      uint256 _actualSrcAmount\n    )\n  {\n    require(_srcToken != _destToken);\n\n    uint256 beforeSrcBalance = getBalance(_srcToken, address(this));\n    uint256 beforeDestBalance = getBalance(_destToken, address(this));\n    \n    if (_srcToken != ETH_TOKEN_ADDRESS) {\n      _actualSrcAmount = 0;\n      Dexag dex = Dexag(DEXAG_ADDR);\n      address approvalHandler = dex.approvalHandler();\n      _srcToken.safeApprove(approvalHandler, 0);\n      _srcToken.safeApprove(approvalHandler, _srcAmount);\n    } else {\n      _actualSrcAmount = _srcAmount;\n    }\n\n    \n    (bool success,) = DEXAG_ADDR.call.value(_actualSrcAmount)(_calldata);\n    require(success);\n\n    \n    _actualDestAmount = beforeDestBalance.sub(getBalance(_destToken, address(this)));\n    _actualSrcAmount = beforeSrcBalance.sub(getBalance(_srcToken, address(this)));\n    require(_actualDestAmount > 0 && _actualSrcAmount > 0);\n    _destPriceInSrc = calcRateFromQty(_actualDestAmount, _actualSrcAmount, getDecimals(_destToken), getDecimals(_srcToken));\n    _srcPriceInDest = calcRateFromQty(_actualSrcAmount, _actualDestAmount, getDecimals(_srcToken), getDecimals(_destToken));\n\n    \n    (, uint256 kyberSrcPriceInDest) = kyber.getExpectedRate(_srcToken, _destToken, _srcAmount);\n    require(kyberSrcPriceInDest > 0 && _srcPriceInDest >= kyberSrcPriceInDest);\n  }\n\n  \n  function isContract(address _addr) internal view returns(bool) {\n    uint size;\n    if (_addr == address(0)) return false;\n    assembly {\n        size := extcodesize(_addr)\n    }\n    return size>0;\n  }\n\n  function toPayableAddr(address _addr) internal pure returns (address payable) {\n    return address(uint160(_addr));\n  }\n}\n\ninterface BetokenProxyInterface {\n  function betokenFundAddress() external view returns (address payable);\n  function updateBetokenFundAddress() external;\n}\n\ninterface ScdMcdMigration {\n  \n  \n  \n  function swapSaiToDai(\n    uint wad\n  ) external;\n}\n\ncontract BetokenStorage is Ownable, ReentrancyGuard {\n  using SafeMath for uint256;\n\n  enum CyclePhase { Intermission, Manage }\n  enum VoteDirection { Empty, For, Against }\n  enum Subchunk { Propose, Vote }\n\n  struct Investment {\n    address tokenAddress;\n    uint256 cycleNumber;\n    uint256 stake;\n    uint256 tokenAmount;\n    uint256 buyPrice; \n    uint256 sellPrice; \n    uint256 buyTime;\n    uint256 buyCostInDAI;\n    bool isSold;\n  }\n\n  \n  uint256 public constant COMMISSION_RATE = 20 * (10 ** 16); \n  uint256 public constant ASSET_FEE_RATE = 1 * (10 ** 15); \n  uint256 public constant NEXT_PHASE_REWARD = 1 * (10 ** 18); \n  uint256 public constant MAX_BUY_KRO_PROP = 1 * (10 ** 16); \n  uint256 public constant FALLBACK_MAX_DONATION = 100 * (10 ** 18); \n  uint256 public constant MIN_KRO_PRICE = 25 * (10 ** 17); \n  uint256 public constant COLLATERAL_RATIO_MODIFIER = 75 * (10 ** 16); \n  uint256 public constant MIN_RISK_TIME = 3 days; \n  uint256 public constant INACTIVE_THRESHOLD = 2; \n  uint256 public constant ROI_PUNISH_THRESHOLD = 1 * (10 ** 17); \n  uint256 public constant ROI_BURN_THRESHOLD = 25 * (10 ** 16); \n  uint256 public constant ROI_PUNISH_SLOPE = 6; \n  uint256 public constant ROI_PUNISH_NEG_BIAS = 5 * (10 ** 17); \n  \n  uint256 public constant CHUNK_SIZE = 3 days;\n  uint256 public constant PROPOSE_SUBCHUNK_SIZE = 1 days;\n  uint256 public constant CYCLES_TILL_MATURITY = 3;\n  uint256 public constant QUORUM = 10 * (10 ** 16); \n  uint256 public constant VOTE_SUCCESS_THRESHOLD = 75 * (10 ** 16); \n\n  \n\n  \n  bool public hasInitializedTokenListings;\n\n  \n  bool public isInitialized;\n\n  \n  address public controlTokenAddr;\n\n  \n  address public shareTokenAddr;\n\n  \n  address payable public proxyAddr;\n\n  \n  address public compoundFactoryAddr;\n\n  \n  address public betokenLogic;\n  address public betokenLogic2;\n\n  \n  address payable public devFundingAccount;\n\n  \n  address payable public previousVersion;\n\n  \n  address public saiAddr;\n\n  \n  uint256 public cycleNumber;\n\n  \n  uint256 public totalFundsInDAI;\n\n  \n  uint256 public startTimeOfCyclePhase;\n\n  \n  uint256 public devFundingRate;\n\n  \n  uint256 public totalCommissionLeft;\n\n  \n  uint256[2] public phaseLengths;\n\n  \n  mapping(address => uint256) internal _lastCommissionRedemption;\n\n  \n  mapping(address => mapping(uint256 => bool)) internal _hasRedeemedCommissionForCycle;\n\n  \n  mapping(address => mapping(uint256 => uint256)) internal _riskTakenInCycle;\n\n  \n  mapping(address => uint256) internal _baseRiskStakeFallback;\n\n  \n  mapping(address => Investment[]) public userInvestments;\n\n  \n  mapping(address => address payable[]) public userCompoundOrders;\n\n  \n  mapping(uint256 => uint256) internal _totalCommissionOfCycle;\n\n  \n  mapping(uint256 => uint256) internal _managePhaseEndBlock;\n\n  \n  mapping(address => uint256) internal _lastActiveCycle;\n\n  \n  mapping(address => bool) public isKyberToken;\n\n  \n  mapping(address => bool) public isCompoundToken;\n\n  \n  mapping(address => bool) public isPositionToken;\n\n  \n  CyclePhase public cyclePhase;\n\n  \n  bool public hasFinalizedNextVersion; \n  bool public upgradeVotingActive; \n  address payable public nextVersion; \n  address[5] public proposers; \n  address payable[5] public candidates; \n  uint256[5] public forVotes; \n  uint256[5] public againstVotes; \n  uint256 public proposersVotingWeight; \n  mapping(uint256 => mapping(address => VoteDirection[5])) public managerVotes; \n  mapping(uint256 => uint256) public upgradeSignalStrength; \n  mapping(uint256 => mapping(address => bool)) public upgradeSignal; \n\n  \n  IMiniMeToken internal cToken;\n  IMiniMeToken internal sToken;\n  BetokenProxyInterface internal proxy;\n  ScdMcdMigration internal mcdaiMigration;\n\n  \n\n  event ChangedPhase(uint256 indexed _cycleNumber, uint256 indexed _newPhase, uint256 _timestamp, uint256 _totalFundsInDAI);\n\n  event Deposit(uint256 indexed _cycleNumber, address indexed _sender, address _tokenAddress, uint256 _tokenAmount, uint256 _daiAmount, uint256 _timestamp);\n  event Withdraw(uint256 indexed _cycleNumber, address indexed _sender, address _tokenAddress, uint256 _tokenAmount, uint256 _daiAmount, uint256 _timestamp);\n\n  event CreatedInvestment(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _tokenAddress, uint256 _stakeInWeis, uint256 _buyPrice, uint256 _costDAIAmount, uint256 _tokenAmount);\n  event SoldInvestment(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _tokenAddress, uint256 _receivedKairo, uint256 _sellPrice, uint256 _earnedDAIAmount);\n\n  event CreatedCompoundOrder(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _order, bool _orderType, address _tokenAddress, uint256 _stakeInWeis, uint256 _costDAIAmount);\n  event SoldCompoundOrder(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _order,  bool _orderType, address _tokenAddress, uint256 _receivedKairo, uint256 _earnedDAIAmount);\n  event RepaidCompoundOrder(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _order, uint256 _repaidDAIAmount);\n\n  event CommissionPaid(uint256 indexed _cycleNumber, address indexed _sender, uint256 _commission);\n  event TotalCommissionPaid(uint256 indexed _cycleNumber, uint256 _totalCommissionInDAI);\n\n  event Register(address indexed _manager, uint256 _donationInDAI, uint256 _kairoReceived);\n\n  event SignaledUpgrade(uint256 indexed _cycleNumber, address indexed _sender, bool indexed _inSupport);\n  event DeveloperInitiatedUpgrade(uint256 indexed _cycleNumber, address _candidate);\n  event InitiatedUpgrade(uint256 indexed _cycleNumber);\n  event ProposedCandidate(uint256 indexed _cycleNumber, uint256 indexed _voteID, address indexed _sender, address _candidate);\n  event Voted(uint256 indexed _cycleNumber, uint256 indexed _voteID, address indexed _sender, bool _inSupport, uint256 _weight);\n  event FinalizedNextVersion(uint256 indexed _cycleNumber, address _nextVersion);\n\n  \n\n  \n  function currentChunk() public view returns (uint) {\n    if (cyclePhase != CyclePhase.Manage) {\n      return 0;\n    }\n    return (now - startTimeOfCyclePhase) / CHUNK_SIZE;\n  }\n\n  \n  function currentSubchunk() public view returns (Subchunk _subchunk) {\n    if (cyclePhase != CyclePhase.Manage) {\n      return Subchunk.Vote;\n    }\n    uint256 timeIntoCurrChunk = (now - startTimeOfCyclePhase) % CHUNK_SIZE;\n    return timeIntoCurrChunk < PROPOSE_SUBCHUNK_SIZE ? Subchunk.Propose : Subchunk.Vote;\n  }\n\n  \n  function getVotingWeight(address _of) public view returns (uint256 _weight) {\n    if (cycleNumber <= CYCLES_TILL_MATURITY || _of == address(0)) {\n      return 0;\n    }\n    return cToken.balanceOfAt(_of, managePhaseEndBlock(cycleNumber.sub(CYCLES_TILL_MATURITY)));\n  }\n\n  \n  function getTotalVotingWeight() public view returns (uint256 _weight) {\n    if (cycleNumber <= CYCLES_TILL_MATURITY) {\n      return 0;\n    }\n    return cToken.totalSupplyAt(managePhaseEndBlock(cycleNumber.sub(CYCLES_TILL_MATURITY))).sub(proposersVotingWeight);\n  }\n\n  \n  function kairoPrice() public view returns (uint256 _kairoPrice) {\n    if (cToken.totalSupply() == 0) { return MIN_KRO_PRICE; }\n    uint256 controlPerKairo = totalFundsInDAI.mul(10 ** 18).div(cToken.totalSupply());\n    if (controlPerKairo < MIN_KRO_PRICE) {\n      \n      return MIN_KRO_PRICE;\n    }\n    return controlPerKairo;\n  }\n\n  function lastCommissionRedemption(address _manager) public view returns (uint256) {\n    if (_lastCommissionRedemption[_manager] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).lastCommissionRedemption(_manager);\n    }\n    return _lastCommissionRedemption[_manager];\n  }\n\n  function hasRedeemedCommissionForCycle(address _manager, uint256 _cycle) public view returns (bool) {\n    if (_hasRedeemedCommissionForCycle[_manager][_cycle] == false) {\n      return previousVersion == address(0) ? false : BetokenStorage(previousVersion).hasRedeemedCommissionForCycle(_manager, _cycle);\n    }\n    return _hasRedeemedCommissionForCycle[_manager][_cycle];\n  }\n\n  function riskTakenInCycle(address _manager, uint256 _cycle) public view returns (uint256) {\n    if (_riskTakenInCycle[_manager][_cycle] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).riskTakenInCycle(_manager, _cycle);\n    }\n    return _riskTakenInCycle[_manager][_cycle];\n  }\n\n  function baseRiskStakeFallback(address _manager) public view returns (uint256) {\n    if (_baseRiskStakeFallback[_manager] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).baseRiskStakeFallback(_manager);\n    }\n    return _baseRiskStakeFallback[_manager];\n  }\n\n  function totalCommissionOfCycle(uint256 _cycle) public view returns (uint256) {\n    if (_totalCommissionOfCycle[_cycle] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).totalCommissionOfCycle(_cycle);\n    }\n    return _totalCommissionOfCycle[_cycle];\n  }\n\n  function managePhaseEndBlock(uint256 _cycle) public view returns (uint256) {\n    if (_managePhaseEndBlock[_cycle] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).managePhaseEndBlock(_cycle);\n    }\n    return _managePhaseEndBlock[_cycle];\n  }\n\n  function lastActiveCycle(address _manager) public view returns (uint256) {\n    if (_lastActiveCycle[_manager] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).lastActiveCycle(_manager);\n    }\n    return _lastActiveCycle[_manager];\n  }\n}\n\ninterface PositionToken {\n  function mintWithToken(\n    address receiver,\n    address depositTokenAddress,\n    uint256 depositAmount,\n    uint256 maxPriceAllowed)\n    external\n    returns (uint256);\n\n  function burnToToken(\n    address receiver,\n    address burnTokenAddress,\n    uint256 burnAmount,\n    uint256 minPriceAllowed)\n    external\n    returns (uint256);\n\n  function tokenPrice()\n   external\n   view\n   returns (uint256 price);\n\n  function liquidationPrice()\n   external\n   view\n   returns (uint256 price);\n\n  function currentLeverage()\n    external\n    view\n    returns (uint256 leverage);\n\n  function decimals()\n    external\n    view\n    returns (uint8);\n\n  function balanceOf(address account)\n    external\n    view\n    returns (uint256);\n}\n\ninterface Comptroller {\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n    function markets(address cToken) external view returns (bool isListed, uint256 collateralFactorMantissa);\n}\n\ninterface PriceOracle {\n  function getUnderlyingPrice(address cToken) external view returns (uint);\n}\n\ninterface CERC20 {\n  function mint(uint mintAmount) external returns (uint);\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function repayBorrow(uint repayAmount) external returns (uint);\n  function borrowBalanceCurrent(address account) external returns (uint);\n  function exchangeRateCurrent() external returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n  function decimals() external view returns (uint);\n  function underlying() external view returns (address);\n}\n\ninterface CEther {\n  function mint() external payable;\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function repayBorrow() external payable;\n  function borrowBalanceCurrent(address account) external returns (uint);\n  function exchangeRateCurrent() external returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n  function decimals() external view returns (uint);\n}\n\ncontract CompoundOrder is Utils(address(0), address(0), address(0)), Ownable {\n  \n  uint256 internal constant NEGLIGIBLE_DEBT = 10 ** 14; \n  uint256 internal constant MAX_REPAY_STEPS = 3; \n  uint256 internal constant DEFAULT_LIQUIDITY_SLIPPAGE = 10 ** 12; \n  uint256 internal constant FALLBACK_LIQUIDITY_SLIPPAGE = 10 ** 15; \n  uint256 internal constant MAX_LIQUIDITY_SLIPPAGE = 10 ** 17; \n\n  \n  Comptroller public COMPTROLLER; \n  PriceOracle public ORACLE; \n  CERC20 public CDAI; \n  address public CETH_ADDR;\n\n  \n  uint256 public stake;\n  uint256 public collateralAmountInDAI;\n  uint256 public loanAmountInDAI;\n  uint256 public cycleNumber;\n  uint256 public buyTime; \n  uint256 public outputAmount; \n  address public compoundTokenAddr;\n  bool public isSold;\n  bool public orderType; \n  bool internal initialized;\n\n\n  constructor() public {}\n\n  function init(\n    address _compoundTokenAddr,\n    uint256 _cycleNumber,\n    uint256 _stake,\n    uint256 _collateralAmountInDAI,\n    uint256 _loanAmountInDAI,\n    bool _orderType,\n    address _daiAddr,\n    address payable _kyberAddr,\n    address _comptrollerAddr,\n    address _priceOracleAddr,\n    address _cDAIAddr,\n    address _cETHAddr\n  ) public {\n    require(!initialized);\n    initialized = true;\n    \n    \n    require(_compoundTokenAddr != _cDAIAddr);\n    require(_stake > 0 && _collateralAmountInDAI > 0 && _loanAmountInDAI > 0); \n    stake = _stake;\n    collateralAmountInDAI = _collateralAmountInDAI;\n    loanAmountInDAI = _loanAmountInDAI;\n    cycleNumber = _cycleNumber;\n    compoundTokenAddr = _compoundTokenAddr;\n    orderType = _orderType;\n\n    COMPTROLLER = Comptroller(_comptrollerAddr);\n    ORACLE = PriceOracle(_priceOracleAddr);\n    CDAI = CERC20(_cDAIAddr);\n    CETH_ADDR = _cETHAddr;\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    dai = ERC20Detailed(_daiAddr);\n    kyber = KyberNetwork(_kyberAddr);\n\n    \n    _transferOwnership(msg.sender);\n  }\n\n  \n  function executeOrder(uint256 _minPrice, uint256 _maxPrice) public;\n\n  \n  function sellOrder(uint256 _minPrice, uint256 _maxPrice) public returns (uint256 _inputAmount, uint256 _outputAmount);\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public;\n\n  function getMarketCollateralFactor() public view returns (uint256);\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount);\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount);\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount);\n\n  \n  function getCurrentProfitInDAI() public returns (bool _isNegative, uint256 _amount) {\n    uint256 l;\n    uint256 r;\n    if (isSold) {\n      l = outputAmount;\n      r = collateralAmountInDAI;\n    } else {\n      uint256 cash = getCurrentCashInDAI();\n      uint256 supply = getCurrentCollateralInDAI();\n      uint256 borrow = getCurrentBorrowInDAI();\n      if (cash >= borrow) {\n        l = supply.add(cash);\n        r = borrow.add(collateralAmountInDAI);\n      } else {\n        l = supply;\n        r = borrow.sub(cash).mul(PRECISION).div(getMarketCollateralFactor()).add(collateralAmountInDAI);\n      }\n    }\n    \n    if (l >= r) {\n      return (false, l.sub(r));\n    } else {\n      return (true, r.sub(l));\n    }\n  }\n\n  \n  function getCurrentCollateralRatioInDAI() public returns (uint256 _amount) {\n    uint256 supply = getCurrentCollateralInDAI();\n    uint256 borrow = getCurrentBorrowInDAI();\n    if (borrow == 0) {\n      return uint256(-1);\n    }\n    return supply.mul(PRECISION).div(borrow);\n  }\n\n  \n  function getCurrentLiquidityInDAI() public returns (bool _isNegative, uint256 _amount) {\n    uint256 supply = getCurrentCollateralInDAI();\n    uint256 borrow = getCurrentBorrowInDAI().mul(PRECISION).div(getMarketCollateralFactor());\n    if (supply >= borrow) {\n      return (false, supply.sub(borrow));\n    } else {\n      return (true, borrow.sub(supply));\n    }\n  }\n\n  function __sellDAIForToken(uint256 _daiAmount) internal returns (uint256 _actualDAIAmount, uint256 _actualTokenAmount) {\n    ERC20Detailed t = __underlyingToken(compoundTokenAddr);\n    (,, _actualTokenAmount, _actualDAIAmount) = __kyberTrade(dai, _daiAmount, t); \n    require(_actualDAIAmount > 0 && _actualTokenAmount > 0); \n  }\n\n  function __sellTokenForDAI(uint256 _tokenAmount) internal returns (uint256 _actualDAIAmount, uint256 _actualTokenAmount) {\n    ERC20Detailed t = __underlyingToken(compoundTokenAddr);\n    (,, _actualDAIAmount, _actualTokenAmount) = __kyberTrade(t, _tokenAmount, dai); \n    require(_actualDAIAmount > 0 && _actualTokenAmount > 0); \n  }\n\n  \n  function __daiToToken(address _cToken, uint256 _daiAmount) internal view returns (uint256) {\n    if (_cToken == CETH_ADDR) {\n      \n      return _daiAmount.mul(ORACLE.getUnderlyingPrice(address(CDAI))).div(PRECISION);\n    }\n    ERC20Detailed t = __underlyingToken(_cToken);\n    return _daiAmount.mul(ORACLE.getUnderlyingPrice(address(CDAI))).mul(10 ** getDecimals(t)).div(ORACLE.getUnderlyingPrice(_cToken).mul(PRECISION));\n  }\n\n  \n  function __tokenToDAI(address _cToken, uint256 _tokenAmount) internal view returns (uint256) {\n    if (_cToken == CETH_ADDR) {\n      \n      return _tokenAmount.mul(PRECISION).div(ORACLE.getUnderlyingPrice(address(CDAI)));\n    }\n    ERC20Detailed t = __underlyingToken(_cToken);\n    return _tokenAmount.mul(ORACLE.getUnderlyingPrice(_cToken)).mul(PRECISION).div(ORACLE.getUnderlyingPrice(address(CDAI)).mul(10 ** uint256(t.decimals())));\n  }\n\n  function __underlyingToken(address _cToken) internal view returns (ERC20Detailed) {\n    if (_cToken == CETH_ADDR) {\n      \n      return ETH_TOKEN_ADDRESS;\n    }\n    CERC20 ct = CERC20(_cToken);\n    address underlyingToken = ct.underlying();\n    ERC20Detailed t = ERC20Detailed(underlyingToken);\n    return t;\n  }\n\n  function() external payable {}\n}\n\ncontract LongCERC20Order is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = ORACLE.getUnderlyingPrice(compoundTokenAddr); \n    require(tokenPrice > 0); \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(collateralAmountInDAI);\n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    token.safeApprove(compoundTokenAddr, 0); \n    token.safeApprove(compoundTokenAddr, actualTokenAmount); \n    require(market.mint(actualTokenAmount) == 0); \n    token.safeApprove(compoundTokenAddr, 0); \n    require(CDAI.borrow(loanAmountInDAI) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    __sellDAIForToken(loanAmountInDAI);\n\n    \n    if (dai.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = dai.balanceOf(address(this));\n      dai.safeApprove(address(CDAI), 0);\n      dai.safeApprove(address(CDAI), repayAmount);\n      require(CDAI.repayBorrow(repayAmount) == 0);\n      dai.safeApprove(address(CDAI), 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n    \n    \n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        liquidity = __daiToToken(compoundTokenAddr, liquidity);\n        uint256 errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            market.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    __sellTokenForDAI(token.balanceOf(address(this)));\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n    token.safeTransfer(owner(), token.balanceOf(address(this))); \n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    uint256 repayAmountInToken = __daiToToken(compoundTokenAddr, _repayAmountInDAI);\n    (uint256 actualDAIAmount,) = __sellTokenForDAI(repayAmountInToken);\n    \n    \n    uint256 currentDebt = CDAI.borrowBalanceCurrent(address(this));\n    if (actualDAIAmount > currentDebt) {\n      actualDAIAmount = currentDebt;\n    }\n    \n    \n    dai.safeApprove(address(CDAI), 0);\n    dai.safeApprove(address(CDAI), actualDAIAmount);\n    require(CDAI.repayBorrow(actualDAIAmount) == 0);\n    dai.safeApprove(address(CDAI), 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(compoundTokenAddr));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 supply = __tokenToDAI(compoundTokenAddr, market.balanceOf(address(this)).mul(market.exchangeRateCurrent()).div(PRECISION));\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    uint256 borrow = CDAI.borrowBalanceCurrent(address(this));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    uint256 cash = __tokenToDAI(compoundTokenAddr, getBalance(token, address(this)));\n    return cash;\n  }\n}\n\ncontract LongCEtherOrder is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = PRECISION; \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n    \n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(collateralAmountInDAI);\n\n    \n    CEther market = CEther(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n    \n    \n    market.mint.value(actualTokenAmount)(); \n    require(CDAI.borrow(loanAmountInDAI) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    __sellDAIForToken(loanAmountInDAI);\n\n    \n    if (dai.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = dai.balanceOf(address(this));\n      dai.safeApprove(address(CDAI), 0);\n      dai.safeApprove(address(CDAI), repayAmount);\n      require(CDAI.repayBorrow(repayAmount) == 0);\n      dai.safeApprove(address(CDAI), 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    CEther market = CEther(compoundTokenAddr);\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        liquidity = __daiToToken(compoundTokenAddr, liquidity);\n        uint256 errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            market.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    __sellTokenForDAI(address(this).balance);\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n    toPayableAddr(owner()).transfer(address(this).balance); \n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    uint256 repayAmountInToken = __daiToToken(compoundTokenAddr, _repayAmountInDAI);\n    (uint256 actualDAIAmount,) = __sellTokenForDAI(repayAmountInToken);\n    \n    \n    uint256 currentDebt = CDAI.borrowBalanceCurrent(address(this));\n    if (actualDAIAmount > currentDebt) {\n      actualDAIAmount = currentDebt;\n    }\n\n    \n    dai.safeApprove(address(CDAI), 0);\n    dai.safeApprove(address(CDAI), actualDAIAmount);\n    require(CDAI.repayBorrow(actualDAIAmount) == 0);\n    dai.safeApprove(address(CDAI), 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(compoundTokenAddr));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    CEther market = CEther(compoundTokenAddr);\n    uint256 supply = __tokenToDAI(compoundTokenAddr, market.balanceOf(address(this)).mul(market.exchangeRateCurrent()).div(PRECISION));\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    uint256 borrow = CDAI.borrowBalanceCurrent(address(this));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    uint256 cash = __tokenToDAI(compoundTokenAddr, getBalance(token, address(this)));\n    return cash;\n  }\n}\n\ncontract ShortCERC20Order is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = ORACLE.getUnderlyingPrice(compoundTokenAddr); \n    require(tokenPrice > 0); \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n    \n    \n    uint256 loanAmountInToken = __daiToToken(compoundTokenAddr, loanAmountInDAI);\n    dai.safeApprove(address(CDAI), 0); \n    dai.safeApprove(address(CDAI), collateralAmountInDAI); \n    require(CDAI.mint(collateralAmountInDAI) == 0); \n    dai.safeApprove(address(CDAI), 0);\n    require(market.borrow(loanAmountInToken) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    (uint256 actualDAIAmount,) = __sellTokenForDAI(loanAmountInToken);\n    loanAmountInDAI = actualDAIAmount; \n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    if (token.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = token.balanceOf(address(this));\n      token.safeApprove(compoundTokenAddr, 0);\n      token.safeApprove(compoundTokenAddr, repayAmount);\n      require(market.repayBorrow(repayAmount) == 0);\n      token.safeApprove(compoundTokenAddr, 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        uint256 errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(_repayAmountInDAI);\n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 currentDebt = market.borrowBalanceCurrent(address(this));\n    if (actualTokenAmount > currentDebt) {\n      actualTokenAmount = currentDebt;\n    }\n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    token.safeApprove(compoundTokenAddr, 0);\n    token.safeApprove(compoundTokenAddr, actualTokenAmount);\n    require(market.repayBorrow(actualTokenAmount) == 0);\n    token.safeApprove(compoundTokenAddr, 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(CDAI));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    uint256 supply = CDAI.balanceOf(address(this)).mul(CDAI.exchangeRateCurrent()).div(PRECISION);\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 borrow = __tokenToDAI(compoundTokenAddr, market.borrowBalanceCurrent(address(this)));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    uint256 cash = getBalance(dai, address(this));\n    return cash;\n  }\n}\n\ncontract ShortCEtherOrder is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = PRECISION; \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n    \n    \n    CEther market = CEther(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n\n    \n    uint256 loanAmountInToken = __daiToToken(compoundTokenAddr, loanAmountInDAI);\n    dai.safeApprove(address(CDAI), 0); \n    dai.safeApprove(address(CDAI), collateralAmountInDAI); \n    require(CDAI.mint(collateralAmountInDAI) == 0); \n    dai.safeApprove(address(CDAI), 0);\n    require(market.borrow(loanAmountInToken) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    (uint256 actualDAIAmount,) = __sellTokenForDAI(loanAmountInToken);\n    loanAmountInDAI = actualDAIAmount; \n\n    \n    if (address(this).balance > 0) {\n      uint256 repayAmount = address(this).balance;\n      market.repayBorrow.value(repayAmount)();\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        uint256 errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(_repayAmountInDAI);\n\n    \n    CEther market = CEther(compoundTokenAddr);\n    uint256 currentDebt = market.borrowBalanceCurrent(address(this));\n    if (actualTokenAmount > currentDebt) {\n      actualTokenAmount = currentDebt;\n    }\n\n    \n    market.repayBorrow.value(actualTokenAmount)();\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(CDAI));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    uint256 supply = CDAI.balanceOf(address(this)).mul(CDAI.exchangeRateCurrent()).div(PRECISION);\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    CEther market = CEther(compoundTokenAddr);\n    uint256 borrow = __tokenToDAI(compoundTokenAddr, market.borrowBalanceCurrent(address(this)));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    uint256 cash = getBalance(dai, address(this));\n    return cash;\n  }\n}\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), targetBytes)\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}\n\ncontract CompoundOrderFactory is CloneFactory {\n  address public SHORT_CERC20_LOGIC_CONTRACT;\n  address public SHORT_CEther_LOGIC_CONTRACT;\n  address public LONG_CERC20_LOGIC_CONTRACT;\n  address public LONG_CEther_LOGIC_CONTRACT;\n\n  address public DAI_ADDR;\n  address payable public KYBER_ADDR;\n  address public COMPTROLLER_ADDR;\n  address public ORACLE_ADDR;\n  address public CDAI_ADDR;\n  address public CETH_ADDR;\n\n  constructor(\n    address _shortCERC20LogicContract,\n    address _shortCEtherLogicContract,\n    address _longCERC20LogicContract,\n    address _longCEtherLogicContract,\n    address _daiAddr,\n    address payable _kyberAddr,\n    address _comptrollerAddr,\n    address _priceOracleAddr,\n    address _cDAIAddr,\n    address _cETHAddr\n  ) public {\n    SHORT_CERC20_LOGIC_CONTRACT = _shortCERC20LogicContract;\n    SHORT_CEther_LOGIC_CONTRACT = _shortCEtherLogicContract;\n    LONG_CERC20_LOGIC_CONTRACT = _longCERC20LogicContract;\n    LONG_CEther_LOGIC_CONTRACT = _longCEtherLogicContract;\n\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    COMPTROLLER_ADDR = _comptrollerAddr;\n    ORACLE_ADDR = _priceOracleAddr;\n    CDAI_ADDR = _cDAIAddr;\n    CETH_ADDR = _cETHAddr;\n  }\n\n  function createOrder(\n    address _compoundTokenAddr,\n    uint256 _cycleNumber,\n    uint256 _stake,\n    uint256 _collateralAmountInDAI,\n    uint256 _loanAmountInDAI,\n    bool _orderType\n  ) external returns (CompoundOrder) {\n    require(_compoundTokenAddr != address(0));\n\n    CompoundOrder order;\n\n    address payable clone;\n    if (_compoundTokenAddr != CETH_ADDR) {\n      if (_orderType) {\n        \n        clone = toPayableAddr(createClone(SHORT_CERC20_LOGIC_CONTRACT));\n      } else {\n        \n        clone = toPayableAddr(createClone(LONG_CERC20_LOGIC_CONTRACT));\n      }\n    } else {\n      if (_orderType) {\n        \n        clone = toPayableAddr(createClone(SHORT_CEther_LOGIC_CONTRACT));\n      } else {\n        \n        clone = toPayableAddr(createClone(LONG_CEther_LOGIC_CONTRACT));\n      }\n    }\n    order = CompoundOrder(clone);\n    order.init(_compoundTokenAddr, _cycleNumber, _stake, _collateralAmountInDAI, _loanAmountInDAI, _orderType,\n      DAI_ADDR, KYBER_ADDR, COMPTROLLER_ADDR, ORACLE_ADDR, CDAI_ADDR, CETH_ADDR);\n    order.transferOwnership(msg.sender);\n    return order;\n  }\n\n  function getMarketCollateralFactor(address _compoundTokenAddr) external view returns (uint256) {\n    Comptroller troll = Comptroller(COMPTROLLER_ADDR);\n    (, uint256 factor) = troll.markets(_compoundTokenAddr);\n    return factor;\n  }\n\n  function tokenIsListed(address _compoundTokenAddr) external view returns (bool) {\n    Comptroller troll = Comptroller(COMPTROLLER_ADDR);\n    (bool isListed,) = troll.markets(_compoundTokenAddr);\n    return isListed;\n  }\n\n  function toPayableAddr(address _addr) internal pure returns (address payable) {\n    return address(uint160(_addr));\n  }\n}\n\ncontract BetokenLogic is BetokenStorage, Utils(address(0), address(0), address(0)) {\n  \n  modifier during(CyclePhase phase) {\n    require(cyclePhase == phase);\n    if (cyclePhase == CyclePhase.Intermission) {\n      require(isInitialized);\n    }\n    _;\n  }\n\n  \n  function investmentsCount(address _userAddr) public view returns(uint256 _count) {\n    return userInvestments[_userAddr].length;\n  }\n\n  \n  function burnDeadman(address _deadman)\n    public\n    nonReentrant\n    during(CyclePhase.Intermission)\n  {\n    require(_deadman != address(this));\n    require(cycleNumber.sub(lastActiveCycle(_deadman)) > INACTIVE_THRESHOLD);\n    require(cToken.destroyTokens(_deadman, cToken.balanceOf(_deadman)));\n  }\n\n  \n  function createInvestment(\n    address _tokenAddress,\n    uint256 _stake,\n    uint256 _minPrice,\n    uint256 _maxPrice\n  )\n    public\n  {\n    bytes memory nil;\n    createInvestmentV2(\n      _tokenAddress,\n      _stake,\n      _minPrice,\n      _maxPrice,\n      nil,\n      true\n    );\n  }\n\n  \n  function sellInvestmentAsset(\n    uint256 _investmentId,\n    uint256 _tokenAmount,\n    uint256 _minPrice,\n    uint256 _maxPrice\n  )\n    public\n  {\n    bytes memory nil;\n    sellInvestmentAssetV2(\n      _investmentId,\n      _tokenAmount,\n      _minPrice,\n      _maxPrice,\n      nil,\n      true\n    );\n  }\n\n  \n  function createInvestmentV2(\n    address _tokenAddress,\n    uint256 _stake,\n    uint256 _minPrice,\n    uint256 _maxPrice,\n    bytes memory _calldata,\n    bool _useKyber\n  )\n    public\n    during(CyclePhase.Manage)\n    nonReentrant\n    isValidToken(_tokenAddress)\n  {\n    require(_minPrice <= _maxPrice);\n    require(_stake > 0);\n    require(isKyberToken[_tokenAddress] || isPositionToken[_tokenAddress]);\n\n    \n    require(cToken.generateTokens(address(this), _stake));\n    require(cToken.destroyTokens(msg.sender, _stake));\n\n    \n    userInvestments[msg.sender].push(Investment({\n      tokenAddress: _tokenAddress,\n      cycleNumber: cycleNumber,\n      stake: _stake,\n      tokenAmount: 0,\n      buyPrice: 0,\n      sellPrice: 0,\n      buyTime: now,\n      buyCostInDAI: 0,\n      isSold: false\n    }));\n\n    \n    uint256 investmentId = investmentsCount(msg.sender).sub(1);\n    (, uint256 actualSrcAmount) = __handleInvestment(investmentId, _minPrice, _maxPrice, true, _calldata, _useKyber);\n\n    \n    _lastActiveCycle[msg.sender] = cycleNumber;\n\n    \n    __emitCreatedInvestmentEvent(investmentId);\n  }\n\n  \n  function sellInvestmentAssetV2(\n    uint256 _investmentId,\n    uint256 _tokenAmount,\n    uint256 _minPrice,\n    uint256 _maxPrice,\n    bytes memory _calldata,\n    bool _useKyber\n  )\n    public\n    during(CyclePhase.Manage)\n    nonReentrant\n  {\n    Investment storage investment = userInvestments[msg.sender][_investmentId];\n    require(investment.buyPrice > 0 && investment.cycleNumber == cycleNumber && !investment.isSold);\n    require(_tokenAmount > 0 && _tokenAmount <= investment.tokenAmount);\n    require(_minPrice <= _maxPrice);\n\n    \n    bool isPartialSell = false;\n    uint256 stakeOfSoldTokens = investment.stake.mul(_tokenAmount).div(investment.tokenAmount);\n    if (_tokenAmount != investment.tokenAmount) {\n      isPartialSell = true;\n\n      __createInvestmentForLeftovers(_investmentId, _tokenAmount);\n    }\n    \n    \n    investment.isSold = true;\n\n    \n    (uint256 actualDestAmount, uint256 actualSrcAmount) = __handleInvestment(_investmentId, _minPrice, _maxPrice, false, _calldata, _useKyber);\n    if (isPartialSell) {\n      \n      userInvestments[msg.sender][investmentsCount(msg.sender).sub(1)].tokenAmount = userInvestments[msg.sender][investmentsCount(msg.sender).sub(1)].tokenAmount.add(_tokenAmount.sub(actualSrcAmount));\n    }\n\n    \n    uint256 receiveKairoAmount = getReceiveKairoAmount(stakeOfSoldTokens, investment.sellPrice, investment.buyPrice);\n    __returnStake(receiveKairoAmount, stakeOfSoldTokens);\n\n    \n    __recordRisk(investment.stake, investment.buyTime);\n\n    \n    totalFundsInDAI = totalFundsInDAI.sub(investment.buyCostInDAI).add(actualDestAmount);\n    \n    \n    if (isPartialSell) {\n      __emitCreatedInvestmentEvent(investmentsCount(msg.sender).sub(1));\n    }\n    __emitSoldInvestmentEvent(_investmentId, receiveKairoAmount, actualDestAmount);\n  }\n\n  function __emitSoldInvestmentEvent(uint256 _investmentId, uint256 _receiveKairoAmount, uint256 _actualDestAmount) internal {\n    Investment storage investment = userInvestments[msg.sender][_investmentId];\n    emit SoldInvestment(cycleNumber, msg.sender, _investmentId, investment.tokenAddress, _receiveKairoAmount, investment.sellPrice, _actualDestAmount);\n  }\n\n  function __createInvestmentForLeftovers(uint256 _investmentId, uint256 _tokenAmount) internal {\n    Investment storage investment = userInvestments[msg.sender][_investmentId];\n\n    uint256 stakeOfSoldTokens = investment.stake.mul(_tokenAmount).div(investment.tokenAmount);\n\n    \n    uint256 soldBuyCostInDAI = investment.buyCostInDAI.mul(_tokenAmount).div(investment.tokenAmount);\n\n    userInvestments[msg.sender].push(Investment({\n      tokenAddress: investment.tokenAddress,\n      cycleNumber: cycleNumber,\n      stake: investment.stake.sub(stakeOfSoldTokens),\n      tokenAmount: investment.tokenAmount.sub(_tokenAmount),\n      buyPrice: investment.buyPrice,\n      sellPrice: 0,\n      buyTime: investment.buyTime,\n      buyCostInDAI: investment.buyCostInDAI.sub(soldBuyCostInDAI),\n      isSold: false\n    }));\n\n    \n    investment.tokenAmount = _tokenAmount;\n    investment.stake = stakeOfSoldTokens;\n    investment.buyCostInDAI = soldBuyCostInDAI;\n  }\n\n  function __emitCreatedInvestmentEvent(uint256 _id) internal {\n    Investment storage investment = userInvestments[msg.sender][_id];\n    emit CreatedInvestment(\n      cycleNumber, msg.sender, _id,\n      investment.tokenAddress, investment.stake, investment.buyPrice,\n      investment.buyCostInDAI, investment.tokenAmount);\n  }\n\n  \n  function createCompoundOrder(\n    bool _orderType,\n    address _tokenAddress,\n    uint256 _stake,\n    uint256 _minPrice,\n    uint256 _maxPrice\n  )\n    public\n    during(CyclePhase.Manage)\n    nonReentrant\n    isValidToken(_tokenAddress)\n  {\n    require(_minPrice <= _maxPrice);\n    require(_stake > 0);\n    require(isCompoundToken[_tokenAddress]);\n\n    \n    require(cToken.generateTokens(address(this), _stake));\n    require(cToken.destroyTokens(msg.sender, _stake));\n\n    \n    uint256 collateralAmountInDAI = totalFundsInDAI.mul(_stake).div(cToken.totalSupply());\n    CompoundOrder order = __createCompoundOrder(_orderType, _tokenAddress, _stake, collateralAmountInDAI);\n    dai.safeApprove(address(order), 0);\n    dai.safeApprove(address(order), collateralAmountInDAI);\n    order.executeOrder(_minPrice, _maxPrice);\n\n    \n    userCompoundOrders[msg.sender].push(address(order));\n\n    \n    _lastActiveCycle[msg.sender] = cycleNumber;\n\n    \n    emit CreatedCompoundOrder(cycleNumber, msg.sender, userCompoundOrders[msg.sender].length - 1, address(order), _orderType, _tokenAddress, _stake, collateralAmountInDAI);\n  }\n\n  \n  function sellCompoundOrder(\n    uint256 _orderId,\n    uint256 _minPrice,\n    uint256 _maxPrice\n  )\n    public\n    during(CyclePhase.Manage)\n    nonReentrant\n  {\n    \n    require(userCompoundOrders[msg.sender][_orderId] != address(0));\n    CompoundOrder order = CompoundOrder(userCompoundOrders[msg.sender][_orderId]);\n    require(order.isSold() == false && order.cycleNumber() == cycleNumber);\n\n    \n    (uint256 inputAmount, uint256 outputAmount) = order.sellOrder(_minPrice, _maxPrice);\n\n    \n    uint256 stake = order.stake();\n    uint256 receiveKairoAmount = getReceiveKairoAmount(stake, outputAmount, inputAmount);\n    __returnStake(receiveKairoAmount, stake);\n\n    \n    __recordRisk(stake, order.buyTime());\n\n    \n    totalFundsInDAI = totalFundsInDAI.sub(inputAmount).add(outputAmount);\n\n    \n    emit SoldCompoundOrder(cycleNumber, msg.sender, userCompoundOrders[msg.sender].length - 1, address(order), order.orderType(), order.compoundTokenAddr(), receiveKairoAmount, outputAmount);\n  }\n\n  \n  function repayCompoundOrder(uint256 _orderId, uint256 _repayAmountInDAI) public during(CyclePhase.Manage) nonReentrant {\n    \n    require(userCompoundOrders[msg.sender][_orderId] != address(0));\n    CompoundOrder order = CompoundOrder(userCompoundOrders[msg.sender][_orderId]);\n    require(order.isSold() == false && order.cycleNumber() == cycleNumber);\n\n    \n    order.repayLoan(_repayAmountInDAI);\n\n    \n    emit RepaidCompoundOrder(cycleNumber, msg.sender, userCompoundOrders[msg.sender].length - 1, address(order), _repayAmountInDAI);\n  }\n\n  function getReceiveKairoAmount(uint256 stake, uint256 output, uint256 input) public view returns(uint256 _amount) {\n    if (output >= input) {\n      \n      return stake.mul(output).div(input);\n    } else {\n      \n      uint256 absROI = input.sub(output).mul(PRECISION).div(input);\n      if (absROI <= ROI_PUNISH_THRESHOLD) {\n        \n        return stake.mul(output).div(input);\n      } else if (absROI > ROI_PUNISH_THRESHOLD && absROI < ROI_BURN_THRESHOLD) {\n        \n        \n        return stake.mul(PRECISION.sub(ROI_PUNISH_SLOPE.mul(absROI).sub(ROI_PUNISH_NEG_BIAS))).div(PRECISION);\n      } else {\n        \n        return 0;\n      }\n    }\n  }\n\n  \n  function commissionBalanceOf(address _manager) public view returns (uint256 _commission, uint256 _penalty) {\n    if (lastCommissionRedemption(_manager) >= cycleNumber) { return (0, 0); }\n    uint256 cycle = lastCommissionRedemption(_manager) > 0 ? lastCommissionRedemption(_manager) : 1;\n    uint256 cycleCommission;\n    uint256 cyclePenalty;\n    for (; cycle < cycleNumber; cycle = cycle.add(1)) {\n      (cycleCommission, cyclePenalty) = commissionOfAt(_manager, cycle);\n      _commission = _commission.add(cycleCommission);\n      _penalty = _penalty.add(cyclePenalty);\n    }\n  }\n\n  \n  function commissionOfAt(address _manager, uint256 _cycle) public view returns (uint256 _commission, uint256 _penalty) {\n    if (hasRedeemedCommissionForCycle(_manager, _cycle)) { return (0, 0); }\n    \n    uint256 baseKairoBalance = cToken.balanceOfAt(_manager, managePhaseEndBlock(_cycle.sub(1)));\n    uint256 baseStake = baseKairoBalance == 0 ? baseRiskStakeFallback(_manager) : baseKairoBalance;\n    if (baseKairoBalance == 0 && baseRiskStakeFallback(_manager) == 0) { return (0, 0); }\n    uint256 riskTakenProportion = riskTakenInCycle(_manager, _cycle).mul(PRECISION).div(baseStake.mul(MIN_RISK_TIME)); \n    riskTakenProportion = riskTakenProportion > PRECISION ? PRECISION : riskTakenProportion; \n\n    uint256 fullCommission = totalCommissionOfCycle(_cycle).mul(cToken.balanceOfAt(_manager, managePhaseEndBlock(_cycle)))\n      .div(cToken.totalSupplyAt(managePhaseEndBlock(_cycle)));\n\n    _commission = fullCommission.mul(riskTakenProportion).div(PRECISION);\n    _penalty = fullCommission.sub(_commission);\n  }\n\n  \n  function redeemCommission(bool _inShares)\n    public\n    during(CyclePhase.Intermission)\n    nonReentrant\n  {\n    uint256 commission = __redeemCommission();\n\n    if (_inShares) {\n      \n      __deposit(commission);\n\n      \n      emit Deposit(cycleNumber, msg.sender, DAI_ADDR, commission, commission, now);\n    } else {\n      \n      dai.safeTransfer(msg.sender, commission);\n    }\n  }\n\n  \n  function redeemCommissionForCycle(bool _inShares, uint256 _cycle)\n    public\n    during(CyclePhase.Intermission)\n    nonReentrant\n  {\n    require(_cycle < cycleNumber);\n\n    uint256 commission = __redeemCommissionForCycle(_cycle);\n\n    if (_inShares) {\n      \n      __deposit(commission);\n\n      \n      emit Deposit(cycleNumber, msg.sender, DAI_ADDR, commission, commission, now);\n    } else {\n      \n      dai.safeTransfer(msg.sender, commission);\n    }\n  }\n\n  \n  function __handleInvestment(uint256 _investmentId, uint256 _minPrice, uint256 _maxPrice, bool _buy, bytes memory _calldata, bool _useKyber)\n    public\n    returns (uint256 _actualDestAmount, uint256 _actualSrcAmount)\n  {\n    Investment storage investment = userInvestments[msg.sender][_investmentId];\n    address token = investment.tokenAddress;\n    if (isPositionToken[token]) {\n      \n      PositionToken pToken = PositionToken(token);\n      uint256 beforeBalance;\n      if (_buy) {\n        _actualSrcAmount = totalFundsInDAI.mul(investment.stake).div(cToken.totalSupply());\n        dai.safeApprove(token, 0);\n        dai.safeApprove(token, _actualSrcAmount);\n        beforeBalance = pToken.balanceOf(address(this));\n        pToken.mintWithToken(address(this), DAI_ADDR, _actualSrcAmount, 0);\n        _actualDestAmount = pToken.balanceOf(address(this)).sub(beforeBalance);\n        require(_actualDestAmount > 0);\n        dai.safeApprove(token, 0);\n\n        investment.buyPrice = calcRateFromQty(_actualDestAmount, _actualSrcAmount, pToken.decimals(), dai.decimals()); \n        require(_minPrice <= investment.buyPrice && investment.buyPrice <= _maxPrice);\n\n        investment.tokenAmount = _actualDestAmount;\n        investment.buyCostInDAI = _actualSrcAmount;\n      } else {\n        _actualSrcAmount = investment.tokenAmount;\n        beforeBalance = dai.balanceOf(address(this));\n        pToken.burnToToken(address(this), DAI_ADDR, _actualSrcAmount, 0);\n        _actualDestAmount = dai.balanceOf(address(this)).sub(beforeBalance);\n\n        investment.sellPrice = calcRateFromQty(_actualSrcAmount, _actualDestAmount, pToken.decimals(), dai.decimals()); \n        require(_minPrice <= investment.sellPrice && investment.sellPrice <= _maxPrice);\n      }\n    } else {\n      \n      uint256 dInS; \n      uint256 sInD; \n      if (_buy) {\n        if (_useKyber) {\n          (dInS, sInD, _actualDestAmount, _actualSrcAmount) = __kyberTrade(dai, totalFundsInDAI.mul(investment.stake).div(cToken.totalSupply()), ERC20Detailed(token));\n        } else {\n          \n          (dInS, sInD, _actualDestAmount, _actualSrcAmount) = __dexagTrade(dai, totalFundsInDAI.mul(investment.stake).div(cToken.totalSupply()), ERC20Detailed(token), _calldata);\n        }\n        require(_minPrice <= dInS && dInS <= _maxPrice);\n        investment.buyPrice = dInS;\n        investment.tokenAmount = _actualDestAmount;\n        investment.buyCostInDAI = _actualSrcAmount;\n      } else {\n        if (_useKyber) {\n          (dInS, sInD, _actualDestAmount, _actualSrcAmount) = __kyberTrade(ERC20Detailed(token), investment.tokenAmount, dai);\n        } else {\n          (dInS, sInD, _actualDestAmount, _actualSrcAmount) = __dexagTrade(ERC20Detailed(token), investment.tokenAmount, dai, _calldata);\n        }\n        \n        require(_minPrice <= sInD && sInD <= _maxPrice);\n        investment.sellPrice = sInD;\n      }\n    }\n  }\n\n  \n  function __createCompoundOrder(\n    bool _orderType, \n    address _tokenAddress,\n    uint256 _stake,\n    uint256 _collateralAmountInDAI\n  ) internal returns (CompoundOrder) {\n    CompoundOrderFactory factory = CompoundOrderFactory(compoundFactoryAddr);\n    uint256 loanAmountInDAI = _collateralAmountInDAI.mul(COLLATERAL_RATIO_MODIFIER).div(PRECISION).mul(factory.getMarketCollateralFactor(_tokenAddress)).div(PRECISION);\n    CompoundOrder order = factory.createOrder(\n      _tokenAddress,\n      cycleNumber,\n      _stake,\n      _collateralAmountInDAI,\n      loanAmountInDAI,\n      _orderType\n    );\n    return order;\n  }\n\n  \n  function __returnStake(uint256 _receiveKairoAmount, uint256 _stake) internal {\n    require(cToken.destroyTokens(address(this), _stake));\n    require(cToken.generateTokens(msg.sender, _receiveKairoAmount));\n  }\n\n  \n  function __recordRisk(uint256 _stake, uint256 _buyTime) internal {\n    _riskTakenInCycle[msg.sender][cycleNumber] = riskTakenInCycle(msg.sender, cycleNumber).add(_stake.mul(now.sub(_buyTime)));\n  }\n\n  \n  function __redeemCommission() internal returns (uint256 _commission) {\n    require(lastCommissionRedemption(msg.sender) < cycleNumber);\n\n    uint256 penalty; \n    (_commission, penalty) = commissionBalanceOf(msg.sender);\n\n    \n    for (uint256 i = lastCommissionRedemption(msg.sender); i < cycleNumber; i = i.add(1)) {\n      _hasRedeemedCommissionForCycle[msg.sender][i] = true;\n    }\n    _lastCommissionRedemption[msg.sender] = cycleNumber;\n\n    \n    totalCommissionLeft = totalCommissionLeft.sub(_commission);\n    \n    _totalCommissionOfCycle[cycleNumber] = totalCommissionOfCycle(cycleNumber).add(penalty);\n    \n    delete userInvestments[msg.sender];\n    delete userCompoundOrders[msg.sender];\n\n    emit CommissionPaid(cycleNumber, msg.sender, _commission);\n  }\n\n  \n  function __redeemCommissionForCycle(uint256 _cycle) internal returns (uint256 _commission) {\n    require(!hasRedeemedCommissionForCycle(msg.sender, _cycle));\n\n    uint256 penalty; \n    (_commission, penalty) = commissionOfAt(msg.sender, _cycle);\n\n    _hasRedeemedCommissionForCycle[msg.sender][_cycle] = true;\n\n    \n    totalCommissionLeft = totalCommissionLeft.sub(_commission);\n    \n    _totalCommissionOfCycle[cycleNumber] = totalCommissionOfCycle(cycleNumber).add(penalty);\n    \n    delete userInvestments[msg.sender];\n    delete userCompoundOrders[msg.sender];\n\n    emit CommissionPaid(_cycle, msg.sender, _commission);\n  }\n\n  \n  function __deposit(uint256 _depositDAIAmount) internal {\n    \n    if (sToken.totalSupply() == 0 || totalFundsInDAI == 0) {\n      require(sToken.generateTokens(msg.sender, _depositDAIAmount));\n    } else {\n      require(sToken.generateTokens(msg.sender, _depositDAIAmount.mul(sToken.totalSupply()).div(totalFundsInDAI)));\n    }\n    totalFundsInDAI = totalFundsInDAI.add(_depositDAIAmount);\n  }\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_newPhase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalFundsInDAI\",\"type\":\"uint256\"}],\"name\":\"ChangedPhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"}],\"name\":\"CommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_order\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_orderType\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeInWeis\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_costDAIAmount\",\"type\":\"uint256\"}],\"name\":\"CreatedCompoundOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeInWeis\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_buyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_costDAIAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"CreatedInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"DeveloperInitiatedUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nextVersion\",\"type\":\"address\"}],\"name\":\"FinalizedNextVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"}],\"name\":\"InitiatedUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_voteID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"ProposedCandidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_donationInDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_kairoReceived\",\"type\":\"uint256\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_order\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_repaidDAIAmount\",\"type\":\"uint256\"}],\"name\":\"RepaidCompoundOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"}],\"name\":\"SignaledUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_order\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_orderType\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_receivedKairo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_earnedDAIAmount\",\"type\":\"uint256\"}],\"name\":\"SoldCompoundOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_receivedKairo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sellPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_earnedDAIAmount\",\"type\":\"uint256\"}],\"name\":\"SoldInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalCommissionInDAI\",\"type\":\"uint256\"}],\"name\":\"TotalCommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_voteID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASSET_FEE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHUNK_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLLATERAL_RATIO_MODIFIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSION_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CYCLES_TILL_MATURITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEXAG_ADDR\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FALLBACK_MAX_DONATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INACTIVE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYBER_ADDR\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BUY_KRO_PROP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_KRO_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_RISK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEXT_PHASE_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERM_HINT\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROPOSE_SUBCHUNK_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUORUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_BURN_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_PUNISH_NEG_BIAS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_PUNISH_SLOPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_PUNISH_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOTE_SUCCESS_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_buy\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_useKyber\",\"type\":\"bool\"}],\"name\":\"__handleInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_actualDestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_actualSrcAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"againstVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"baseRiskStakeFallback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betokenLogic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betokenLogic2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deadman\",\"type\":\"address\"}],\"name\":\"burnDeadman\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"candidates\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"commissionBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_penalty\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"commissionOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_penalty\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compoundFactoryAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controlTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_orderType\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"createCompoundOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"createInvestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_useKyber\",\"type\":\"bool\"}],\"name\":\"createInvestmentV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentChunk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSubchunk\",\"outputs\":[{\"internalType\":\"enum BetokenStorage.Subchunk\",\"name\":\"_subchunk\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycleNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cyclePhase\",\"outputs\":[{\"internalType\":\"enum BetokenStorage.CyclePhase\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFundingAccount\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFundingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"name\":\"getReceiveKairoAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalVotingWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getVotingWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasFinalizedNextVersion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasInitializedTokenListings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"hasRedeemedCommissionForCycle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"investmentsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCompoundToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKyberToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPositionToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kairoPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_kairoPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"lastActiveCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"lastCommissionRedemption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"managePhaseEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"managerVotes\",\"outputs\":[{\"internalType\":\"enum BetokenStorage.VoteDirection\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextVersion\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phaseLengths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousVersion\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposersVotingWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyAddr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_inShares\",\"type\":\"bool\"}],\"name\":\"redeemCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_inShares\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"redeemCommissionForCycle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_repayAmountInDAI\",\"type\":\"uint256\"}],\"name\":\"repayCompoundOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"riskTakenInCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saiAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"sellCompoundOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"sellInvestmentAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_useKyber\",\"type\":\"bool\"}],\"name\":\"sellInvestmentAssetV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimeOfCyclePhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCommissionLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"totalCommissionOfCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFundsInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"upgradeSignal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"upgradeSignalStrength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeVotingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userCompoundOrders\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInvestments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyCostInDAI\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSold\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BetokenLogic","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://89c06801cffa2668f8821d6fc6abff563c77e035e29d9b360b5f1238c0d00e1c"}]}