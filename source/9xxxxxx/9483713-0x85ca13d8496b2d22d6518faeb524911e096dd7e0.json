{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title EIP20/ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract EIP20 is ERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n}\r\n\r\ncontract WETHInterface is EIP20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n  */\r\n  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return ((_a - 1) / _b) + 1;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n  /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n  uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n  /// @dev Constant for locked guard state\r\n  uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one `nonReentrant` function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and an `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n    reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n    _;\r\n    reentrancyLock = REENTRANCY_GUARD_FREE;\r\n  }\r\n\r\n}\r\n\r\ncontract LoanTokenization is ReentrancyGuard, Ownable {\r\n\r\n    uint256 internal constant MAX_UINT = 2**256 - 1;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public bZxContract;\r\n    address public bZxVault;\r\n    address public bZxOracle;\r\n    address public wethContract;\r\n\r\n    address public loanTokenAddress;\r\n\r\n    // price of token at last user checkpoint\r\n    mapping (address => uint256) internal checkpointPrices_;\r\n}\r\n\r\ncontract LoanTokenStorage is LoanTokenization {\r\n\r\n    struct ListIndex {\r\n        uint256 index;\r\n        bool isSet;\r\n    }\r\n\r\n    struct LoanData {\r\n        bytes32 loanOrderHash;\r\n        uint256 leverageAmount;\r\n        uint256 initialMarginAmount;\r\n        uint256 maintenanceMarginAmount;\r\n        uint256 maxDurationUnixTimestampSec;\r\n        uint256 index;\r\n        uint256 marginPremiumAmount;\r\n        address collateralTokenAddress;\r\n    }\r\n\r\n    struct TokenReserves {\r\n        address lender;\r\n        uint256 amount;\r\n    }\r\n\r\n    event Borrow(\r\n        address indexed borrower,\r\n        uint256 borrowAmount,\r\n        uint256 interestRate,\r\n        address collateralTokenAddress,\r\n        address tradeTokenToFillAddress,\r\n        bool withdrawOnOpen\r\n    );\r\n\r\n    event Repay(\r\n        bytes32 indexed loanOrderHash,\r\n        address indexed borrower,\r\n        address closer,\r\n        uint256 amount,\r\n        bool isLiquidation\r\n    );\r\n\r\n    event Claim(\r\n        address indexed claimant,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 remainingTokenAmount,\r\n        uint256 price\r\n    );\r\n\r\n    bool internal isInitialized_ = false;\r\n\r\n    address public tokenizedRegistry;\r\n\r\n    uint256 public baseRate = 1000000000000000000; // 1.0%\r\n    uint256 public rateMultiplier = 18750000000000000000; // 18.75%\r\n\r\n    // slot addition (non-sequential): lowUtilBaseRate = 8000000000000000000; // 8.0%\r\n    // slot addition (non-sequential): lowUtilRateMultiplier = 4750000000000000000; // 4.75%\r\n\r\n    // \"fee percentage retained by the oracle\" = SafeMath.sub(10**20, spreadMultiplier);\r\n    uint256 public spreadMultiplier;\r\n\r\n    mapping (uint256 => bytes32) public loanOrderHashes; // mapping of levergeAmount to loanOrderHash\r\n    mapping (bytes32 => LoanData) public loanOrderData; // mapping of loanOrderHash to LoanOrder\r\n    uint256[] public leverageList;\r\n\r\n    TokenReserves[] public burntTokenReserveList; // array of TokenReserves\r\n    mapping (address => ListIndex) public burntTokenReserveListIndex; // mapping of lender address to ListIndex objects\r\n    uint256 public burntTokenReserved; // total outstanding burnt token amount\r\n    address internal nextOwedLender_;\r\n\r\n    uint256 public totalAssetBorrow; // current amount of loan token amount tied up in loans\r\n\r\n    uint256 public checkpointSupply;\r\n\r\n    uint256 internal lastSettleTime_;\r\n\r\n    uint256 public initialPrice;\r\n}\r\n\r\ncontract AdvancedTokenStorage is LoanTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Mint(\r\n        address indexed minter,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n    event Burn(\r\n        address indexed burner,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint256 internal totalSupply_;\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract AdvancedToken is AdvancedTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n    {\r\n        require(_to != address(0), \"15\");\r\n        totalSupply_ = totalSupply_.add(_tokenAmount);\r\n        balances[_to] = balances[_to].add(_tokenAmount);\r\n\r\n        emit Mint(_to, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(address(0), _to, _tokenAmount);\r\n    }\r\n\r\n    function _burn(\r\n        address _who,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n    {\r\n        require(_tokenAmount <= balances[_who], \"16\");\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_who] = balances[_who].sub(_tokenAmount);\r\n        if (balances[_who] <= 10) { // we can't leave such small balance quantities\r\n            _tokenAmount = _tokenAmount.add(balances[_who]);\r\n            balances[_who] = 0;\r\n        }\r\n\r\n        totalSupply_ = totalSupply_.sub(_tokenAmount);\r\n\r\n        emit Burn(_who, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(_who, address(0), _tokenAmount);\r\n    }\r\n}\r\n\r\ncontract BZxObjects {\r\n\r\n    struct LoanOrder {\r\n        address loanTokenAddress;\r\n        address interestTokenAddress;\r\n        address collateralTokenAddress;\r\n        address oracleAddress;\r\n        uint256 loanTokenAmount;\r\n        uint256 interestAmount;\r\n        uint256 initialMarginAmount;\r\n        uint256 maintenanceMarginAmount;\r\n        uint256 maxDurationUnixTimestampSec;\r\n        bytes32 loanOrderHash;\r\n    }\r\n\r\n    struct LoanPosition {\r\n        address trader;\r\n        address collateralTokenAddressFilled;\r\n        address positionTokenAddressFilled;\r\n        uint256 loanTokenAmountFilled;\r\n        uint256 loanTokenAmountUsed;\r\n        uint256 collateralTokenAmountFilled;\r\n        uint256 positionTokenAmountFilled;\r\n        uint256 loanStartUnixTimestampSec;\r\n        uint256 loanEndUnixTimestampSec;\r\n        bool active;\r\n        uint256 positionId;\r\n    }\r\n}\r\n\r\ncontract OracleNotifierInterface {\r\n\r\n    function closeLoanNotifier(\r\n        BZxObjects.LoanOrder memory loanOrder,\r\n        BZxObjects.LoanPosition memory loanPosition,\r\n        address loanCloser,\r\n        uint256 closeAmount,\r\n        bool isLiquidation)\r\n        public\r\n        returns (bool);\r\n}\r\n\r\ninterface IBZx {\r\n    function takeOrderFromiToken(\r\n        bytes32 loanOrderHash, // existing loan order hash\r\n        address[4] calldata sentAddresses,\r\n            // trader: borrower/trader\r\n            // collateralTokenAddress: collateral token\r\n            // tradeTokenAddress: trade token\r\n            // receiver: receiver of funds (address(0) assumes trader address)\r\n        uint256[7] calldata sentAmounts,\r\n            // newInterestRate: new loan interest rate\r\n            // newLoanAmount: new loan size (principal from lender)\r\n            // interestInitialAmount: interestAmount sent to determine initial loan length (this is included in one of the below)\r\n            // loanTokenSent: loanTokenAmount + interestAmount + any extra\r\n            // collateralTokenSent: collateralAmountRequired + any extra\r\n            // tradeTokenSent: tradeTokenAmount (optional)\r\n            // withdrawalAmount: Actual amount sent to borrower (can't exceed newLoanAmount)\r\n        bytes calldata loanDataBytes)\r\n        external\r\n        payable\r\n        returns (uint256);\r\n\r\n    function payInterestForOracle(\r\n        address oracleAddress,\r\n        address interestTokenAddress)\r\n        external\r\n        returns (uint256);\r\n\r\n    function getLenderInterestForOracle(\r\n        address lender,\r\n        address oracleAddress,\r\n        address interestTokenAddress)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 interestPaid,\r\n            uint256 interestPaidDate,\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid);\r\n\r\n    function oracleAddresses(\r\n        address oracleAddress)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getRequiredCollateral(\r\n        address loanTokenAddress,\r\n        address collateralTokenAddress,\r\n        address oracleAddress,\r\n        uint256 newLoanAmount,\r\n        uint256 marginAmount)\r\n        external\r\n        view\r\n        returns (uint256 collateralTokenAmount);\r\n\r\n    function getBorrowAmount(\r\n        address loanTokenAddress,\r\n        address collateralTokenAddress,\r\n        address oracleAddress,\r\n        uint256 collateralTokenAmount,\r\n        uint256 marginAmount)\r\n        external\r\n        view\r\n        returns (uint256 borrowAmount);\r\n}\r\n\r\ninterface IBZxOracle {\r\n    function getTradeData(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint256 sourceTokenAmount)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 sourceToDestRate,\r\n            uint256 sourceToDestPrecision,\r\n            uint256 destTokenAmount\r\n        );\r\n}\r\n\r\ninterface IWethHelper {\r\n    function claimEther(\r\n        address receiver,\r\n        uint256 amount)\r\n        external\r\n        returns (uint256 claimAmount);\r\n}\r\n\r\ncontract LoanTokenLogicV4 is AdvancedToken, OracleNotifierInterface {\r\n    using SafeMath for uint256;\r\n\r\n    address internal target_;\r\n\r\n    address internal constant arbitraryCaller = 0x000F400e6818158D541C3EBE45FE3AA0d47372FF;\r\n\r\n    modifier onlyOracle() {\r\n        require(msg.sender == IBZx(bZxContract).oracleAddresses(bZxOracle), \"1\");\r\n        _;\r\n    }\r\n\r\n\r\n    function()\r\n        external\r\n    {}\r\n\r\n\r\n    /* Public functions */\r\n\r\n    function mintWithEther(\r\n        address receiver)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (uint256 mintAmount)\r\n    {\r\n        require(loanTokenAddress == wethContract, \"2\");\r\n        return _mintToken(\r\n            receiver,\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    function mint(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 mintAmount)\r\n    {\r\n        return _mintToken(\r\n            receiver,\r\n            depositAmount\r\n        );\r\n    }\r\n\r\n    function burnToEther(\r\n        address receiver,\r\n        uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        require(loanTokenAddress == wethContract, \"3\");\r\n        loanAmountPaid = _burnToken(\r\n            burnAmount\r\n        );\r\n\r\n        if (loanAmountPaid != 0) {\r\n            IWethHelper wethHelper = IWethHelper(0x3b5bDCCDFA2a0a1911984F203C19628EeB6036e0);\r\n\r\n            _transfer(loanTokenAddress, address(wethHelper), loanAmountPaid, \"4\");\r\n            require(loanAmountPaid == wethHelper.claimEther(receiver, loanAmountPaid), \"4\");\r\n        }\r\n    }\r\n\r\n    function burn(\r\n        address receiver,\r\n        uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(\r\n            burnAmount\r\n        );\r\n\r\n        if (loanAmountPaid != 0) {\r\n            _transfer(loanTokenAddress, receiver, loanAmountPaid, \"5\");\r\n        }\r\n    }\r\n\r\n    function flashBorrowToken(\r\n        uint256 borrowAmount,\r\n        address borrower,\r\n        address target,\r\n        string calldata signature,\r\n        bytes calldata data)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (bytes memory)\r\n    {\r\n        _checkPause();\r\n\r\n        _settleInterest();\r\n\r\n        // save before balances\r\n        uint256 beforeEtherBalance = address(this).balance.sub(msg.value);\r\n        uint256 beforeAssetsBalance = ERC20(loanTokenAddress).balanceOf(address(this))\r\n            .add(totalAssetBorrow);\r\n\r\n        // lock totalAssetSupply for duration of flash loan\r\n        burntTokenReserved = beforeAssetsBalance;\r\n\r\n        // transfer assets to calling contract\r\n        if (borrowAmount != 0) {\r\n            _transfer(loanTokenAddress, borrower, borrowAmount, \"39\");\r\n        }\r\n\r\n        bytes memory callData;\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // arbitrary call\r\n        (bool success, bytes memory returnData) = arbitraryCaller.call.value(msg.value)(\r\n            abi.encodeWithSelector(\r\n                0xde064e0d, // sendCall(address,bytes)\r\n                target,\r\n                callData\r\n            )\r\n        );\r\n        require(success, \"call failed\");\r\n\r\n        // unlock totalAssetSupply\r\n        burntTokenReserved = 0;\r\n\r\n        // verifies return of flash loan\r\n        require(\r\n            address(this).balance >= beforeEtherBalance &&\r\n            ERC20(loanTokenAddress).balanceOf(address(this))\r\n                .add(totalAssetBorrow) >= beforeAssetsBalance,\r\n            \"40\"\r\n        );\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function borrowTokenFromDeposit(\r\n        uint256 borrowAmount,\r\n        uint256 leverageAmount,\r\n        uint256 initialLoanDuration,    // duration in seconds\r\n        uint256 collateralTokenSent,    // set to 0 if sending ETH\r\n        address borrower,\r\n        address receiver,\r\n        address collateralTokenAddress, // address(0) means ETH and ETH must be sent with the call\r\n        bytes memory /*loanDataBytes*/) // arbitrary order data\r\n        public\r\n        payable\r\n        returns (bytes32 loanOrderHash)\r\n    {\r\n        require(\r\n            ((msg.value == 0 && collateralTokenAddress != address(0) && collateralTokenSent != 0) ||\r\n            (msg.value != 0 && (collateralTokenAddress == address(0) || collateralTokenAddress == wethContract) && collateralTokenSent == 0)),\r\n            \"6\"\r\n        );\r\n\r\n        if (msg.value != 0) {\r\n            collateralTokenAddress = wethContract;\r\n            collateralTokenSent = msg.value;\r\n        }\r\n\r\n        uint256 _borrowAmount = borrowAmount;\r\n\r\n        leverageAmount = uint256(keccak256(abi.encodePacked(leverageAmount,collateralTokenAddress)));\r\n        loanOrderHash = loanOrderHashes[leverageAmount];\r\n        require(loanOrderHash != 0, \"7\");\r\n\r\n        _settleInterest();\r\n\r\n        uint256[7] memory sentAmounts;\r\n\r\n        LoanData memory loanOrder = loanOrderData[loanOrderHash];\r\n        bool useFixedInterestModel = loanOrder.maxDurationUnixTimestampSec == 0;\r\n\r\n        if (_borrowAmount == 0) {\r\n            _borrowAmount = _getBorrowAmountForDeposit(\r\n                collateralTokenSent,\r\n                leverageAmount,\r\n                initialLoanDuration,\r\n                collateralTokenAddress\r\n            );\r\n            require(_borrowAmount != 0, \"35\");\r\n\r\n            // withdrawalAmount\r\n            sentAmounts[6] = _borrowAmount;\r\n        } else {\r\n            // withdrawalAmount\r\n            sentAmounts[6] = _borrowAmount;\r\n        }\r\n\r\n        // interestRate, interestInitialAmount, borrowAmount (newBorrowAmount)\r\n        (sentAmounts[0], sentAmounts[2], _borrowAmount) = _getInterestRateAndAmount(\r\n            _borrowAmount,\r\n            _totalAssetSupply(0), // interest is settled above\r\n            initialLoanDuration,\r\n            useFixedInterestModel\r\n        );\r\n\r\n        sentAmounts[6] = _borrowTokenAndUseFinal(\r\n            loanOrderHash,\r\n            [\r\n                borrower,\r\n                collateralTokenAddress,\r\n                address(0), // tradeTokenAddress\r\n                receiver\r\n            ],\r\n            [\r\n                sentAmounts[0],         // interestRate\r\n                _borrowAmount,\r\n                sentAmounts[2],         // interestInitialAmount\r\n                0,                      // loanTokenSent\r\n                collateralTokenSent,\r\n                0,                      // tradeTokenSent\r\n                sentAmounts[6]          // withdrawalAmount\r\n            ],\r\n            \"\"                          // loanDataBytes\r\n        );\r\n        require(sentAmounts[6] == _borrowAmount, \"8\");\r\n    }\r\n\r\n    // Called by pTokens to borrow and immediately get into a positions\r\n    // Other traders can call this, but it's recommended to instead use borrowTokenAndUse(...) instead\r\n    // assumption: depositAmount is collateral + interest deposit and will be denominated in deposit token\r\n    // assumption: loan token and interest token are the same\r\n    // returns loanOrderHash for the base protocol loan\r\n    function marginTradeFromDeposit(\r\n        uint256 depositAmount,\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        uint256 tradeTokenSent,\r\n        address trader,\r\n        address depositTokenAddress,\r\n        address collateralTokenAddress,\r\n        address tradeTokenAddress,\r\n        bytes memory loanDataBytes)\r\n        public\r\n        payable\r\n        returns (bytes32 loanOrderHash)\r\n    {\r\n        require(tradeTokenAddress != address(0) &&\r\n            tradeTokenAddress != loanTokenAddress,\r\n            \"10\"\r\n        );\r\n\r\n        uint256 amount = depositAmount;\r\n        // To calculate borrow amount and interest owed to lender we need deposit amount to be represented as loan token\r\n        if (depositTokenAddress == tradeTokenAddress) {\r\n            (,,amount) = IBZxOracle(bZxOracle).getTradeData(\r\n                tradeTokenAddress,\r\n                loanTokenAddress,\r\n                amount\r\n            );\r\n        } else if (depositTokenAddress != loanTokenAddress) {\r\n            // depositTokenAddress can only be tradeTokenAddress or loanTokenAddress\r\n            revert(\"11\");\r\n        }\r\n\r\n        loanOrderHash = _borrowTokenAndUse(\r\n            leverageAmount,\r\n            [\r\n                trader,\r\n                collateralTokenAddress,     // collateralTokenAddress\r\n                tradeTokenAddress,          // tradeTokenAddress\r\n                trader                      // receiver\r\n            ],\r\n            [\r\n                0,                      // interestRate (found later)\r\n                amount,                 // amount of deposit\r\n                0,                      // interestInitialAmount (interest is calculated based on fixed-term loan)\r\n                loanTokenSent,\r\n                collateralTokenSent,\r\n                tradeTokenSent,\r\n                0\r\n            ],\r\n            true,                       // amountIsADeposit\r\n            loanDataBytes\r\n        );\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_value <= balances[msg.sender] &&\r\n            _to != address(0),\r\n            \"13\"\r\n        );\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        // handle checkpoint update\r\n        uint256 currentPrice = tokenPrice();\r\n        if (balances[msg.sender] != 0) {\r\n            checkpointPrices_[msg.sender] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[msg.sender] = 0;\r\n        }\r\n        if (balances[_to] != 0) {\r\n            checkpointPrices_[_to] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[_to] = 0;\r\n        }\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 allowanceAmount = allowed[_from][msg.sender];\r\n        require(_value <= balances[_from] &&\r\n            _value <= allowanceAmount &&\r\n            _to != address(0),\r\n            \"14\"\r\n        );\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if (allowanceAmount < MAX_UINT) {\r\n            allowed[_from][msg.sender] = allowanceAmount.sub(_value);\r\n        }\r\n\r\n        // handle checkpoint update\r\n        uint256 currentPrice = tokenPrice();\r\n        if (balances[_from] != 0) {\r\n            checkpointPrices_[_from] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[_from] = 0;\r\n        }\r\n        if (balances[_to] != 0) {\r\n            checkpointPrices_[_to] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[_to] = 0;\r\n        }\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /* Public View functions */\r\n\r\n    function tokenPrice()\r\n        public\r\n        view\r\n        returns (uint256 price)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != block.timestamp) {\r\n            (,interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _tokenPrice(_totalAssetSupply(interestUnPaid));\r\n    }\r\n\r\n    function checkpointPrice(\r\n        address _user)\r\n        public\r\n        view\r\n        returns (uint256 price)\r\n    {\r\n        return checkpointPrices_[_user];\r\n    }\r\n\r\n    function marketLiquidity()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalSupply = totalAssetSupply();\r\n        if (totalSupply > totalAssetBorrow) {\r\n            return totalSupply.sub(totalAssetBorrow);\r\n        }\r\n    }\r\n\r\n    function protocolInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _protocolInterestRate(totalAssetBorrow);\r\n    }\r\n\r\n    // the minimum rate the next base protocol borrower will receive for variable-rate loans\r\n    function borrowInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(\r\n            0,              // borrowAmount\r\n            false           // useFixedInterestModel\r\n        );\r\n    }\r\n\r\n    function nextBorrowInterestRate(\r\n        uint256 borrowAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(\r\n            borrowAmount,\r\n            false           // useFixedInterestModel\r\n        );\r\n    }\r\n\r\n    function nextBorrowInterestRateWithOption(\r\n        uint256 borrowAmount,\r\n        bool useFixedInterestModel)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(\r\n            borrowAmount,\r\n            useFixedInterestModel\r\n        );\r\n    }\r\n\r\n    // the average interest that borrowers are currently paying for open loans\r\n    function avgBorrowInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetBorrow = totalAssetBorrow;\r\n        if (assetBorrow != 0) {\r\n            return _protocolInterestRate(assetBorrow)\r\n                .mul(checkpointSupply)\r\n                .div(totalAssetSupply());\r\n        } else {\r\n            return _getLowUtilBaseRate();\r\n        }\r\n    }\r\n\r\n    // interest that lenders are currently receiving when supplying to the pool\r\n    function supplyInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(totalAssetSupply());\r\n    }\r\n\r\n    function nextSupplyInterestRate(\r\n        uint256 supplyAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(totalAssetSupply().add(supplyAmount));\r\n    }\r\n\r\n    function totalSupplyInterestRate(\r\n        uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetBorrow = totalAssetBorrow;\r\n        if (assetBorrow != 0) {\r\n            return _supplyInterestRate(\r\n                assetBorrow,\r\n                assetSupply\r\n            );\r\n        }\r\n    }\r\n\r\n    function totalAssetSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != block.timestamp) {\r\n            (,interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _totalAssetSupply(interestUnPaid);\r\n    }\r\n\r\n    function getMaxEscrowAmount(\r\n        uint256 leverageAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        LoanData memory loanData = loanOrderData[loanOrderHashes[leverageAmount]];\r\n        if (loanData.initialMarginAmount == 0)\r\n            return 0;\r\n\r\n        return marketLiquidity()\r\n            .mul(loanData.initialMarginAmount)\r\n            .div(_adjustValue(\r\n                10**20, // maximum possible interest (100%)\r\n                loanData.maxDurationUnixTimestampSec,\r\n                loanData.initialMarginAmount));\r\n    }\r\n\r\n    function getLeverageList()\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return leverageList;\r\n    }\r\n\r\n    function getLoanData(\r\n        bytes32 loanOrderHash)\r\n        public\r\n        view\r\n        returns (LoanData memory)\r\n    {\r\n        return loanOrderData[loanOrderHash];\r\n    }\r\n\r\n    // returns the user's balance of underlying token\r\n    function assetBalanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balanceOf(_owner)\r\n            .mul(tokenPrice())\r\n            .div(10**18);\r\n    }\r\n\r\n    function getDepositAmountForBorrow(\r\n        uint256 borrowAmount,\r\n        uint256 leverageAmount,             // use 2000000000000000000 for 150% initial margin\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256 depositAmount)\r\n    {\r\n        if (borrowAmount != 0) {\r\n            leverageAmount = uint256(keccak256(abi.encodePacked(leverageAmount,collateralTokenAddress)));\r\n            LoanData memory loanOrder = loanOrderData[loanOrderHashes[leverageAmount]];\r\n            uint256 marginAmount = loanOrder.initialMarginAmount\r\n                .add(10**20); // adjust for over-collateralized loan\r\n                //.add(loanOrder.marginPremiumAmount);\r\n\r\n            // adjust value since interest is also borrowed\r\n            borrowAmount = borrowAmount\r\n                .mul(_getTargetNextRateMultiplierValue(initialLoanDuration))\r\n                .div(10**22);\r\n\r\n            if (borrowAmount <= ERC20(loanTokenAddress).balanceOf(address(this))) {\r\n                return IBZx(bZxContract).getRequiredCollateral(\r\n                    loanTokenAddress,\r\n                    collateralTokenAddress != address(0) ? collateralTokenAddress : wethContract,\r\n                    bZxOracle,\r\n                    borrowAmount,\r\n                    marginAmount\r\n                ).add(10); // add some dust to ensure enough is borrowed later\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBorrowAmountForDeposit(\r\n        uint256 depositAmount,\r\n        uint256 leverageAmount,             // use 2000000000000000000 for 150% initial margin\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256 borrowAmount)\r\n    {\r\n        leverageAmount = uint256(keccak256(abi.encodePacked(leverageAmount,collateralTokenAddress)));\r\n        borrowAmount = _getBorrowAmountForDeposit(\r\n            depositAmount,\r\n            leverageAmount,\r\n            initialLoanDuration,\r\n            collateralTokenAddress\r\n        );\r\n    }\r\n\r\n\r\n    /* Internal functions */\r\n\r\n    function _mintToken(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        internal\r\n        returns (uint256 mintAmount)\r\n    {\r\n        require (depositAmount != 0, \"17\");\r\n\r\n        _settleInterest();\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n        mintAmount = depositAmount.mul(10**18).div(currentPrice);\r\n\r\n        if (msg.value == 0) {\r\n            _transferFrom(loanTokenAddress, msg.sender, address(this), depositAmount, \"18\");\r\n        } else {\r\n            WETHInterface(wethContract).deposit.value(depositAmount)();\r\n        }\r\n\r\n        _mint(receiver, mintAmount, depositAmount, currentPrice);\r\n\r\n        checkpointPrices_[receiver] = currentPrice;\r\n    }\r\n\r\n    function _burnToken(\r\n        uint256 burnAmount)\r\n        internal\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        require(burnAmount != 0, \"19\");\r\n\r\n        if (burnAmount > balanceOf(msg.sender)) {\r\n            burnAmount = balanceOf(msg.sender);\r\n        }\r\n\r\n        _settleInterest();\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n\r\n        uint256 loanAmountOwed = burnAmount.mul(currentPrice).div(10**18);\r\n        uint256 loanAmountAvailableInContract = ERC20(loanTokenAddress).balanceOf(address(this));\r\n\r\n        loanAmountPaid = loanAmountOwed;\r\n        require(loanAmountPaid <= loanAmountAvailableInContract, \"37\");\r\n\r\n        _burn(msg.sender, burnAmount, loanAmountPaid, currentPrice);\r\n\r\n        if (balances[msg.sender] != 0) {\r\n            checkpointPrices_[msg.sender] = currentPrice;\r\n        } else {\r\n            checkpointPrices_[msg.sender] = 0;\r\n        }\r\n    }\r\n\r\n    function _settleInterest()\r\n        internal\r\n    {\r\n        if (lastSettleTime_ != block.timestamp) {\r\n            IBZx(bZxContract).payInterestForOracle(\r\n                bZxOracle, // (leave as original value)\r\n                loanTokenAddress // same as interestTokenAddress\r\n            );\r\n\r\n            lastSettleTime_ = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function _getBorrowAmountForDeposit(\r\n        uint256 depositAmount,\r\n        uint256 leverageAmount,             // use 2000000000000000000 for 150% initial margin\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        internal\r\n        view\r\n        returns (uint256 borrowAmount)\r\n    {\r\n        if (depositAmount != 0) {\r\n            LoanData memory loanOrder = loanOrderData[loanOrderHashes[leverageAmount]];\r\n            uint256 marginAmount = loanOrder.initialMarginAmount\r\n                .add(10**20); // adjust for over-collateralized loan\r\n                //.add(loanOrder.marginPremiumAmount);\r\n\r\n            borrowAmount = IBZx(bZxContract).getBorrowAmount(\r\n                loanTokenAddress,\r\n                collateralTokenAddress != address(0) ? collateralTokenAddress : wethContract,\r\n                bZxOracle,\r\n                depositAmount,\r\n                marginAmount\r\n            );\r\n\r\n            // adjust value since interest is also borrowed\r\n            borrowAmount = borrowAmount\r\n                .mul(10**22)\r\n                .div(_getTargetNextRateMultiplierValue(initialLoanDuration));\r\n\r\n            if (borrowAmount > ERC20(loanTokenAddress).balanceOf(address(this))) {\r\n                borrowAmount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getTargetNextRateMultiplierValue(\r\n        uint256 initialLoanDuration)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return rateMultiplier\r\n            .mul(80 ether)\r\n            .div(10**20)\r\n            .add(baseRate)\r\n            .mul(initialLoanDuration)\r\n            .div(315360) // 365 * 86400 / 100\r\n            .add(10**22);\r\n    }\r\n\r\n    function _getInterestRateAndAmount(\r\n        uint256 borrowAmount,\r\n        uint256 assetSupply,\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        bool useFixedInterestModel)         // False=variable interest, True=fixed interest\r\n        internal\r\n        view\r\n        returns (uint256 interestRate, uint256 interestInitialAmount, uint256 newBorrowAmount)\r\n    {\r\n        (,interestInitialAmount) = _getInterestRateAndAmount2(\r\n            borrowAmount,\r\n            assetSupply,\r\n            initialLoanDuration,\r\n            useFixedInterestModel\r\n        );\r\n\r\n        (interestRate, interestInitialAmount) = _getInterestRateAndAmount2(\r\n            borrowAmount\r\n                .add(interestInitialAmount),\r\n            assetSupply,\r\n            initialLoanDuration,\r\n            useFixedInterestModel\r\n        );\r\n\r\n        newBorrowAmount = borrowAmount\r\n            .add(interestInitialAmount);\r\n    }\r\n\r\n    function _getInterestRateAndAmount2(\r\n        uint256 borrowAmount,\r\n        uint256 assetSupply,\r\n        uint256 initialLoanDuration,\r\n        bool useFixedInterestModel)\r\n        internal\r\n        view\r\n        returns (uint256 interestRate, uint256 interestInitialAmount)\r\n    {\r\n        interestRate = _nextBorrowInterestRate2(\r\n            borrowAmount,\r\n            assetSupply,\r\n            useFixedInterestModel\r\n        );\r\n\r\n        // initial interestInitialAmount\r\n        interestInitialAmount = borrowAmount\r\n            .mul(interestRate)\r\n            .mul(initialLoanDuration)\r\n            .div(31536000 * 10**20); // 365 * 86400 * 10**20\r\n    }\r\n\r\n    function _borrowTokenAndUse(\r\n        uint256 leverageAmount,\r\n        address[4] memory sentAddresses,\r\n        uint256[7] memory sentAmounts,\r\n        bool amountIsADeposit,\r\n        bytes memory loanDataBytes)\r\n        internal\r\n        returns (bytes32 loanOrderHash)\r\n    {\r\n        require(sentAmounts[1] != 0, \"21\"); // amount\r\n\r\n        loanOrderHash = loanOrderHashes[leverageAmount];\r\n        require(loanOrderHash != 0, \"22\");\r\n\r\n        _settleInterest();\r\n\r\n        LoanData memory loanOrder = loanOrderData[loanOrderHash];\r\n        bool useFixedInterestModel = loanOrder.maxDurationUnixTimestampSec == 0;\r\n        //sentAmounts[7] = loanOrder.marginPremiumAmount;\r\n\r\n        if (amountIsADeposit) {\r\n            (sentAmounts[1], sentAmounts[0]) = _getBorrowAmountAndRate( // borrowAmount, interestRate\r\n                loanOrderHash,\r\n                sentAmounts[1], // amount\r\n                useFixedInterestModel\r\n            );\r\n\r\n            // update for borrowAmount\r\n            sentAmounts[6] = sentAmounts[1]; // borrowAmount\r\n        } else {\r\n            // amount is borrow amount\r\n            sentAmounts[0] = _nextBorrowInterestRate2( // interestRate\r\n                sentAmounts[1], // amount\r\n                _totalAssetSupply(0),\r\n                useFixedInterestModel\r\n            );\r\n        }\r\n\r\n        if (sentAddresses[2] == address(0)) { // tradeTokenAddress\r\n            // tradeTokenSent is ignored if trade token isn't specified\r\n            sentAmounts[5] = 0;\r\n        }\r\n\r\n        uint256 borrowAmount = _borrowTokenAndUseFinal(\r\n            loanOrderHash,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n        require(borrowAmount == sentAmounts[1], \"23\");\r\n    }\r\n\r\n    // returns borrowAmount\r\n    function _borrowTokenAndUseFinal(\r\n        bytes32 loanOrderHash,\r\n        address[4] memory sentAddresses,\r\n        uint256[7] memory sentAmounts,\r\n        bytes memory loanDataBytes)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        _checkPause();\r\n\r\n        require (sentAmounts[1] <= ERC20(loanTokenAddress).balanceOf(address(this)) && // borrowAmount\r\n            sentAddresses[0] != address(0), // borrower\r\n            \"24\"\r\n        );\r\n\r\n\t    if (sentAddresses[3] == address(0)) {\r\n            sentAddresses[3] = sentAddresses[0]; // receiver = borrower\r\n        }\r\n\r\n        // handle transfers prior to adding borrowAmount to loanTokenSent\r\n        _verifyTransfers(\r\n            sentAddresses,\r\n            sentAmounts\r\n        );\r\n\r\n        // adding the loan token amount from the lender to loanTokenSent\r\n        sentAmounts[3] = sentAmounts[3]\r\n            .add(sentAmounts[1]); // borrowAmount\r\n\r\n        uint256 msgValue;\r\n        if (msg.value != 0) {\r\n            msgValue = address(this).balance;\r\n            if (msgValue > msg.value) {\r\n                msgValue = msg.value;\r\n            }\r\n        }\r\n        sentAmounts[1] = IBZx(bZxContract).takeOrderFromiToken.value(msgValue)( // borrowAmount\r\n            loanOrderHash,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n        require (sentAmounts[1] != 0, \"25\");\r\n\r\n        // update total borrowed amount outstanding in loans\r\n        totalAssetBorrow = totalAssetBorrow\r\n            .add(sentAmounts[1]); // borrowAmount\r\n\r\n        // checkpoint supply since the base protocol borrow stats have changed\r\n        checkpointSupply = _totalAssetSupply(0);\r\n\r\n        emit Borrow(\r\n            sentAddresses[0],               // borrower\r\n            sentAmounts[1],                 // borrowAmount\r\n            sentAmounts[0],                 // interestRate\r\n            sentAddresses[1],               // collateralTokenAddress\r\n            sentAddresses[2],               // tradeTokenAddress\r\n            sentAddresses[2] == address(0)  // withdrawOnOpen\r\n        );\r\n\r\n        return sentAmounts[1]; // borrowAmount;\r\n    }\r\n\r\n    // sentAddresses[0]: borrower\r\n    // sentAddresses[1]: collateralTokenAddress\r\n    // sentAddresses[2]: tradeTokenAddress\r\n    // sentAddresses[3]: receiver\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: borrowAmount\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    // sentAmounts[5]: tradeTokenSent\r\n    // sentAmounts[6]: withdrawalAmount\r\n    function _verifyTransfers(\r\n        address[4] memory sentAddresses,\r\n        uint256[7] memory sentAmounts)\r\n        internal\r\n    {\r\n        address collateralTokenAddress = sentAddresses[1];\r\n        address tradeTokenAddress = sentAddresses[2];\r\n        address receiver = sentAddresses[3];\r\n        uint256 borrowAmount = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n        uint256 tradeTokenSent = sentAmounts[5];\r\n        uint256 withdrawalAmount = sentAmounts[6];\r\n\r\n        bool success;\r\n        if (tradeTokenAddress == address(0)) { // withdrawOnOpen == true\r\n            if (loanTokenAddress == wethContract) {\r\n                IWethHelper wethHelper = IWethHelper(0x3b5bDCCDFA2a0a1911984F203C19628EeB6036e0);\r\n\r\n                _transfer(loanTokenAddress, address(wethHelper), withdrawalAmount, \"\");\r\n                success = withdrawalAmount == wethHelper.claimEther(receiver, withdrawalAmount);\r\n            } else {\r\n                _transfer(loanTokenAddress, receiver, withdrawalAmount, \"\");\r\n                success = true;\r\n            }\r\n\r\n            if (success && borrowAmount > withdrawalAmount) {\r\n                _transfer(loanTokenAddress, bZxVault, borrowAmount - withdrawalAmount, \"\");\r\n            }\r\n            require(success, \"26\");\r\n        } else {\r\n            _transfer(loanTokenAddress, bZxVault, borrowAmount, \"26\");\r\n        }\r\n\r\n        if (collateralTokenSent != 0) {\r\n            if (collateralTokenAddress == wethContract && msg.value != 0 && collateralTokenSent == msg.value) {\r\n                WETHInterface(wethContract).deposit.value(collateralTokenSent)();\r\n                _transfer(collateralTokenAddress, bZxVault, collateralTokenSent, \"27\");\r\n            } else {\r\n                if (collateralTokenAddress == loanTokenAddress) {\r\n                    loanTokenSent = loanTokenSent.add(collateralTokenSent);\r\n                } else if (collateralTokenAddress == tradeTokenAddress) {\r\n                    tradeTokenSent = tradeTokenSent.add(collateralTokenSent);\r\n                } else {\r\n                    _transferFrom(collateralTokenAddress, msg.sender, bZxVault, collateralTokenSent, \"27\");\r\n                }\r\n            }\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            if (loanTokenAddress == tradeTokenAddress) {\r\n                tradeTokenSent = tradeTokenSent.add(loanTokenSent);\r\n            } else {\r\n                _transferFrom(loanTokenAddress, msg.sender, bZxVault, loanTokenSent, \"31\");\r\n            }\r\n        }\r\n\r\n        if (tradeTokenSent != 0) {\r\n            _transferFrom(tradeTokenAddress, msg.sender, bZxVault, tradeTokenSent, \"32\");\r\n        }\r\n    }\r\n\r\n    function _transfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        (bool success,) = token.call(\r\n            abi.encodeWithSelector(\r\n                0xa9059cbb, // transfer(address,uint256)\r\n                to,\r\n                amount\r\n            )\r\n        );\r\n        require(success, errorMsg);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        (bool success,) = token.call(\r\n            abi.encodeWithSelector(\r\n                0x23b872dd, // transferFrom(address,address,uint256)\r\n                from,\r\n                to,\r\n                amount\r\n            )\r\n        );\r\n        require(success, errorMsg);\r\n    }\r\n\r\n    /* Internal View functions */\r\n\r\n    function _tokenPrice(\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalTokenSupply = totalSupply_;\r\n\r\n        return totalTokenSupply != 0 ?\r\n            assetSupply\r\n                .mul(10**18)\r\n                .div(totalTokenSupply) : initialPrice;\r\n    }\r\n\r\n    function _protocolInterestRate(\r\n        uint256 assetBorrow)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0) {\r\n            (uint256 interestOwedPerDay,) = _getAllInterest();\r\n            return interestOwedPerDay\r\n                .mul(10**20)\r\n                .div(assetBorrow)\r\n                .mul(365);\r\n        }\r\n    }\r\n\r\n    // next supply interest adjustment\r\n    function _supplyInterestRate(\r\n        uint256 assetBorrow,\r\n        uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply >= assetBorrow) {\r\n            return _protocolInterestRate(assetBorrow)\r\n                .mul(_utilizationRate(assetBorrow, assetSupply))\r\n                .div(10**20);\r\n        }\r\n        /*if (assetBorrow != 0 && assetSupply >= assetBorrow) {\r\n            return _protocolInterestRate(assetBorrow)\r\n                .mul(_utilizationRate(assetBorrow, assetSupply))\r\n                .mul(spreadMultiplier)\r\n                .div(10**40);\r\n        }*/\r\n    }\r\n\r\n    function _nextBorrowInterestRate(\r\n        uint256 borrowAmount,\r\n        bool useFixedInterestModel)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (borrowAmount != 0) {\r\n            if (lastSettleTime_ != block.timestamp) {\r\n                (,interestUnPaid) = _getAllInterest();\r\n            }\r\n\r\n            uint256 balance = ERC20(loanTokenAddress).balanceOf(address(this))\r\n                .add(interestUnPaid);\r\n            if (borrowAmount > balance) {\r\n                borrowAmount = balance;\r\n            }\r\n        }\r\n\r\n        return _nextBorrowInterestRate2(\r\n            borrowAmount,\r\n            _totalAssetSupply(interestUnPaid),\r\n            useFixedInterestModel\r\n        );\r\n    }\r\n\r\n    function _nextBorrowInterestRate2(\r\n        uint256 newBorrowAmount,\r\n        uint256 assetSupply,\r\n        bool useFixedInterestModel)\r\n        internal\r\n        view\r\n        returns (uint256 nextRate)\r\n    {\r\n        uint256 utilRate = _utilizationRate(\r\n            totalAssetBorrow.add(newBorrowAmount),\r\n            assetSupply\r\n        );\r\n\r\n        uint256 minRate;\r\n        uint256 maxRate;\r\n        uint256 thisBaseRate;\r\n        uint256 thisRateMultiplier;\r\n\r\n        if (useFixedInterestModel) {\r\n            if (utilRate < 80 ether) {\r\n                // target 80% utilization when loan is fixed-rate and utilization is under 80%\r\n                utilRate = 80 ether;\r\n            }\r\n\r\n            //keccak256(\"iToken_FixedInterestBaseRate\")\r\n            //keccak256(\"iToken_FixedInterestRateMultiplier\")\r\n            assembly {\r\n                thisBaseRate := sload(0x185a40c6b6d3f849f72c71ea950323d21149c27a9d90f7dc5e5ea2d332edcf7f)\r\n                thisRateMultiplier := sload(0x9ff54bc0049f5eab56ca7cd14591be3f7ed6355b856d01e3770305c74a004ea2)\r\n            }\r\n        } else if (utilRate < 50 ether) {\r\n            thisBaseRate = _getLowUtilBaseRate();\r\n\r\n            //keccak256(\"iToken_LowUtilRateMultiplier\")\r\n            assembly {\r\n                thisRateMultiplier := sload(0x2b4858b1bc9e2d14afab03340ce5f6c81b703c86a0c570653ae586534e095fb1)\r\n            }\r\n        } else {\r\n            thisBaseRate = baseRate;\r\n            thisRateMultiplier = rateMultiplier;\r\n        }\r\n\r\n        if (utilRate > 90 ether) {\r\n            // scale rate proportionally up to 100%\r\n\r\n            utilRate = utilRate.sub(90 ether);\r\n            if (utilRate > 10 ether)\r\n                utilRate = 10 ether;\r\n\r\n            maxRate = thisRateMultiplier\r\n                .add(thisBaseRate)\r\n                .mul(90)\r\n                .div(100);\r\n\r\n            nextRate = utilRate\r\n                .mul(SafeMath.sub(100 ether, maxRate))\r\n                .div(10 ether)\r\n                .add(maxRate);\r\n        } else {\r\n            nextRate = utilRate\r\n                .mul(thisRateMultiplier)\r\n                .div(10**20)\r\n                .add(thisBaseRate);\r\n\r\n            minRate = thisBaseRate;\r\n            maxRate = thisRateMultiplier\r\n                .add(thisBaseRate);\r\n\r\n            if (nextRate < minRate)\r\n                nextRate = minRate;\r\n            else if (nextRate > maxRate)\r\n                nextRate = maxRate;\r\n        }\r\n    }\r\n\r\n    function _getAllInterest()\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid)\r\n    {\r\n        (,,interestOwedPerDay,interestUnPaid) = IBZx(bZxContract).getLenderInterestForOracle(\r\n            address(this),\r\n            bZxOracle, // (leave as original value)\r\n            loanTokenAddress // same as interestTokenAddress\r\n        );\r\n\r\n        interestUnPaid = interestUnPaid\r\n            .mul(spreadMultiplier)\r\n            .div(10**20);\r\n    }\r\n\r\n    function _getBorrowAmountAndRate(\r\n        bytes32 loanOrderHash,\r\n        uint256 depositAmount,\r\n        bool useFixedInterestModel)\r\n        internal\r\n        view\r\n        returns (uint256 borrowAmount, uint256 interestRate)\r\n    {\r\n        LoanData memory loanData = loanOrderData[loanOrderHash];\r\n        require(loanData.initialMarginAmount != 0, \"33\");\r\n\r\n        interestRate = _nextBorrowInterestRate2(\r\n            depositAmount\r\n                .mul(10**20)\r\n                .div(loanData.initialMarginAmount),\r\n            totalAssetSupply(),\r\n            useFixedInterestModel\r\n        );\r\n\r\n        // assumes that loan, collateral, and interest token are the same\r\n        borrowAmount = depositAmount\r\n            .mul(10**40)\r\n            .div(_adjustValue(\r\n                interestRate,\r\n                loanData.maxDurationUnixTimestampSec,\r\n                loanData.initialMarginAmount))\r\n            .div(loanData.initialMarginAmount);\r\n    }\r\n\r\n    function _totalAssetSupply(\r\n        uint256 interestUnPaid)\r\n        internal\r\n        view\r\n        returns (uint256 assetSupply)\r\n    {\r\n        if (totalSupply_ != 0) {\r\n            uint256 assetsBalance = burntTokenReserved; // temporary holder when flash lending\r\n            if (assetsBalance == 0) {\r\n                assetsBalance = ERC20(loanTokenAddress).balanceOf(address(this))\r\n                    .add(totalAssetBorrow);\r\n            }\r\n\r\n            return assetsBalance\r\n                .add(interestUnPaid);\r\n        }\r\n    }\r\n\r\n    function _getLowUtilBaseRate()\r\n        internal\r\n        view\r\n        returns (uint256 lowUtilBaseRate)\r\n    {\r\n        //keccak256(\"iToken_LowUtilBaseRate\")\r\n        assembly {\r\n            lowUtilBaseRate := sload(0x3d82e958c891799f357c1316ae5543412952ae5c423336f8929ed7458039c995)\r\n        }\r\n    }\r\n\r\n    function _checkPause()\r\n        internal\r\n        view\r\n    {\r\n        //keccak256(\"iToken_FunctionPause\")\r\n        bytes32 slot = keccak256(abi.encodePacked(msg.sig, uint256(0xd46a704bc285dbd6ff5ad3863506260b1df02812f4f857c8cc852317a6ac64f2)));\r\n        bool isPaused;\r\n        assembly {\r\n            isPaused := sload(slot)\r\n        }\r\n        require(!isPaused, \"unauthorized\");\r\n    }\r\n\r\n    function _adjustValue(\r\n        uint256 interestRate,\r\n        uint256 maxDuration,\r\n        uint256 marginAmount)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return maxDuration != 0 ?\r\n            interestRate\r\n                .mul(10**20)\r\n                .div(31536000) // 86400 * 365\r\n                .mul(maxDuration)\r\n                .div(marginAmount)\r\n                .add(10**20) :\r\n            10**20;\r\n    }\r\n\r\n    function _utilizationRate(\r\n        uint256 assetBorrow,\r\n        uint256 assetSupply)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply != 0) {\r\n            // U = total_borrow / total_supply\r\n            return assetBorrow\r\n                .mul(10**20)\r\n                .div(assetSupply);\r\n        }\r\n    }\r\n\r\n\r\n    /* Oracle-Only functions */\r\n\r\n    // called only by BZxOracle when a loan is partially or fully closed\r\n    function closeLoanNotifier(\r\n        BZxObjects.LoanOrder memory loanOrder,\r\n        BZxObjects.LoanPosition memory loanPosition,\r\n        address loanCloser,\r\n        uint256 closeAmount,\r\n        bool isLiquidation)\r\n        public\r\n        onlyOracle\r\n        returns (bool)\r\n    {\r\n        _settleInterest();\r\n\r\n        LoanData memory loanData = loanOrderData[loanOrder.loanOrderHash];\r\n        if (loanData.loanOrderHash == loanOrder.loanOrderHash) {\r\n            totalAssetBorrow = totalAssetBorrow > closeAmount ?\r\n                totalAssetBorrow.sub(closeAmount) : 0;\r\n\r\n            emit Repay(\r\n                loanOrder.loanOrderHash,    // loanOrderHash\r\n                loanPosition.trader,        // borrower\r\n                loanCloser,                 // closer\r\n                closeAmount,                // amount\r\n                isLiquidation               // isLiquidation\r\n            );\r\n\r\n            if (closeAmount == 0)\r\n                return true;\r\n\r\n            // checkpoint supply since the base protocol borrow stats have changed\r\n            checkpointSupply = _totalAssetSupply(0);\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /* Owner-Only functions */\r\n\r\n    function updateSettings(\r\n        address settingsTarget,\r\n        bytes memory callData)\r\n        public\r\n    {\r\n        if (msg.sender != owner) {\r\n            address _lowerAdmin;\r\n            address _lowerAdminContract;\r\n\r\n            //keccak256(\"iToken_LowerAdminAddress\")\r\n            //keccak256(\"iToken_LowerAdminContract\")\r\n            assembly {\r\n                _lowerAdmin := sload(0x7ad06df6a0af6bd602d90db766e0d5f253b45187c3717a0f9026ea8b10ff0d4b)\r\n                _lowerAdminContract := sload(0x34b31cff1dbd8374124bd4505521fc29cab0f9554a5386ba7d784a4e611c7e31)\r\n            }\r\n            require(msg.sender == _lowerAdmin && settingsTarget == _lowerAdminContract);\r\n        }\r\n\r\n        address currentTarget = target_;\r\n        target_ = settingsTarget;\r\n\r\n        (bool result,) = address(this).call(callData);\r\n\r\n        uint256 size;\r\n        uint256 ptr;\r\n        assembly {\r\n            size := returndatasize\r\n            ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            if eq(result, 0) { revert(ptr, size) }\r\n        }\r\n\r\n        target_ = currentTarget;\r\n\r\n        assembly {\r\n            return(ptr, size)\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"assetBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burntTokenReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetSupply\",\"type\":\"uint256\"}],\"name\":\"totalSupplyInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"loanTokenSent\",\"type\":\"uint256\"},{\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"name\":\"tradeTokenSent\",\"type\":\"uint256\"},{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"depositTokenAddress\",\"type\":\"address\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"tradeTokenAddress\",\"type\":\"address\"},{\"name\":\"loanDataBytes\",\"type\":\"bytes\"}],\"name\":\"marginTradeFromDeposit\",\"outputs\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssetBorrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"name\":\"getBorrowAmountForDeposit\",\"outputs\":[{\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"loanOrderData\",\"outputs\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"initialMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maxDurationUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"marginPremiumAmount\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"settingsTarget\",\"type\":\"address\"},{\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"updateSettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLeverageList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avgBorrowInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"name\":\"borrower\",\"type\":\"address\"},{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashBorrowToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetBorrow\",\"type\":\"uint256\"},{\"name\":\"assetSupply\",\"type\":\"uint256\"}],\"name\":\"_supplyInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenizedRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burntTokenReserveList\",\"outputs\":[{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkpointSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"name\":\"useFixedInterestModel\",\"type\":\"bool\"}],\"name\":\"nextBorrowInterestRateWithOption\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burnToEther\",\"outputs\":[{\"name\":\"loanAmountPaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"leverageAmount\",\"type\":\"uint256\"}],\"name\":\"getMaxEscrowAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"name\":\"getDepositAmountForBorrow\",\"outputs\":[{\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mintWithEther\",\"outputs\":[{\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssetSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"leverageList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"loanAmountPaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"nextBorrowInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"}],\"name\":\"getLoanData\",\"outputs\":[{\"components\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"initialMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maxDurationUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"marginPremiumAmount\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"loanTokenAddress\",\"type\":\"address\"},{\"name\":\"interestTokenAddress\",\"type\":\"address\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"loanTokenAmount\",\"type\":\"uint256\"},{\"name\":\"interestAmount\",\"type\":\"uint256\"},{\"name\":\"initialMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maxDurationUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"}],\"name\":\"loanOrder\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"collateralTokenAddressFilled\",\"type\":\"address\"},{\"name\":\"positionTokenAddressFilled\",\"type\":\"address\"},{\"name\":\"loanTokenAmountFilled\",\"type\":\"uint256\"},{\"name\":\"loanTokenAmountUsed\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAmountFilled\",\"type\":\"uint256\"},{\"name\":\"positionTokenAmountFilled\",\"type\":\"uint256\"},{\"name\":\"loanStartUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"loanEndUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"loanPosition\",\"type\":\"tuple\"},{\"name\":\"loanCloser\",\"type\":\"address\"},{\"name\":\"closeAmount\",\"type\":\"uint256\"},{\"name\":\"isLiquidation\",\"type\":\"bool\"}],\"name\":\"closeLoanNotifier\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"name\":\"borrower\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"borrowTokenFromDeposit\",\"outputs\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"supplyAmount\",\"type\":\"uint256\"}],\"name\":\"nextSupplyInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spreadMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkpointPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"burntTokenReserveListIndex\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"isSet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocolInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loanOrderHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"interestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tradeTokenToFillAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawOnOpen\",\"type\":\"bool\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"loanOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"closer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isLiquidation\",\"type\":\"bool\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remainingTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LoanTokenLogicV4","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://35c1abd400af9e0be5973d7cd0b8f0c91da3cf6c9bf45535fcf369633c0f50b2"}]}