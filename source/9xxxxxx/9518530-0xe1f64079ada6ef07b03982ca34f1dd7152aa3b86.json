{"status":"1","message":"OK","result":[{"SourceCode":"/*\n* Synthetix - Depot.sol\n*\n* https://github.com/Synthetixio/synthetix\n* https://synthetix.io\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\t\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n    \n/* ===============================================\n* Flattened with Solidifier by Coinage\n* \n* https://solidifier.coina.ge\n* ===============================================\n*/\n\n\npragma solidity ^0.4.24;\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n  /// @dev counter to allow mutex lock with only one SSTORE operation\n  uint256 private _guardCounter;\n\n  constructor() internal {\n    // The counter starts at one to prevent changing it from zero to a non-zero\n    // value, which is a more expensive operation.\n    _guardCounter = 1;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and make it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n  }\n\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Owned.sol\nversion:    1.1\nauthor:     Anton Jurisevic\n            Dominic Romanowski\n\ndate:       2018-2-26\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nAn Owned contract, to be inherited by other contracts.\nRequires its owner to be explicitly set in the constructor.\nProvides an onlyOwner access modifier.\n\nTo change owner, the current owner must nominate the next owner,\nwho then has to accept the nomination. The nomination can be\ncancelled before it is accepted by the new owner by having the\nprevious owner change the nomination (setting it to 0).\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title A contract with an owner.\n * @notice Contract ownership can be transferred by first nominating the new owner,\n * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\n */\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    /**\n     * @dev Owned Constructor\n     */\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    /**\n     * @notice Nominate a new owner of this contract.\n     * @dev Only the current owner may nominate a new owner.\n     */\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    /**\n     * @notice Accept the nomination to be owner.\n     */\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       SelfDestructible.sol\nversion:    1.2\nauthor:     Anton Jurisevic\n\ndate:       2018-05-29\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThis contract allows an inheriting contract to be destroyed after\nits owner indicates an intention and then waits for a period\nwithout changing their mind. All ether contained in the contract\nis forwarded to a nominated beneficiary upon destruction.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title A contract that can be destroyed by its owner after a delay elapses.\n */\ncontract SelfDestructible is Owned {\n    uint public initiationTime;\n    bool public selfDestructInitiated;\n    address public selfDestructBeneficiary;\n    uint public constant SELFDESTRUCT_DELAY = 4 weeks;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        require(_owner != address(0), \"Owner must not be zero\");\n        selfDestructBeneficiary = _owner;\n        emit SelfDestructBeneficiaryUpdated(_owner);\n    }\n\n    /**\n     * @notice Set the beneficiary address of this contract.\n     * @dev Only the contract owner may call this. The provided beneficiary must be non-null.\n     * @param _beneficiary The address to pay any eth contained in this contract to upon self-destruction.\n     */\n    function setSelfDestructBeneficiary(address _beneficiary) external onlyOwner {\n        require(_beneficiary != address(0), \"Beneficiary must not be zero\");\n        selfDestructBeneficiary = _beneficiary;\n        emit SelfDestructBeneficiaryUpdated(_beneficiary);\n    }\n\n    /**\n     * @notice Begin the self-destruction counter of this contract.\n     * Once the delay has elapsed, the contract may be self-destructed.\n     * @dev Only the contract owner may call this.\n     */\n    function initiateSelfDestruct() external onlyOwner {\n        initiationTime = now;\n        selfDestructInitiated = true;\n        emit SelfDestructInitiated(SELFDESTRUCT_DELAY);\n    }\n\n    /**\n     * @notice Terminate and reset the self-destruction timer.\n     * @dev Only the contract owner may call this.\n     */\n    function terminateSelfDestruct() external onlyOwner {\n        initiationTime = 0;\n        selfDestructInitiated = false;\n        emit SelfDestructTerminated();\n    }\n\n    /**\n     * @notice If the self-destruction delay has elapsed, destroy this contract and\n     * remit any ether it owns to the beneficiary address.\n     * @dev Only the contract owner may call this.\n     */\n    function selfDestruct() external onlyOwner {\n        require(selfDestructInitiated, \"Self Destruct not yet initiated\");\n        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay not met\");\n        address beneficiary = selfDestructBeneficiary;\n        emit SelfDestructed(beneficiary);\n        selfdestruct(beneficiary);\n    }\n\n    event SelfDestructTerminated();\n    event SelfDestructed(address beneficiary);\n    event SelfDestructInitiated(uint selfDestructDelay);\n    event SelfDestructBeneficiaryUpdated(address newBeneficiary);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Pausable.sol\nversion:    1.0\nauthor:     Kevin Brown\n\ndate:       2018-05-22\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThis contract allows an inheriting contract to be marked as\npaused. It also defines a modifier which can be used by the\ninheriting contract to prevent actions while paused.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title A contract that can be paused by its owner\n */\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath.mul Error\");\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"SafeMath.div Error\"); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath.sub Error\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath.add Error\");\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath.mod Error\");\n    return a % b;\n  }\n}\n\n\n/*\n\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       SafeDecimalMath.sol\nversion:    2.0\nauthor:     Kevin Brown\n            Gavin Conway\ndate:       2018-10-18\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA library providing safe mathematical operations for division and\nmultiplication with the capability to round or truncate the results\nto the nearest increment. Operations can return a standard precision\nor high precision decimal. High precision decimals are useful for\nexample when attempting to calculate percentages or fractions\naccurately.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title Safely manipulate unsigned fixed-point decimals at a given precision level.\n * @dev Functions accepting uints in this contract and derived contracts\n * are taken to be such fixed point decimals of a specified precision (either standard\n * or high).\n */\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /** \n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /** \n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     * \n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     * \n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\n\ninterface ISynth {\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(address from, address to, uint value) external returns (bool);\n\n    function balanceOf(address owner) external view returns (uint);\n}\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(address from, address to, uint value) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n/**\n * @title ExchangeRates interface\n */\ninterface IExchangeRates {\n    function effectiveValue(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function ratesForCurrencies(bytes32[] currencyKeys) external view returns (uint[] memory);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\n\n    function anyRateIsStale(bytes32[] currencyKeys) external view returns (bool);\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function ratesAndStaleForCurrencies(bytes32[] currencyKeys) external view returns (uint[], bool);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n}\n\n\ncontract AddressResolver is Owned {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] names, address[] destinations) public onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            repository[names[i]] = destinations[i];\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getAddress(bytes32 name) public view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string reason) public view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n}\n\n\ncontract MixinResolver is Owned {\n    AddressResolver public resolver;\n\n    constructor(address _owner, address _resolver) public Owned(_owner) {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== SETTERS ========== */\n\n    function setResolver(AddressResolver _resolver) public onlyOwner {\n        resolver = _resolver;\n    }\n}\n\n\ncontract Depot is SelfDestructible, Pausable, ReentrancyGuard, MixinResolver {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 constant SNX = \"SNX\";\n    bytes32 constant ETH = \"ETH\";\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address where the ether and Synths raised for selling SNX is transfered to\n    // Any ether raised for selling Synths gets sent back to whoever deposited the Synths,\n    // and doesn't have anything to do with this address.\n    address public fundsWallet;\n\n    /* Stores deposits from users. */\n    struct synthDeposit {\n        // The user that made the deposit\n        address user;\n        // The amount (in Synths) that they deposited\n        uint amount;\n    }\n\n    /* User deposits are sold on a FIFO (First in First out) basis. When users deposit\n       synths with us, they get added this queue, which then gets fulfilled in order.\n       Conceptually this fits well in an array, but then when users fill an order we\n       end up copying the whole array around, so better to use an index mapping instead\n       for gas performance reasons.\n\n       The indexes are specified (inclusive, exclusive), so (0, 0) means there's nothing\n       in the array, and (3, 6) means there are 3 elements at 3, 4, and 5. You can obtain\n       the length of the \"array\" by querying depositEndIndex - depositStartIndex. All index\n       operations use safeAdd, so there is no way to overflow, so that means there is a\n       very large but finite amount of deposits this contract can handle before it fills up. */\n    mapping(uint => synthDeposit) public deposits;\n    // The starting index of our queue inclusive\n    uint public depositStartIndex;\n    // The ending index of our queue exclusive\n    uint public depositEndIndex;\n\n    /* This is a convenience variable so users and dApps can just query how much sUSD\n       we have available for purchase without having to iterate the mapping with a\n       O(n) amount of calls for something we'll probably want to display quite regularly. */\n    uint public totalSellableDeposits;\n\n    // The minimum amount of sUSD required to enter the FiFo queue\n    uint public minimumDepositAmount = 50 * SafeDecimalMath.unit();\n\n    // A cap on the amount of sUSD you can buy with ETH in 1 transaction\n    uint public maxEthPurchase = 500 * SafeDecimalMath.unit();\n\n    // If a user deposits a synth amount < the minimumDepositAmount the contract will keep\n    // the total of small deposits which will not be sold on market and the sender\n    // must call withdrawMyDepositedSynths() to get them back.\n    mapping(address => uint) public smallDeposits;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        // Ownable\n        address _owner,\n        // Funds Wallet\n        address _fundsWallet,\n        // Address Resolver\n        address _resolver\n    )\n        public\n        /* Owned is initialised in SelfDestructible */\n        SelfDestructible(_owner)\n        Pausable(_owner)\n        MixinResolver(_owner, _resolver)\n    {\n        fundsWallet = _fundsWallet;\n    }\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEthPurchase(uint _maxEthPurchase) external onlyOwner {\n        maxEthPurchase = _maxEthPurchase;\n        emit MaxEthPurchaseUpdated(maxEthPurchase);\n    }\n\n    /**\n     * @notice Set the funds wallet where ETH raised is held\n     * @param _fundsWallet The new address to forward ETH and Synths to\n     */\n    function setFundsWallet(address _fundsWallet) external onlyOwner {\n        fundsWallet = _fundsWallet;\n        emit FundsWalletUpdated(fundsWallet);\n    }\n\n    /**\n     * @notice Set the minimum deposit amount required to depoist sUSD into the FIFO queue\n     * @param _amount The new new minimum number of sUSD required to deposit\n     */\n    function setMinimumDepositAmount(uint _amount) external onlyOwner {\n        // Do not allow us to set it less than 1 dollar opening up to fractional desposits in the queue again\n        require(_amount > SafeDecimalMath.unit(), \"Minimum deposit amount must be greater than UNIT\");\n        minimumDepositAmount = _amount;\n        emit MinimumDepositAmountUpdated(minimumDepositAmount);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Fallback function (exchanges ETH to sUSD)\n     */\n    function() external payable {\n        exchangeEtherForSynths();\n    }\n\n    /**\n     * @notice Exchange ETH to sUSD.\n     */\n    function exchangeEtherForSynths()\n        public\n        payable\n        nonReentrant\n        rateNotStale(ETH)\n        notPaused\n        returns (\n            uint // Returns the number of Synths (sUSD) received\n        )\n    {\n        require(msg.value <= maxEthPurchase, \"ETH amount above maxEthPurchase limit\");\n        uint ethToSend;\n\n        // The multiplication works here because exchangeRates().rateForCurrency(ETH) is specified in\n        // 18 decimal places, just like our currency base.\n        uint requestedToPurchase = msg.value.multiplyDecimal(exchangeRates().rateForCurrency(ETH));\n        uint remainingToFulfill = requestedToPurchase;\n\n        // Iterate through our outstanding deposits and sell them one at a time.\n        for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n            synthDeposit memory deposit = deposits[i];\n\n            // If it's an empty spot in the queue from a previous withdrawal, just skip over it and\n            // update the queue. It's already been deleted.\n            if (deposit.user == address(0)) {\n                depositStartIndex = depositStartIndex.add(1);\n            } else {\n                // If the deposit can more than fill the order, we can do this\n                // without touching the structure of our queue.\n                if (deposit.amount > remainingToFulfill) {\n                    // Ok, this deposit can fulfill the whole remainder. We don't need\n                    // to change anything about our queue we can just fulfill it.\n                    // Subtract the amount from our deposit and total.\n                    uint newAmount = deposit.amount.sub(remainingToFulfill);\n                    deposits[i] = synthDeposit({user: deposit.user, amount: newAmount});\n\n                    totalSellableDeposits = totalSellableDeposits.sub(remainingToFulfill);\n\n                    // Transfer the ETH to the depositor. Send is used instead of transfer\n                    // so a non payable contract won't block the FIFO queue on a failed\n                    // ETH payable for synths transaction. The proceeds to be sent to the\n                    // synthetix foundation funds wallet. This is to protect all depositors\n                    // in the queue in this rare case that may occur.\n                    ethToSend = remainingToFulfill.divideDecimal(exchangeRates().rateForCurrency(ETH));\n\n                    // We need to use send here instead of transfer because transfer reverts\n                    // if the recipient is a non-payable contract. Send will just tell us it\n                    // failed by returning false at which point we can continue.\n                    // solium-disable-next-line security/no-send\n                    if (!deposit.user.send(ethToSend)) {\n                        fundsWallet.transfer(ethToSend);\n                        emit NonPayableContract(deposit.user, ethToSend);\n                    } else {\n                        emit ClearedDeposit(msg.sender, deposit.user, ethToSend, remainingToFulfill, i);\n                    }\n\n                    // And the Synths to the recipient.\n                    // Note: Fees are calculated by the Synth contract, so when\n                    //       we request a specific transfer here, the fee is\n                    //       automatically deducted and sent to the fee pool.\n                    synthsUSD().transfer(msg.sender, remainingToFulfill);\n\n                    // And we have nothing left to fulfill on this order.\n                    remainingToFulfill = 0;\n                } else if (deposit.amount <= remainingToFulfill) {\n                    // We need to fulfill this one in its entirety and kick it out of the queue.\n                    // Start by kicking it out of the queue.\n                    // Free the storage because we can.\n                    delete deposits[i];\n                    // Bump our start index forward one.\n                    depositStartIndex = depositStartIndex.add(1);\n                    // We also need to tell our total it's decreased\n                    totalSellableDeposits = totalSellableDeposits.sub(deposit.amount);\n\n                    // Now fulfill by transfering the ETH to the depositor. Send is used instead of transfer\n                    // so a non payable contract won't block the FIFO queue on a failed\n                    // ETH payable for synths transaction. The proceeds to be sent to the\n                    // synthetix foundation funds wallet. This is to protect all depositors\n                    // in the queue in this rare case that may occur.\n                    ethToSend = deposit.amount.divideDecimal(exchangeRates().rateForCurrency(ETH));\n\n                    // We need to use send here instead of transfer because transfer reverts\n                    // if the recipient is a non-payable contract. Send will just tell us it\n                    // failed by returning false at which point we can continue.\n                    // solium-disable-next-line security/no-send\n                    if (!deposit.user.send(ethToSend)) {\n                        fundsWallet.transfer(ethToSend);\n                        emit NonPayableContract(deposit.user, ethToSend);\n                    } else {\n                        emit ClearedDeposit(msg.sender, deposit.user, ethToSend, deposit.amount, i);\n                    }\n\n                    // And the Synths to the recipient.\n                    // Note: Fees are calculated by the Synth contract, so when\n                    //       we request a specific transfer here, the fee is\n                    //       automatically deducted and sent to the fee pool.\n                    synthsUSD().transfer(msg.sender, deposit.amount);\n\n                    // And subtract the order from our outstanding amount remaining\n                    // for the next iteration of the loop.\n                    remainingToFulfill = remainingToFulfill.sub(deposit.amount);\n                }\n            }\n        }\n\n        // Ok, if we're here and 'remainingToFulfill' isn't zero, then\n        // we need to refund the remainder of their ETH back to them.\n        if (remainingToFulfill > 0) {\n            msg.sender.transfer(remainingToFulfill.divideDecimal(exchangeRates().rateForCurrency(ETH)));\n        }\n\n        // How many did we actually give them?\n        uint fulfilled = requestedToPurchase.sub(remainingToFulfill);\n\n        if (fulfilled > 0) {\n            // Now tell everyone that we gave them that many (only if the amount is greater than 0).\n            emit Exchange(\"ETH\", msg.value, \"sUSD\", fulfilled);\n        }\n\n        return fulfilled;\n    }\n\n    /**\n     * @notice Exchange ETH to sUSD while insisting on a particular rate. This allows a user to\n     *         exchange while protecting against frontrunning by the contract owner on the exchange rate.\n     * @param guaranteedRate The exchange rate (ether price) which must be honored or the call will revert.\n     */\n    function exchangeEtherForSynthsAtRate(uint guaranteedRate)\n        public\n        payable\n        rateNotStale(ETH)\n        notPaused\n        returns (\n            uint // Returns the number of Synths (sUSD) received\n        )\n    {\n        require(guaranteedRate == exchangeRates().rateForCurrency(ETH), \"Guaranteed rate would not be received\");\n\n        return exchangeEtherForSynths();\n    }\n\n    /**\n     * @notice Exchange ETH to SNX.\n     */\n    function exchangeEtherForSNX()\n        public\n        payable\n        rateNotStale(SNX)\n        rateNotStale(ETH)\n        notPaused\n        returns (\n            uint // Returns the number of SNX received\n        )\n    {\n        // How many SNX are they going to be receiving?\n        uint synthetixToSend = synthetixReceivedForEther(msg.value);\n\n        // Store the ETH in our funds wallet\n        fundsWallet.transfer(msg.value);\n\n        // And send them the SNX.\n        synthetix().transfer(msg.sender, synthetixToSend);\n\n        emit Exchange(\"ETH\", msg.value, \"SNX\", synthetixToSend);\n\n        return synthetixToSend;\n    }\n\n    /**\n     * @notice Exchange ETH to SNX while insisting on a particular set of rates. This allows a user to\n     *         exchange while protecting against frontrunning by the contract owner on the exchange rates.\n     * @param guaranteedEtherRate The ether exchange rate which must be honored or the call will revert.\n     * @param guaranteedSynthetixRate The synthetix exchange rate which must be honored or the call will revert.\n     */\n    function exchangeEtherForSNXAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate)\n        public\n        payable\n        rateNotStale(SNX)\n        rateNotStale(ETH)\n        notPaused\n        returns (\n            uint // Returns the number of SNX received\n        )\n    {\n        require(guaranteedEtherRate == exchangeRates().rateForCurrency(ETH), \"Guaranteed ether rate would not be received\");\n        require(\n            guaranteedSynthetixRate == exchangeRates().rateForCurrency(SNX),\n            \"Guaranteed synthetix rate would not be received\"\n        );\n\n        return exchangeEtherForSNX();\n    }\n\n    /**\n     * @notice Exchange sUSD for SNX\n     * @param synthAmount The amount of synths the user wishes to exchange.\n     */\n    function exchangeSynthsForSNX(uint synthAmount)\n        public\n        rateNotStale(SNX)\n        notPaused\n        returns (\n            uint // Returns the number of SNX received\n        )\n    {\n        // How many SNX are they going to be receiving?\n        uint synthetixToSend = synthetixReceivedForSynths(synthAmount);\n\n        // Ok, transfer the Synths to our funds wallet.\n        // These do not go in the deposit queue as they aren't for sale as such unless\n        // they're sent back in from the funds wallet.\n        synthsUSD().transferFrom(msg.sender, fundsWallet, synthAmount);\n\n        // And send them the SNX.\n        synthetix().transfer(msg.sender, synthetixToSend);\n\n        emit Exchange(\"sUSD\", synthAmount, \"SNX\", synthetixToSend);\n\n        return synthetixToSend;\n    }\n\n    /**\n     * @notice Exchange sUSD for SNX while insisting on a particular rate. This allows a user to\n     *         exchange while protecting against frontrunning by the contract owner on the exchange rate.\n     * @param synthAmount The amount of synths the user wishes to exchange.\n     * @param guaranteedRate A rate (synthetix price) the caller wishes to insist upon.\n     */\n    function exchangeSynthsForSNXAtRate(uint synthAmount, uint guaranteedRate)\n        public\n        rateNotStale(SNX)\n        notPaused\n        returns (\n            uint // Returns the number of SNX received\n        )\n    {\n        require(guaranteedRate == exchangeRates().rateForCurrency(SNX), \"Guaranteed rate would not be received\");\n\n        return exchangeSynthsForSNX(synthAmount);\n    }\n\n    /**\n     * @notice Allows the owner to withdraw SNX from this contract if needed.\n     * @param amount The amount of SNX to attempt to withdraw (in 18 decimal places).\n     */\n    function withdrawSynthetix(uint amount) external onlyOwner {\n        synthetix().transfer(owner, amount);\n\n        // We don't emit our own events here because we assume that anyone\n        // who wants to watch what the Depot is doing can\n        // just watch ERC20 events from the Synth and/or Synthetix contracts\n        // filtered to our address.\n    }\n\n    /**\n     * @notice Allows a user to withdraw all of their previously deposited synths from this contract if needed.\n     *         Developer note: We could keep an index of address to deposits to make this operation more efficient\n     *         but then all the other operations on the queue become less efficient. It's expected that this\n     *         function will be very rarely used, so placing the inefficiency here is intentional. The usual\n     *         use case does not involve a withdrawal.\n     */\n    function withdrawMyDepositedSynths() external {\n        uint synthsToSend = 0;\n\n        for (uint i = depositStartIndex; i < depositEndIndex; i++) {\n            synthDeposit memory deposit = deposits[i];\n\n            if (deposit.user == msg.sender) {\n                // The user is withdrawing this deposit. Remove it from our queue.\n                // We'll just leave a gap, which the purchasing logic can walk past.\n                synthsToSend = synthsToSend.add(deposit.amount);\n                delete deposits[i];\n                //Let the DApps know we've removed this deposit\n                emit SynthDepositRemoved(deposit.user, deposit.amount, i);\n            }\n        }\n\n        // Update our total\n        totalSellableDeposits = totalSellableDeposits.sub(synthsToSend);\n\n        // Check if the user has tried to send deposit amounts < the minimumDepositAmount to the FIFO\n        // queue which would have been added to this mapping for withdrawal only\n        synthsToSend = synthsToSend.add(smallDeposits[msg.sender]);\n        smallDeposits[msg.sender] = 0;\n\n        // If there's nothing to do then go ahead and revert the transaction\n        require(synthsToSend > 0, \"You have no deposits to withdraw.\");\n\n        // Send their deposits back to them (minus fees)\n        synthsUSD().transfer(msg.sender, synthsToSend);\n\n        emit SynthWithdrawal(msg.sender, synthsToSend);\n    }\n\n    /**\n     * @notice depositSynths: Allows users to deposit synths via the approve / transferFrom workflow\n     * @param amount The amount of sUSD you wish to deposit (must have been approved first)\n     */\n    function depositSynths(uint amount) external {\n        // Grab the amount of synths. Will fail if not approved first\n        synthsUSD().transferFrom(msg.sender, this, amount);\n\n        // A minimum deposit amount is designed to protect purchasers from over paying\n        // gas for fullfilling multiple small synth deposits\n        if (amount < minimumDepositAmount) {\n            // We cant fail/revert the transaction or send the synths back in a reentrant call.\n            // So we will keep your synths balance seperate from the FIFO queue so you can withdraw them\n            smallDeposits[msg.sender] = smallDeposits[msg.sender].add(amount);\n\n            emit SynthDepositNotAccepted(msg.sender, amount, minimumDepositAmount);\n        } else {\n            // Ok, thanks for the deposit, let's queue it up.\n            deposits[depositEndIndex] = synthDeposit({user: msg.sender, amount: amount});\n            emit SynthDeposit(msg.sender, amount, depositEndIndex);\n\n            // Walk our index forward as well.\n            depositEndIndex = depositEndIndex.add(1);\n\n            // And add it to our total.\n            totalSellableDeposits = totalSellableDeposits.add(amount);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Calculate how many SNX you will receive if you transfer\n     *         an amount of synths.\n     * @param amount The amount of synths (in 18 decimal places) you want to ask about\n     */\n    function synthetixReceivedForSynths(uint amount) public view returns (uint) {\n        // And what would that be worth in SNX based on the current price?\n        return amount.divideDecimal(exchangeRates().rateForCurrency(SNX));\n    }\n\n    /**\n     * @notice Calculate how many SNX you will receive if you transfer\n     *         an amount of ether.\n     * @param amount The amount of ether (in wei) you want to ask about\n     */\n    function synthetixReceivedForEther(uint amount) public view returns (uint) {\n        // How much is the ETH they sent us worth in sUSD (ignoring the transfer fee)?\n        uint valueSentInSynths = amount.multiplyDecimal(exchangeRates().rateForCurrency(ETH));\n\n        // Now, how many SNX will that USD amount buy?\n        return synthetixReceivedForSynths(valueSentInSynths);\n    }\n\n    /**\n     * @notice Calculate how many synths you will receive if you transfer\n     *         an amount of ether.\n     * @param amount The amount of ether (in wei) you want to ask about\n     */\n    function synthsReceivedForEther(uint amount) public view returns (uint) {\n        // How many synths would that amount of ether be worth?\n        return amount.multiplyDecimal(exchangeRates().rateForCurrency(ETH));\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function synthsUSD() internal view returns (ISynth) {\n        return ISynth(resolver.requireAndGetAddress(\"SynthsUSD\", \"Missing SynthsUSD address\"));\n    }\n\n    function synthetix() internal view returns (IERC20) {\n        return IERC20(resolver.requireAndGetAddress(\"Synthetix\", \"Missing Synthetix address\"));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(resolver.requireAndGetAddress(\"ExchangeRates\", \"Missing ExchangeRates address\"));\n    }\n\n    // ========== MODIFIERS ==========\n\n    modifier rateNotStale(bytes32 currencyKey) {\n        require(!exchangeRates().rateIsStale(currencyKey), \"Rate stale or not a synth\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event MaxEthPurchaseUpdated(uint amount);\n    event FundsWalletUpdated(address newFundsWallet);\n    event Exchange(string fromCurrency, uint fromAmount, string toCurrency, uint toAmount);\n    event SynthWithdrawal(address user, uint amount);\n    event SynthDeposit(address indexed user, uint amount, uint indexed depositIndex);\n    event SynthDepositRemoved(address indexed user, uint amount, uint indexed depositIndex);\n    event SynthDepositNotAccepted(address user, uint amount, uint minimum);\n    event MinimumDepositAmountUpdated(uint amount);\n    event NonPayableContract(address indexed receiver, uint amount);\n    event ClearedDeposit(\n        address indexed fromAddress,\n        address indexed toAddress,\n        uint fromETHAmount,\n        uint toAmount,\n        uint indexed depositIndex\n    );\n}\n\n\n    ","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"exchangeEtherForSNX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumDepositAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guaranteedRate\",\"type\":\"uint256\"}],\"name\":\"exchangeEtherForSynthsAtRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"synthsReceivedForEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initiationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeEtherForSynths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setSelfDestructBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundsWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminateSelfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSellableDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundsWallet\",\"type\":\"address\"}],\"name\":\"setFundsWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositStartIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawMyDepositedSynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guaranteedEtherRate\",\"type\":\"uint256\"},{\"name\":\"guaranteedSynthetixRate\",\"type\":\"uint256\"}],\"name\":\"exchangeEtherForSNXAtRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"synthetixReceivedForSynths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SELFDESTRUCT_DELAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMinimumDepositAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"synthAmount\",\"type\":\"uint256\"},{\"name\":\"guaranteedRate\",\"type\":\"uint256\"}],\"name\":\"exchangeSynthsForSNXAtRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxEthPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructInitiated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxEthPurchase\",\"type\":\"uint256\"}],\"name\":\"setMaxEthPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initiateSelfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"smallDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"synthetixReceivedForEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositSynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSynthetix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"synthAmount\",\"type\":\"uint256\"}],\"name\":\"exchangeSynthsForSNX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositEndIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_fundsWallet\",\"type\":\"address\"},{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxEthPurchaseUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFundsWallet\",\"type\":\"address\"}],\"name\":\"FundsWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromCurrency\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toCurrency\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"toAmount\",\"type\":\"uint256\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SynthWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"depositIndex\",\"type\":\"uint256\"}],\"name\":\"SynthDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"depositIndex\",\"type\":\"uint256\"}],\"name\":\"SynthDepositRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minimum\",\"type\":\"uint256\"}],\"name\":\"SynthDepositNotAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinimumDepositAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NonPayableContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fromETHAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"depositIndex\",\"type\":\"uint256\"}],\"name\":\"ClearedDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SelfDestructTerminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"selfDestructDelay\",\"type\":\"uint256\"}],\"name\":\"SelfDestructInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructBeneficiaryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"Depot","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b64ff7a4a33acdf48d97dab0d764afd0f6176882000000000000000000000000b64ff7a4a33acdf48d97dab0d764afd0f6176882000000000000000000000000fbb6526ed92da8915d4843a86166020d0b7baad0","Library":"SafeDecimalMath:84d626b2bb4d0f064067e4bf80fce7055d8f3e7b","LicenseType":"","SwarmSource":""}]}