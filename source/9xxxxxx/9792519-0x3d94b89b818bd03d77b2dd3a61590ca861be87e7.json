{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with buidler v1.2.0 https://buidler.dev\n\n// File @pie-dao/proxy/contracts/PProxyStorage.sol@v0.0.6\n\npragma solidity ^0.6.2;\n\ncontract PProxyStorage {\n\n    function readString(bytes32 _key) public view returns(string memory) {\n        return bytes32ToString(storageRead(_key));\n    }\n\n    function setString(bytes32 _key, string memory _value) internal {\n        storageSet(_key, stringToBytes32(_value));\n    }\n\n    function readBool(bytes32 _key) public view returns(bool) {\n        return storageRead(_key) == bytes32(uint256(1));\n    }\n\n    function setBool(bytes32 _key, bool _value) internal {\n        if(_value) {\n            storageSet(_key, bytes32(uint256(1)));\n        } else {\n            storageSet(_key, bytes32(uint256(0)));\n        }\n    }\n\n    function readAddress(bytes32 _key) public view returns(address) {\n        return bytes32ToAddress(storageRead(_key));\n    }\n\n    function setAddress(bytes32 _key, address _value) internal {\n        storageSet(_key, addressToBytes32(_value));\n    }\n\n    function storageRead(bytes32 _key) public view returns(bytes32) {\n        bytes32 value;\n        //solium-disable-next-line security/no-inline-assembly\n        assembly {\n            value := sload(_key)\n        }\n        return value;\n    }\n\n    function storageSet(bytes32 _key, bytes32 _value) internal {\n        // targetAddress = _address;  // No!\n        bytes32 implAddressStorageKey = _key;\n        //solium-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(implAddressStorageKey, _value)\n        }\n    }\n\n    function bytes32ToAddress(bytes32 _value) public pure returns(address) {\n        return address(uint160(uint256(_value)));\n    }\n\n    function addressToBytes32(address _value) public pure returns(bytes32) {\n        return bytes32(uint256(_value));\n    }\n\n    function stringToBytes32(string memory _value) public pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(_value);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(_value, 32))\n        }\n    }\n\n    function bytes32ToString(bytes32 _value) public pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint charCount = 0;\n        for (uint256 j = 0; j < 32; j++) {\n            byte char = byte(bytes32(uint(_value) * 2 ** (8 * j)));\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 j = 0; j < charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }\n}\n\n\n// File @pie-dao/proxy/contracts/PProxy.sol@v0.0.6\n\npragma solidity ^0.6.2;\n\n\ncontract PProxy is PProxyStorage {\n\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(abi.encodePacked(\"IMPLEMENTATION_SLOT\"));\n    bytes32 constant OWNER_SLOT = keccak256(abi.encodePacked(\"OWNER_SLOT\"));\n\n    modifier onlyProxyOwner() {\n        require(msg.sender == readAddress(OWNER_SLOT), \"PProxy.onlyProxyOwner: msg sender not owner\");\n        _;\n    }\n\n    constructor () public {\n        setAddress(OWNER_SLOT, msg.sender);\n    }\n\n    function getProxyOwner() public view returns (address) {\n       return readAddress(OWNER_SLOT);\n    }\n\n    function setProxyOwner(address _newOwner) onlyProxyOwner public {\n        setAddress(OWNER_SLOT, _newOwner);\n    }\n\n    function getImplementation() public view returns (address) {\n        return readAddress(IMPLEMENTATION_SLOT);\n    }\n\n    function setImplementation(address _newImplementation) onlyProxyOwner public {\n        setAddress(IMPLEMENTATION_SLOT, _newImplementation);\n    }\n\n\n    fallback () external payable {\n       return internalFallback();\n    }\n\n    function internalFallback() internal virtual {\n        address contractAddr = readAddress(IMPLEMENTATION_SLOT);\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), contractAddr, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n\n}\n\n\n// File @pie-dao/proxy/contracts/PProxyPausable.sol@v0.0.6\n\npragma solidity ^0.6.2;\n\n\ncontract PProxyPausable is PProxy {\n\n    bytes32 constant PAUSED_SLOT = keccak256(abi.encodePacked(\"PAUSED_SLOT\"));\n    bytes32 constant PAUZER_SLOT = keccak256(abi.encodePacked(\"PAUZER_SLOT\"));\n\n    constructor() PProxy() public {\n        setAddress(PAUZER_SLOT, msg.sender);\n    }\n\n    modifier onlyPauzer() {\n        require(msg.sender == readAddress(PAUZER_SLOT), \"PProxyPausable.onlyPauzer: msg sender not pauzer\");\n        _;\n    }\n\n    modifier notPaused() {\n        require(!readBool(PAUSED_SLOT), \"PProxyPausable.notPaused: contract is paused\");\n        _;\n    }\n\n    function getPauzer() public view returns (address) {\n        return readAddress(PAUZER_SLOT);\n    }\n\n    function setPauzer(address _newPauzer) public onlyProxyOwner{\n        setAddress(PAUZER_SLOT, _newPauzer);\n    }\n\n    function renouncePauzer() public onlyPauzer {\n        setAddress(PAUZER_SLOT, address(0));\n    }\n\n    function getPaused() public view returns (bool) {\n        return readBool(PAUSED_SLOT);\n    }\n\n    function setPaused(bool _value) public onlyPauzer {\n        setBool(PAUSED_SLOT, _value);\n    }\n\n    function internalFallback() internal virtual override notPaused {\n        super.internalFallback();\n    }\n\n}\n\n\n// File contracts/interfaces/IBFactory.sol\n\npragma solidity ^0.6.4;\n\ninterface IBFactory {\n    function newBPool() external returns (address);\n}\n\n\n// File contracts/interfaces/IBPool.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is disstributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.6.4;\n\ninterface IBPool {\n    function isBound(address token) external view returns(bool);\n    function getBalance(address token) external view returns (uint);\n    function rebind(address token, uint balance, uint denorm) external;\n    function setSwapFee(uint swapFee) external;\n    function setPublicSwap(bool _public) external;\n    function bind(address token, uint balance, uint denorm) external;\n    function unbind(address token) external;\n    function getDenormalizedWeight(address token) external view returns (uint);\n    function getTotalDenormalizedWeight() external view returns (uint);\n    function getCurrentTokens() external view returns(address[] memory);\n    function setController(address manager) external;\n    function isPublicSwap() external view returns(bool);\n    function getSwapFee() external view returns (uint256);\n    function gulp(address token) external;\n\n    function calcPoolOutGivenSingleIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        external pure\n        returns (uint poolAmountOut);\n\n    function calcSingleInGivenPoolOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountOut,\n        uint swapFee\n    )\n        external pure\n        returns (uint tokenAmountIn);\n\n    function calcSingleOutGivenPoolIn(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountIn,\n        uint swapFee\n    )\n        external pure\n        returns (uint tokenAmountOut);\n\n    function calcPoolInGivenSingleOut(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        external pure\n        returns (uint poolAmountIn);\n}\n\n\n// File contracts/interfaces/IERC20.sol\n\npragma solidity ^0.6.4;\n\ninterface IERC20 {\n    event Approval(address indexed _src, address indexed _dst, uint _amount);\n    event Transfer(address indexed _src, address indexed _dst, uint _amount);\n\n    function totalSupply() external view returns (uint);\n    function balanceOf(address _whom) external view returns (uint);\n    function allowance(address _src, address _dst) external view returns (uint);\n\n    function approve(address _dst, uint _amount) external returns (bool);\n    function transfer(address _dst, uint _amount) external returns (bool);\n    function transferFrom(\n        address _src, address _dst, uint _amount\n    ) external returns (bool);\n}\n\n\n// File contracts/Ownable.sol\n\npragma solidity ^0.6.4;\n\n// TODO move this generic contract to a seperate repo with all generic smart contracts\n\ncontract Ownable {\n\n    bytes32 constant public oSlot = keccak256(\"Ownable.storage.location\");\n\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\n\n    // Ownable struct\n    struct os {\n        address owner;\n    }\n\n    modifier onlyOwner(){\n        require(msg.sender == los().owner, \"Ownable.onlyOwner: msg.sender not owner\");\n        _;\n    }\n\n    /**\n        @notice Transfer ownership to a new address\n        @param _newOwner Address of the new owner\n    */\n    function transferOwnership(address _newOwner) onlyOwner external {\n        _setOwner(_newOwner);\n    }\n\n    /**\n        @notice Internal method to set the owner\n        @param _newOwner Address of the new owner\n    */\n    function _setOwner(address _newOwner) internal {\n        emit OwnerChanged(los().owner, _newOwner);\n        los().owner = _newOwner;\n    }\n\n    /**\n        @notice Load ownable storage\n        @return s Storage pointer to the Ownable storage struct\n    */\n    function los() internal pure returns (os storage s) {\n        bytes32 loc = oSlot;\n        assembly {\n            s_slot := loc\n        }\n    }\n\n}\n\n\n// File contracts/interfaces/IPSmartPool.sol\n\npragma solidity ^0.6.4;\n\ninterface IPSmartPool is IERC20 {\n    function joinPool(uint256 _amount) external;\n    function exitPool(uint256 _amount) external;\n    function getController() external view returns(address);\n    function getTokens() external view returns(address[] memory);\n    function calcTokensForAmount(uint256 _amount) external view  returns(address[] memory tokens, uint256[] memory amounts);\n}\n\n\n// File contracts/PCTokenStorage.sol\n\npragma solidity ^0.6.4;\n\ncontract PCTokenStorage {\n\n    bytes32 constant public ptSlot = keccak256(\"PCToken.storage.location\");\n    struct pts {\n        string name;\n        string symbol;\n        uint256 totalSupply;\n        mapping(address => uint256) balance;\n        mapping(address => mapping(address=>uint256)) allowance;\n    }\n\n    /**\n        @notice Load pool token storage\n        @return s Storage pointer to the pool token struct\n    */\n    function lpts() internal pure returns (pts storage s) {\n        bytes32 loc = ptSlot;\n        assembly {\n            s_slot := loc\n        }\n    }\n\n}\n\n\n// File contracts/PCToken.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.4;\n\n\n\n// Highly opinionated token implementation\n// Based on the balancer Implementation\n\n\ncontract PCToken is IERC20, PCTokenStorage {\n\n    event Approval(address indexed _src, address indexed _dst, uint _amount);\n    event Transfer(address indexed _src, address indexed _dst, uint _amount);\n\n    uint8 public constant decimals = 18;\n    uint public constant BONE              = 10**18;\n    uint public constant MAX_BOUND_TOKENS  = 8;\n    uint public constant MIN_WEIGHT        = BONE;\n    uint public constant MAX_WEIGHT        = BONE * 50;\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\n    uint public constant MIN_BALANCE       = BONE / 10**6;\n    uint public constant MAX_BALANCE       = BONE * 10**12;\n\n    uint public constant MIN_POOL_SUPPLY   = BONE;\n\n    function badd(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        (uint c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint a, uint b)\n        internal pure\n        returns (uint, bool)\n    {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint c2 = c1 / b;\n        return c2;\n    }\n\n    function _mint(uint _amount) internal {\n        pts storage s = lpts();\n        s.balance[address(this)] = badd(s.balance[address(this)], _amount);\n        s.totalSupply = badd(s.totalSupply, _amount);\n        emit Transfer(address(0), address(this), _amount);\n    }\n\n    function _burn(uint _amount) internal {\n        pts storage s = lpts();\n        require(s.balance[address(this)] >= _amount, \"ERR_INSUFFICIENT_BAL\");\n        s.balance[address(this)] = bsub(s.balance[address(this)], _amount);\n        s.totalSupply = bsub(s.totalSupply, _amount);\n        emit Transfer(address(this), address(0), _amount);\n    }\n\n    function _move(address _src, address _dst, uint _amount) internal {\n        pts storage s = lpts();\n        require(s.balance[_src] >= _amount, \"ERR_INSUFFICIENT_BAL\");\n        s.balance[_src] = bsub(s.balance[_src], _amount);\n        s.balance[_dst] = badd(s.balance[_dst], _amount);\n        emit Transfer(_src, _dst, _amount);\n    }\n\n    function _push(address _to, uint _amount) internal {\n        _move(address(this), _to, _amount);\n    }\n\n    function _pull(address _from, uint _amount) internal {\n        _move(_from, address(this), _amount);\n    }\n\n    function allowance(address _src, address _dst) external view override returns (uint) {\n        return lpts().allowance[_src][_dst];\n    }\n\n    function balanceOf(address _whom) external view override returns (uint) {\n        return lpts().balance[_whom];\n    }\n\n    function totalSupply() public view override returns (uint) {\n        return lpts().totalSupply;\n    }\n\n    function name() external view returns (string memory) {\n        return lpts().name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return lpts().symbol;\n    }\n\n    function approve(address _dst, uint _amount) external override returns (bool) {\n        lpts().allowance[msg.sender][_dst] = _amount;\n        emit Approval(msg.sender, _dst, _amount);\n        return true;\n    }\n\n    function increaseApproval(address _dst, uint _amount) external returns (bool) {\n        pts storage s = lpts();\n        s.allowance[msg.sender][_dst] = badd(s.allowance[msg.sender][_dst], _amount);\n        emit Approval(msg.sender, _dst, s.allowance[msg.sender][_dst]);\n        return true;\n    }\n\n    function decreaseApproval(address _dst, uint _amount) external returns (bool) {\n        pts storage s = lpts();\n        uint oldValue = s.allowance[msg.sender][_dst];\n        if (_amount > oldValue) {\n            s.allowance[msg.sender][_dst] = 0;\n        } else {\n            s.allowance[msg.sender][_dst] = bsub(oldValue, _amount);\n        }\n        emit Approval(msg.sender, _dst, s.allowance[msg.sender][_dst]);\n        return true;\n    }\n\n    function transfer(address _dst, uint _amount) external override returns (bool) {\n        _move(msg.sender, _dst, _amount);\n        return true;\n    }\n\n    function transferFrom(address _src, address _dst, uint _amount) external override returns (bool) {\n        pts storage s = lpts();\n        require(msg.sender == _src || _amount <= s.allowance[_src][msg.sender], \"ERR_PCTOKEN_BAD_CALLER\");\n        _move(_src, _dst, _amount);\n        if (msg.sender != _src && s.allowance[_src][msg.sender] != uint256(-1)) {\n            s.allowance[_src][msg.sender] = bsub(s.allowance[_src][msg.sender], _amount);\n            emit Approval(msg.sender, _dst, s.allowance[_src][msg.sender]);\n        }\n        return true;\n    }\n}\n\n\n// File contracts/ReentryProtection.sol\n\npragma solidity ^0.6.4;\n\n// TODO move this generic contract to a seperate repo with all generic smart contracts\n\ncontract ReentryProtection {\n\n    bytes32 constant public rpSlot = keccak256(\"ReentryProtection.storage.location\");\n\n    // reentry protection storage\n    struct rps {\n        uint256 lockCounter;\n    }\n\n    modifier noReentry {\n        // Use counter to only write to storage once\n        lrps().lockCounter ++;\n        uint256 lockValue = lrps().lockCounter;\n        _;\n        require(lockValue == lrps().lockCounter, \"ReentryProtection.noReentry: reentry detected\");\n    }\n\n    /**\n        @notice Load reentry protection storage\n        @return s Pointer to the reentry protection storage struct\n    */\n    function lrps() internal pure returns (rps storage s) {\n        bytes32 loc = rpSlot;\n        assembly {\n            s_slot := loc\n        }\n    }\n\n}\n\n\n// File contracts/smart-pools/PBasicSmartPool.sol\n\npragma solidity ^0.6.4;\n\n\n\n\n\ncontract PBasicSmartPool is IPSmartPool, PCToken, ReentryProtection {\n    \n    // P Basic Smart Struct\n    bytes32 constant public pbsSlot = keccak256(\"PBasicSmartPool.storage.location\");\n    struct pbs {\n        IBPool bPool;\n        address controller;\n        address publicSwapSetter;\n        address tokenBinder;\n    }\n    \n    modifier ready() {\n        require(address(lpbs().bPool) != address(0), \"PBasicSmartPool.ready: not ready\");\n        _;\n    }   \n\n     event LOG_JOIN(\n        address indexed caller,\n        address indexed tokenIn,\n        uint256 tokenAmountIn\n    );\n\n    event LOG_EXIT(\n        address indexed caller,\n        address indexed tokenOut,\n        uint256 tokenAmountOut\n    );\n\n    event TokensApproved();\n    event ControllerChanged(address indexed previousController, address indexed newController);\n    event PublicSwapSetterChanged(address indexed previousSetter, address indexed newSetter);\n    event TokenBinderChanged(address indexed previousTokenBinder, address indexed newTokenBinder);\n    event PublicSwapSet(address indexed setter, bool indexed value);\n    event SwapFeeSet(address indexed setter, uint256 newFee);\n    event PoolJoined(address indexed from, uint256 amount);\n    event PoolExited(address indexed from, uint256 amount);\n\n    modifier onlyController() {\n        require(msg.sender == lpbs().controller, \"PBasicSmartPool.onlyController: not controller\");\n        _;\n    }\n\n    modifier onlyPublicSwapSetter() {\n        require(msg.sender == lpbs().publicSwapSetter, \"PBasicSmartPool.onlyPublicSwapSetter: not public swap setter\");\n        _;\n    }\n\n    modifier onlyTokenBinder() {\n        require(msg.sender == lpbs().tokenBinder, \"PBasicSmartPool.onlyTokenBinder: not token binder\");\n        _;\n    }\n\n    /**\n        @notice Initialises the contract\n        @param _bPool Address of the underlying balancer pool\n        @param _name Name for the smart pool token\n        @param _symbol Symbol for the smart pool token\n        @param _initialSupply Initial token supply to mint\n    */\n    function init(address _bPool, string calldata _name, string calldata _symbol, uint256 _initialSupply) external {\n        pbs storage s = lpbs();\n        require(address(s.bPool) == address(0), \"PBasicSmartPool.init: already initialised\");\n        s.bPool = IBPool(_bPool);\n        s.controller = msg.sender;\n        s.publicSwapSetter = msg.sender;\n        s.tokenBinder = msg.sender;\n        lpts().name = _name;\n        lpts().symbol = _symbol;\n        _mintPoolShare(_initialSupply);\n        _pushPoolShare(msg.sender, _initialSupply);\n    }\n\n    /**\n        @notice Sets approval to all tokens to the underlying balancer pool\n        @dev It uses this function to save on gas in joinPool\n    */\n    function approveTokens() public {\n        IBPool bPool = lpbs().bPool;\n        address[] memory tokens = bPool.getCurrentTokens();\n        for(uint256 i = 0; i < tokens.length; i ++) {\n            IERC20(tokens[i]).approve(address(bPool), uint256(-1));\n        }\n        emit TokensApproved();\n    }\n\n    /**\n        @notice Sets the controller address. Can only be set by the current controller\n        @param _controller Address of the new controller\n    */\n    function setController(address _controller) onlyController noReentry external {\n        emit ControllerChanged(lpbs().controller, _controller);\n        lpbs().controller = _controller;\n    }\n\n    /**\n        @notice Sets public swap setter address. Can only be set by the controller\n        @param _newPublicSwapSetter Address of the new public swap setter\n    */\n    function setPublicSwapSetter(address _newPublicSwapSetter) onlyController external {\n        emit PublicSwapSetterChanged(lpbs().publicSwapSetter, _newPublicSwapSetter);\n        lpbs().publicSwapSetter = _newPublicSwapSetter;\n    }\n\n    /**\n        @notice Sets the token binder address. Can only be set by the controller\n        @param _newTokenBinder Address of the new token binder\n    */\n    function setTokenBinder(address _newTokenBinder) onlyController external {\n        emit TokenBinderChanged(lpbs().tokenBinder, _newTokenBinder);\n        lpbs().tokenBinder = _newTokenBinder;\n    }\n\n    /**\n        @notice Enables or disables public swapping on the underlying balancer pool. Can only be set by the controller\n        @param _public Public or not\n    */\n    function setPublicSwap(bool _public) onlyPublicSwapSetter external {\n        emit PublicSwapSet(msg.sender, _public);\n        lpbs().bPool.setPublicSwap(_public);\n    }\n\n    /**\n        @notice Set the swap fee on the underlying balancer pool. Can only be called by the controller\n        @param _swapFee The new swap fee\n    */\n    function setSwapFee(uint256 _swapFee) onlyController external {\n        emit SwapFeeSet(msg.sender, _swapFee);\n        lpbs().bPool.setSwapFee(_swapFee);\n    }\n\n    /** \n        @notice Mints pool shares in exchange for underlying assets\n        @param _amount Amount of pool shares to mint\n    */\n    function joinPool(uint256 _amount) external override virtual ready {\n        _joinPool(_amount);\n    }\n\n    /**\n        @notice Internal join pool function. See joinPool for more info\n        @param _amount Amount of pool shares to mint\n    */\n    function _joinPool(uint256 _amount) internal virtual ready {\n        IBPool bPool = lpbs().bPool;\n        uint poolTotal = totalSupply();\n        uint ratio = bdiv(_amount, poolTotal);\n        require(ratio != 0);\n\n        address[] memory tokens = bPool.getCurrentTokens();\n\n        for (uint i = 0; i < tokens.length; i++) {\n            address t = tokens[i];\n            uint bal = bPool.getBalance(t);\n            uint tokenAmountIn = bmul(ratio, bal);\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n            _pullUnderlying(t, msg.sender, tokenAmountIn, bal);\n        }\n        _mintPoolShare(_amount);\n        _pushPoolShare(msg.sender, _amount);\n        emit PoolJoined(msg.sender, _amount);\n    }\n\n    /** \n        @notice Burns pool shares and sends back the underlying assets\n        @param _amount Amount of pool tokens to burn\n    */\n    function exitPool(uint256 _amount) external override ready noReentry {\n        IBPool bPool = lpbs().bPool;\n        uint poolTotal = totalSupply();\n        uint ratio = bdiv(_amount, poolTotal);\n        require(ratio != 0);\n\n        _pullPoolShare(msg.sender, _amount);\n        _burnPoolShare(_amount);\n\n        address[] memory tokens = bPool.getCurrentTokens();\n\n        for (uint i = 0; i < tokens.length; i++) {\n            address t = tokens[i];\n            uint bal = bPool.getBalance(t);\n            uint tAo = bmul(ratio, bal);\n            emit LOG_EXIT(msg.sender, t, tAo);  \n            _pushUnderlying(t, msg.sender, tAo, bal);\n        }\n        emit PoolExited(msg.sender, _amount);\n    }\n\n    /**\n        @notice Bind a token to the underlying balancer pool. Can only be called by the token binder\n        @param _token Token to bind\n        @param _balance Amount to bind\n        @param _denorm Denormalised weight\n    */\n    function bind(address _token, uint256 _balance, uint256 _denorm) external onlyTokenBinder {\n        IBPool bPool = lpbs().bPool;\n        IERC20 token = IERC20(_token);\n        token.transferFrom(msg.sender, address(this), _balance);\n        token.approve(address(bPool), uint256(-1));\n        bPool.bind(_token, _balance, _denorm);\n    }\n\n    /**\n        @notice Rebind a token to the pool\n        @param _token Token to bind\n        @param _balance Amount to bind\n        @param _denorm Denormalised weight\n    */\n    function rebind(address _token, uint256 _balance, uint256 _denorm) external onlyTokenBinder {\n        IBPool bPool = lpbs().bPool;\n        IERC20 token = IERC20(_token);\n        \n        // gulp old non acounted for token balance in the contract\n        bPool.gulp(_token);\n\n        uint256 oldBalance = token.balanceOf(address(bPool));\n        // If tokens need to be pulled from msg.sender\n        if(_balance > oldBalance) {\n            token.transferFrom(msg.sender, address(this), bsub(_balance, oldBalance));\n            token.approve(address(bPool), uint256(-1));\n        }\n\n        bPool.rebind(_token, _balance, _denorm);\n\n        // If any tokens are in this contract send them to msg.sender\n        uint256 tokenBalance = token.balanceOf(address(this));\n        if(tokenBalance > 0) {\n            token.transfer(msg.sender, tokenBalance);\n        }\n    }\n\n    /**\n        @notice Unbind a token\n        @param _token Token to unbind\n    */\n    function unbind(address _token) external onlyTokenBinder {\n        IBPool bPool = lpbs().bPool;\n        IERC20 token = IERC20(_token);\n        // unbind the token in the bPool\n        bPool.unbind(_token);\n\n        // If any tokens are in this contract send them to msg.sender\n        uint256 tokenBalance = token.balanceOf(address(this));\n        if(tokenBalance > 0) {\n            token.transfer(msg.sender, tokenBalance);\n        }\n    }\n\n    function getTokens() external view override returns(address[] memory) {\n        return lpbs().bPool.getCurrentTokens();\n    }\n\n    /**\n        @notice Gets the underlying assets and amounts to mint specific pool shares.\n        @param _amount Amount of pool shares to calculate the values for\n        @return tokens The addresses of the tokens\n        @return amounts The amounts of tokens needed to mint that amount of pool shares\n    */\n    function calcTokensForAmount(uint256 _amount) external view override returns(address[] memory tokens, uint256[] memory amounts) {\n        tokens = lpbs().bPool.getCurrentTokens();\n        amounts = new uint256[](tokens.length);\n        uint256 ratio = bdiv(_amount, totalSupply());\n\n        for(uint256 i = 0; i < tokens.length; i ++) {\n            address t = tokens[i];\n            uint256 bal = lpbs().bPool.getBalance(t);\n            uint256 amount = bmul(ratio, bal);\n            amounts[i] = amount;\n        }\n    }\n\n    /** \n        @notice Get the address of the controller\n        @return The address of the pool\n    */\n    function getController() external view override returns(address) {\n        return lpbs().controller;\n    }\n\n    /** \n        @notice Get the address of the public swap setter\n        @return The public swap setter address\n    */\n    function getPublicSwapSetter() external view returns(address) {\n        return lpbs().publicSwapSetter;\n    }\n\n    /**\n        @notice Get the address of the token binder\n        @return The token binder address\n    */\n    function getTokenBinder() external view returns(address) {\n        return lpbs().tokenBinder;\n    }\n\n    /**\n        @notice Get if public swapping is enabled\n        @return If public swapping is enabled\n    */\n    function isPublicSwap() external view returns (bool) {\n        return lpbs().bPool.isPublicSwap();\n    }\n\n    /**\n        @notice Get the current swap fee\n        @return The current swap fee\n    */\n    function getSwapFee() external view returns (uint256) {\n        return lpbs().bPool.getSwapFee();\n    }\n\n    /**\n        @notice Get the address of the underlying Balancer pool\n        @return The address of the underlying balancer pool\n    */\n    function getBPool() external view returns(address) {\n        return address(lpbs().bPool);\n    }\n\n    /**\n        @notice Pull the underlying token from an address and rebind it to the balancer pool\n        @param _token Address of the token to pull\n        @param _from Address to pull the token from\n        @param _amount Amount of token to pull\n        @param _tokenBalance Balance of the token already in the balancer pool\n    */\n    function _pullUnderlying(address _token, address _from, uint256 _amount, uint256 _tokenBalance)\n        internal\n    {   \n        IBPool bPool = lpbs().bPool;\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\n        uint tokenWeight = bPool.getDenormalizedWeight(_token);\n\n        bool xfer = IERC20(_token).transferFrom(_from, address(this), _amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n        bPool.rebind(_token, badd(_tokenBalance, _amount), tokenWeight);\n    }\n\n    /** \n        @notice Push a underlying token and rebind the token to the balancer pool\n        @param _token Address of the token to push\n        @param _to Address to pull the token to\n        @param _amount Amount of token to push\n        @param _tokenBalance Balance of the token already in the balancer pool\n    */\n    function _pushUnderlying(address _token, address _to, uint256 _amount, uint256 _tokenBalance)\n        internal\n    {   \n        IBPool bPool = lpbs().bPool;\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\n        uint tokenWeight = bPool.getDenormalizedWeight(_token);\n        bPool.rebind(_token, bsub(_tokenBalance, _amount), tokenWeight);\n\n        bool xfer = IERC20(_token).transfer(_to, _amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    /**\n        @notice Pull pool shares\n        @param _from Address to pull pool shares from\n        @param _amount Amount of pool shares to pull\n    */\n    function _pullPoolShare(address _from, uint256 _amount)\n        internal\n    {\n        _pull(_from, _amount);\n    }\n\n    /**\n        @notice Burn pool shares\n        @param _amount Amount of pool shares to burn\n    */\n    function _burnPoolShare(uint256 _amount)\n        internal\n    {\n        _burn(_amount);\n    }\n\n    /** \n        @notice Mint pool shares \n        @param _amount Amount of pool shares to mint\n    */\n    function _mintPoolShare(uint256 _amount)\n        internal\n    {\n        _mint(_amount);\n    }\n\n    /**\n        @notice Push pool shares to account\n        @param _to Address to push the pool shares to\n        @param _amount Amount of pool shares to push\n    */\n    function _pushPoolShare(address _to, uint256 _amount)\n        internal\n    {\n        _push(_to, _amount);\n    }\n\n    /**\n        @notice Load PBasicPool storage\n        @return s Pointer to the storage struct\n    */\n    function lpbs() internal pure returns (pbs storage s) {\n        bytes32 loc = pbsSlot;\n        assembly {\n            s_slot := loc\n        }\n    }\n\n}\n\n\n// File contracts/smart-pools/PCappedSmartPool.sol\n\npragma solidity ^0.6.4;\n\ncontract PCappedSmartPool is PBasicSmartPool {\n\n    bytes32 constant public pcsSlot = keccak256(\"PCappedSmartPool.storage.location\");\n\n    event CapChanged(address indexed setter, uint256 oldCap, uint256 newCap);\n\n    struct pcs {\n        uint256 cap;\n    }\n\n    modifier withinCap() {\n        _;\n        require(totalSupply() < lpcs().cap, \"PCappedSmartPool.withinCap: Cap limit reached\");\n    }\n\n    /**\n        @notice Set the maximum cap of the contract\n        @param _cap New cap in wei\n    */\n    function setCap(uint256 _cap) onlyController external {\n        emit CapChanged(msg.sender, lpcs().cap, _cap);\n        lpcs().cap = _cap;\n    }\n\n    /**\n        @notice Takes underlying assets and mints smart pool tokens. Enforces the cap\n        @param _amount Amount of pool tokens to mint\n    */\n    function joinPool(uint256 _amount) external override withinCap {\n        super._joinPool(_amount);\n    }\n\n\n    /**\n        @notice Get the current cap\n        @return The current cap in wei\n    */\n    function getCap() external view returns(uint256) {\n        return lpcs().cap;\n    }\n\n    /**\n        @notice Load the PCappedSmartPool storage\n        @return s Pointer to the storage struct\n    */\n    function lpcs() internal pure returns (pcs storage s) {\n        bytes32 loc = pcsSlot;\n        assembly {\n            s_slot := loc\n        }\n    }\n\n}\n\n\n// File contracts/factory/PProxiedFactory.sol\n\npragma solidity ^0.6.4;\n\n\n\n\n\n\n\ncontract PProxiedFactory is Ownable {\n\n    IBFactory public balancerFactory;\n    address public smartPoolImplementation;\n    mapping(address => bool) public isPool;\n    address[] public pools;\n\n    event SmartPoolCreated(address indexed poolAddress, string name, string symbol);\n\n    function init(address _balancerFactory) public {\n        require(smartPoolImplementation == address(0), \"Already initialised\");\n        _setOwner(msg.sender);\n        balancerFactory = IBFactory(_balancerFactory);\n        \n        PCappedSmartPool implementation = new PCappedSmartPool();\n        // function init(address _bPool, string calldata _name, string calldata _symbol, uint256 _initialSupply) external {\n        implementation.init(address(0), \"IMPL\", \"IMPL\", 1 ether);\n        smartPoolImplementation = address(implementation);\n    }\n\n    function newProxiedSmartPool(\n        string memory _name, \n        string memory _symbol,\n        uint256 _initialSupply,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _weights,\n        uint256 _cap\n    ) public onlyOwner returns(address) {\n        // Deploy proxy contract\n        PProxyPausable proxy = new PProxyPausable();\n        \n        // Setup proxy\n        proxy.setImplementation(smartPoolImplementation);\n        proxy.setPauzer(msg.sender);\n        proxy.setProxyOwner(msg.sender); \n        \n        // Setup balancer pool\n        address balancerPoolAddress = balancerFactory.newBPool();\n        IBPool bPool = IBPool(balancerPoolAddress);\n\n        for(uint256 i = 0; i < _tokens.length; i ++) {\n            IERC20 token = IERC20(_tokens[i]);\n            // Transfer tokens to this contract\n            token.transferFrom(msg.sender, address(this), _amounts[i]);\n            // Approve the balancer pool\n            token.approve(balancerPoolAddress, uint256(-1));\n            // Bind tokens\n            bPool.bind(_tokens[i], _amounts[i], _weights[i]);\n        }\n        bPool.setController(address(proxy));\n        \n        // Setup smart pool\n        PCappedSmartPool smartPool = PCappedSmartPool(address(proxy));\n    \n        smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\n        smartPool.setCap(_cap);\n        smartPool.setPublicSwapSetter(msg.sender);\n        smartPool.setTokenBinder(msg.sender);\n        smartPool.setController(msg.sender);\n        smartPool.approveTokens();\n        \n        isPool[address(smartPool)] = true;\n        pools.push(address(smartPool));\n\n        emit SmartPoolCreated(address(smartPool), _name, _symbol);\n\n        smartPool.transfer(msg.sender, _initialSupply);\n\n        return address(smartPool);\n    }\n\n}\n\n\n// File contracts/interfaces/IUniswapFactory.sol\n\npragma solidity ^0.6.4;\n\ninterface IUniswapFactory {\n    // Create Exchange\n    function createExchange(address token) external returns (address exchange);\n    // Get Exchange and Token Info\n    function getExchange(address token) external view returns (address exchange);\n    function getToken(address exchange) external view returns (address token);\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\n    // Never use\n    function initializeFactory(address template) external;\n}\n\n\n// File contracts/interfaces/IUniswapExchange.sol\n\npragma solidity ^0.6.4;\n\ninterface IUniswapExchange {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n    // Provide Liquidity\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\n    // ERC20 comaptibility for liquidity tokens\n    // bytes32 public name;\n    // bytes32 public symbol;\n    // uint256 public decimals;\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    // Never use\n    function setup(address token_addr) external;\n}\n\n\n// File contracts/recipes/PUniswapPoolRecipe.sol\n\npragma solidity ^0.6.4;\n\n\n\n\n\n// Takes ETH and mints smart pool tokens\ncontract PUniswapPoolRecipe {\n    \n    bytes32 constant public uprSlot = keccak256(\"PUniswapPoolRecipe.storage.location\");\n\n    // Uniswap pool recipe struct\n    struct uprs {\n        IPSmartPool pool;\n        IUniswapFactory uniswapFactory;\n    }\n\n    function init(address _pool, address _uniswapFactory) public virtual {\n        uprs storage s = luprs();\n        require(address(s.pool) == address(0), \"already initialised\");\n        s.pool = IPSmartPool(_pool);\n        s.uniswapFactory = IUniswapFactory(_uniswapFactory);\n    }\n\n    // Using same interface as Uniswap for compatibility\n    function ethToTokenTransferOutput(uint256 _tokens_bought, uint256 _deadline, address _recipient) public payable returns (uint256  eth_sold) {\n        uprs storage s = luprs();\n        require(_deadline >= block.timestamp);\n        (address[] memory tokens, uint256[] memory amounts) = s.pool.calcTokensForAmount(_tokens_bought);\n\n        eth_sold = 0;\n        // Buy and approve tokens\n        for(uint256 i = 0; i < tokens.length; i ++) {\n            eth_sold += _ethToToken(tokens[i], amounts[i]);\n            IERC20(tokens[i]).approve(address(s.pool), uint256(-1));\n        }\n\n        // Calculate amount of eth sold\n        eth_sold = msg.value - address(this).balance;\n        // Send back excess eth\n        msg.sender.transfer(address(this).balance);\n\n        // Join pool\n        s.pool.joinPool(_tokens_bought);\n\n        // Send pool tokens to receiver\n        s.pool.transfer(_recipient, s.pool.balanceOf(address(this)));\n        return eth_sold;\n    }\n\n    function ethToTokenSwapOutput(uint256 _tokens_bought, uint256 _deadline) external payable returns (uint256 eth_sold) {\n        return ethToTokenTransferOutput(_tokens_bought, _deadline, msg.sender);\n    }\n\n    function _ethToToken(address _token, uint256 _tokens_bought) internal virtual returns (uint256) {\n        uprs storage s = luprs();\n        IUniswapExchange exchange = IUniswapExchange(s.uniswapFactory.getExchange(_token));\n        return exchange.ethToTokenSwapOutput{value: address(this).balance}(_tokens_bought, uint256(-1));\n    }\n\n    function getEthToTokenOutputPrice(uint256 _tokens_bought) external view virtual returns (uint256 eth_sold) {\n        uprs storage s = luprs();\n        (address[] memory tokens, uint256[] memory amounts) = s.pool.calcTokensForAmount(_tokens_bought);\n\n        eth_sold = 0;\n\n        for(uint256 i = 0; i < tokens.length; i ++) {\n            IUniswapExchange exchange = IUniswapExchange(s.uniswapFactory.getExchange(tokens[i]));\n            eth_sold += exchange.getEthToTokenOutputPrice(amounts[i]);\n        }\n\n        return eth_sold;\n    }\n\n    function tokenToEthTransferInput(uint256 _tokens_sold, uint256 _min_eth, uint256 _deadline, address _recipient) public returns (uint256 eth_bought) {\n        uprs storage s = luprs();\n        require(_deadline >= block.timestamp);\n        require(s.pool.transferFrom(msg.sender, address(this), _tokens_sold), \"PUniswapPoolRecipe.tokenToEthTransferInput: transferFrom failed\");\n\n        s.pool.exitPool(_tokens_sold);\n\n        address[] memory tokens = s.pool.getTokens();\n\n        uint256 ethAmount = 0;\n\n        for(uint256 i = 0; i < tokens.length; i ++) {\n            IERC20 token = IERC20(tokens[i]);\n            \n            uint256 balance = token.balanceOf(address(this));\n           \n            // Exchange for ETH\n            ethAmount += _tokenToEth(token, balance, _recipient);\n        }\n\n        require(ethAmount > _min_eth, \"PUniswapPoolRecipe.tokenToEthTransferInput: not enough ETH\");\n        return ethAmount;\n    }\n\n    function tokenToEthSwapInput(uint256 _tokens_sold, uint256 _min_eth, uint256 _deadline) external returns (uint256 eth_bought) {\n        return tokenToEthTransferInput(_tokens_sold, _min_eth, _deadline, msg.sender);\n    }\n\n    function _tokenToEth(IERC20 _token, uint256 _tokens_sold, address _recipient) internal virtual returns (uint256 eth_bought) {\n        uprs storage s = luprs();\n        IUniswapExchange exchange = IUniswapExchange(s.uniswapFactory.getExchange(address(_token)));\n        _token.approve(address(exchange), _tokens_sold);\n        // Exchange for ETH\n        return exchange.tokenToEthTransferInput(_tokens_sold, 1, uint256(-1), _recipient);\n    }\n\n    function getTokenToEthInputPrice(uint256 _tokens_sold) external view virtual returns (uint256 eth_bought) {\n        uprs storage s = luprs();\n        (address[] memory tokens, uint256[] memory amounts) = s.pool.calcTokensForAmount(_tokens_sold);\n\n        eth_bought = 0;\n\n        for(uint256 i = 0; i < tokens.length; i ++) {\n            IUniswapExchange exchange = IUniswapExchange(s.uniswapFactory.getExchange(address(tokens[i])));\n            eth_bought += exchange.getTokenToEthInputPrice(amounts[i]);\n        }\n\n        return eth_bought;\n    }\n\n    function pool() external view returns (address) {\n        return address(luprs().pool);\n    }\n\n    receive() external payable {\n\n    }\n\n    // Load uniswap pool recipe\n    function luprs() internal pure returns (uprs storage s) {\n        bytes32 loc = uprSlot;\n        assembly {\n            s_slot := loc\n        }\n    }\n}\n\n\n// File contracts/interfaces/IKyberNetwork.sol\n\npragma solidity ^0.6.4;\n\ninterface IKyberNetwork {\n\n    function trade(\n        address src,\n        uint srcAmount,\n        address dest,\n        address payable destAddress,\n        uint maxDestAmount,\n        uint minConversionRate,\n        address walletId\n    ) external payable returns(uint256);\n}\n\n\n// File contracts/recipes/PUniswapKyberPoolRecipe.sol\n\npragma solidity ^0.6.4;\n\n\n\n\ncontract PUniswapKyberPoolRecipe is PUniswapPoolRecipe, Ownable {\n\n    bytes32 constant public ukprSlot = keccak256(\"PUniswapKyberPoolRecipe.storage.location\");\n\n    // Uniswap pool recipe struct\n    struct ukprs {\n        mapping(address => bool) swapOnKyber;\n        IKyberNetwork kyber;\n        address feeReceiver;\n    }\n\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    function init(address, address) public override {\n        require(false, \"not enabled\");\n    }\n\n    // Use seperate init function\n    function initUK(address _pool, address _uniswapFactory, address _kyber, address[] memory _swapOnKyber, address _feeReciever) public {\n        // UnsiwapRecipe enforces that init can only be called once\n        ukprs storage s = lukprs();\n\n        PUniswapPoolRecipe.init(_pool, _uniswapFactory);\n        s.kyber = IKyberNetwork(_kyber);\n        s.feeReceiver = _feeReciever;\n\n        _setOwner(msg.sender);\n\n        for(uint256 i = 0; i < _swapOnKyber.length; i ++) {\n            s.swapOnKyber[_swapOnKyber[i]] = true;\n        }\n    }\n\n    function setKyberSwap(address _token, bool _value) external onlyOwner {\n        ukprs storage s = lukprs();\n        s.swapOnKyber[_token] = _value;\n    }\n\n    function _ethToToken(address _token, uint256 _tokens_bought) internal override returns (uint256) {\n        ukprs storage s = lukprs();\n        if(!s.swapOnKyber[_token]) {\n            return super._ethToToken(_token, _tokens_bought);\n        }\n\n        uint256 ethBefore = address(this).balance;\n        s.kyber.trade{value: address(this).balance}(ETH, address(this).balance, _token, address(this), _tokens_bought, 1, s.feeReceiver);\n        uint256 ethAfter = address(this).balance;\n\n        // return amount of ETH spend\n        return ethBefore - ethAfter;\n    }\n\n    function _tokenToEth(IERC20 _token, uint256 _tokens_sold, address _recipient) internal override returns (uint256 eth_bought) {\n        ukprs storage s = lukprs();\n        if(!s.swapOnKyber[address(_token)]) {\n            return super._tokenToEth(_token, _tokens_sold, _recipient);\n        }\n\n        uint256 ethBefore = address(this).balance;\n        _token.approve(address(s.kyber), uint256(-1));\n        s.kyber.trade(address(_token), _tokens_sold, ETH, address(this), uint256(-1), 1, s.feeReceiver);\n        uint256 ethAfter = address(this).balance;\n\n        // return amount of ETH received\n        return ethAfter - ethBefore;\n    }\n\n    // Load uniswap pool recipe\n    function lukprs() internal pure returns (ukprs storage s) {\n        bytes32 loc = ukprSlot;\n        assembly {\n            s_slot := loc\n        }\n    }\n\n}\n\n\n// File contracts/test/TestReentryProtection.sol\n\npragma solidity ^0.6.4;\n\n\ncontract TestReentryProtection is ReentryProtection {\n\n    // This should fail\n    function test() external noReentry {\n        reenter();\n    }\n\n    function reenter() public noReentry {\n        // Do nothing\n    }\n\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"SmartPoolCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"balancerFactory\",\"outputs\":[{\"internalType\":\"contract IBFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_balancerFactory\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"newProxiedSmartPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartPoolImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PProxiedFactory","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}]}