{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// @author Ben Scholtz @ Linum Labs\n// @title Bonding curve functions\n\ncontract CurveFunctions {\n\tusing SafeMath for uint256;\n\n\t// Description of function (function ID)\n\tstring constant public curveFunction = \"linear: (1/20000)*x + 0.5\tcurve integral: (0.000025*x + 0.5)*x\tinverse curve integral: -10000 + 200*sqrt(x + 2500)\";\n\t// Decimal place precision\n\tuint256 constant public DECIMALS = 18;\n\n\t/**\n      * @dev    Calculates the definite integral of the curve.\n\t  * @notice\tVarious symboles are used within this function (i.e a, b). This\n\t  *\t\t\tis done to represent the variables within the curve integral \n\t  *\t\t\tequation.\n      * @param  _x : Token value for upper limit of definite integral\n      */\n\tfunction curveIntegral(uint256 _x) public pure returns (uint256) {\n\t\t// Ensuring that after scaling the number will not be too large\n\t\trequire(_x <= 10**40, 'Input argument too large');\n\n\t\t// Calculate equation arguments\n\t\tuint256 a = 25*10**(DECIMALS - 6);\n\t\t// hatch price\n\t\tuint256 b = 5*10**(DECIMALS - 1);\n\n\t\t// curve integral: (0.000025*x + 0.5)*x\n\t\treturn (a.mul(_x).div(10**DECIMALS).add(b)).mul(_x).div(10**DECIMALS);\n\t}\n\n\t/**\n\t  * @dev    Calculates the definite inverse integral of the curve\n\t  * @notice\tVarious symbols are used within this function (i.e a, b). This\n\t  *\t\t\tis done to represent the variables within the inverse curve \n\t  *\t\t\tintegral equation.\n\t\t* @param  _x : collateral value for upper limit of definite integral\n\t\t*/\n\tfunction inverseCurveIntegral(uint256 _x) public pure returns(uint256) {\n\t\t// Ensuring that after scaling the number will not be too large\n\t\trequire(_x <= 10**40, 'Input argument too large');\n\n\t\t// Use 36 decimal places for square root precision\n\t\tuint256 DECIMALS_36 = 36;\n\n\t\t// Calculate equation arguments\n\t\tuint256 x = _x*10**DECIMALS;\n\t\tuint256 prefix = 200*10**DECIMALS_36;\n\t\tuint256 a = prefix\n\t\t\t.mul(sqrt(x + 2500*10**DECIMALS_36))\n\t\t\t.div(sqrt(10**DECIMALS_36));\n\n\t\t// inverse curve integral: -10000 + 200*sqrt(x + 2500)\n\t\treturn uint256(\n\t\t\t\t-10000*int256(10**DECIMALS_36) + int256(a)\n\t\t\t).div(10**DECIMALS);\n\t}\n\n\t/**\n\t  * @notice\tSquare root function.\n\t  *\t@param\t_x : Vaule getting square rooted.\n\t  */\n\tfunction sqrt(uint256 _x) public pure returns (uint256) {\n\t\tif (_x == 0) return 0;\n\t\telse if (_x <= 3) return 1;\n\t\tuint256 z = (_x + 1) / 2;\n\t\tuint256 y = _x;\n\t\t\n\t\twhile (z < y) {\n\t\t\ty = z;\n\t\t\tz = (_x / z + z) / 2;\n\t\t}\n\n\t\treturn y;\n\t}\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"}],\"name\":\"curveIntegral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"}],\"name\":\"sqrt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curveFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"}],\"name\":\"inverseCurveIntegral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"CurveFunctions","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://91873f7e945c4e0826e1689d9261918c593d0fb83cb29f6e92a7a2a63055cf77"}]}