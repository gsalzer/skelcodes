{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title Mining logic\r\n * @dev Calculation of mining quantity\r\n */\r\ncontract NEST_3_OrePoolLogic {\r\n    using address_make_payable for address;\r\n    using SafeMath for uint256;\r\n    uint256 blockAttenuation = 2400000;                         //  Block attenuation interval\r\n    uint256 attenuationTop = 90;                                //  Attenuation coefficient\r\n    uint256 attenuationBottom = 100;                            //  Attenuation coefficient\r\n    mapping(uint256 => mapping(address => uint256)) blockEth;   //  Total service charge of quotation block. block No. = > token address = > total service charge\r\n    mapping(uint256 => uint256) blockTokenNum;                  //  Block currency quantity. block number = > currency quantity\r\n    mapping(uint256 => uint256) blockMining;                    //  Ore yield of quotation block. Block No. = > ore yield\r\n    uint256 latestMining;                                       //  Latest quotation block\r\n    NEST_2_Mapping mappingContract;                             //  Mapping contract\r\n    NEST_3_MiningSave miningSave;                               //  Ore pool contract\r\n    address abonusAddress;                                      //  Address of dividend pool\r\n    address offerFactoryAddress;                                //  Offer factory contract address\r\n    mapping(uint256 => uint256) blockAmountList;                //  Attenuation list. block number = > attenuation coefficient\r\n    uint256 latestBlock;                                        //  Latest attenuation block\r\n\r\n    //  Current block, last quoted block, current block ore yield, current handling fee, token address\r\n    event oreDrawingLog(uint256 nowBlock, uint256 frontBlock, uint256 blockAmount, uint256 miningEth, address tokenAddress);\r\n    //  Quotation block, token address, all handling charges of token, my handling charges, number of tokens\r\n    event miningLog(uint256 blockNum, address tokenAddress, uint256 miningEthAll, uint256 miningEthSelf, uint256 tokenNum);\r\n\r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    constructor(address map) public {\r\n        mappingContract = NEST_2_Mapping(address(map));                  \r\n        miningSave = NEST_3_MiningSave(mappingContract.checkAddress(\"miningSave\"));\r\n        abonusAddress = address(mappingContract.checkAddress(\"abonus\"));\r\n        offerFactoryAddress = address(mappingContract.checkAddress(\"offerFactory\"));\r\n        latestBlock = block.number.sub(388888);\r\n        latestMining = block.number;\r\n        blockAmountList[block.number.sub(2788888)] = 400 ether;\r\n        blockAmountList[block.number.sub(388888)] = blockAmountList[block.number.sub(2788888)].mul(attenuationTop).div(attenuationBottom);\r\n    }\r\n    \r\n    /**\r\n    * @dev Change mapping contract\r\n    * @param map Mapping contract address\r\n    */\r\n    function changeMapping(address map) public onlyOwner {\r\n        mappingContract = NEST_2_Mapping(address(map));                 \r\n        miningSave = NEST_3_MiningSave(mappingContract.checkAddress(\"miningSave\"));\r\n        abonusAddress = address(mappingContract.checkAddress(\"abonus\"));\r\n        offerFactoryAddress = address(mappingContract.checkAddress(\"offerFactory\"));\r\n    }\r\n    \r\n    /**\r\n    * @dev Calculation of mining volume\r\n    * @param token Offer token address\r\n    */\r\n    function oreDrawing(address token) public payable {\r\n        require(address(msg.sender) == offerFactoryAddress);\r\n        uint256 frontBlock = latestMining;\r\n        changeBlockAmountList();\r\n        if (blockEth[block.number][token] == 0) {\r\n            blockTokenNum[block.number] = blockTokenNum[block.number].add(1);\r\n        }\r\n        blockEth[block.number][token] = blockEth[block.number][token].add(msg.value);\r\n        repayEth(msg.value);\r\n        emit oreDrawingLog(block.number, frontBlock,blockAmountList[latestBlock],msg.value,token);\r\n    }\r\n    \r\n    /**\r\n    * @dev Mining\r\n    * @param amount Number of handling charges\r\n    * @param blockNum Offer block number\r\n    * @param target Transfer target\r\n    * @param token Token address\r\n    * @return Ore yield\r\n    */\r\n    function mining(uint256 amount, uint256 blockNum, address target, address token) public returns(uint256) {\r\n        require(address(msg.sender) == offerFactoryAddress);\r\n        uint256 miningAmount = amount.mul(blockMining[blockNum]).div(blockEth[blockNum][token].mul(blockTokenNum[blockNum]));\r\n        uint256 realAmount = miningSave.turnOut(miningAmount, target);\r\n        emit miningLog(blockNum, token,blockEth[blockNum][token],amount,blockTokenNum[blockNum]);\r\n        return realAmount;\r\n    }\r\n    \r\n    function changeBlockAmountList() private {\r\n        uint256 subBlock = block.number.sub(latestBlock);\r\n        if (subBlock >= blockAttenuation) {\r\n            uint256 subBlockTimes = subBlock.div(blockAttenuation);\r\n            for (uint256 i = 1; i < subBlockTimes.add(1); i++) {\r\n                uint256 newBlockAmount = blockAmountList[latestBlock].mul(attenuationTop).div(attenuationBottom);\r\n                latestBlock = latestBlock.add(blockAttenuation);\r\n                if (latestMining < latestBlock) {\r\n                    blockMining[block.number] = blockMining[block.number].add((blockAmountList[latestBlock.sub(blockAttenuation)]).mul(latestBlock.sub(latestMining).sub(1)));\r\n                    latestMining = latestBlock.sub(1);\r\n                }\r\n                blockAmountList[latestBlock] = newBlockAmount;\r\n            }\r\n        }\r\n        blockMining[block.number] = blockMining[block.number].add(blockAmountList[latestBlock].mul(block.number.sub(latestMining)));\r\n        latestMining = block.number;\r\n    }\r\n    \r\n    function repayEth(uint256 asset) private {\r\n        address payable addr = abonusAddress.make_payable();\r\n        addr.transfer(asset);\r\n    }\r\n\r\n    //  View block falloff interval\r\n    function checkBlockAttenuation() public view returns(uint256) {\r\n        return blockAttenuation;\r\n    }\r\n\r\n    //  View attenuation factor\r\n    function checkAttenuation() public view returns(uint256 top, uint256 bottom) {\r\n        return (attenuationTop, attenuationBottom);\r\n    }\r\n\r\n    //  View the total service charge of quotation block\r\n    function checkBlockEth(uint256 blockNum, address token) public view returns(uint256) {\r\n        return blockEth[blockNum][token];\r\n    }\r\n\r\n    //  View block currency quantity\r\n    function checkBlockTokenNum(uint256 blockNum) public view returns(uint256) {\r\n        return blockTokenNum[blockNum];\r\n    }\r\n\r\n    //  View the ore yield of quotation block\r\n    function checkBlockMining(uint256 blockNum) public view returns(uint256) {\r\n        return blockMining[blockNum];\r\n    }\r\n\r\n    //  View the latest quotation block\r\n    function checkLatestMining() public view returns(uint256) {\r\n        return latestMining;\r\n    }\r\n\r\n    //  View falloff list\r\n    function checkBlockAmountList(uint256 blockNum) public view returns(uint256) {\r\n        return blockAmountList[blockNum];\r\n    }\r\n\r\n    //  View current ore output\r\n    function checkBlockAmountListLatest() public view returns(uint256) {\r\n        return blockAmountList[latestBlock];\r\n    }\r\n\r\n    //  View the latest falloff block\r\n    function checkLatestBlock() public view returns(uint256) {\r\n        return latestBlock;\r\n    }\r\n\r\n    //  View the output of quotation contract\r\n    function checkBlockRealAmount(uint256 amount, uint256 blockNum, address token) public view returns(uint256) {\r\n        return amount.mul(blockMining[blockNum]).div(blockEth[blockNum][token].mul(blockTokenNum[blockNum]));\r\n    }\r\n\r\n    function changeBlockAttenuation(uint256 blockNum) public onlyOwner {\r\n        require(blockNum > 0);\r\n        blockAttenuation = blockNum;\r\n    }\r\n    \r\n    function changeAttenuation(uint256 top, uint256 bottom) public onlyOwner {\r\n        require(top > 0);\r\n        require(bottom > 0);\r\n        attenuationTop = top;\r\n        attenuationBottom = bottom;\r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n        require(mappingContract.checkOwners(msg.sender) == true);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract NEST_3_MiningSave {\r\n    function turnOut(uint256 amount, address target) public returns(uint256);\r\n    function checkBalance() public view returns(uint256);\r\n}\r\n\r\ncontract NEST_2_Mapping {\r\n\tfunction checkAddress(string memory name) public view returns (address contractAddress);\r\n\tfunction checkOwners(address man) public view returns (bool);\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf( address who ) public view returns (uint value);\r\n    function allowance( address owner, address spender ) public view returns (uint _allowance);\r\n\r\n    function transfer( address to, uint256 value) external;\r\n    function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n    function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\nlibrary address_make_payable {\r\n   function make_payable(address x) internal pure returns (address payable) {\r\n      return address(uint160(x));\r\n   }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = _a / _b;\r\n    assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"map\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"miningEthAll\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"miningEthSelf\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenNum\",\"type\":\"uint256\"}],\"name\":\"miningLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nowBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"frontBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"miningEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"oreDrawingLog\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"top\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bottom\",\"type\":\"uint256\"}],\"name\":\"changeAttenuation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"changeBlockAttenuation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"map\",\"type\":\"address\"}],\"name\":\"changeMapping\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkAttenuation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"top\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bottom\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"checkBlockAmountList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkBlockAmountListLatest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkBlockAttenuation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"checkBlockEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"checkBlockMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"checkBlockRealAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"checkBlockTokenNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkLatestBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkLatestMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"mining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"oreDrawing\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"NEST_3_OrePoolLogic","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005e7db2ffc5b2c7c47103e4f21c702bc402603fbf","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://4b1a67186a9788a066186ddb867ce290d79a05212a672302c9d22a102f0e4fcb"}]}