{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\ninterface IMultipleDistribution {\r\n    function initialize(address _tokenAddress) external;\r\n    function poolStake() external view returns (uint256);\r\n}\r\n\r\n\r\ninterface IDistribution {\r\n    function supply() external view returns(uint256);\r\n    function poolAddress(uint8) external view returns(address);\r\n}\r\n\r\n\r\ninterface IERC677MultiBridgeToken {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferDistribution(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function balanceOf(address _account) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @dev Distributes STAKE tokens.\r\ncontract Distribution is Ownable, IDistribution {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    /// @dev Emits when `preInitialize` method has been called.\r\n    /// @param token The address of ERC677MultiBridgeToken.\r\n    /// @param caller The address of the caller.\r\n    event PreInitialized(address token, address caller);\r\n\r\n    /// @dev Emits when `initialize` method has been called.\r\n    /// @param caller The address of the caller.\r\n    event Initialized(address caller);\r\n\r\n    /// @dev Emits when an installment for the specified pool has been made.\r\n    /// @param pool The index of the pool.\r\n    /// @param value The installment value.\r\n    /// @param caller The address of the caller.\r\n    event InstallmentMade(uint8 indexed pool, uint256 value, address caller);\r\n\r\n    /// @dev Emits when the pool address was changed.\r\n    /// @param pool The index of the pool.\r\n    /// @param oldAddress Old address.\r\n    /// @param newAddress New address.\r\n    event PoolAddressChanged(uint8 indexed pool, address oldAddress, address newAddress);\r\n\r\n    /// @dev The instance of ERC677MultiBridgeToken.\r\n    IERC677MultiBridgeToken public token;\r\n\r\n    uint8 public constant ECOSYSTEM_FUND = 1;\r\n    uint8 public constant PUBLIC_OFFERING = 2;\r\n    uint8 public constant PRIVATE_OFFERING = 3;\r\n    uint8 public constant ADVISORS_REWARD = 4;\r\n    uint8 public constant FOUNDATION_REWARD = 5;\r\n    uint8 public constant LIQUIDITY_FUND = 6;\r\n\r\n    /// @dev Pool address.\r\n    mapping (uint8 => address) public poolAddress;\r\n    /// @dev Pool total amount of tokens.\r\n    mapping (uint8 => uint256) public stake;\r\n    /// @dev Amount of remaining tokens to distribute for the pool.\r\n    mapping (uint8 => uint256) public tokensLeft;\r\n    /// @dev Pool cliff period (in seconds).\r\n    mapping (uint8 => uint256) public cliff;\r\n    /// @dev Total number of installments for the pool.\r\n    mapping (uint8 => uint256) public numberOfInstallments;\r\n    /// @dev Number of installments that were made.\r\n    mapping (uint8 => uint256) public numberOfInstallmentsMade;\r\n    /// @dev The value of one-time installment for the pool.\r\n    mapping (uint8 => uint256) public installmentValue;\r\n    /// @dev The value to transfer to the pool at cliff.\r\n    mapping (uint8 => uint256) public valueAtCliff;\r\n    /// @dev Boolean variable that contains whether the value for the pool at cliff was paid or not.\r\n    mapping (uint8 => bool) public wasValueAtCliffPaid;\r\n    /// @dev Boolean variable that contains whether all installments for the pool were made or not.\r\n    mapping (uint8 => bool) public installmentsEnded;\r\n\r\n    /// @dev The total token supply.\r\n    uint256 constant public supply = 8537500 ether;\r\n\r\n    /// @dev The timestamp of the distribution start.\r\n    uint256 public distributionStartTimestamp;\r\n\r\n    /// @dev The timestamp of pre-initialization.\r\n    uint256 public preInitializationTimestamp;\r\n    /// @dev Boolean variable that indicates whether the contract was pre-initialized.\r\n    bool public isPreInitialized = false;\r\n    /// @dev Boolean variable that indicates whether the contract was initialized.\r\n    bool public isInitialized = false;\r\n\r\n    /// @dev Checks that the contract is initialized.\r\n    modifier initialized() {\r\n        require(isInitialized, \"not initialized\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Checks that the installments for the given pool are started and are not finished already.\r\n    /// @param _pool The index of the pool.\r\n    modifier active(uint8 _pool) {\r\n        require(\r\n            // solium-disable-next-line security/no-block-members\r\n            _now() >= distributionStartTimestamp.add(cliff[_pool]) && !installmentsEnded[_pool],\r\n            \"installments are not active for this pool\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Sets up constants and pools addresses that are used in distribution.\r\n    /// @param _ecosystemFundAddress The address of the Ecosystem Fund.\r\n    /// @param _publicOfferingAddress The address of the Public Offering.\r\n    /// @param _privateOfferingAddress The address of the Private Offering contract.\r\n    /// @param _advisorsRewardAddress The address of the Advisors Reward contract.\r\n    /// @param _foundationAddress The address of the Foundation Reward.\r\n    /// @param _liquidityFundAddress The address of the Liquidity Fund.\r\n    constructor(\r\n        address _ecosystemFundAddress,\r\n        address _publicOfferingAddress,\r\n        address _privateOfferingAddress,\r\n        address _advisorsRewardAddress,\r\n        address _foundationAddress,\r\n        address _liquidityFundAddress\r\n    ) public {\r\n        // validate provided addresses\r\n        require(\r\n            _privateOfferingAddress.isContract() &&\r\n            _advisorsRewardAddress.isContract(),\r\n            \"not a contract address\"\r\n        );\r\n        _validateAddress(_ecosystemFundAddress);\r\n        _validateAddress(_publicOfferingAddress);\r\n        _validateAddress(_foundationAddress);\r\n        _validateAddress(_liquidityFundAddress);\r\n        poolAddress[ECOSYSTEM_FUND] = _ecosystemFundAddress;\r\n        poolAddress[PUBLIC_OFFERING] = _publicOfferingAddress;\r\n        poolAddress[PRIVATE_OFFERING] = _privateOfferingAddress;\r\n        poolAddress[ADVISORS_REWARD] = _advisorsRewardAddress;\r\n        poolAddress[FOUNDATION_REWARD] = _foundationAddress;\r\n        poolAddress[LIQUIDITY_FUND] = _liquidityFundAddress;\r\n\r\n        // initialize token amounts\r\n        stake[ECOSYSTEM_FUND] = 4000000 ether;\r\n        stake[PUBLIC_OFFERING] = 400000 ether;\r\n        stake[PRIVATE_OFFERING] = IMultipleDistribution(poolAddress[PRIVATE_OFFERING]).poolStake();\r\n        stake[ADVISORS_REWARD] = IMultipleDistribution(poolAddress[ADVISORS_REWARD]).poolStake();\r\n        stake[FOUNDATION_REWARD] = 699049 ether;\r\n        stake[LIQUIDITY_FUND] = 816500 ether;\r\n\r\n        require(\r\n            stake[ECOSYSTEM_FUND] // solium-disable-line operator-whitespace\r\n                .add(stake[PUBLIC_OFFERING])\r\n                .add(stake[PRIVATE_OFFERING])\r\n                .add(stake[ADVISORS_REWARD])\r\n                .add(stake[FOUNDATION_REWARD])\r\n                .add(stake[LIQUIDITY_FUND])\r\n            == supply,\r\n            \"wrong sum of pools stakes\"\r\n        );\r\n\r\n        tokensLeft[ECOSYSTEM_FUND] = stake[ECOSYSTEM_FUND];\r\n        tokensLeft[PUBLIC_OFFERING] = stake[PUBLIC_OFFERING];\r\n        tokensLeft[PRIVATE_OFFERING] = stake[PRIVATE_OFFERING];\r\n        tokensLeft[ADVISORS_REWARD] = stake[ADVISORS_REWARD];\r\n        tokensLeft[FOUNDATION_REWARD] = stake[FOUNDATION_REWARD];\r\n        tokensLeft[LIQUIDITY_FUND] = stake[LIQUIDITY_FUND];\r\n\r\n        valueAtCliff[ECOSYSTEM_FUND] = stake[ECOSYSTEM_FUND].mul(20).div(100);       // 20%\r\n        valueAtCliff[PRIVATE_OFFERING] = stake[PRIVATE_OFFERING].mul(10).div(100);   // 10%\r\n        valueAtCliff[ADVISORS_REWARD] = stake[ADVISORS_REWARD].mul(20).div(100);     // 20%\r\n        valueAtCliff[FOUNDATION_REWARD] = stake[FOUNDATION_REWARD].mul(20).div(100); // 20%\r\n\r\n        cliff[ECOSYSTEM_FUND] = 336 days;\r\n        cliff[PRIVATE_OFFERING] = 28 days;\r\n        cliff[ADVISORS_REWARD] = 84 days;\r\n        cliff[FOUNDATION_REWARD] = 84 days;\r\n\r\n        numberOfInstallments[ECOSYSTEM_FUND] = 336; // days\r\n        numberOfInstallments[PRIVATE_OFFERING] = 224; // days\r\n        numberOfInstallments[ADVISORS_REWARD] = 252; // days\r\n        numberOfInstallments[FOUNDATION_REWARD] = 252; // days\r\n\r\n        installmentValue[ECOSYSTEM_FUND] = _calculateInstallmentValue(ECOSYSTEM_FUND);\r\n        installmentValue[PRIVATE_OFFERING] = _calculateInstallmentValue(\r\n            PRIVATE_OFFERING,\r\n            stake[PRIVATE_OFFERING].mul(35).div(100) // 25% will be distributed at pre-initializing and 10% at cliff\r\n        );\r\n        installmentValue[ADVISORS_REWARD] = _calculateInstallmentValue(ADVISORS_REWARD);\r\n        installmentValue[FOUNDATION_REWARD] = _calculateInstallmentValue(FOUNDATION_REWARD);\r\n    }\r\n\r\n    /// @dev Pre-initializes the contract after the token is created.\r\n    /// Distributes tokens for Public Offering, Liquidity Fund, and part of Private Offering.\r\n    /// @param _tokenAddress The address of the STAKE token contract.\r\n    /// @param _initialStakeAmount The sum of initial stakes made on xDai chain before transitioning to POSDAO.\r\n    /// This amount must be sent to address(0) because it is excess on Mainnet side.\r\n    function preInitialize(address _tokenAddress, uint256 _initialStakeAmount) external onlyOwner {\r\n        require(!isPreInitialized, \"already pre-initialized\");\r\n\r\n        token = IERC677MultiBridgeToken(_tokenAddress);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance == supply, \"wrong contract balance\");\r\n\r\n        preInitializationTimestamp = _now(); // solium-disable-line security/no-block-members\r\n        isPreInitialized = true;\r\n\r\n        IMultipleDistribution(poolAddress[PRIVATE_OFFERING]).initialize(_tokenAddress);\r\n        IMultipleDistribution(poolAddress[ADVISORS_REWARD]).initialize(_tokenAddress);\r\n        uint256 privateOfferingPrerelease = stake[PRIVATE_OFFERING].mul(25).div(100); // 25%\r\n\r\n        token.transferDistribution(poolAddress[PUBLIC_OFFERING], stake[PUBLIC_OFFERING]); // 100%\r\n        token.transfer(poolAddress[PRIVATE_OFFERING], privateOfferingPrerelease);\r\n\r\n        uint256 liquidityFundDistribution = stake[LIQUIDITY_FUND].sub(_initialStakeAmount);\r\n        token.transferDistribution(poolAddress[LIQUIDITY_FUND], liquidityFundDistribution);\r\n        if (_initialStakeAmount > 0) {\r\n            token.transferDistribution(address(0), _initialStakeAmount);\r\n        }\r\n\r\n        tokensLeft[PUBLIC_OFFERING] = tokensLeft[PUBLIC_OFFERING].sub(stake[PUBLIC_OFFERING]);\r\n        tokensLeft[PRIVATE_OFFERING] = tokensLeft[PRIVATE_OFFERING].sub(privateOfferingPrerelease);\r\n        tokensLeft[LIQUIDITY_FUND] = tokensLeft[LIQUIDITY_FUND].sub(stake[LIQUIDITY_FUND]);\r\n\r\n        emit PreInitialized(_tokenAddress, msg.sender);\r\n        emit InstallmentMade(PUBLIC_OFFERING, stake[PUBLIC_OFFERING], msg.sender);\r\n        emit InstallmentMade(PRIVATE_OFFERING, privateOfferingPrerelease, msg.sender);\r\n        emit InstallmentMade(LIQUIDITY_FUND, liquidityFundDistribution, msg.sender);\r\n\r\n        if (_initialStakeAmount > 0) {\r\n            emit InstallmentMade(0, _initialStakeAmount, msg.sender);\r\n        }\r\n    }\r\n\r\n    /// @dev Initializes token distribution.\r\n    function initialize() external {\r\n        require(isPreInitialized, \"not pre-initialized\");\r\n        require(!isInitialized, \"already initialized\");\r\n\r\n        if (_now().sub(preInitializationTimestamp) < 90 days) { // solium-disable-line security/no-block-members\r\n            require(isOwner(), \"for now only owner can call this method\");\r\n        }\r\n\r\n        distributionStartTimestamp = _now(); // solium-disable-line security/no-block-members\r\n        isInitialized = true;\r\n\r\n        emit Initialized(msg.sender);\r\n    }\r\n\r\n    /// @dev Changes the address of the specified pool.\r\n    /// @param _pool The index of the pool (only ECOSYSTEM_FUND or FOUNDATION_REWARD are allowed).\r\n    /// @param _newAddress The new address for the change.\r\n    function changePoolAddress(uint8 _pool, address _newAddress) external {\r\n        require(_pool == ECOSYSTEM_FUND || _pool == FOUNDATION_REWARD, \"wrong pool\");\r\n        require(msg.sender == poolAddress[_pool], \"not authorized\");\r\n        _validateAddress(_newAddress);\r\n        emit PoolAddressChanged(_pool, poolAddress[_pool], _newAddress);\r\n        poolAddress[_pool] = _newAddress;\r\n    }\r\n\r\n    /// @dev Makes an installment for one of the following pools:\r\n    /// Private Offering, Advisors Reward, Ecosystem Fund, Foundation Reward.\r\n    /// @param _pool The index of the pool.\r\n    function makeInstallment(uint8 _pool) public initialized active(_pool) {\r\n        require(\r\n            _pool == PRIVATE_OFFERING ||\r\n            _pool == ADVISORS_REWARD ||\r\n            _pool == ECOSYSTEM_FUND ||\r\n            _pool == FOUNDATION_REWARD,\r\n            \"wrong pool\"\r\n        );\r\n        uint256 value = 0;\r\n        if (!wasValueAtCliffPaid[_pool]) {\r\n            value = valueAtCliff[_pool];\r\n            wasValueAtCliffPaid[_pool] = true;\r\n        }\r\n        uint256 availableNumberOfInstallments = _calculateNumberOfAvailableInstallments(_pool);\r\n        value = value.add(installmentValue[_pool].mul(availableNumberOfInstallments));\r\n\r\n        require(value > 0, \"no installments available\");\r\n\r\n        uint256 remainder = _updatePoolData(_pool, value, availableNumberOfInstallments);\r\n        value = value.add(remainder);\r\n\r\n        if (_pool == PRIVATE_OFFERING || _pool == ADVISORS_REWARD) {\r\n            token.transfer(poolAddress[_pool], value);\r\n        } else {\r\n            token.transferDistribution(poolAddress[_pool], value);\r\n        }\r\n\r\n        emit InstallmentMade(_pool, value, msg.sender);\r\n    }\r\n\r\n    /// @dev This method is called after the STAKE tokens are transferred to this contract.\r\n    function onTokenTransfer(address, uint256, bytes memory) public pure returns (bool) {\r\n        revert(\"sending tokens to this contract is not allowed\");\r\n    }\r\n\r\n    /// @dev The removed implementation of the ownership renouncing.\r\n    function renounceOwnership() public onlyOwner {\r\n        revert(\"not implemented\");\r\n    }\r\n\r\n    function _now() internal view returns (uint256) {\r\n        return now; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /// @dev Updates the given pool data after each installment:\r\n    /// the remaining number of tokens,\r\n    /// the number of made installments.\r\n    /// If the last installment are done and the tokens remained\r\n    /// then transfers them to the pool and marks that all installments for the given pool are made.\r\n    /// @param _pool The index of the pool.\r\n    /// @param _value Current installment value.\r\n    /// @param _currentNumberOfInstallments Number of installment that are made.\r\n    function _updatePoolData(\r\n        uint8 _pool,\r\n        uint256 _value,\r\n        uint256 _currentNumberOfInstallments\r\n    ) internal returns (uint256) {\r\n        uint256 remainder = 0;\r\n        tokensLeft[_pool] = tokensLeft[_pool].sub(_value);\r\n        numberOfInstallmentsMade[_pool] = numberOfInstallmentsMade[_pool].add(_currentNumberOfInstallments);\r\n        if (numberOfInstallmentsMade[_pool] >= numberOfInstallments[_pool]) {\r\n            if (tokensLeft[_pool] > 0) {\r\n                remainder = tokensLeft[_pool];\r\n                tokensLeft[_pool] = 0;\r\n            }\r\n            _endInstallment(_pool);\r\n        }\r\n        return remainder;\r\n    }\r\n\r\n    /// @dev Marks that all installments for the given pool are made.\r\n    /// @param _pool The index of the pool.\r\n    function _endInstallment(uint8 _pool) internal {\r\n        installmentsEnded[_pool] = true;\r\n    }\r\n\r\n    /// @dev Calculates the value of the installment for 1 day for the given pool.\r\n    /// @param _pool The index of the pool.\r\n    /// @param _valueAtCliff Custom value to distribute at cliff.\r\n    function _calculateInstallmentValue(\r\n        uint8 _pool,\r\n        uint256 _valueAtCliff\r\n    ) internal view returns (uint256) {\r\n        return stake[_pool].sub(_valueAtCliff).div(numberOfInstallments[_pool]);\r\n    }\r\n\r\n    /// @dev Calculates the value of the installment for 1 day for the given pool.\r\n    /// @param _pool The index of the pool.\r\n    function _calculateInstallmentValue(uint8 _pool) internal view returns (uint256) {\r\n        return _calculateInstallmentValue(_pool, valueAtCliff[_pool]);\r\n    }\r\n\r\n    /// @dev Calculates the number of available installments for the given pool.\r\n    /// @param _pool The index of the pool.\r\n    /// @return The number of available installments.\r\n    function _calculateNumberOfAvailableInstallments(\r\n        uint8 _pool\r\n    ) internal view returns (\r\n        uint256 availableNumberOfInstallments\r\n    ) {\r\n        uint256 paidDays = numberOfInstallmentsMade[_pool].mul(1 days);\r\n        uint256 lastTimestamp = distributionStartTimestamp.add(cliff[_pool]).add(paidDays);\r\n        // solium-disable-next-line security/no-block-members\r\n        availableNumberOfInstallments = _now().sub(lastTimestamp).div(1 days);\r\n        if (numberOfInstallmentsMade[_pool].add(availableNumberOfInstallments) > numberOfInstallments[_pool]) {\r\n            availableNumberOfInstallments = numberOfInstallments[_pool].sub(numberOfInstallmentsMade[_pool]);\r\n        }\r\n    }\r\n\r\n    /// @dev Checks for an empty address.\r\n    function _validateAddress(address _address) internal pure {\r\n        if (_address == address(0)) {\r\n            revert(\"invalid address\");\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"installmentsEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pool\",\"type\":\"uint8\"},{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changePoolAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"cliff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preInitializationTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDATION_REWARD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPreInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"installmentValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_initialStakeAmount\",\"type\":\"uint256\"}],\"name\":\"preInitialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"stake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADVISORS_REWARD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"wasValueAtCliffPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRIVATE_OFFERING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"numberOfInstallments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ECOSYSTEM_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"poolAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionStartTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"valueAtCliff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pool\",\"type\":\"uint8\"}],\"name\":\"makeInstallment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDITY_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PUBLIC_OFFERING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"numberOfInstallmentsMade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ecosystemFundAddress\",\"type\":\"address\"},{\"name\":\"_publicOfferingAddress\",\"type\":\"address\"},{\"name\":\"_privateOfferingAddress\",\"type\":\"address\"},{\"name\":\"_advisorsRewardAddress\",\"type\":\"address\"},{\"name\":\"_foundationAddress\",\"type\":\"address\"},{\"name\":\"_liquidityFundAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"PreInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pool\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InstallmentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pool\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PoolAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Distribution","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000015c13a1ade048a967456bf9807a4d5bfdb3b651c0000000000000000000000001440eb0dd965524e83b317373366b98c5a604ef300000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004","Library":"","LicenseType":"None","SwarmSource":"bzzr://88f298bf27edd2094e8090af781a9eb4f1105883aa759f15e7c749b81e06713a"}]}