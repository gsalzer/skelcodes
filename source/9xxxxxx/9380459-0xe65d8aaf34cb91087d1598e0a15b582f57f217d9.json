{"status":"1","message":"OK","result":[{"SourceCode":"// File: @ensdomains/ens/contracts/ENS.sol\r\n\r\npragma solidity >=0.4.24;\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\r\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n    function recordExists(bytes32 node) external view returns (bool);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @ensdomains/ethregistrar/contracts/BaseRegistrar.sol\r\n\r\npragma solidity >=0.4.24;\r\n\r\n\r\n\r\n\r\ncontract BaseRegistrar is IERC721, Ownable {\r\n    uint constant public GRACE_PERIOD = 90 days;\r\n\r\n    event ControllerAdded(address indexed controller);\r\n    event ControllerRemoved(address indexed controller);\r\n    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\r\n    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\r\n    event NameRenewed(uint256 indexed id, uint expires);\r\n\r\n    // The ENS registry\r\n    ENS public ens;\r\n\r\n    // The namehash of the TLD this registrar owns (eg, .eth)\r\n    bytes32 public baseNode;\r\n\r\n    // A map of addresses that are authorised to register and renew names.\r\n    mapping(address=>bool) public controllers;\r\n\r\n    // Authorises a controller, who can register and renew domains.\r\n    function addController(address controller) external;\r\n\r\n    // Revoke controller permission for an address.\r\n    function removeController(address controller) external;\r\n\r\n    // Set the resolver for the TLD this registrar manages.\r\n    function setResolver(address resolver) external;\r\n\r\n    // Returns the expiration timestamp of the specified label hash.\r\n    function nameExpires(uint256 id) external view returns(uint);\r\n\r\n    // Returns true iff the specified name is available for registration.\r\n    function available(uint256 id) public view returns(bool);\r\n\r\n    /**\r\n     * @dev Register a name.\r\n     */\r\n    function register(uint256 id, address owner, uint duration) external returns(uint);\r\n\r\n    function renew(uint256 id, uint duration) external returns(uint);\r\n\r\n    /**\r\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\r\n     */\r\n    function reclaim(uint256 id, address owner) external;\r\n}\r\n\r\n// File: @ensdomains/subdomain-registrar/contracts/Resolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev A basic interface for ENS resolvers.\r\n */\r\ncontract Resolver {\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool);\r\n    function addr(bytes32 node) public view returns (address);\r\n    function setAddr(bytes32 node, address addr) public;\r\n}\r\n\r\n// File: @ensdomains/subdomain-registrar/contracts/RegistrarInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract RegistrarInterface {\r\n    event OwnerChanged(bytes32 indexed label, address indexed oldOwner, address indexed newOwner);\r\n    event DomainConfigured(bytes32 indexed label);\r\n    event DomainUnlisted(bytes32 indexed label);\r\n    event NewRegistration(bytes32 indexed label, string subdomain, address indexed owner, address indexed referrer, uint price);\r\n    event RentPaid(bytes32 indexed label, string subdomain, uint amount, uint expirationDate);\r\n\r\n    // InterfaceID of these four methods is 0xc1b15f5a\r\n    function query(bytes32 label, string calldata subdomain) external view returns (string memory domain, uint signupFee, uint rent, uint referralFeePPM);\r\n    function register(bytes32 label, string calldata subdomain, address owner, address payable referrer, address resolver) external payable;\r\n\r\n    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp);\r\n    function payRent(bytes32 label, string calldata subdomain) external payable;\r\n}\r\n\r\n// File: @ensdomains/subdomain-registrar/contracts/AbstractSubdomainRegistrar.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract AbstractSubdomainRegistrar is RegistrarInterface {\r\n\r\n    // namehash('eth')\r\n    bytes32 constant public TLD_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\r\n\r\n    bool public stopped = false;\r\n    address public registrarOwner;\r\n    address public migration;\r\n\r\n    address public registrar;\r\n\r\n    ENS public ens;\r\n\r\n    modifier owner_only(bytes32 label) {\r\n        require(owner(label) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier not_stopped() {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n\r\n    modifier registrar_owner_only() {\r\n        require(msg.sender == registrarOwner);\r\n        _;\r\n    }\r\n\r\n    event DomainTransferred(bytes32 indexed label, string name);\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n        registrar = ens.owner(TLD_NODE);\r\n        registrarOwner = msg.sender;\r\n    }\r\n\r\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\r\n        // Get the subdomain so we can configure it\r\n        ens.setSubnodeOwner(node, label, address(this));\r\n\r\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\r\n        // Set the subdomain's resolver\r\n        ens.setResolver(subnode, address(resolver));\r\n\r\n        // Set the address record on the resolver\r\n        resolver.setAddr(subnode, subdomainOwner);\r\n\r\n        // Pass ownership of the new subdomain to the registrant\r\n        ens.setOwner(subnode, subdomainOwner);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return (\r\n            (interfaceID == 0x01ffc9a7) // supportsInterface(bytes4)\r\n            || (interfaceID == 0xc1b15f5a) // RegistrarInterface\r\n        );\r\n    }\r\n\r\n    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp) {\r\n        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the resolver record for a name in ENS.\r\n     * @param name The name to set the resolver for.\r\n     * @param resolver The address of the resolver\r\n     */\r\n    function setResolver(string memory name, address resolver) public owner_only(keccak256(bytes(name))) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        bytes32 node = keccak256(abi.encodePacked(TLD_NODE, label));\r\n        ens.setResolver(node, resolver);\r\n    }\r\n\r\n    /**\r\n     * @dev Configures a domain for sale.\r\n     * @param name The name to configure.\r\n     * @param price The price in wei to charge for subdomain registrations\r\n     * @param referralFeePPM The referral fee to offer, in parts per million\r\n     */\r\n    function configureDomain(string memory name, uint price, uint referralFeePPM) public {\r\n        configureDomainFor(name, price, referralFeePPM, msg.sender, address(0x0));\r\n    }\r\n\r\n    /**\r\n     * @dev Stops the registrar, disabling configuring of new domains.\r\n     */\r\n    function stop() public not_stopped registrar_owner_only {\r\n        stopped = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address where domains are migrated to.\r\n     * @param _migration Address of the new registrar.\r\n     */\r\n    function setMigrationAddress(address _migration) public registrar_owner_only {\r\n        require(stopped);\r\n        migration = _migration;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public registrar_owner_only {\r\n        registrarOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns information about a subdomain.\r\n     * @param label The label hash for the domain.\r\n     * @param subdomain The label for the subdomain.\r\n     * @return domain The name of the domain, or an empty string if the subdomain\r\n     *                is unavailable.\r\n     * @return price The price to register a subdomain, in wei.\r\n     * @return rent The rent to retain a subdomain, in wei per second.\r\n     * @return referralFeePPM The referral fee for the dapp, in ppm.\r\n     */\r\n    function query(bytes32 label, string calldata subdomain) external view returns (string memory domain, uint price, uint rent, uint referralFeePPM);\r\n\r\n    function owner(bytes32 label) public view returns (address);\r\n    function configureDomainFor(string memory name, uint price, uint referralFeePPM, address payable _owner, address _transfer) public;\r\n}\r\n\r\n// File: @ensdomains/subdomain-registrar/contracts/EthRegistrarSubdomainRegistrar.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implements an ENS registrar that sells subdomains on behalf of their owners.\r\n *\r\n * Users may register a subdomain by calling `register` with the name of the domain\r\n * they wish to register under, and the label hash of the subdomain they want to\r\n * register. They must also specify the new owner of the domain, and the referrer,\r\n * who is paid an optional finder's fee. The registrar then configures a simple\r\n * default resolver, which resolves `addr` lookups to the new owner, and sets\r\n * the `owner` account as the owner of the subdomain in ENS.\r\n *\r\n * New domains may be added by calling `configureDomain`, then transferring\r\n * ownership in the ENS registry to this contract. Ownership in the contract\r\n * may be transferred using `transfer`, and a domain may be unlisted for sale\r\n * using `unlistDomain`. There is (deliberately) no way to recover ownership\r\n * in ENS once the name is transferred to this registrar.\r\n *\r\n * Critically, this contract does not check one key property of a listed domain:\r\n *\r\n * - Is the name UTS46 normalised?\r\n *\r\n * User applications MUST check these two elements for each domain before\r\n * offering them to users for registration.\r\n *\r\n * Applications should additionally check that the domains they are offering to\r\n * register are controlled by this registrar, since calls to `register` will\r\n * fail if this is not the case.\r\n */\r\ncontract EthRegistrarSubdomainRegistrar is AbstractSubdomainRegistrar {\r\n\r\n    struct Domain {\r\n        string name;\r\n        address payable owner;\r\n        uint price;\r\n        uint referralFeePPM;\r\n    }\r\n\r\n    mapping (bytes32 => Domain) domains;\r\n\r\n    constructor(ENS ens) AbstractSubdomainRegistrar(ens) public { }\r\n\r\n    /**\r\n     * @dev owner returns the address of the account that controls a domain.\r\n     *      Initially this is a null address. If the name has been\r\n     *      transferred to this contract, then the internal mapping is consulted\r\n     *      to determine who controls it. If the owner is not set,\r\n     *      the owner of the domain in the Registrar is returned.\r\n     * @param label The label hash of the deed to check.\r\n     * @return The address owning the deed.\r\n     */\r\n    function owner(bytes32 label) public view returns (address) {\r\n        if (domains[label].owner != address(0x0)) {\r\n            return domains[label].owner;\r\n        }\r\n\r\n        return BaseRegistrar(registrar).ownerOf(uint256(label));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers internal control of a name to a new account. Does not update\r\n     *      ENS.\r\n     * @param name The name to transfer.\r\n     * @param newOwner The address of the new owner.\r\n     */\r\n    function transfer(string memory name, address payable newOwner) public owner_only(keccak256(bytes(name))) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        emit OwnerChanged(label, domains[label].owner, newOwner);\r\n        domains[label].owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Configures a domain, optionally transferring it to a new owner.\r\n     * @param name The name to configure.\r\n     * @param price The price in wei to charge for subdomain registrations.\r\n     * @param referralFeePPM The referral fee to offer, in parts per million.\r\n     * @param _owner The address to assign ownership of this domain to.\r\n     * @param _transfer The address to set as the transfer address for the name\r\n     *        when the permanent registrar is replaced. Can only be set to a non-zero\r\n     *        value once.\r\n     */\r\n    function configureDomainFor(string memory name, uint price, uint referralFeePPM, address payable _owner, address _transfer) public owner_only(keccak256(bytes(name))) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        Domain storage domain = domains[label];\r\n\r\n        if (BaseRegistrar(registrar).ownerOf(uint256(label)) != address(this)) {\r\n            BaseRegistrar(registrar).transferFrom(msg.sender, address(this), uint256(label));\r\n            BaseRegistrar(registrar).reclaim(uint256(label), address(this));\r\n        }\r\n\r\n        if (domain.owner != _owner) {\r\n            domain.owner = _owner;\r\n        }\r\n\r\n        if (keccak256(bytes(domain.name)) != label) {\r\n            // New listing\r\n            domain.name = name;\r\n        }\r\n\r\n        domain.price = price;\r\n        domain.referralFeePPM = referralFeePPM;\r\n\r\n        emit DomainConfigured(label);\r\n    }\r\n\r\n    /**\r\n     * @dev Unlists a domain\r\n     * May only be called by the owner.\r\n     * @param name The name of the domain to unlist.\r\n     */\r\n    function unlistDomain(string memory name) public owner_only(keccak256(bytes(name))) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        Domain storage domain = domains[label];\r\n        emit DomainUnlisted(label);\r\n\r\n        domain.name = '';\r\n        domain.price = 0;\r\n        domain.referralFeePPM = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns information about a subdomain.\r\n     * @param label The label hash for the domain.\r\n     * @param subdomain The label for the subdomain.\r\n     * @return domain The name of the domain, or an empty string if the subdomain\r\n     *                is unavailable.\r\n     * @return price The price to register a subdomain, in wei.\r\n     * @return rent The rent to retain a subdomain, in wei per second.\r\n     * @return referralFeePPM The referral fee for the dapp, in ppm.\r\n     */\r\n    function query(bytes32 label, string calldata subdomain) external view returns (string memory domain, uint price, uint rent, uint referralFeePPM) {\r\n        bytes32 node = keccak256(abi.encodePacked(TLD_NODE, label));\r\n        bytes32 subnode = keccak256(abi.encodePacked(node, keccak256(bytes(subdomain))));\r\n\r\n        if (ens.owner(subnode) != address(0x0)) {\r\n            return ('', 0, 0, 0);\r\n        }\r\n\r\n        Domain storage data = domains[label];\r\n        return (data.name, data.price, 0, data.referralFeePPM);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers a subdomain.\r\n     * @param label The label hash of the domain to register a subdomain of.\r\n     * @param subdomain The desired subdomain label.\r\n     * @param _subdomainOwner The account that should own the newly configured subdomain.\r\n     * @param referrer The address of the account to receive the referral fee.\r\n     */\r\n    function register(bytes32 label, string calldata subdomain, address _subdomainOwner, address payable referrer, address resolver) external not_stopped payable {\r\n        address subdomainOwner = _subdomainOwner;\r\n        bytes32 domainNode = keccak256(abi.encodePacked(TLD_NODE, label));\r\n        bytes32 subdomainLabel = keccak256(bytes(subdomain));\r\n\r\n        // Subdomain must not be registered already.\r\n        require(ens.owner(keccak256(abi.encodePacked(domainNode, subdomainLabel))) == address(0));\r\n\r\n        Domain storage domain = domains[label];\r\n\r\n        // Domain must be available for registration\r\n        require(keccak256(bytes(domain.name)) == label);\r\n\r\n        // User must have paid enough\r\n        require(msg.value >= domain.price);\r\n\r\n        // Send any extra back\r\n        if (msg.value > domain.price) {\r\n            msg.sender.transfer(msg.value - domain.price);\r\n        }\r\n\r\n        // Send any referral fee\r\n        uint256 total = domain.price;\r\n        if (domain.referralFeePPM > 0 && referrer != address(0x0) && referrer != domain.owner) {\r\n            uint256 referralFee = (domain.price * domain.referralFeePPM) / 1000000;\r\n            referrer.transfer(referralFee);\r\n            total -= referralFee;\r\n        }\r\n\r\n        // Send the registration fee\r\n        if (total > 0) {\r\n            domain.owner.transfer(total);\r\n        }\r\n\r\n        // Register the domain\r\n        if (subdomainOwner == address(0x0)) {\r\n            subdomainOwner = msg.sender;\r\n        }\r\n        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\r\n\r\n        emit NewRegistration(label, subdomain, subdomainOwner, referrer, domain.price);\r\n    }\r\n\r\n    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp) {\r\n        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n    }\r\n\r\n    /**\r\n     * @dev Migrates the domain to a new registrar.\r\n     * @param name The name of the domain to migrate.\r\n     */\r\n    function migrate(string memory name) public owner_only(keccak256(bytes(name))) {\r\n        require(stopped);\r\n        require(migration != address(0x0));\r\n\r\n        bytes32 label = keccak256(bytes(name));\r\n        Domain storage domain = domains[label];\r\n\r\n        BaseRegistrar(registrar).approve(migration, uint256(label));\r\n\r\n        EthRegistrarSubdomainRegistrar(migration).configureDomainFor(\r\n            domain.name,\r\n            domain.price,\r\n            domain.referralFeePPM,\r\n            domain.owner,\r\n            address(0x0)\r\n        );\r\n\r\n        delete domains[label];\r\n\r\n        emit DomainTransferred(label, name);\r\n    }\r\n\r\n    function payRent(bytes32 label, string calldata subdomain) external payable {\r\n        revert();\r\n    }\r\n}\r\n\r\n// File: @ensdomains/subdomain-registrar/contracts/ENSMigrationSubdomainRegistrar.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implements an ENS registrar that sells subdomains on behalf of their owners.\r\n *\r\n * Users may register a subdomain by calling `register` with the name of the domain\r\n * they wish to register under, and the label hash of the subdomain they want to\r\n * register. They must also specify the new owner of the domain, and the referrer,\r\n * who is paid an optional finder's fee. The registrar then configures a simple\r\n * default resolver, which resolves `addr` lookups to the new owner, and sets\r\n * the `owner` account as the owner of the subdomain in ENS.\r\n *\r\n * New domains may be added by calling `configureDomain`, then transferring\r\n * ownership in the ENS registry to this contract. Ownership in the contract\r\n * may be transferred using `transfer`, and a domain may be unlisted for sale\r\n * using `unlistDomain`. There is (deliberately) no way to recover ownership\r\n * in ENS once the name is transferred to this registrar.\r\n *\r\n * Critically, this contract does not check one key property of a listed domain:\r\n *\r\n * - Is the name UTS46 normalised?\r\n *\r\n * User applications MUST check these two elements for each domain before\r\n * offering them to users for registration.\r\n *\r\n * Applications should additionally check that the domains they are offering to\r\n * register are controlled by this registrar, since calls to `register` will\r\n * fail if this is not the case.\r\n */\r\ncontract ENSMigrationSubdomainRegistrar is EthRegistrarSubdomainRegistrar {\r\n\r\n    constructor(ENS ens) EthRegistrarSubdomainRegistrar(ens) public { }\r\n\r\n    function migrateSubdomain(bytes32 node, bytes32 label) external {\r\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\r\n        address previous = ens.owner(subnode);\r\n\r\n        // only allow a contract to run their own migration\r\n        require(!isContract(previous) || msg.sender == previous);\r\n\r\n        ens.setSubnodeRecord(node, label, previous, ens.resolver(subnode), ens.ttl(subnode));\r\n    }\r\n\r\n    function isContract(address addr) private returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ens\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"DomainConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"DomainTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"DomainUnlisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"NewRegistration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationDate\",\"type\":\"uint256\"}],\"name\":\"RentPaid\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"TLD_NODE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralFeePPM\",\"type\":\"uint256\"}],\"name\":\"configureDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralFeePPM\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_transfer\",\"type\":\"address\"}],\"name\":\"configureDomainFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"internalType\":\"contract ENS\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"migrateSubdomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migration\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"payRent\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"query\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralFeePPM\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_subdomainOwner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrarOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"rentDue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_migration\",\"type\":\"address\"}],\"name\":\"setMigrationAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"unlistDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ENSMigrationSubdomainRegistrar","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e","Library":"","LicenseType":"None","SwarmSource":"bzzr://8751e27803ad5386d933139faf690ecb1e80c3045ffede7816138b0531f8d76b"}]}