{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\r\n/*\r\n *\tLottery 5 of 36 (Weekly) v0.0.4\r\n */\r\n\r\n\r\ncontract SmartLotto {\r\n\r\n    // CONSTANTS //////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    uint private constant TICKET_PRICE = 0.01 ether;\r\n\r\n    uint8 private constant REQ_NUMBERS = 5;\r\n    uint8 private constant MAX_NUMBER = 36;\r\n    uint8 private constant MIN_WIN_MATCH = 2;\r\n    uint8 private constant ARR_SIZE = REQ_NUMBERS - MIN_WIN_MATCH + 1;\r\n\r\n    uint8 private constant DRAW_DOW = 2;\r\n    uint private constant DRAW_HOUR = 16 hours;\r\n    uint private constant BEF_PERIOD = 60 minutes;\r\n    uint private constant AFT_PERIOD = 60 minutes;\r\n\r\n    uint8 private constant PERCENT_FUND_PR = 20;\r\n    uint8[ARR_SIZE] private PERCENT_FUNDS = [20, 30, 35, 15];\r\n\r\n    // Controll addresses\r\n    address private constant CONTROL = 0x203bF6B46508eD917c085F50F194F36b0a62EB02;\r\n    address payable private constant PR = 0xCD66911b6f38FaAF5BFeE427b3Ceb7D18Dd09F78;\r\n    address payable private constant ADMIN_JACKPOT = 0x531d3Bd0400Ae601f26B335EfbD787415Aa5CB81;\r\n\r\n    uint private constant ACTIVITY_PERIOD = 20 weeks;\r\n    uint private constant POOL_SIZE = 50;\r\n\r\n    // STRUCTURES /////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    struct Member {\r\n        address payable addr;\r\n        uint8[REQ_NUMBERS] numbers;\r\n        uint8 matchNumbers;\r\n        uint prize;\r\n    }\r\n\r\n    struct Game {\r\n        uint membersCounter;\r\n        uint winnersCounter;\r\n        uint8[REQ_NUMBERS] winNumbers;\r\n        uint totalFund;\r\n        uint[ARR_SIZE] funds;\r\n        uint[ARR_SIZE] winners;\r\n        uint8 status;\r\n        mapping(uint => Member) members;\r\n        mapping(uint => uint) winTickets;\r\n    }\r\n\r\n    // VARIABLES //////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    uint8 private contractStatus = 1;\r\n\r\n    uint private gameNum = 1;\r\n    mapping(uint => Game) private games;\r\n\r\n    uint private firstActivityTime = 0;\r\n    uint private lastActivityTime = 0;\r\n    uint private adminJackpotAmount = 0;\r\n    \r\n    uint private poolCounter = 0;\r\n    uint private controlPhase = 0;\r\n\r\n    // EVENTS /////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    // _action: 0 - New game, 1 - Change status (Drawing), 2 - Jackpot change\r\n    event GameChanged(uint _gameNum, uint8 _action);\r\n    event MemberChanged(uint _gameNum, uint _member, uint _prize);\r\n\r\n    // API ////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    // For any status\r\n    function getGameInfo(uint gamenum) public view returns \r\n            (uint _gamenum, uint _membersCounter, uint _totalFund, uint8 _status) {\r\n        if (gamenum == 0) gamenum = gameNum;\r\n        return (gamenum, games[gamenum].membersCounter, games[gamenum].totalFund, games[gamenum].status);\r\n    }\r\n    // For any status\r\n    function getGameFunds(uint gamenum) public view returns (uint[ARR_SIZE] memory _funds) {\r\n        if (games[gamenum].status > 0)\r\n            _funds = games[gamenum].funds;\r\n        else\r\n            _funds = calcGameFunds();\r\n        return _funds;\r\n    }\r\n    // For status > 0\r\n    function getGameWinNumbers(uint gamenum) public view returns (uint8[REQ_NUMBERS] memory _winNumbers) {\r\n        return games[gamenum].winNumbers;\r\n    }\r\n    // For status == 2\r\n    function getGameWinners(uint gamenum) public view returns (uint[ARR_SIZE] memory _winners) {\r\n        return games[gamenum].winners;\r\n    }\r\n\r\n    function getMemberInfo(uint gamenum, uint member) public view returns \r\n        (address _addr, uint _prize, uint8[REQ_NUMBERS] memory _numbers) {\r\n        Member memory mbr = games[gamenum].members[member];\r\n        return (mbr.addr, mbr.prize, mbr.numbers);\r\n    }\r\n\r\n    // FUNCTIONS //////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    // ENTRY POINT\r\n    function() external payable {\r\n        \r\n        // Check contract status\r\n        require(contractStatus == 1, \"Contract closed.\");\r\n        \r\n        // CONTROL\r\n        if (msg.sender == CONTROL) {\r\n            doControl();\r\n            return;\r\n        }\r\n        \r\n        // For admin & user game status must be 0\r\n        require(games[gameNum].status == 0, \"The game is drawing, try again later.\");\r\n        \r\n        // ADMIN JACKPOT\r\n        if (msg.sender == ADMIN_JACKPOT) {\r\n            doAdminJackpot();\r\n            return;\r\n        }\r\n        // USER\r\n        uint8 weekday = getWeekday(now);\r\n        uint nowMinute = getDayMinute(now);\r\n        bool isDrawTime = (weekday == DRAW_DOW && (nowMinute > (DRAW_HOUR - BEF_PERIOD) / 60) && (nowMinute < (DRAW_HOUR + AFT_PERIOD) / 60));\r\n        \r\n        require(!isDrawTime, \"The game is drawing, try again later.\");\r\n        require(msg.value == TICKET_PRICE, \"Value must be '0.01' for play.\");\r\n        doUser();\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    // Admin Jackpot process\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function doAdminJackpot() private {\r\n        // If value > 0, increase admin jackpot and jackpot for current game\r\n        if (msg.value > 0) {\r\n            adminJackpotAmount += msg.value;\r\n            games[gameNum].funds[ARR_SIZE - 1] += msg.value;               // Increase last funds elem\r\n            emit GameChanged(gameNum, 2);\r\n            return;\r\n        }\r\n        returnAdminJackpot();\r\n    }\r\n    \r\n    // Return admin jackpot after ACTIVITY PERIOD\r\n    function returnAdminJackpot() private {\r\n        // Requires\r\n        require(adminJackpotAmount > 0, \r\n            \"Admin Jackpot amount must be greater than 0.\");\r\n        uint gameJackpotAmount = games[gameNum].funds[ARR_SIZE - 1];\r\n        require(gameJackpotAmount > adminJackpotAmount * 2 || (now - firstActivityTime) > ACTIVITY_PERIOD,\r\n            \"Jackpot return is not currently available.\");\r\n\r\n        if (gameJackpotAmount > adminJackpotAmount) {\r\n            ADMIN_JACKPOT.transfer(adminJackpotAmount);\r\n            games[gameNum].funds[ARR_SIZE - 1] -= adminJackpotAmount;\r\n        } else {\r\n            ADMIN_JACKPOT.transfer(gameJackpotAmount);\r\n            games[gameNum].funds[ARR_SIZE - 1] = 0;\r\n        }\r\n        adminJackpotAmount = 0;\r\n        emit GameChanged(gameNum, 2);\r\n\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    // Control process\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function doControl() private {\r\n        require(msg.value == 0, \"Control value must be 0.\");\r\n        // First time check contract activity and generate winning numbers\r\n        if (games[gameNum].status == 0) {\r\n            // Check contract activity\r\n            checkContractActivity();\r\n            if (contractStatus == 0) return;\r\n            // Change game status to \"Draw\"\r\n            games[gameNum].status = 1;\r\n            // Generate winning numbers\r\n            games[gameNum].winNumbers = generateNumbers();\r\n            // Transfer PR fund\r\n            uint fundPR = games[gameNum].totalFund * PERCENT_FUND_PR / 100;\r\n            PR.transfer(fundPR);\r\n            // Calculate game funds\r\n            games[gameNum].funds = calcGameFunds();\r\n            emit GameChanged(gameNum, 1);\r\n            // Set control phase to 0 (Calculate)\r\n            controlPhase = 0;\r\n            // Reset pool counter to 0\r\n            poolCounter = 0;\r\n        }\r\n\r\n        if (controlPhase == 0) {\r\n            doCalculate();\r\n        } else {\r\n            doPayout();\r\n        }\r\n\r\n    }\r\n\r\n    function doCalculate() private {\r\n\r\n        // Process members list (calculate every match winners)\r\n        uint index;\r\n        uint8 mn;\r\n        uint8[ARR_SIZE] memory _w;\r\n        \r\n        uint start = POOL_SIZE * poolCounter + 1;\r\n        uint end = POOL_SIZE * poolCounter + POOL_SIZE;\r\n\r\n        if (end > games[gameNum].membersCounter) end = games[gameNum].membersCounter;\r\n\r\n        // Calulate winners for pool \r\n        for (uint i = start; i <= end; i++) {\r\n            mn = findMatch(games[gameNum].winNumbers, games[gameNum].members[i].numbers);\r\n            // Change ticket match numbers\r\n            if (mn > 0)\r\n                games[gameNum].members[i].matchNumbers = mn;\r\n            // If ticket win prize \r\n            if (mn >= MIN_WIN_MATCH) {\r\n                _w[mn - MIN_WIN_MATCH]++;\r\n                games[gameNum].winnersCounter++;\r\n                index = games[gameNum].winnersCounter;\r\n                games[gameNum].winTickets[index] = i;\r\n            }\r\n        }\r\n\r\n        // Icrease game winners count\r\n        for (uint8 i = 0; i < ARR_SIZE; i++)\r\n            if (_w[i] != 0)\r\n                games[gameNum].winners[i] += _w[i];\r\n\r\n        // If last pool\r\n        if (end == games[gameNum].membersCounter) {\r\n            \r\n            // If not exist matches 2/5, 3/5 etc, increase game jackpot on fund2, fund3 etc\r\n            for (uint8 i = 0; i < ARR_SIZE - 1; i++) {\r\n                if (games[gameNum].winners[i] == 0) \r\n                    games[gameNum].funds[ARR_SIZE - 1] += games[gameNum].funds[i];\r\n            }   \r\n\r\n            // Check and transit Jackpot\r\n            if (games[gameNum].winners[ARR_SIZE - 1] != 0) {\r\n                adminJackpotAmount = 0;\r\n            } else {\r\n                games[gameNum + 1].funds[ARR_SIZE - 1] = games[gameNum].funds[ARR_SIZE - 1];\r\n            }\r\n\r\n            // Set control phase to 1 (Payout) and reset poolCounter to 0\r\n            controlPhase = 1;\r\n            poolCounter = 0;\r\n\r\n        } else {\r\n            poolCounter++;\r\n        }\r\n\r\n    }\r\n\r\n    function doPayout() private {\r\n\r\n        // Process winning tickets list and payout prize\r\n        uint winTicket;\r\n        uint prize;\r\n        uint8 mn;\r\n        uint start = POOL_SIZE * poolCounter + 1;\r\n        uint end = POOL_SIZE * poolCounter + POOL_SIZE;\r\n\r\n        if (end > games[gameNum].winnersCounter) end = games[gameNum].winnersCounter;\r\n\r\n        // Loop winning tickets and payout RRR\r\n        for (uint i = start; i <= end; i++) {\r\n            winTicket = games[gameNum].winTickets[i];\r\n            mn = games[gameNum].members[winTicket].matchNumbers;\r\n            prize = games[gameNum].funds[mn - MIN_WIN_MATCH] / games[gameNum].winners[mn - MIN_WIN_MATCH];\r\n            games[gameNum].members[winTicket].prize = prize;\r\n            games[gameNum].members[winTicket].addr.transfer(prize);\r\n            emit MemberChanged(gameNum, i, prize);\r\n        }\r\n\r\n        if (end == games[gameNum].winnersCounter) {\r\n            // Change game status on \"Closed\"\r\n            games[gameNum].status = 2;\r\n            // Init Next Game\r\n            gameNum++;\r\n            emit GameChanged(gameNum, 0);\r\n        } else {\r\n            poolCounter++;\r\n        }\r\n\r\n    }\r\n\r\n    // Check contract activity\r\n    function checkContractActivity() private {\r\n        uint balance = address(this).balance;\r\n        // Set last activity\r\n        if (games[gameNum].membersCounter > 0) {\r\n            lastActivityTime = now;\r\n        }\r\n        // Check last activity\r\n        if (now - lastActivityTime > ACTIVITY_PERIOD) {\r\n            PR.transfer(balance);\r\n            contractStatus = 0;\r\n            games[gameNum].funds[ARR_SIZE - 1] = 0;\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    // User process\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function doUser() private {\r\n        \r\n        // First activity & last activity\r\n        if (firstActivityTime == 0) {\r\n            firstActivityTime = now;\r\n            lastActivityTime = now;\r\n        }\r\n        \r\n        doTicket();\r\n    }\r\n    \r\n    // Ticket process\r\n    function doTicket() private {\r\n\r\n        bool err = false;\r\n        uint8[REQ_NUMBERS] memory numbers;\r\n\r\n        // Parse and check msg.DATA\r\n        (err, numbers) = parseCheckData();\r\n\r\n        uint mbrCnt;\r\n\r\n        // If error DATA, generate random ticket numbers\r\n        if (err) {\r\n            numbers = generateNumbers();    \r\n        } else {\r\n            numbers = sortNumbers(numbers);    \r\n        }\r\n\r\n        // Increase member counter and total fund\r\n        games[gameNum].membersCounter++;\r\n        games[gameNum].totalFund += msg.value;\r\n\r\n        // Store member\r\n        mbrCnt = games[gameNum].membersCounter;\r\n        games[gameNum].members[mbrCnt].addr = msg.sender;\r\n        games[gameNum].members[mbrCnt].numbers = numbers;\r\n\r\n        emit MemberChanged(gameNum, mbrCnt, 0);\r\n\r\n    }\r\n\r\n    // UTILS //////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    // Get timestamp minute of day\r\n    function getDayMinute(uint timestamp) private pure returns (uint) {\r\n        return ((timestamp / 60) % 1440);\r\n    }\r\n\r\n    // Get timestamp day of week\r\n    function getWeekday(uint timestamp) private pure returns (uint8) {\r\n        return uint8((timestamp / 86400 + 4) % 7);\r\n    }\r\n    \r\n    // Generate random number\r\n    function random(uint8 num) internal view returns (uint8) {\r\n        return uint8((uint(blockhash(block.number - 1 - num*2)) + now) % MAX_NUMBER + 1);\r\n    }\r\n\r\n    // Generate winning numbers\r\n    function generateNumbers() private view returns (uint8[REQ_NUMBERS] memory numbers) {\r\n        // Generate random numbers\r\n        for (uint8 i = 0; i < REQ_NUMBERS; i++) numbers[i] = random(i);\r\n        // Sort numbers array\r\n        numbers = sortNumbers(numbers);\r\n        // Change dublicate numbers\r\n        for (uint8 i = 0; i < REQ_NUMBERS - 1; i++)\r\n            for (uint8 j = i + 1; j < REQ_NUMBERS; j++)\r\n                if (numbers[i] == numbers[j])\r\n                    numbers[j]++;\r\n\r\n        return numbers;\r\n    }\r\n\r\n    // Sort array of number function\r\n    function sortNumbers(uint8[REQ_NUMBERS] memory arrNumbers) private pure returns (uint8[REQ_NUMBERS] memory) {\r\n        uint8 temp;\r\n        for (uint8 i = 0; i < REQ_NUMBERS - 1; i++)\r\n            for (uint j = 0; j < REQ_NUMBERS - i - 1; j++)\r\n                if (arrNumbers[j] > arrNumbers[j + 1]) {\r\n                    temp = arrNumbers[j];\r\n                    arrNumbers[j] = arrNumbers[j + 1];\r\n                    arrNumbers[j + 1] = temp;\r\n                }\r\n\r\n        return arrNumbers;\r\n    }\r\n\r\n    // Find match numbers function\r\n    function findMatch(uint8[REQ_NUMBERS] memory arr1, uint8[REQ_NUMBERS] memory arr2) private pure returns (uint8) {\r\n        uint8 cnt = 0;\r\n        for (uint8 i = 0; i < REQ_NUMBERS; i++)\r\n            for (uint8 j = 0; j < REQ_NUMBERS; j++)\r\n                if (arr1[i] == arr2[j]) {\r\n                    cnt++;\r\n                    break;\r\n                }\r\n        return cnt;\r\n    }\r\n\r\n    // Parse and check msg.DATA function\r\n    function parseCheckData() private pure returns (bool, uint8[REQ_NUMBERS] memory) {\r\n        bool err = false;\r\n        uint8[REQ_NUMBERS] memory numbers;\r\n\r\n        // Check 5 numbers entered\r\n        if (msg.data.length == REQ_NUMBERS) {\r\n            // Parse DATA string\r\n            for (uint8 i = 0; i < REQ_NUMBERS; i++)\r\n                numbers[i] = uint8(msg.data[i]);\r\n\r\n            // Check range: 1 - MAX_NUMBER\r\n            for (uint8 i = 0; i < REQ_NUMBERS; i++)\r\n                if (numbers[i] < 1 || numbers[i] > MAX_NUMBER) {\r\n                    err = true;\r\n                    break;\r\n                }\r\n            // Check dublicate numbers\r\n            if (!err)\r\n                for (uint8 i = 0; i < REQ_NUMBERS - 1; i++) {\r\n                    for (uint8 j = i + 1; j < REQ_NUMBERS; j++) {\r\n                        if (numbers[i] == numbers[j]) {\r\n                            err = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (err) break;\r\n                }\r\n        } else {\r\n            err = true;\r\n        }\r\n        return (err, numbers);\r\n    }\r\n    \r\n    // Calculate game funds\r\n    function calcGameFunds() private view returns (uint[ARR_SIZE] memory funds) {\r\n        uint fundPR = games[gameNum].totalFund * PERCENT_FUND_PR / 100;\r\n        for (uint8 i = 0; i < ARR_SIZE; i++)\r\n            funds[i] = (games[gameNum].totalFund - fundPR) * PERCENT_FUNDS[i] / 100;\r\n        funds[ARR_SIZE - 1] += games[gameNum].funds[ARR_SIZE - 1];\r\n        return funds;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"gamenum\",\"type\":\"uint256\"}],\"name\":\"getGameFunds\",\"outputs\":[{\"name\":\"_funds\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gamenum\",\"type\":\"uint256\"}],\"name\":\"getGameWinners\",\"outputs\":[{\"name\":\"_winners\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gamenum\",\"type\":\"uint256\"}],\"name\":\"getGameWinNumbers\",\"outputs\":[{\"name\":\"_winNumbers\",\"type\":\"uint8[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gamenum\",\"type\":\"uint256\"}],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"_gamenum\",\"type\":\"uint256\"},{\"name\":\"_membersCounter\",\"type\":\"uint256\"},{\"name\":\"_totalFund\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gamenum\",\"type\":\"uint256\"},{\"name\":\"member\",\"type\":\"uint256\"}],\"name\":\"getMemberInfo\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_prize\",\"type\":\"uint256\"},{\"name\":\"_numbers\",\"type\":\"uint8[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_gameNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_action\",\"type\":\"uint8\"}],\"name\":\"GameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_gameNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_member\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_prize\",\"type\":\"uint256\"}],\"name\":\"MemberChanged\",\"type\":\"event\"}]","ContractName":"SmartLotto","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://a9d487593a79678d0071a5e44affbf64a655d3f75d190878fdc6046abaf47aed"}]}