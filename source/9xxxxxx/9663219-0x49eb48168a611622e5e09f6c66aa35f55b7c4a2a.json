{"status":"1","message":"OK","result":[{"SourceCode":"{\"Agent.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Agent contract - base contract with an agent\\n */\\ncontract Agent is Ownable {\\n    mapping(address =\\u003e bool) public Agents;\\n\\n    event UpdatedAgent(address _agent, bool _status);\\n\\n    modifier onlyAgent() {\\n        assert(Agents[msg.sender]);\\n        _;\\n    }\\n\\n    function updateAgent(address _agent, bool _status) public onlyOwner {\\n        assert(_agent != address(0));\\n        Agents[_agent] = _status;\\n\\n        emit UpdatedAgent(_agent, _status);\\n    }\\n}\\n\"},\"CashBackMoney.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\nimport \\\"./Agent.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./CashBackMoneyI.sol\\\";\\n\\n/**\\n * @title CashBackMoney Investing Contract\\n */\\ncontract CashBackMoney is CashBackMoneyI, Agent {\\n    using SafeMath for uint256;\\n\\n    // Constants\\n    uint256 public constant amount1 = 0.05 ether;\\n    uint256 public constant amount2 = 0.10 ether;\\n    uint256 public constant amount3 = 0.50 ether;\\n    uint256 public constant amount4 = 1.00 ether;\\n    uint256 public constant amount5 = 5.00 ether;\\n    uint256 public constant amount6 = 10.00 ether;\\n\\n    uint256 public constant subs_amount1 = 1.00 ether;\\n    uint256 public constant subs_amount2 = 5.00 ether;\\n    uint256 public constant subs_amount3 = 10.00 ether;\\n\\n    uint256 public constant subs_amount_with_fee1 = 1.18 ether;\\n    uint256 public constant subs_amount_with_fee2 = 5.90 ether;\\n    uint256 public constant subs_amount_with_fee3 = 11.80 ether;\\n\\n    uint256 days1 = 1 days;\\n    uint256 hours24 = 24 hours;\\n    uint256 hours3 = 3 hours;\\n\\n    // Variables\\n    bool public production = false;\\n    uint256 public deploy_block;\\n\\n    address payable public reward_account;\\n    uint256 public reward;\\n    uint256 public start_point;\\n\\n    uint256 public NumberOfParticipants = 0;\\n    uint256 public NumberOfClicks = 0;\\n    uint256 public NumberOfSubscriptions = 0;\\n    uint256 public ProfitPayoutAmount = 0;\\n    uint256 public FundBalance = 0;\\n\\n    uint256 public LastRefererID = 0;\\n\\n    // RefererID[referer address]\\n    mapping(address =\\u003e uint256) public RefererID;\\n\\n    // RefererAddr[referer ID]\\n    mapping(uint256 =\\u003e address) public RefererAddr;\\n\\n    // Referer[Referal address]\\n    mapping(address =\\u003e uint256) public Referer;\\n\\n    // Participants[address]\\n    mapping(address =\\u003e bool) public Participants;\\n\\n    // OwnerAmountStatus[owner address][payXamount]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e bool)) public OwnerAmountStatus;\\n\\n    // RefClickCount[referer address][payXamount]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public RefClickCount;\\n\\n    // OwnerTotalProfit[owner address]\\n    mapping(address =\\u003e uint256) public OwnerTotalProfit;\\n\\n    // RefTotalClicks[referer address]\\n    mapping(address =\\u003e uint256) public RefTotalClicks;\\n\\n    // RefTotalIncome[referer address]\\n    mapping(address =\\u003e uint256) public RefTotalIncome;\\n\\n    // Balances[address][level][payXamount]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e bool))) public Balances;\\n\\n    // WithdrawDate[address][level][payXamount]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256))) public WithdrawDate;\\n\\n    // OwnerAutoClickCount[owner address][msg.value][GetPeriod(now)]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256))) public OwnerAutoClickCount;\\n\\n    // RefAutoClickCount[referer address][msg.value][GetPeriod(now)]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256))) public RefAutoClickCount;\\n\\n    // AutoBalances[address][payXamount]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e bool)) public AutoBalances;\\n\\n    // WithdrawAutoDate[address][payXamount]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public WithdrawAutoDate;\\n\\n    // Subscriptions[address][payXamount]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public Subscriptions;\\n\\n    // Intermediate[address][payXamount]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public Intermediate;\\n\\n    // RefSubscCount[referer address][payXamount][Period]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256))) public RefSubscCount;\\n\\n    // RefSubscStatus[owner address][payXamount][Period]\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e bool))) public RefSubscStatus;\\n\\n    // Events\\n    event ChangeContractBalance(string text);\\n\\n    event ChangeClickRefefalNumbers(\\n        address indexed referer,\\n        uint256 amount,\\n        uint256 number\\n    );\\n\\n    event AmountInvestedByPay(address indexed owner, uint256 amount);\\n    event AmountInvestedByAutoPay(address indexed owner, uint256 amount);\\n    event AmountInvestedBySubscription(address indexed owner, uint256 amount);\\n\\n    event AmountWithdrawnFromPay(address indexed owner, uint256 amount);\\n    event AmountWithdrawnFromAutoPay(address indexed owner, uint256 amount);\\n    event AmountWithdrawnFromSubscription(\\n        address indexed owner,\\n        uint256 amount\\n    );\\n\\n    /**\\n    * Contructor\\n    */\\n    constructor(\\n        address payable _reward_account,\\n        uint256 _reward,\\n        uint256 _start_point,\\n        bool _mode\\n    ) public {\\n        reward_account = _reward_account;\\n        reward = _reward;\\n        start_point = _start_point;\\n\\n        production = _mode;\\n        deploy_block = block.number;\\n    }\\n\\n    modifier onlyFixedAmount(uint256 _amount) {\\n        require(\\n            _amount == amount1 ||\\n                _amount == amount2 ||\\n                _amount == amount3 ||\\n                _amount == amount4 ||\\n                _amount == amount5 ||\\n                _amount == amount6,\\n            \\\"CashBackMoney: wrong msg.value\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyFixedAmountSubs(uint256 _amount) {\\n        require(\\n            _amount == subs_amount_with_fee1 ||\\n                _amount == subs_amount_with_fee2 ||\\n                _amount == subs_amount_with_fee3,\\n            \\\"CashBackMoney: wrong msg.value for subscription\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyFixedAmountWithdrawSubs(uint256 _amount) {\\n        require(\\n            _amount == subs_amount1 ||\\n                _amount == subs_amount2 ||\\n                _amount == subs_amount3,\\n            \\\"CashBackMoney: wrong msg.value for subscription\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyInStagingMode() {\\n        require(\\n            !production,\\n            \\\"CashBackMoney: this function can only be used in the stage mode\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n    *  Pay or Withdraw all possible \\\"pay\\\" amount\\n    */\\n    function() external payable {\\n        if (\\n            (msg.value == subs_amount_with_fee1) ||\\n            (msg.value == subs_amount_with_fee2) ||\\n            (msg.value == subs_amount_with_fee3)\\n        ) {\\n            Subscribe(0);\\n        } else if (msg.value \\u003e 0) {\\n            PayAll(msg.value);\\n        } else {\\n            WithdrawPayAll();\\n            WithdrawSubscribeAll();\\n        }\\n    }\\n\\n    /**\\n    * To replenish the balance of the contract\\n    */\\n    function TopUpContract() external payable {\\n        require(msg.value \\u003e 0, \\\"TopUpContract: msg.value must be great than 0\\\");\\n        emit ChangeContractBalance(\\\"Thank you very much\\\");\\n    }\\n\\n    /**\\n    *  GetPeriod - calculate period for all functions\\n    */\\n    function GetPeriod(uint256 _timestamp)\\n        internal\\n        view\\n        returns (uint256 _period)\\n    {\\n        return (_timestamp.sub(start_point)).div(days1);\\n    }\\n\\n    /**\\n    *  Accept payment\\n    */\\n    function Pay(uint256 _level, uint256 _refererID)\\n        external\\n        payable\\n        onlyFixedAmount(msg.value)\\n    {\\n        // If a RefererID is not yet assigned\\n        if (RefererID[msg.sender] == 0) {\\n            CreateRefererID(msg.sender);\\n        }\\n\\n        require(\\n            RefererID[msg.sender] != _refererID,\\n            \\\"Pay: you cannot be a referral to yourself\\\"\\n        );\\n        require(_level \\u003e 0 \\u0026\\u0026 _level \\u003c 4, \\\"Pay: level can only be 1,2 or 3\\\");\\n        require(\\n            !Balances[msg.sender][_level][msg.value],\\n            \\\"Pay: amount already paid\\\"\\n        );\\n\\n        // If owner invest this amount for the first time\\n        if (!OwnerAmountStatus[msg.sender][msg.value]) {\\n            OwnerAmountStatus[msg.sender][msg.value] = true;\\n        }\\n\\n        // If a referrer is not yet installed\\n        if ((Referer[msg.sender] == 0) \\u0026\\u0026 (_refererID != 0)) {\\n            Referer[msg.sender] = _refererID;\\n        }\\n\\n        // Add to Total \\u0026 AutoClick\\n        if (\\n            (Referer[msg.sender] != 0) \\u0026\\u0026\\n            (OwnerAmountStatus[RefererAddr[Referer[msg.sender]]][msg.value])\\n        ) {\\n            RefTotalClicks[RefererAddr[Referer[msg.sender]]] += 1;\\n            RefTotalIncome[RefererAddr[Referer[msg.sender]]] += msg.value;\\n\\n            RefClickCount[RefererAddr[Referer[msg.sender]]][msg.value] += 1;\\n            emit ChangeClickRefefalNumbers(\\n                RefererAddr[Referer[msg.sender]],\\n                msg.value,\\n                RefClickCount[RefererAddr[Referer[msg.sender]]][msg.value]\\n            );\\n\\n            uint256 Current = GetPeriod(now);\\n            uint256 Start = Current - 30;\\n\\n            OwnerAutoClickCount[msg.sender][msg.value][Current] += 1;\\n\\n            uint256 CountOp = 0;\\n\\n            for (uint256 k = Start; k \\u003c Current; k++) {\\n                CountOp += OwnerAutoClickCount[msg.sender][msg.value][k];\\n            }\\n\\n            if (CountOp \\u003e= 30) {\\n                RefAutoClickCount[RefererAddr[Referer[msg.sender]]][msg\\n                    .value][Current] += 1;\\n            }\\n        }\\n\\n        uint256 refs;\\n        uint256 wd_time;\\n\\n        if (_level == 1) {\\n            if (RefClickCount[msg.sender][msg.value] \\u003e 21) {\\n                refs = 21;\\n            } else {\\n                refs = RefClickCount[msg.sender][msg.value];\\n            }\\n        }\\n\\n        if (_level == 2) {\\n            require(\\n                RefClickCount[msg.sender][msg.value] \\u003e= 21,\\n                \\\"Pay: not enough referrals\\\"\\n            );\\n            if (RefClickCount[msg.sender][msg.value] \\u003e 42) {\\n                refs = 21;\\n            } else {\\n                refs = RefClickCount[msg.sender][msg.value].sub(21);\\n            }\\n        }\\n\\n        if (_level == 3) {\\n            require(\\n                RefClickCount[msg.sender][msg.value] \\u003e= 42,\\n                \\\"Pay: not enough referrals\\\"\\n            );\\n            if (RefClickCount[msg.sender][msg.value] \\u003e 63) {\\n                refs = 21;\\n            } else {\\n                refs = RefClickCount[msg.sender][msg.value].sub(42);\\n            }\\n        }\\n\\n        wd_time = now.add(hours24);\\n        wd_time = wd_time.sub((refs.div(3)).mul(hours3));\\n\\n        RefClickCount[msg.sender][msg.value] = RefClickCount[msg.sender][msg\\n            .value]\\n            .sub(refs.div(3).mul(3));\\n        emit ChangeClickRefefalNumbers(\\n            msg.sender,\\n            msg.value,\\n            RefClickCount[msg.sender][msg.value]\\n        );\\n\\n        Balances[msg.sender][_level][msg.value] = true;\\n        WithdrawDate[msg.sender][_level][msg.value] = wd_time;\\n\\n        reward_account.transfer(msg.value.perc(reward));\\n\\n        if (!Participants[msg.sender]) {\\n            Participants[msg.sender] = true;\\n            NumberOfParticipants += 1;\\n        }\\n\\n        FundBalance += msg.value.perc(reward);\\n        NumberOfClicks += 1;\\n        emit AmountInvestedByPay(msg.sender, msg.value);\\n    }\\n\\n    /**\\n    *  Withdraw \\\"pay\\\" sum\\n    */\\n    function WithdrawPay(uint256 _level, uint256 _amount)\\n        external\\n        onlyFixedAmount(_amount)\\n    {\\n        require(\\n            Balances[msg.sender][_level][_amount],\\n            \\\"WithdrawPay: amount has not yet been paid\\\"\\n        );\\n        require(\\n            now \\u003e= WithdrawDate[msg.sender][_level][_amount],\\n            \\\"WithdrawPay: time has not come yet\\\"\\n        );\\n\\n        Balances[msg.sender][_level][_amount] = false;\\n        WithdrawDate[msg.sender][_level][_amount] = 0;\\n\\n        uint256 Amount = _amount.add(_amount.perc(100));\\n        msg.sender.transfer(Amount);\\n\\n        OwnerTotalProfit[msg.sender] += _amount.perc(100);\\n        ProfitPayoutAmount += Amount;\\n        emit AmountWithdrawnFromPay(msg.sender, Amount);\\n    }\\n\\n    /**\\n    *  Accept payment and its automatic distribution\\n    */\\n    function PayAll(uint256 _amount) internal onlyFixedAmount(_amount) {\\n        uint256 refs;\\n        uint256 wd_time;\\n        uint256 level = 0;\\n\\n        // If a RefererID is not yet assigned\\n        if (RefererID[msg.sender] == 0) {\\n            CreateRefererID(msg.sender);\\n        }\\n\\n        if (!Balances[msg.sender][1][_amount]) {\\n            level = 1;\\n            if (RefClickCount[msg.sender][_amount] \\u003e 21) {\\n                refs = 21;\\n            } else {\\n                refs = RefClickCount[msg.sender][_amount];\\n            }\\n        }\\n\\n        if (\\n            (level == 0) \\u0026\\u0026\\n            (!Balances[msg.sender][2][_amount]) \\u0026\\u0026\\n            (RefClickCount[msg.sender][_amount] \\u003e= 21)\\n        ) {\\n            level = 2;\\n            if (RefClickCount[msg.sender][_amount] \\u003e 42) {\\n                refs = 21;\\n            } else {\\n                refs = RefClickCount[msg.sender][_amount].sub(21);\\n            }\\n        }\\n\\n        if (\\n            (level == 0) \\u0026\\u0026\\n            (!Balances[msg.sender][3][_amount]) \\u0026\\u0026\\n            (RefClickCount[msg.sender][_amount] \\u003e= 42)\\n        ) {\\n            level = 3;\\n            if (RefClickCount[msg.sender][_amount] \\u003e 63) {\\n                refs = 21;\\n            } else {\\n                refs = RefClickCount[msg.sender][_amount].sub(42);\\n            }\\n        }\\n\\n        require(\\n            level \\u003e 0,\\n            \\\"PayAll: amount already paid or not enough referals\\\"\\n        );\\n\\n        wd_time = now.add(hours24);\\n        wd_time = wd_time.sub((refs.div(3)).mul(hours3));\\n\\n        RefClickCount[msg.sender][msg.value] = RefClickCount[msg.sender][msg\\n            .value]\\n            .sub(refs.div(3).mul(3));\\n        emit ChangeClickRefefalNumbers(\\n            msg.sender,\\n            msg.value,\\n            RefClickCount[msg.sender][msg.value]\\n        );\\n\\n        Balances[msg.sender][level][_amount] = true;\\n        WithdrawDate[msg.sender][level][_amount] = wd_time;\\n\\n        reward_account.transfer(_amount.perc(reward));\\n\\n        if (!Participants[msg.sender]) {\\n            Participants[msg.sender] = true;\\n            NumberOfParticipants += 1;\\n        }\\n\\n        FundBalance += _amount.perc(reward);\\n        NumberOfClicks += 1;\\n        emit AmountInvestedByPay(msg.sender, _amount);\\n    }\\n\\n    /**\\n    *  Withdraw all possible \\\"pay\\\" sum\\n    */\\n    function WithdrawPayAll() public {\\n        uint256 Amount = 0;\\n\\n        for (uint256 i = 1; i \\u003c= 3; i++) {\\n            if (\\n                (Balances[msg.sender][i][amount1]) \\u0026\\u0026\\n                (now \\u003e= WithdrawDate[msg.sender][i][amount1])\\n            ) {\\n                Balances[msg.sender][i][amount1] = false;\\n                WithdrawDate[msg.sender][i][amount1] = 0;\\n                Amount += amount1.add(amount1.perc(100));\\n                OwnerTotalProfit[msg.sender] += amount1.perc(100);\\n            }\\n            if (\\n                (Balances[msg.sender][i][amount2]) \\u0026\\u0026\\n                (now \\u003e= WithdrawDate[msg.sender][i][amount2])\\n            ) {\\n                Balances[msg.sender][i][amount2] = false;\\n                WithdrawDate[msg.sender][i][amount2] = 0;\\n                Amount += amount2.add(amount2.perc(100));\\n                OwnerTotalProfit[msg.sender] += amount2.perc(100);\\n            }\\n            if (\\n                (Balances[msg.sender][i][amount3]) \\u0026\\u0026\\n                (now \\u003e= WithdrawDate[msg.sender][i][amount3])\\n            ) {\\n                Balances[msg.sender][i][amount3] = false;\\n                WithdrawDate[msg.sender][i][amount3] = 0;\\n                Amount += amount3.add(amount3.perc(100));\\n                OwnerTotalProfit[msg.sender] += amount3.perc(100);\\n            }\\n            if (\\n                (Balances[msg.sender][i][amount4]) \\u0026\\u0026\\n                (now \\u003e= WithdrawDate[msg.sender][i][amount4])\\n            ) {\\n                Balances[msg.sender][i][amount4] = false;\\n                WithdrawDate[msg.sender][i][amount4] = 0;\\n                Amount += amount4.add(amount4.perc(100));\\n                OwnerTotalProfit[msg.sender] += amount4.perc(100);\\n            }\\n            if (\\n                (Balances[msg.sender][i][amount5]) \\u0026\\u0026\\n                (now \\u003e= WithdrawDate[msg.sender][i][amount5])\\n            ) {\\n                Balances[msg.sender][i][amount5] = false;\\n                WithdrawDate[msg.sender][i][amount5] = 0;\\n                Amount += amount5.add(amount5.perc(100));\\n                OwnerTotalProfit[msg.sender] += amount5.perc(100);\\n            }\\n            if (\\n                (Balances[msg.sender][i][amount6]) \\u0026\\u0026\\n                (now \\u003e= WithdrawDate[msg.sender][i][amount6])\\n            ) {\\n                Balances[msg.sender][i][amount6] = false;\\n                WithdrawDate[msg.sender][i][amount6] = 0;\\n                Amount += amount6.add(amount6.perc(100));\\n                OwnerTotalProfit[msg.sender] += amount6.perc(100);\\n            }\\n        }\\n\\n        if (Amount \\u003e 0) {\\n            msg.sender.transfer(Amount);\\n\\n            ProfitPayoutAmount += Amount;\\n            emit AmountWithdrawnFromPay(msg.sender, Amount);\\n        }\\n    }\\n\\n    /**\\n    *  Accept auto payment\\n    */\\n    function AutoPay(uint256 _refererID)\\n        external\\n        payable\\n        onlyFixedAmount(msg.value)\\n    {\\n        // If a RefererID is not yet assigned\\n        if (RefererID[msg.sender] == 0) {\\n            CreateRefererID(msg.sender);\\n        }\\n\\n        require(\\n            RefererID[msg.sender] != _refererID,\\n            \\\"AutoPay: you cannot be a referral to yourself\\\"\\n        );\\n        require(\\n            !AutoBalances[msg.sender][msg.value],\\n            \\\"AutoPay: amount already paid\\\"\\n        );\\n\\n        // If a referrer is not yet installed\\n        if ((Referer[msg.sender] == 0) \\u0026\\u0026 (_refererID != 0)) {\\n            Referer[msg.sender] = _refererID;\\n        }\\n\\n        // Add to Total \\u0026 AutoClick\\n        if (\\n            (Referer[msg.sender] != 0) \\u0026\\u0026\\n            (OwnerAmountStatus[RefererAddr[Referer[msg.sender]]][msg.value])\\n        ) {\\n            RefTotalClicks[RefererAddr[Referer[msg.sender]]] += 1;\\n            RefTotalIncome[RefererAddr[Referer[msg.sender]]] += msg.value;\\n\\n            RefClickCount[RefererAddr[Referer[msg.sender]]][msg.value] += 1;\\n            emit ChangeClickRefefalNumbers(\\n                RefererAddr[Referer[msg.sender]],\\n                msg.value,\\n                RefClickCount[RefererAddr[Referer[msg.sender]]][msg.value]\\n            );\\n\\n            uint256 Current = GetPeriod(now);\\n            uint256 Start = Current - 30;\\n\\n            OwnerAutoClickCount[msg.sender][msg.value][Current] += 1;\\n\\n            uint256 CountOp = 0;\\n\\n            for (uint256 k = Start; k \\u003c Current; k++) {\\n                CountOp += OwnerAutoClickCount[msg.sender][msg.value][k];\\n            }\\n\\n            if (CountOp \\u003e= 30) {\\n                RefAutoClickCount[RefererAddr[Referer[msg.sender]]][msg\\n                    .value][Current] += 1;\\n            }\\n        }\\n\\n        uint256 Current = GetPeriod(now);\\n        uint256 Start = Current - 30;\\n\\n        uint256 Count1 = 0;\\n        uint256 Count2 = 0;\\n        uint256 Count3 = 0;\\n        uint256 Count4 = 0;\\n        uint256 Count5 = 0;\\n        uint256 Count6 = 0;\\n\\n        for (uint256 k = Start; k \\u003c Current; k++) {\\n            Count1 += RefAutoClickCount[msg.sender][amount1][k];\\n            Count2 += RefAutoClickCount[msg.sender][amount2][k];\\n            Count3 += RefAutoClickCount[msg.sender][amount3][k];\\n            Count4 += RefAutoClickCount[msg.sender][amount4][k];\\n            Count5 += RefAutoClickCount[msg.sender][amount5][k];\\n            Count6 += RefAutoClickCount[msg.sender][amount6][k];\\n        }\\n\\n        // Only when every slot \\u003e= 63\\n        require(Count1 \\u003e 62, \\\"AutoPay: not enough autoclick1 referrals\\\");\\n        require(Count2 \\u003e 62, \\\"AutoPay: not enough autoclick2 referrals\\\");\\n        require(Count3 \\u003e 62, \\\"AutoPay: not enough autoclick3 referrals\\\");\\n        require(Count4 \\u003e 62, \\\"AutoPay: not enough autoclick4 referrals\\\");\\n        require(Count5 \\u003e 62, \\\"AutoPay: not enough autoclick5 referrals\\\");\\n        require(Count6 \\u003e 62, \\\"AutoPay: not enough autoclick6 referrals\\\");\\n\\n        AutoBalances[msg.sender][msg.value] = true;\\n        WithdrawAutoDate[msg.sender][msg.value] = now.add(hours24);\\n\\n        reward_account.transfer(msg.value.perc(reward));\\n\\n        if (!Participants[msg.sender]) {\\n            Participants[msg.sender] = true;\\n            NumberOfParticipants += 1;\\n        }\\n\\n        FundBalance += msg.value.perc(reward);\\n        NumberOfClicks += 1;\\n        emit AmountInvestedByAutoPay(msg.sender, msg.value);\\n    }\\n\\n    /**\\n    *  Withdraw \\\"pay\\\" sum\\n    */\\n    function WithdrawAutoPay(uint256 _amount)\\n        external\\n        onlyFixedAmount(_amount)\\n    {\\n        require(\\n            AutoBalances[msg.sender][_amount],\\n            \\\"WithdrawAutoPay: autoclick amount has not yet been paid\\\"\\n        );\\n        require(\\n            now \\u003e= WithdrawAutoDate[msg.sender][_amount],\\n            \\\"WithdrawAutoPay: autoclick time has not come yet\\\"\\n        );\\n\\n        AutoBalances[msg.sender][_amount] = false;\\n        WithdrawAutoDate[msg.sender][_amount] = 0;\\n\\n        uint256 Amount = _amount.add(_amount.perc(800));\\n        msg.sender.transfer(Amount);\\n\\n        OwnerTotalProfit[msg.sender] += _amount.perc(800);\\n        ProfitPayoutAmount += Amount;\\n        emit AmountWithdrawnFromAutoPay(msg.sender, Amount);\\n    }\\n\\n    /**\\n    * Buy subscription\\n    */\\n    function Subscribe(uint256 _refererID)\\n        public\\n        payable\\n        onlyFixedAmountSubs(msg.value)\\n    {\\n        // If a RefererID is not yet assigned\\n        if (RefererID[msg.sender] == 0) {\\n            CreateRefererID(msg.sender);\\n        }\\n\\n        require(\\n            RefererID[msg.sender] != _refererID,\\n            \\\"Subscribe: you cannot be a referral to yourself\\\"\\n        );\\n\\n        uint256 reward_amount = msg.value.perc(reward);\\n\\n        uint256 Amount;\\n\\n        if (msg.value == subs_amount_with_fee1) {\\n            Amount = subs_amount1;\\n        } else if (msg.value == subs_amount_with_fee2) {\\n            Amount = subs_amount2;\\n        } else if (msg.value == subs_amount_with_fee3) {\\n            Amount = subs_amount3;\\n        } else {\\n            require(\\n                true,\\n                \\\"Subscribe: something went wrong, should not get here\\\"\\n            );\\n        }\\n\\n        require(\\n            Subscriptions[msg.sender][Amount] == 0,\\n            \\\"Subscribe: subscription already paid\\\"\\n        );\\n\\n        // If a referrer is not yet installed\\n        if ((Referer[msg.sender] == 0) \\u0026\\u0026 (_refererID != 0)) {\\n            Referer[msg.sender] = _refererID;\\n        }\\n\\n        // Add to Total\\n        if (Referer[msg.sender] != 0) {\\n            RefTotalIncome[RefererAddr[Referer[msg.sender]]] += msg.value;\\n        }\\n\\n        uint256 Period = GetPeriod(now);\\n\\n        if (\\n            (Referer[msg.sender] != 0) \\u0026\\u0026\\n            (!RefSubscStatus[msg.sender][Amount][Period])\\n        ) {\\n            // numbers of subscriptions per period (RefSubscCount[referer address][payXamount][Period])\\n            RefSubscCount[RefererAddr[Referer[msg\\n                .sender]]][Amount][Period] += 1;\\n            // only one subscription per period (RefSubscStatus[owner address][payXamount][Period])\\n            RefSubscStatus[msg.sender][Amount][Period] = true;\\n        }\\n\\n        Subscriptions[msg.sender][Amount] = now;\\n\\n        reward_account.transfer(reward_amount);\\n\\n        if (!Participants[msg.sender]) {\\n            Participants[msg.sender] = true;\\n            NumberOfParticipants += 1;\\n        }\\n\\n        FundBalance += reward_amount;\\n        NumberOfSubscriptions += 1;\\n        emit AmountInvestedBySubscription(msg.sender, Amount);\\n    }\\n\\n    /**\\n    *  Withdraw \\\"subscribe\\\" amount\\n    */\\n    function WithdrawSubscribe(uint256 _amount)\\n        external\\n        onlyFixedAmountWithdrawSubs(_amount)\\n    {\\n        require(\\n            Subscriptions[msg.sender][_amount] \\u003e 0,\\n            \\\"WithdrawSubscribe: subscription has not yet been paid\\\"\\n        );\\n\\n        uint256 Start;\\n        uint256 Finish;\\n        uint256 Current = GetPeriod(now);\\n\\n        Start = GetPeriod(Subscriptions[msg.sender][_amount]);\\n        Finish = Start + 30;\\n\\n        require(\\n            Current \\u003e Start,\\n            \\\"WithdrawSubscribe: the withdrawal time has not yet arrived\\\"\\n        );\\n\\n        uint256 Amount = WithdrawAmountCalculate(msg.sender, _amount);\\n\\n        msg.sender.transfer(Amount);\\n\\n        ProfitPayoutAmount += Amount;\\n        emit AmountWithdrawnFromSubscription(msg.sender, Amount);\\n    }\\n\\n    /**\\n    *  Withdraw all possible \\\"subscribe\\\" amount\\n    */\\n    function WithdrawSubscribeAll() internal {\\n        uint256 Amount = WithdrawAmountCalculate(msg.sender, subs_amount1);\\n        Amount += WithdrawAmountCalculate(msg.sender, subs_amount2);\\n        Amount += WithdrawAmountCalculate(msg.sender, subs_amount3);\\n\\n        if (Amount \\u003e 0) {\\n            msg.sender.transfer(Amount);\\n\\n            ProfitPayoutAmount += Amount;\\n            emit AmountWithdrawnFromSubscription(msg.sender, Amount);\\n        }\\n    }\\n\\n    /**\\n    *  Withdraw amount calculation\\n    */\\n    function WithdrawAmountCalculate(address _sender, uint256 _amount)\\n        internal\\n        returns (uint256)\\n    {\\n        if (Subscriptions[_sender][_amount] == 0) {\\n            return 0;\\n        }\\n\\n        uint256 Start;\\n        uint256 Finish;\\n        uint256 Current = GetPeriod(now);\\n\\n        Start = GetPeriod(Subscriptions[_sender][_amount]);\\n        Finish = Start + 30;\\n\\n        if (Current \\u003c= Start) {\\n            return 0;\\n        }\\n\\n        if (Intermediate[_sender][_amount] == 0) {\\n            Intermediate[_sender][_amount] = now;\\n        } else {\\n            Start = GetPeriod(Intermediate[_sender][_amount]);\\n            Intermediate[_sender][_amount] = now;\\n        }\\n\\n        uint256[30] memory Count;\\n        uint256 Amount = 0;\\n        uint256 Profit = 0;\\n\\n        if (Current \\u003e= Finish) {\\n            Current = Finish;\\n            Subscriptions[_sender][_amount] = 0;\\n            Intermediate[_sender][_amount] = 0;\\n            Amount += _amount;\\n        }\\n\\n        uint256 i = Start - 30;\\n        uint256 j = 0;\\n        uint256 k = 0;\\n\\n        while (i \\u003c Current) {\\n            if (i \\u003c= Start) {\\n                j = 0;\\n            } else {\\n                j = i - Start;\\n            }\\n\\n            while ((j \\u003c= k) \\u0026\\u0026 (Start + j \\u003c Current)) {\\n                Count[j] += RefSubscCount[_sender][_amount][i];\\n                j++;\\n            }\\n            i++;\\n            k++;\\n        }\\n\\n        for (i = 0; i \\u003c (Current - Start); i++) {\\n            if (Count[i] \\u003e 15) {\\n                Count[i] = 15;\\n            }\\n            Profit += _amount.perc(200 + Count[i].mul(15));\\n        }\\n\\n        OwnerTotalProfit[msg.sender] += Profit;\\n        Amount = Amount.add(Profit);\\n        return Amount;\\n    }\\n\\n    /**\\n    //  Sets click referals in staging mode\\n    */\\n    function SetRefClickCount(address _address, uint256 _sum, uint256 _count)\\n        external\\n        onlyInStagingMode\\n    {\\n        RefClickCount[_address][_sum] = _count;\\n    }\\n\\n    /**\\n    //  Sets autoclick owner operations for all amounts in current period in staging mode\\n    */\\n    function SetOwnerAutoClickCountAll(\\n        uint256 _count1,\\n        uint256 _count2,\\n        uint256 _count3,\\n        uint256 _count4,\\n        uint256 _count5,\\n        uint256 _count6\\n    ) external onlyInStagingMode {\\n        OwnerAutoClickCount[msg.sender][amount1][GetPeriod(now)] = _count1;\\n        OwnerAutoClickCount[msg.sender][amount2][GetPeriod(now)] = _count2;\\n        OwnerAutoClickCount[msg.sender][amount3][GetPeriod(now)] = _count3;\\n        OwnerAutoClickCount[msg.sender][amount4][GetPeriod(now)] = _count4;\\n        OwnerAutoClickCount[msg.sender][amount5][GetPeriod(now)] = _count5;\\n        OwnerAutoClickCount[msg.sender][amount6][GetPeriod(now)] = _count6;\\n    }\\n\\n    /**\\n    //  Sets autoclick referals in staging mode\\n    */\\n    function SetRefAutoClickCount(\\n        address _address,\\n        uint256 _sum,\\n        uint256 _period,\\n        uint256 _count\\n    ) external onlyInStagingMode {\\n        RefAutoClickCount[_address][_sum][_period] = _count;\\n    }\\n\\n    /**\\n    //  Sets autoclick referals for all amounts in current period in staging mode\\n    */\\n    function SetRefAutoClickCountAll(\\n        uint256 _count1,\\n        uint256 _count2,\\n        uint256 _count3,\\n        uint256 _count4,\\n        uint256 _count5,\\n        uint256 _count6\\n    ) external onlyInStagingMode {\\n        RefAutoClickCount[msg.sender][amount1][GetPeriod(now)] = _count1;\\n        RefAutoClickCount[msg.sender][amount2][GetPeriod(now)] = _count2;\\n        RefAutoClickCount[msg.sender][amount3][GetPeriod(now)] = _count3;\\n        RefAutoClickCount[msg.sender][amount4][GetPeriod(now)] = _count4;\\n        RefAutoClickCount[msg.sender][amount5][GetPeriod(now)] = _count5;\\n        RefAutoClickCount[msg.sender][amount6][GetPeriod(now)] = _count6;\\n    }\\n\\n    /**\\n    //  Sets subscription referals in staging mode\\n    */\\n    function SetRefSubscCount(\\n        address _address,\\n        uint256 _sum,\\n        uint256 _period,\\n        uint256 _count\\n    ) external onlyInStagingMode {\\n        RefSubscCount[_address][_sum][_period] = _count;\\n    }\\n\\n    /**\\n    //  Sets variables in staging mode\\n    */\\n    function SetValues(\\n        uint256 _NumberOfParticipants,\\n        uint256 _NumberOfClicks,\\n        uint256 _NumberOfSubscriptions,\\n        uint256 _ProfitPayoutAmount,\\n        uint256 _FundBalance\\n    ) external onlyInStagingMode {\\n        NumberOfParticipants = _NumberOfParticipants;\\n        NumberOfClicks = _NumberOfClicks;\\n        NumberOfSubscriptions = _NumberOfSubscriptions;\\n        ProfitPayoutAmount = _ProfitPayoutAmount;\\n        FundBalance = _FundBalance;\\n    }\\n\\n    /**\\n    /  Return current period\\n    */\\n    function GetCurrentPeriod() external view returns (uint256 _period) {\\n        return GetPeriod(now);\\n    }\\n\\n    /**\\n    /  Return fixed period\\n    */\\n    function GetFixedPeriod(uint256 _timestamp)\\n        external\\n        view\\n        returns (uint256 _period)\\n    {\\n        return GetPeriod(_timestamp);\\n    }\\n\\n    /**\\n    *  Returns number of active referals\\n    */\\n    function GetAutoClickRefsNumber()\\n        external\\n        view\\n        returns (uint256 number_of_referrals)\\n    {\\n        uint256 Current = GetPeriod(now);\\n        uint256 Start = Current - 30;\\n\\n        uint256 Count1 = 0;\\n        uint256 Count2 = 0;\\n        uint256 Count3 = 0;\\n        uint256 Count4 = 0;\\n        uint256 Count5 = 0;\\n        uint256 Count6 = 0;\\n\\n        for (uint256 k = Start; k \\u003c Current; k++) {\\n            Count1 += RefAutoClickCount[msg.sender][amount1][k];\\n            Count2 += RefAutoClickCount[msg.sender][amount2][k];\\n            Count3 += RefAutoClickCount[msg.sender][amount3][k];\\n            Count4 += RefAutoClickCount[msg.sender][amount4][k];\\n            Count5 += RefAutoClickCount[msg.sender][amount5][k];\\n            Count6 += RefAutoClickCount[msg.sender][amount6][k];\\n        }\\n\\n        if (Count1 \\u003e 63) {\\n            Count1 = 63;\\n        }\\n        if (Count2 \\u003e 63) {\\n            Count2 = 63;\\n        }\\n        if (Count3 \\u003e 63) {\\n            Count3 = 63;\\n        }\\n        if (Count4 \\u003e 63) {\\n            Count4 = 63;\\n        }\\n        if (Count5 \\u003e 63) {\\n            Count5 = 63;\\n        }\\n        if (Count6 \\u003e 63) {\\n            Count6 = 63;\\n        }\\n\\n        return Count1 + Count2 + Count3 + Count4 + Count5 + Count6;\\n    }\\n\\n    /**\\n    *  Returns number of active subscribe referals\\n    */\\n    function GetSubscribeRefsNumber(uint256 _amount)\\n        external\\n        view\\n        onlyFixedAmount(_amount)\\n        returns (uint256 number_of_referrals)\\n    {\\n        uint256 Current = GetPeriod(now);\\n        uint256 Start = Current - 30;\\n\\n        uint256 Count = 0;\\n        for (uint256 k = Start; k \\u003c Current; k++) {\\n            Count += RefSubscCount[msg.sender][_amount][k];\\n        }\\n\\n        if (Count \\u003e 15) {\\n            Count = 15;\\n        }\\n\\n        return Count;\\n    }\\n\\n    /**\\n    *  Returns subscription investment income based on the number of active referrals\\n    */\\n    function GetSubscribeIncome(uint256 _amount)\\n        external\\n        view\\n        onlyFixedAmount(_amount)\\n        returns (uint256 income)\\n    {\\n        uint256 Start = GetPeriod(now);\\n        uint256 Finish = Start + 30;\\n\\n        uint256[30] memory Count;\\n        uint256 Amount = 0;\\n\\n        uint256 i = Start - 30;\\n        uint256 j = 0;\\n        uint256 k = 0;\\n\\n        while (i \\u003c Finish) {\\n            if (i \\u003c= Start) {\\n                j = 0;\\n            } else {\\n                j = i - Start;\\n            }\\n\\n            while ((j \\u003c= k) \\u0026\\u0026 (Start + j \\u003c Finish)) {\\n                Count[j] += RefSubscCount[msg.sender][_amount][i];\\n                j++;\\n            }\\n            i++;\\n            k++;\\n        }\\n\\n        for (i = 0; i \\u003c (Finish - Start); i++) {\\n            if (Count[i] \\u003e 15) {\\n                Count[i] = 15;\\n            }\\n            Amount += _amount.perc(200 + Count[i].mul(15));\\n        }\\n\\n        return Amount;\\n    }\\n\\n    /**\\n    *  Returns the end time of a subscription\\n    */\\n    function GetSubscribeFinish(uint256 _amount)\\n        external\\n        view\\n        onlyFixedAmount(_amount)\\n        returns (uint256 finish)\\n    {\\n        if (Subscriptions[msg.sender][_amount] == 0) {\\n            return 0;\\n        }\\n\\n        uint256 Start = GetPeriod(Subscriptions[msg.sender][_amount]);\\n        uint256 Finish = Start + 30;\\n\\n        return Finish.mul(days1).add(start_point);\\n    }\\n\\n    /**\\n    *  Returns the near future possible withdraw\\n    */\\n    function GetSubscribeNearPossiblePeriod(uint256 _amount)\\n        external\\n        view\\n        onlyFixedAmount(_amount)\\n        returns (uint256 timestamp)\\n    {\\n        if (Subscriptions[msg.sender][_amount] == 0) {\\n            return 0;\\n        }\\n\\n        uint256 Current = GetPeriod(now);\\n        uint256 Start = GetPeriod(Subscriptions[msg.sender][_amount]);\\n\\n        if (Intermediate[msg.sender][_amount] != 0) {\\n            Start = GetPeriod(Intermediate[msg.sender][_amount]);\\n        }\\n\\n        if (Current \\u003e Start) {\\n            return now;\\n        } else {\\n            return Start.add(1).mul(days1).add(start_point);\\n        }\\n    }\\n\\n    /**\\n    *  Create referer id (uint256)\\n    */\\n    function CreateRefererID(address _referer) internal {\\n        require(\\n            RefererID[_referer] == 0,\\n            \\\"CreateRefererID: referal id already assigned\\\"\\n        );\\n\\n        bytes32 hash = keccak256(abi.encodePacked(now, _referer));\\n\\n        RefererID[_referer] = LastRefererID.add((uint256(hash) % 13) + 1);\\n        LastRefererID = RefererID[_referer];\\n        RefererAddr[LastRefererID] = _referer;\\n    }\\n}\\n\"},\"CashBackMoneyI.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n/**\\n * @title CashBackMoney Investing Contract Interface\\n */\\ninterface CashBackMoneyI {\\n    /**\\n    * Buy subscription\\n    * 0x0000000000000000000000000000000000000000\\n    */\\n    function Subscribe(uint256 refererID) external payable;\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\nimport \\\"./ERC20I.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the `ERC20I` interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\n * For a generic mechanism see `ERC20Mintable`.\\n */\\ncontract ERC20 is ERC20I {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See `ERC20I.totalSupply`.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See `ERC20I.balanceOf`.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See `ERC20I.transfer`.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `ERC20I.allowance`.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See `ERC20I.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `ERC20I.transferFrom`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `ERC20I.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `ERC20I.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to `transfer`, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a `Transfer` event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n    * @dev Destoys `amount` tokens from `account`, reducing the\\n    * total supply.\\n    *\\n    * Emits a `Transfer` event with `to` set to the zero address.\\n    *\\n    * Requirements\\n    *\\n    * - `account` cannot be the zero address.\\n    * - `account` must have at least `amount` tokens.\\n    */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller\\u0027s allowance.\\n     *\\n     * See `_burn` and `_approve`.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\n    }\\n}\"},\"ERC20I.sol\":{\"content\":\"pragma solidity ^0.5.10;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include the optional functions;\\r\\n */\\r\\ninterface ERC20I {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when `approve` or `transferFrom` are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to `approve`. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * \\u003e Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Returns the integer percentage of the number.\\n    */\\n    function perc(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        c = c / 10000; // percent to hundredths\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_reward_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start_point\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_mode\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountInvestedByAutoPay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountInvestedByPay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountInvestedBySubscription\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountWithdrawnFromAutoPay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountWithdrawnFromPay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountWithdrawnFromSubscription\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"ChangeClickRefefalNumbers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"}],\"name\":\"ChangeContractBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"UpdatedAgent\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Agents\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AutoBalances\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refererID\",\"type\":\"uint256\"}],\"name\":\"AutoPay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Balances\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FundBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetAutoClickRefsNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number_of_referrals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetCurrentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"GetFixedPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"GetSubscribeFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"GetSubscribeIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"income\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"GetSubscribeNearPossiblePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"GetSubscribeRefsNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number_of_referrals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Intermediate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LastRefererID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NumberOfClicks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NumberOfParticipants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NumberOfSubscriptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"OwnerAmountStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"OwnerAutoClickCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"OwnerTotalProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Participants\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refererID\",\"type\":\"uint256\"}],\"name\":\"Pay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ProfitPayoutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefAutoClickCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefClickCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefSubscCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefSubscStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RefTotalClicks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RefTotalIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Referer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefererAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RefererID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count6\",\"type\":\"uint256\"}],\"name\":\"SetOwnerAutoClickCountAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"SetRefAutoClickCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count6\",\"type\":\"uint256\"}],\"name\":\"SetRefAutoClickCountAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"SetRefClickCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"SetRefSubscCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_NumberOfParticipants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_NumberOfClicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_NumberOfSubscriptions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ProfitPayoutAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_FundBalance\",\"type\":\"uint256\"}],\"name\":\"SetValues\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refererID\",\"type\":\"uint256\"}],\"name\":\"Subscribe\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Subscriptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"TopUpContract\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"WithdrawAutoDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawAutoPay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"WithdrawDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawPay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawPayAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawSubscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amount1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amount2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amount3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amount4\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amount5\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amount6\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deploy_block\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"production\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reward_account\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start_point\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subs_amount1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subs_amount2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subs_amount3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subs_amount_with_fee1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subs_amount_with_fee2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subs_amount_with_fee3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agent\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CashBackMoney","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000030dc3b1751c68173db5d27a4469735e48250bfda00000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000005c2aad800000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://179210a2e6c99d89bc749f17cf57033dca4edecef0106b2bcf7b86176c6b970c"}]}