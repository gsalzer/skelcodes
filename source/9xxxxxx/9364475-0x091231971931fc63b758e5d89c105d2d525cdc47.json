{"status":"1","message":"OK","result":[{"SourceCode":"{\"AlumniStore.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\ncontract AlumniStore {\\n    function getAlumniAddress(bytes32 _blockchainCertificateHash) public view returns (address payable _address){}\\n}\"},\"OpenCertsStore.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\ncontract OpenCertsStore {\\n    function isIssued(bytes32 document) public view returns (bool){}\\n}\"},\"ScholarshipContract_V2.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\nimport \\\"./AlumniStore.sol\\\";\\nimport \\\"./OpenCertsStore.sol\\\";\\nimport \\\"./TokenContract.sol\\\";\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n}\\n\\ncontract ScholarshipContract_V2 {\\n    using SafeMath for uint256;\\n    OpenCertsStore openCertsStore;\\n    AlumniStore alumniStore;\\n    TokenContract tokenContract;\\n\\n    address payable owner;\\n    uint256 bitDegreeFee = 3; //percent\\n\\n    constructor(address _openCertsStoreAddress, address _alumniStoreAddress, address _tokenContractAddress) public {\\n        owner = msg.sender;\\n        openCertsStore = OpenCertsStore(_openCertsStoreAddress);\\n        alumniStore = AlumniStore(_alumniStoreAddress);\\n        tokenContract = TokenContract(_tokenContractAddress);\\n    }\\n\\n    modifier onlyOwner {\\n        require(\\n            msg.sender == owner,\\n            \\\"Only owner can call this function.\\\"\\n        );\\n        _;\\n    }\\n\\n    function() external payable {}\\n\\n    function changeOwner(address payable _newOwnerAddress) public onlyOwner returns (bool) {\\n        owner = _newOwnerAddress;\\n        return true;\\n    }\\n\\n    function isCertificateIssued(bytes32 _blockchainCertificateHash) private view returns (address payable _address) {\\n        if (openCertsStore.isIssued(_blockchainCertificateHash)) {\\n            return alumniStore.getAlumniAddress(_blockchainCertificateHash);\\n        } else {\\n            return 0x0000000000000000000000000000000000000000;\\n        }\\n    }\\n\\n    function unlockScholarship(bytes32 _blockchainCertificateHash) public returns (bool){\\n        uint256 toBitDegree = tokenContract.balanceOf(address(this)).mul(bitDegreeFee).div(100);\\n        uint256 toStudent = tokenContract.balanceOf(address(this)).sub(toBitDegree);\\n        address payable studentAddress = isCertificateIssued(_blockchainCertificateHash);\\n        if (studentAddress != address(0x0)) {\\n            tokenContract.transfer(studentAddress, toStudent);\\n            tokenContract.transfer(owner, toBitDegree);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function refund() public onlyOwner returns (bool) {\\n        tokenContract.transfer(owner,tokenContract.balanceOf(address(this)));\\n        return true;\\n    }\\n\\n    function selfDestruct() public onlyOwner {\\n        selfdestruct(owner);\\n    }\\n}\"},\"TokenContract.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\ncontract TokenContract {\\n    function balanceOf(address ownerAddress) public view returns (uint);\\n    function transfer(address to, uint tokens) public returns (bool success);\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerAddress\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockchainCertificateHash\",\"type\":\"bytes32\"}],\"name\":\"unlockScholarship\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_openCertsStoreAddress\",\"type\":\"address\"},{\"name\":\"_alumniStoreAddress\",\"type\":\"address\"},{\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ScholarshipContract_V2","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c2ec08aeafe5232ba6019365da08b34ffc4371760000000000000000000000003d3972c31d6b434000758a106b979b0722b3b5b00000000000000000000000001961b3331969ed52770751fc718ef530838b6dee","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://5a778de059d7d3d3a541c2576c67fe72e7bcd5bab0d46b22de790b8dbabfa25c"}]}