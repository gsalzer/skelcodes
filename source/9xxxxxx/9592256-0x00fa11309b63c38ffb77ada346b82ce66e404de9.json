{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/InternalModule.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\ncontract InternalModule {\r\n\r\n    address[] _authAddress;\r\n\r\n    address payable[] public _contractOwners = [\r\n        address(0xD04C3c9eEC7BE36d28a925598B909954b4fd83cB)   // Prod\r\n        // address(0x4ad16f3f6B4C1C48C644756979f96bcd0bfa077B)   // Truffle Develop\r\n    ];\r\n\r\n    address payable public _defaultReciver;\r\n\r\n    constructor() public {\r\n\r\n        require(_contractOwners.length > 0);\r\n\r\n        _defaultReciver = _contractOwners[0];\r\n\r\n        _contractOwners.push(msg.sender);\r\n    }\r\n\r\n    modifier OwnerOnly() {\r\n\r\n        bool exist = false;\r\n        for ( uint i = 0; i < _contractOwners.length; i++ ) {\r\n            if ( _contractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    modifier DAODefense() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \"DAO_Warning\" );\r\n        _;\r\n    }\r\n\r\n    modifier APIMethod() {\r\n\r\n        bool exist = false;\r\n\r\n        for (uint i = 0; i < _authAddress.length; i++) {\r\n            if ( _authAddress[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function AuthAddresses() external view returns (address[] memory authAddr) {\r\n        return _authAddress;\r\n    }\r\n\r\n    function AddAuthAddress(address _addr) external OwnerOnly {\r\n        _authAddress.push(_addr);\r\n    }\r\n\r\n    function DelAuthAddress(address _addr) external OwnerOnly {\r\n\r\n        for (uint i = 0; i < _authAddress.length; i++) {\r\n            if (_authAddress[i] == _addr) {\r\n                for (uint j = 0; j < _authAddress.length - 1; j++) {\r\n                    _authAddress[j] = _authAddress[j+1];\r\n                }\r\n                delete _authAddress[_authAddress.length - 1];\r\n                _authAddress.length--;\r\n                return ;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\n// File: contracts/interface/ERC20Interface.sol\r\n\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interface/RecommendInterface.sol\r\n\r\ninterface RecommendInterface {\r\n\r\n\r\n    function GetIntroducer( address _owner ) external view returns (address);\r\n\r\n\r\n    function RecommendList( address _owner, uint256 depth ) external view returns ( address[] memory list, uint256 len );\r\n\r\n\r\n    function ShortCodeToAddress( bytes6 shortCode ) external view returns (address);\r\n\r\n\r\n    function AddressToShortCode( address _addr ) external view returns (bytes6);\r\n\r\n\r\n    function TeamMemberTotal( address _addr ) external view returns (uint256);\r\n\r\n\r\n    function IsValidMember( address _addr ) external view returns (bool);\r\n\r\n\r\n    function IsValidMemberEx( address _addr ) external view returns (bool, uint256);\r\n\r\n\r\n    function DirectValidMembersCount( address _addr ) external view returns (uint256);\r\n\r\n\r\n    function RegisterShortCode( bytes6 shortCode ) external;\r\n\r\n\r\n    function BindRelation(address _recommer ) external;\r\n\r\n\r\n    function BindRelationEx(address _recommer, bytes6 shortCode ) external;\r\n\r\n\r\n    function GetSearchDepthMaxLimit() external view returns (uint256);\r\n\r\n\r\n    function API_MakeAddressToValid( address _owner ) external;\r\n}\r\n\r\n// File: contracts/library/RoundController.sol\r\n\r\nlibrary Times {\r\n    function OneDay() public pure returns (uint256) {\r\n        return 1 days;\r\n    }\r\n}\r\n\r\nlibrary TokenAssetPool {\r\n\r\n    uint constant UINT_MAX = 2 ** 256 - 1;\r\n\r\n    struct MainDB {\r\n\r\n        mapping(address => uint256) totalAmountsMapping;\r\n\r\n        mapping(address => uint256) assetsAmountMapping;\r\n    }\r\n\r\n    function TotalAmount(MainDB storage self, address owner) internal view returns (uint256) {\r\n        return self.assetsAmountMapping[owner];\r\n    }\r\n\r\n    function TotalSum(MainDB storage self, address owner ) internal view returns (uint256) {\r\n        return self.totalAmountsMapping[owner];\r\n    }\r\n\r\n    function AddAmount(MainDB storage self, address owner, uint256 amount) internal {\r\n\r\n        require( amount <= UINT_MAX );\r\n\r\n        self.assetsAmountMapping[owner] += amount;\r\n\r\n        self.totalAmountsMapping[owner] += amount;\r\n    }\r\n\r\n    function SubAmount(MainDB storage self, address owner, uint256 amount) internal {\r\n\r\n        require( amount <= UINT_MAX );\r\n        require( TotalAmount(self,owner) >= amount );\r\n\r\n        self.assetsAmountMapping[owner] -= amount;\r\n    }\r\n\r\n}\r\n\r\nlibrary StaticMath {\r\n\r\n    function S(uint256 ir) internal pure returns (uint256 s) {\r\n\r\n        s = 1000 ether;\r\n\r\n        for (uint i = 0; i < ir; i ++ ) {\r\n            s = s * 1300000 / 1000000;\r\n        }\r\n\r\n        /// INT\r\n        s = s / 1 ether * 1 ether;\r\n    }\r\n\r\n    function P(uint256 ir) internal pure returns (uint256 r) {\r\n\r\n        if ( ir >= 4 ) {\r\n\r\n            for ( uint ji = 0; ji < ir - 3; ji++ ) {\r\n                r += S(ji) * 300000 / 1000000;\r\n            }\r\n\r\n            for ( uint i = ir - 3; i < ir; i++ ) {\r\n                r += S(i) * 80000 / 1000000;\r\n            }\r\n\r\n        } else if ( ir != 0 && ir < 4 ) {\r\n\r\n            for ( uint i = 0; i < ir; i++ ) {\r\n                r += S(i) * 80000 / 1000000;\r\n            }\r\n\r\n        } else {\r\n\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n    function O(uint256 ir, uint256 n) internal pure returns (uint256) {\r\n\r\n        if (ir - n == 1 ) {\r\n            return 400000;\r\n        } else if (ir - n == 2 ) {\r\n            return 350000;\r\n        } else if (ir - n == 3 ) {\r\n            return 250000;\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n    function T(uint256 ir, uint256 n) internal pure returns (uint256) {\r\n        return P(ir) * O(ir, n) / 1000000;\r\n    }\r\n\r\n    function W(uint256 ir, uint256 n) internal pure returns (uint256) {\r\n\r\n        if ( ir - n <= 3 ) {\r\n\r\n            uint256 subp = T(ir, n) * 1000000 / S(n);\r\n            if ( subp != 0 ) {\r\n                subp ++;\r\n            }\r\n\r\n            return 1000000 - subp;\r\n\r\n        } else {\r\n\r\n            return 1100000;\r\n        }\r\n    }\r\n\r\n    function ProfitHandle(uint256 ir, bool irTimeoutable, uint256 n, uint256 ns) internal pure returns (uint256) {\r\n\r\n        if ( (ir - n <= 3 && !irTimeoutable) || n > ir ) {\r\n            return 0;\r\n        }\r\n\r\n        return ns * W(ir, n) / 1000000;\r\n    }\r\n}\r\n\r\nlibrary DynamicMath {\r\n\r\n    struct MainDB {\r\n\r\n        RecommendInterface RCMINC;\r\n\r\n        uint[] dyp;\r\n    }\r\n\r\n    struct Request {\r\n        address owner;\r\n        uint oid;\r\n        uint ownerDepositAmount;\r\n        uint stProfix;\r\n    }\r\n\r\n    function Init( MainDB storage self, RecommendInterface rcminc ) internal {\r\n\r\n        self.RCMINC = rcminc;\r\n\r\n        self.dyp = [20, 15, 10, 10, 10, 5, 5, 5, 5, 5];\r\n    }\r\n\r\n    function ProfitHandle(\r\n        MainDB storage self,\r\n        RoundController.MainDB storage RCDB,\r\n        Request memory req\r\n    )\r\n    internal view\r\n    returns (\r\n        uint256 len,\r\n        address [] memory addrs,\r\n        uint256 [] memory profixs\r\n    ) {\r\n        address parent = req.owner;\r\n        len = self.dyp.length;\r\n        addrs = new address[](len);\r\n        profixs = new uint256[](len);\r\n\r\n        for ( (uint i, uint j) = (0,0); i < self.RCMINC.GetSearchDepthMaxLimit() && j < self.dyp.length; i++ ) {\r\n\r\n            parent = self.RCMINC.GetIntroducer(parent);\r\n\r\n            if ( parent != address(0x0) && parent != address(0xFF) ) {\r\n\r\n\r\n                uint s = self.RCMINC.DirectValidMembersCount(parent);\r\n                if ( self.RCMINC.IsValidMember(parent) && ( s >= j+1 || s >= 6 ) ) {\r\n\r\n\r\n                    addrs[j] = parent;\r\n                    profixs[j] = req.stProfix * self.dyp[j] / 100;\r\n\r\n\r\n                    if ( RCDB.roundList[req.oid].depositedMapping[parent].totalAmount * 2 < req.ownerDepositAmount ) {\r\n\r\n                        uint bp = RCDB.roundList[req.oid].depositedMapping[parent].totalAmount * 200000 / req.ownerDepositAmount;\r\n\r\n                        profixs[j] = profixs[j] * bp / 100000;\r\n                    }\r\n\r\n                    ++j;\r\n                }\r\n\r\n            } else {\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory c) {\r\n\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n\r\n        while (i != 0){\r\n            bstr[k--] = byte( uint8(48 + i % 10) );\r\n            i /= 10;\r\n        }\r\n        c = string(bstr);\r\n    }\r\n\r\n}\r\n\r\nlibrary LevelMath {\r\n\r\n    struct MainDB {\r\n\r\n        RecommendInterface RCMINC;\r\n\r\n        uint256[] lvProfits;\r\n\r\n        mapping(uint256 => mapping(address => uint256)) achievementMapping;\r\n\r\n        uint256 searchDepth;\r\n    }\r\n\r\n    function Init( MainDB storage self, RecommendInterface _RINC ) internal {\r\n        self.RCMINC = _RINC;\r\n        self.lvProfits = [0, 10, 5, 5, 5, 5];\r\n        self.searchDepth = 1024;\r\n    }\r\n\r\n\r\n    function SetSearchDepth( MainDB storage self, uint256 d) internal {\r\n        self.searchDepth = d;\r\n    }\r\n\r\n\r\n    function AddAchievement( MainDB storage self, address owner, uint256 oid, uint256 amount) internal {\r\n\r\n\r\n        address parent = owner;\r\n\r\n        for ( uint i = 0; i < self.searchDepth; i++ ) {\r\n\r\n            if ( parent != address(0x0) && parent != address(0xFF) ) {\r\n\r\n                self.achievementMapping[oid][parent] += amount;\r\n\r\n            } else {\r\n\r\n                return ;\r\n            }\r\n\r\n\r\n            parent = self.RCMINC.GetIntroducer(parent);\r\n        }\r\n    }\r\n\r\n\r\n    function ProfitHandle( MainDB storage self, address owner, uint256 oid, uint256 totalRoundCount, uint staticProfixAmount )\r\n    internal view\r\n    returns (\r\n        uint256 len,\r\n        address [] memory addrs,\r\n        uint [] memory profitAmounts\r\n    ) {\r\n        len = self.lvProfits.length;\r\n        addrs = new address[](len);\r\n        profitAmounts = new uint[](len);\r\n\r\n\r\n        address parent = owner;\r\n\r\n        uint256[] memory copyProfits = self.lvProfits;\r\n\r\n        for ( uint i = 0; i < self.searchDepth; i++ ) {\r\n\r\n            parent = self.RCMINC.GetIntroducer(parent);\r\n\r\n            if ( parent == address(0x0) || parent == address(0xFF) ) {\r\n                break;\r\n            }\r\n\r\n\r\n            if ( !self.RCMINC.IsValidMember(parent) ) {\r\n                continue;\r\n            }\r\n\r\n\r\n            uint parentLv = CurrentLevelOf(self, parent, oid, totalRoundCount);\r\n\r\n\r\n            uint psum = 0;\r\n            for ( uint p = 0; p <= parentLv; p++ ) {\r\n\r\n                psum += copyProfits[p];\r\n\r\n\r\n                copyProfits[p] = 0;\r\n            }\r\n\r\n\r\n            if ( psum > 0 ) {\r\n                addrs[parentLv] = parent;\r\n                profitAmounts[parentLv] = staticProfixAmount * psum / 100;\r\n            }\r\n\r\n\r\n            if ( parentLv >= self.lvProfits.length - 1 ) {\r\n                break;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n    function CurrentLevelOf( MainDB storage self, address owner, uint256 oid, uint256 totalRoundCount )\r\n    internal view\r\n    returns (uint256) {\r\n\r\n\r\n        (address [] memory communityList, uint256 rlen) = self.RCMINC.RecommendList(owner, 0);\r\n\r\n\r\n        uint256 achievementSum = 0;\r\n        uint256 maxCommunityAmount = 0;\r\n\r\n        for ( uint i = 0; i < rlen; i++) {\r\n\r\n            uint256 communitySum = 0;\r\n\r\n            for ( uint o = oid; o < oid + 4 && o < totalRoundCount; o++ ) {\r\n                communitySum += self.achievementMapping[o][communityList[i]];\r\n            }\r\n\r\n            achievementSum += communitySum;\r\n\r\n            if ( communitySum > maxCommunityAmount ) {\r\n                maxCommunityAmount = communitySum;\r\n            }\r\n        }\r\n\r\n        achievementSum -= maxCommunityAmount;\r\n\r\n\r\n        uint256 lv = 0;\r\n\r\n        if ( achievementSum >= 100 ether ) {\r\n            lv = 1;\r\n        }\r\n\r\n        if ( achievementSum >= 300 ether ) {\r\n            lv = 2;\r\n        }\r\n\r\n        if ( achievementSum >= 1000 ether ) {\r\n            lv = 3;\r\n        }\r\n\r\n        if ( achievementSum >= 3000 ether ) {\r\n            lv = 4;\r\n        }\r\n\r\n        if ( achievementSum >= 9000 ether ) {\r\n            lv = 5;\r\n        }\r\n\r\n        return lv;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory c) {\r\n\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n\r\n        while (i != 0){\r\n            bstr[k--] = byte( uint8(48 + i % 10) );\r\n            i /= 10;\r\n        }\r\n        c = string(bstr);\r\n    }\r\n\r\n}\r\n\r\nlibrary LuckAssetPool {\r\n\r\n    using TokenAssetPool for TokenAssetPool.MainDB;\r\n\r\n\r\n    uint constant UINT_MAX = 2 ** 256 - 1;\r\n\r\n    struct MainDB {\r\n\r\n\r\n        uint256 currentRoundTempAmount;\r\n\r\n\r\n        uint256 rewardAmountTotal;\r\n\r\n\r\n        uint256 currentRID;\r\n\r\n\r\n        mapping(uint256 => uint256) assetAmountMapping;\r\n\r\n\r\n        mapping(uint256 => uint256) rollbackAmountMapping;\r\n\r\n\r\n        mapping(uint256 => Invest[]) investMapping;\r\n    }\r\n\r\n    struct Invest {\r\n        address who;\r\n        uint256 when;\r\n        uint256 amount;\r\n    }\r\n\r\n    function RoundTimeOutDelegate(MainDB storage self, uint256 timeoutable_oid, TokenAssetPool.MainDB storage userPool)\r\n    internal\r\n    returns (\r\n        address[20] memory luckyOnes,\r\n        uint256[20] memory rewardAmounts\r\n    )\r\n    {\r\n        self.rollbackAmountMapping[timeoutable_oid] = self.currentRoundTempAmount;\r\n\r\n        self.currentRoundTempAmount = 0;\r\n\r\n\r\n        (luckyOnes, rewardAmounts) = winningThePrizeAtRID(self, self.currentRID, userPool);\r\n\r\n        self.currentRID ++;\r\n    }\r\n\r\n    function RoundSuccessDelegate(MainDB storage self) internal {\r\n\r\n\r\n        self.assetAmountMapping[self.currentRID] += self.currentRoundTempAmount;\r\n\r\n        self.currentRoundTempAmount = 0;\r\n    }\r\n\r\n\r\n    function BalanceOfRID(MainDB storage self, uint256 rid) internal view returns (uint256) {\r\n        return self.assetAmountMapping[rid];\r\n    }\r\n\r\n    function DoRollback(MainDB storage self, uint256 oid, uint256 amount) internal returns (uint256 realAmount) {\r\n\r\n        if ( self.rollbackAmountMapping[oid] >= amount ) {\r\n\r\n            self.rollbackAmountMapping[oid] -= amount;\r\n\r\n            realAmount = amount;\r\n\r\n        } else {\r\n\r\n            realAmount = self.rollbackAmountMapping[oid];\r\n\r\n            self.rollbackAmountMapping[oid] = 0;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function AppendingAmount(MainDB storage self, uint256 amount) internal {\r\n        self.assetAmountMapping[self.currentRID] += amount;\r\n    }\r\n\r\n\r\n    function AddAmountAndTryGetReward(MainDB storage self, address who, uint256 amount) internal returns (uint256 reward) {\r\n\r\n        require( amount <= UINT_MAX );\r\n\r\n\r\n        self.currentRoundTempAmount += (amount * 30000 / 1000000);\r\n\r\n        self.investMapping[self.currentRID].push( Invest(who, now, amount) );\r\n\r\n\r\n        reward = amount * 5 / 100;\r\n        if ( self.rewardAmountTotal >= reward ) {\r\n\r\n            self.rewardAmountTotal -= reward;\r\n\r\n        } else {\r\n\r\n            reward = self.rewardAmountTotal;\r\n            self.rewardAmountTotal = 0;\r\n        }\r\n    }\r\n\r\n\r\n    function SubAmount(MainDB storage self, uint256 rid, uint256 amount) internal {\r\n\r\n        require( amount <= UINT_MAX );\r\n        require( BalanceOfRID(self, rid) >= amount );\r\n\r\n        self.assetAmountMapping[rid] -= amount;\r\n    }\r\n\r\n\r\n    function winningThePrizeAtRID(MainDB storage self, uint256 rid, TokenAssetPool.MainDB storage userPool )\r\n    private\r\n    returns (\r\n        address[20] memory luckyOnes,\r\n        uint256[20] memory rewardAmounts\r\n    )\r\n    {\r\n        uint256 ridTotalAmount = self.assetAmountMapping[rid];\r\n        uint256 ridTotalAmountDelta = ridTotalAmount;\r\n\r\n        Invest[] storage _investList = self.investMapping[rid];\r\n\r\n\r\n        if ( _investList.length == 0 ) {\r\n\r\n            self.assetAmountMapping[rid] = 0;\r\n\r\n            self.assetAmountMapping[rid+1] += ridTotalAmountDelta;\r\n\r\n            return (luckyOnes, rewardAmounts);\r\n        }\r\n\r\n\r\n        uint8[20] memory rewardsDescProps = [\r\n            50, /// desc 1\r\n            10,10,10,10, /// desc 2 - 5\r\n            5,5,5,5,5,5,5,5,5,5,5,5,5,5,5 /// desc 6-20\r\n        ];\r\n\r\n\r\n        uint256 descIndex = 0;\r\n\r\n        for ( int li = int(_investList.length - 1); li >= 0 && descIndex < 20; li-- ) {\r\n\r\n            Invest storage invest = _investList[uint(li)];\r\n\r\n\r\n            bool exist = false;\r\n            for ( uint exid = 0; exid < descIndex; exid ++ ) {\r\n\r\n                if ( luckyOnes[exid] == invest.who ) {\r\n                    exist = true;\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n\r\n            if (exist) {\r\n                continue;\r\n            }\r\n\r\n\r\n            uint256 rewardAmount = invest.amount * rewardsDescProps[descIndex];\r\n\r\n\r\n            if ( descIndex == 0 && rewardAmount > ridTotalAmount * 10 / 100 ) { /// desc 1\r\n\r\n                rewardAmount = ridTotalAmount * 10 / 100;\r\n\r\n            } else if ( descIndex >= 1 && descIndex <= 4 && rewardAmount > ridTotalAmount * 5 / 100 ) { /// desc 2-5\r\n\r\n                rewardAmount = ridTotalAmount * 5 / 100;\r\n\r\n            } else if ( descIndex >= 5 && rewardAmount > ridTotalAmount * 2 / 100 ) {\r\n\r\n                rewardAmount = ridTotalAmount * 2 / 100;\r\n            }\r\n\r\n\r\n            if ( rewardAmount < ridTotalAmountDelta ) {\r\n\r\n                userPool.AddAmount( invest.who, rewardAmount );\r\n                ridTotalAmountDelta -= rewardAmount;\r\n\r\n\r\n                luckyOnes[descIndex] = invest.who;\r\n                rewardAmounts[descIndex] = rewardAmount;\r\n                ++descIndex;\r\n            }\r\n\r\n            else {\r\n\r\n                userPool.AddAmount( invest.who, ridTotalAmountDelta );\r\n                ridTotalAmountDelta = 0;\r\n\r\n                luckyOnes[descIndex] = invest.who;\r\n                rewardAmounts[descIndex] = ridTotalAmountDelta;\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n\r\n        if ( ridTotalAmountDelta > 0 ) {\r\n            self.rewardAmountTotal += ridTotalAmountDelta;\r\n        }\r\n\r\n\r\n        self.assetAmountMapping[rid] = 0;\r\n    }\r\n}\r\n\r\nlibrary OwnerAssetPool {\r\n\r\n\r\n    uint constant UINT_MAX = 2 ** 256 - 1;\r\n\r\n    address constant OwnerAddress = address(0xD04C3c9eEC7BE36d28a925598B909954b4fd83cB);\r\n\r\n    struct MainDB {\r\n\r\n        ERC20Interface ERC20Inc;\r\n\r\n\r\n        uint256 currentRoundTempAmount;\r\n    }\r\n\r\n    function Init(MainDB storage self, ERC20Interface _erc20inc) internal {\r\n        self.ERC20Inc = _erc20inc;\r\n    }\r\n\r\n    function RoundTimeOutDelegate(MainDB storage self) internal {\r\n        self.currentRoundTempAmount = 0;\r\n    }\r\n\r\n    function RoundSuccessDelegate(MainDB storage self) internal {\r\n\r\n        self.ERC20Inc.transfer( OwnerAddress, self.currentRoundTempAmount );\r\n\r\n        self.currentRoundTempAmount = 0;\r\n    }\r\n\r\n\r\n    function AddAmount(MainDB storage self, uint256 amount) internal {\r\n\r\n        require( amount <= UINT_MAX );\r\n\r\n        self.currentRoundTempAmount += (amount * 50000 / 1000000);\r\n    }\r\n\r\n}\r\n\r\nlibrary RoundController {\r\n\r\n    using TokenAssetPool for TokenAssetPool.MainDB;\r\n    using LevelMath for LevelMath.MainDB;\r\n    using DynamicMath for DynamicMath.MainDB;\r\n    using LuckAssetPool for LuckAssetPool.MainDB;\r\n    using OwnerAssetPool for OwnerAssetPool.MainDB;\r\n\r\n    struct Deposited {\r\n\r\n        address owner;\r\n\r\n        uint256 totalAmount;\r\n\r\n        uint256 latestDepositedTime;\r\n\r\n        bool autoReDepostied;\r\n\r\n        uint256 toOID;\r\n\r\n        uint256 totalStProfit;\r\n\r\n        uint256 totalDyProfit;\r\n\r\n        uint256 totalMrgProfit;\r\n    }\r\n\r\n    struct Round {\r\n\r\n        uint256 rid;\r\n\r\n        uint256 internalRoundID;\r\n\r\n        uint8 status;\r\n\r\n        uint256 totalAmount;\r\n\r\n        uint256 currentAmount;\r\n\r\n        uint256 createTime;\r\n\r\n        uint256 startTime;\r\n\r\n        uint256 endTime;\r\n\r\n        mapping(address => Deposited) depositedMapping;\r\n    }\r\n\r\n    struct MainDB {\r\n\r\n\r\n        uint256 newRIDInitProp;\r\n\r\n        RecommendInterface RCMINC;\r\n        ERC20Interface ERC20INC;\r\n\r\n        LuckAssetPool.MainDB luckAssetPool;\r\n        OwnerAssetPool.MainDB ownerAssetPool;\r\n        TokenAssetPool.MainDB userTokenPool;\r\n\r\n        Round[] roundList;\r\n\r\n\r\n        mapping(uint256 => address[]) autoRedepositAddressMapping;\r\n    }\r\n\r\n    event LogsToken(\r\n        address indexed owner,\r\n        uint256 when,\r\n        int256  amount,\r\n        uint256 indexed oid,\r\n        uint16 indexed typeID\r\n    );\r\n\r\n    event LogsAmount(\r\n        address indexed owner,\r\n        uint256 when,\r\n        int256  amount,\r\n        uint256 indexed oid,\r\n        uint16 indexed typeID\r\n    );\r\n\r\n    function InitFristRound(\r\n        MainDB storage self,\r\n        uint256 atTime,\r\n        RecommendInterface _rcminc,\r\n        ERC20Interface _erc20inc\r\n\r\n    ) internal returns (bool) {\r\n\r\n        if ( self.roundList.length > 0 ) {\r\n            return false;\r\n        }\r\n\r\n        self.newRIDInitProp = 10;\r\n\r\n        self.RCMINC = _rcminc;\r\n\r\n        self.ERC20INC = _erc20inc;\r\n\r\n        self.ownerAssetPool.Init(_erc20inc);\r\n\r\n        self.roundList.push(\r\n            Round(\r\n                0,///rid\r\n                0,/// internalRoundID\r\n                1,/// status\r\n                1000 ether, /// totalAmount\r\n                0, /// currentAmount\r\n                atTime, /// createTime\r\n                atTime + Times.OneDay() * 1, /// startTime\r\n                atTime + Times.OneDay() * 8 /// endTime\r\n            )\r\n        );\r\n    }\r\n\r\n    function EnableAutoRedeposit(MainDB storage self, address owner, uint256 fromRoundIdx) internal returns (bool) {\r\n\r\n\r\n        if ( !(self.roundList[fromRoundIdx].status == 2 || self.roundList[fromRoundIdx].status == 3) ) {\r\n            return false;\r\n        }\r\n\r\n\r\n        Deposited storage ownerDepositedRecord = self.roundList[fromRoundIdx].depositedMapping[owner];\r\n\r\n\r\n        address[] storage autoAddresses = self.autoRedepositAddressMapping[fromRoundIdx];\r\n\r\n\r\n        if ( !ownerDepositedRecord.autoReDepostied ) {\r\n\r\n            ownerDepositedRecord.autoReDepostied = true;\r\n            autoAddresses.push(owner);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function TotalCount(MainDB storage self) internal view returns (uint256) {\r\n        return self.roundList.length;\r\n    }\r\n\r\n    function RoundAt(MainDB storage self, uint i) internal view returns (Round storage) {\r\n        require( i >= 0 && i < self.roundList.length );\r\n        return self.roundList[i];\r\n    }\r\n\r\n    function CurrentRound(MainDB storage self) internal view returns (Round storage r) {\r\n        return self.roundList[self.roundList.length - 1];\r\n    }\r\n\r\n    function CurrentRountOID(MainDB storage self) internal view returns (uint256) {\r\n        return self.roundList.length - 1;\r\n    }\r\n\r\n    function CurrentRoundIID(MainDB storage self) internal view returns (uint256) {\r\n        return CurrentRound(self).internalRoundID;\r\n    }\r\n\r\n    function CurrentRoundRID(MainDB storage self) internal view returns (uint256) {\r\n        return CurrentRound(self).rid;\r\n    }\r\n\r\n    function InternalRoundCount(MainDB storage self, uint256 oid) internal view returns (uint256) {\r\n\r\n        uint256 iid = self.roundList[oid].internalRoundID;\r\n\r\n        for ( uint i = oid + 1; i < self.roundList.length; i++ ) {\r\n            if ( self.roundList[i].internalRoundID - iid == 1 ) {\r\n                iid = self.roundList[i].internalRoundID;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return iid + 1;\r\n    }\r\n\r\n    function CurrentRoundStatus(MainDB storage self) internal view returns (uint8) {\r\n\r\n        Round storage currRound = CurrentRound(self);\r\n\r\n        if ( currRound.status == 1 ) {\r\n\r\n            if ( now >= currRound.startTime && now < currRound.endTime ) {\r\n                return 2;\r\n            } else if ( now >= currRound.endTime ) {\r\n                return 4;\r\n            }\r\n        }\r\n        else if ( currRound.status == 2 ) {\r\n\r\n            if ( now >= currRound.endTime ) {\r\n                return 4;\r\n            }\r\n\r\n            if ( currRound.currentAmount >= currRound.totalAmount ) {\r\n                return 3;\r\n            }\r\n        }\r\n\r\n        return currRound.status;\r\n    }\r\n\r\n    function UpdateRoundStatus(MainDB storage self) internal {\r\n\r\n        Round memory mRound = self.roundList[self.roundList.length - 1];\r\n        Round storage sRound = self.roundList[self.roundList.length - 1];\r\n\r\n        sRound.status = CurrentRoundStatus(self);\r\n\r\n        if ( mRound.status == 2 && sRound.status == 3 ) {\r\n\r\n            sRound.endTime = now;\r\n\r\n            if ( sRound.internalRoundID >= 3 ) {\r\n                self.roundList[ self.roundList.length - 1 - 3 ].status = 5;\r\n            }\r\n\r\n        }\r\n        else if ( (mRound.status == 2 || mRound.status == 1) && sRound.status == 4 ) {\r\n\r\n            uint256 internalRoundCount = InternalRoundCount( self, self.roundList.length - 1 );\r\n            uint n = 0;\r\n            if ( internalRoundCount > 4 ) {\r\n                n = internalRoundCount - 4;\r\n            }\r\n            for ( uint i = n; i < self.roundList.length && i < n + 3; i++ ) {\r\n                self.roundList[i].status = 6;\r\n            }\r\n\r\n        }\r\n\r\n        CheckAndCreateNewRound(self);\r\n    }\r\n\r\n    function HasPriorityabPermission(MainDB storage self, address owner) internal view returns (bool) {\r\n\r\n        if ( self.roundList[self.roundList.length - 1].internalRoundID != 0 ||\r\n             self.roundList.length < 3 ) {\r\n            return false;\r\n        }\r\n\r\n        for ( int i = int(self.roundList.length) - (1 + 2); i >= 0 && i > int(self.roundList.length) - (1 + 4); i-- ) {\r\n\r\n            Round storage r = self.roundList[uint(i)];\r\n\r\n            if ( r.status == 6 && r.depositedMapping[owner].totalAmount > 0 ) {\r\n                return true;\r\n            }\r\n\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function DepositedToCurrentRound(MainDB storage self, address owner, uint256 amount, bool priorityab) internal returns (bool) {\r\n\r\n        UpdateRoundStatus(self);\r\n\r\n        Round storage currRound = CurrentRound(self);\r\n\r\n        if ( currRound.currentAmount + amount > currRound.totalAmount ) {\r\n\r\n            return false;\r\n\r\n        } else if ( currRound.status != 2 && !priorityab ) {\r\n\r\n            return false;\r\n        }\r\n\r\n        currRound.depositedMapping[owner].owner = owner;\r\n        currRound.depositedMapping[owner].totalAmount += amount;\r\n        currRound.depositedMapping[owner].latestDepositedTime = now;\r\n\r\n        currRound.currentAmount += amount;\r\n\r\n        self.ownerAssetPool.AddAmount( amount );\r\n\r\n        uint256 reward = self.luckAssetPool.AddAmountAndTryGetReward( owner, amount );\r\n        if ( reward > 0 ) {\r\n\r\n            self.ERC20INC.transfer(owner, reward);\r\n\r\n            emit LogsToken(owner, now, int256(reward), CurrentRountOID(self), 7);\r\n        }\r\n\r\n        UpdateRoundStatus(self);\r\n\r\n        emit LogsToken(owner, now, -int256(amount), CurrentRountOID(self), 1);\r\n\r\n        return true;\r\n    }\r\n\r\n    function SettlementRoundOf(\r\n        MainDB storage self,\r\n        DynamicMath.MainDB storage DyMath,\r\n        LevelMath.MainDB storage LVMath,\r\n        address owner,\r\n        uint256 oid\r\n    )\r\n    internal\r\n    returns (\r\n        PESResponse memory rsp\r\n    ) {\r\n        UpdateRoundStatus(self);\r\n\r\n        Round storage settRound = RoundAt(self, oid);\r\n\r\n        Deposited storage depositedRecord = settRound.depositedMapping[owner];\r\n\r\n        require( depositedRecord.totalStProfit == 0 );\r\n\r\n        require( settRound.status == 4 || settRound.status == 5 || settRound.status == 6, \"RoundStatusExpection\");\r\n\r\n        rsp = PreExecSettlementRoundOf(self, DyMath, LVMath, owner, oid );\r\n\r\n        uint256 maxProfitLimitDelta = depositedRecord.totalAmount * 120000 / 1000000;\r\n\r\n        depositedRecord.totalStProfit = rsp.originalAmount + rsp.staticProfix;\r\n\r\n        for ( uint di = 0; di < rsp.dyLen; di++ ) {\r\n\r\n            if ( rsp.dyAddrs[di] == address(0x0) || rsp.dyProfits[di] <= 0 ) {\r\n                continue;\r\n            }\r\n\r\n            settRound.depositedMapping[rsp.dyAddrs[di]].totalDyProfit += rsp.dyProfits[di];\r\n\r\n            if ( maxProfitLimitDelta < rsp.dyProfits[di] ) {\r\n                maxProfitLimitDelta = 0;\r\n            } else {\r\n                maxProfitLimitDelta -= rsp.dyProfits[di];\r\n            }\r\n\r\n            if ( rsp.dyProfits[di] > 0 ) {\r\n\r\n                self.userTokenPool.AddAmount(rsp.dyAddrs[di], rsp.dyProfits[di]);\r\n\r\n                /// logs\r\n                emit LogsAmount(rsp.dyAddrs[di], now, int256(rsp.dyProfits[di]), oid, uint16(200 + di));\r\n            }\r\n        }\r\n\r\n        for ( uint mi = 0; mi < rsp.managerLen; mi++ ) {\r\n\r\n            if ( rsp.managers[mi] == address(0x0) || rsp.managers[mi] == address(0xFF) || rsp.managerProfits[mi] == 0 ) {\r\n                continue;\r\n            }\r\n\r\n            settRound.depositedMapping[rsp.managers[mi]].totalMrgProfit += rsp.managerProfits[mi];\r\n\r\n            if ( maxProfitLimitDelta < rsp.managerProfits[mi] ) {\r\n                maxProfitLimitDelta = 0;\r\n            } else {\r\n                maxProfitLimitDelta -= rsp.managerProfits[mi];\r\n            }\r\n\r\n            self.userTokenPool.AddAmount(rsp.managers[mi], rsp.managerProfits[mi]);\r\n\r\n            /// logs\r\n            emit LogsAmount(rsp.managers[mi], now, int256(rsp.managerProfits[mi]), oid, uint16(300 + mi));\r\n        }\r\n\r\n        if ( settRound.status == 5 ) {\r\n\r\n            self.luckAssetPool.AppendingAmount( maxProfitLimitDelta );\r\n\r\n            if ( !depositedRecord.autoReDepostied ) {\r\n\r\n                self.ERC20INC.transfer(owner, depositedRecord.totalStProfit);\r\n\r\n                /// logs\r\n                emit LogsToken(owner, now, int(depositedRecord.totalStProfit), oid, 2);\r\n\r\n            } else {\r\n\r\n                Round storage targetRound = CurrentRound(self);\r\n\r\n                if ((targetRound.status == 1 || targetRound.status == 2) &&\r\n                    targetRound.totalAmount - targetRound.currentAmount >= depositedRecord.totalStProfit ) {\r\n\r\n                    depositedRecord.toOID = self.roundList.length - 1;\r\n                    DepositedToCurrentRound(self, owner, depositedRecord.totalStProfit, true);\r\n\r\n                } else {\r\n\r\n                    self.ERC20INC.transfer(owner, depositedRecord.totalStProfit);\r\n\r\n                    depositedRecord.toOID = 1;\r\n\r\n                    /// logs\r\n                    emit LogsToken(owner, now, int(depositedRecord.totalStProfit), oid, 2);\r\n                }\r\n            }\r\n        }\r\n        else if ( settRound.status == 4 ) {\r\n\r\n            uint256 rollbackLuckAmount = self.luckAssetPool.DoRollback( oid, depositedRecord.totalStProfit * 30000 / 1000000 );\r\n\r\n            self.ERC20INC.transfer(owner, depositedRecord.totalStProfit * 970000 / 1000000 + rollbackLuckAmount );\r\n\r\n            /// logs\r\n            emit LogsToken(owner, now, int(depositedRecord.totalStProfit), oid, 5);\r\n\r\n        }\r\n        else if (settRound.status == 6 ) {\r\n\r\n            self.ERC20INC.transfer(owner, depositedRecord.totalStProfit);\r\n\r\n            /// logs\r\n            emit LogsToken(owner, now, int(depositedRecord.totalStProfit), oid, 6);\r\n        }\r\n\r\n    }\r\n\r\n    struct PESResponse {\r\n        uint256 originalAmount;\r\n        uint256 staticProfix;\r\n        uint256 dyLen;\r\n        address [] dyAddrs;\r\n        uint256 [] dyProfits;\r\n        uint256 managerLen;\r\n        address [] managers;\r\n        uint256 [] managerProfits;\r\n    }\r\n    function PreExecSettlementRoundOf(\r\n        MainDB storage self,\r\n        DynamicMath.MainDB storage DyMath,\r\n        LevelMath.MainDB storage LVMath,\r\n        address owner,\r\n        uint256 oid\r\n    )\r\n    internal view\r\n    returns (PESResponse memory rsp) {\r\n\r\n        Round storage settRound = RoundAt(self, oid);\r\n        // Round storage currRound = CurrentRound(self);\r\n\r\n        uint internalCount = InternalRoundCount(self, oid);\r\n        Round memory settMaxRound = self.roundList[ oid + (internalCount - settRound.internalRoundID - 1) ];\r\n\r\n        rsp.originalAmount = settRound.depositedMapping[owner].totalAmount;\r\n\r\n        // ProfitHandle(uint256 ir, bool irTimeoutable, uint256 n, uint256 ns) internal pure returns (uint256) {\r\n        uint256 nowAmount = StaticMath.ProfitHandle(\r\n            settMaxRound.internalRoundID,\r\n            (settMaxRound.status == 4),\r\n            settRound.internalRoundID,\r\n            rsp.originalAmount\r\n        );\r\n\r\n        if ( nowAmount < rsp.originalAmount ) {\r\n            rsp.originalAmount = nowAmount;\r\n            return rsp;\r\n        }\r\n\r\n        rsp.staticProfix = nowAmount - rsp.originalAmount;\r\n\r\n        ( rsp.dyLen, rsp.dyAddrs, rsp.dyProfits ) = DyMath.ProfitHandle(\r\n            self,\r\n            DynamicMath.Request(\r\n                owner,\r\n                oid,\r\n                settRound.depositedMapping[owner].totalAmount,\r\n                rsp.staticProfix\r\n            )\r\n        );\r\n\r\n        (rsp.managerLen, rsp.managers, rsp.managerProfits) = LVMath.ProfitHandle( owner, oid, self.roundList.length, rsp.staticProfix );\r\n    }\r\n\r\n    function CheckAndCreateNewRound(MainDB storage self) internal {\r\n\r\n        Round memory latestRound = self.roundList[self.roundList.length - 1];\r\n\r\n        if ( latestRound.status == 3 ) {\r\n\r\n            if ( latestRound.endTime - latestRound.createTime < 2 * Times.OneDay() ) {\r\n\r\n                self.roundList.push(\r\n                    Round(\r\n                        latestRound.rid,\r\n                        latestRound.internalRoundID + 1,\r\n                        1, /// status\r\n                        ((latestRound.totalAmount * 130) / 100) / 1 ether * 1 ether, /// totalAmount\r\n                        0, /// currentAmount\r\n                        latestRound.createTime + Times.OneDay() * 2, /// createTime\r\n                        latestRound.createTime + Times.OneDay() * (2 + 1), /// startTime\r\n                        latestRound.createTime + Times.OneDay() * (2 + 8) /// endTime\r\n                    )\r\n                );\r\n\r\n            } else {\r\n\r\n                self.roundList.push(\r\n                    Round(\r\n                        latestRound.rid, /// rid\r\n                        latestRound.internalRoundID + 1, ///internalRoundID\r\n                        1, /// status\r\n                        ((latestRound.totalAmount * 130) / 100) / 1 ether * 1 ether, /// totalAmount\r\n                        0, /// currentAmount\r\n                        now, /// createTime\r\n                        now + Times.OneDay() * 1, /// startTime\r\n                        now + Times.OneDay() * 8 /// endTime\r\n                    )\r\n                );\r\n            }\r\n\r\n            self.luckAssetPool.RoundSuccessDelegate();\r\n            self.ownerAssetPool.RoundSuccessDelegate();\r\n        }\r\n        else if ( latestRound.status == 4 ) {\r\n\r\n            uint256 totalAmount = (latestRound.totalAmount - latestRound.currentAmount) * self.newRIDInitProp / 100;\r\n\r\n            if ( totalAmount < 1000 ether ) {\r\n                totalAmount = 1000 ether;\r\n            }\r\n\r\n            self.roundList.push(\r\n                Round(\r\n                    latestRound.rid + 1, /// rid\r\n                    0, /// internalRoundID\r\n                    1, /// status\r\n                    totalAmount / 1 ether * 1 ether, /// totalAmount\r\n                    0, /// currentAmount\r\n                    now, /// createTime\r\n                    now + Times.OneDay() * 1, /// startTime\r\n                    now + Times.OneDay() * 8 /// endTime\r\n                )\r\n            );\r\n\r\n            self.ownerAssetPool.RoundTimeOutDelegate();\r\n\r\n            (address[20] memory addrs, uint256[20] memory amounts) = self.luckAssetPool.RoundTimeOutDelegate( self.roundList.length - 2, self.userTokenPool );\r\n\r\n            for ( uint s = 0; s < 20; s++ ) {\r\n                /// logs\r\n                if ( addrs[s] != address(0x0) && addrs[s] != address(0xFF) ) {\r\n                    emit LogsAmount( addrs[s], now, int(amounts[s]), self.roundList.length - 2, 100 );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function PoolBalanceOf(MainDB storage self, address owner) internal view returns (uint256) {\r\n        return self.userTokenPool.TotalAmount(owner);\r\n    }\r\n\r\n    function PoolWithdraw(MainDB storage self, address owner, uint256 amount) internal returns (bool) {\r\n\r\n        if (self.userTokenPool.TotalAmount(owner) < amount ) {\r\n            return false;\r\n        }\r\n\r\n        self.userTokenPool.SubAmount(owner, amount);\r\n\r\n        self.ERC20INC.transfer(owner, amount - amount / 100);\r\n\r\n        self.ERC20INC.transfer(address(0xdead), amount / 100);\r\n\r\n        /// logs\r\n        emit LogsAmount( owner, now, -int256(amount), 0, 6 );\r\n\r\n        /// logs\r\n        emit LogsToken( owner, now, int(amount), 0, 6 );\r\n\r\n        return true;\r\n    }\r\n\r\n    function TotalDyAmountSum(MainDB storage self, address owner) internal view returns (uint256) {\r\n        return self.userTokenPool.TotalSum(owner);\r\n    }\r\n}\r\n\r\n// File: contracts/MainContract.sol\r\ncontract MainContract is InternalModule {\r\n\r\n    RoundController.MainDB private _controller;\r\n    using RoundController for RoundController.MainDB;\r\n\r\n    DynamicMath.MainDB private _dyMath;\r\n    using DynamicMath for DynamicMath.MainDB;\r\n\r\n    LevelMath.MainDB private _levelMath;\r\n    using LevelMath for LevelMath.MainDB;\r\n\r\n    ERC20Interface public _Token;\r\n    RecommendInterface public _RCMINC;\r\n\r\n    uint256 public _depositMinLimit = 1 ether;\r\n\r\n\r\n    uint256 public _depositMaxLimitProp = 1;\r\n\r\n    constructor( RecommendInterface rinc, ERC20Interface tinc ) public {\r\n\r\n        _RCMINC = rinc;\r\n        _Token = tinc;\r\n\r\n        _controller.InitFristRound(now, rinc, _Token);\r\n        _dyMath.Init(rinc);\r\n        _levelMath.Init(rinc);\r\n    }\r\n\r\n    function CurrentAllowance() public view returns (uint256) {\r\n        return _Token.allowance(msg.sender, address(this));\r\n    }\r\n\r\n\r\n    function HasPriorityabPermission( address owner ) external view returns (bool) {\r\n        return _controller.HasPriorityabPermission(owner);\r\n    }\r\n\r\n\r\n    function DoDeposit( uint256 amount ) external DAODefense {\r\n\r\n\r\n        require( _RCMINC.GetIntroducer( msg.sender ) != address(0x0), \"-0\" );\r\n\r\n\r\n        require( CurrentAllowance() >= amount, \"-1\" );\r\n\r\n\r\n        require( amount % 0.001 ether == 0 );\r\n\r\n\r\n        RoundController.Round storage currRound = _controller.CurrentRound();\r\n        if ( currRound.totalAmount - currRound.currentAmount > 1 ether ) {\r\n            require( amount >= _depositMinLimit, \"Less then minlimit.\" );\r\n        }\r\n\r\n\r\n        require( amount <= currRound.totalAmount - currRound.currentAmount, \"-2\" );\r\n\r\n\r\n        require( currRound.depositedMapping[msg.sender].totalAmount + amount <= currRound.totalAmount * _depositMaxLimitProp / 100, \"-3\" );\r\n\r\n\r\n        require( _Token.transferFrom( msg.sender, address(this), amount ), \"-4\" );\r\n\r\n\r\n        bool hasPriorityab = _controller.HasPriorityabPermission(msg.sender);\r\n\r\n\r\n        require( _controller.DepositedToCurrentRound(msg.sender, amount, hasPriorityab), \"-5\" );\r\n\r\n\r\n        _levelMath.AddAchievement(msg.sender, _controller.CurrentRountOID(), amount );\r\n\r\n\r\n        if ( amount >= 10 ether ) {\r\n            _RCMINC.API_MakeAddressToValid(msg.sender);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function DoSettlement( uint256 oid )\r\n    external DAODefense\r\n    returns (\r\n        uint256 originalAmount,\r\n        uint256 staticProfix,\r\n        address [] memory dyAddrs,\r\n        uint256 [] memory dyProfits,\r\n        address [] memory managers,\r\n        uint256 [] memory managerProfits\r\n    ) {\r\n\r\n        RoundController.PESResponse memory rsp = _controller.SettlementRoundOf(\r\n            _dyMath,\r\n            _levelMath,\r\n            msg.sender,\r\n            oid\r\n        );\r\n\r\n        return (\r\n            rsp.originalAmount,\r\n            rsp.staticProfix,\r\n            rsp.dyAddrs,\r\n            rsp.dyProfits,\r\n            rsp.managers,\r\n            rsp.managerProfits\r\n        );\r\n    }\r\n\r\n    function RoundTotalCount() external view returns (uint256) {\r\n        return _controller.TotalCount();\r\n    }\r\n\r\n    function RoundStatusAt( uint256 oid ) external view returns (\r\n        /// inside round id\r\n        uint256 iid,\r\n\r\n        uint8 status,\r\n\r\n        uint256 totalAmount,\r\n\r\n        uint256 currentAmount,\r\n\r\n        uint256 createTime,\r\n\r\n        uint256 startTime,\r\n\r\n        uint256 endTime\r\n    ) {\r\n        uint256 id = oid;\r\n\r\n        RoundController.Round memory round;\r\n\r\n        if ( id >= _controller.TotalCount() ) {\r\n            id = _controller.CurrentRountOID();\r\n        }\r\n\r\n        round = _controller.RoundAt(id);\r\n\r\n        if ( id == _controller.CurrentRountOID() ) {\r\n            status = _controller.CurrentRoundStatus();\r\n        } else {\r\n            status = round.status;\r\n        }\r\n\r\n        iid = round.internalRoundID;\r\n        totalAmount = round.totalAmount;\r\n        currentAmount = round.currentAmount;\r\n        createTime = round.createTime;\r\n        startTime = round.startTime;\r\n        endTime = round.endTime;\r\n    }\r\n\r\n    function EnableAutoRedepostied( uint256 oid ) external {\r\n        require( _controller.EnableAutoRedeposit( msg.sender, oid ) );\r\n    }\r\n\r\n    function DepositedRoundOIDS( address owner ) public view returns (uint256[] memory ids, uint256 len) {\r\n\r\n        uint256[] memory tempIds = new uint256[](_controller.TotalCount());\r\n\r\n        len = 0;\r\n\r\n        for (uint i = 0; i < _controller.TotalCount(); i++ ) {\r\n            if ( _controller.RoundAt(i).depositedMapping[owner].owner == owner ) {\r\n                tempIds[len++] = i;\r\n            }\r\n        }\r\n\r\n        if (len == 0) {\r\n            return (new uint256[](0), 0);\r\n        }\r\n\r\n        ids = new uint256[](len);\r\n        for ( uint256 si = 0; si < len; si++ ) {\r\n            ids[si] = tempIds[si];\r\n        }\r\n\r\n    }\r\n\r\n    function DepositedInfo( address owner, uint256 oid ) external view returns (\r\n\r\n        uint256 statuse,\r\n\r\n        uint256 totalAmount,\r\n\r\n        uint256 latestDepositedTime,\r\n\r\n        bool autoReDepostied,\r\n\r\n        uint256 redepositedToOID,\r\n\r\n        uint256 totalStProfit,\r\n\r\n        uint256 totalDyProfit,\r\n\r\n        uint256 totalMrgProfit,\r\n\r\n        uint256 lv\r\n    ) {\r\n        require (oid < _controller.TotalCount() );\r\n\r\n        RoundController.Round storage r = _controller.RoundAt(oid);\r\n        RoundController.Deposited memory d = r.depositedMapping[owner];\r\n\r\n        statuse = r.status;\r\n        totalAmount = d.totalAmount;\r\n        latestDepositedTime = d.latestDepositedTime;\r\n        autoReDepostied = d.autoReDepostied;\r\n        totalStProfit = d.totalStProfit;\r\n        totalDyProfit = d.totalDyProfit;\r\n        totalMrgProfit = d.totalMrgProfit;\r\n        redepositedToOID = d.toOID;\r\n        lv = _levelMath.CurrentLevelOf(owner, oid, _controller.TotalCount());\r\n    }\r\n\r\n    function CurrentDepositedTotalCount(address owner) external view returns (uint256 total) {\r\n\r\n        (uint256[] memory allIDS, uint256 len) = DepositedRoundOIDS(owner);\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            RoundController.Deposited memory d = _controller.RoundAt(allIDS[i]).depositedMapping[owner];\r\n\r\n            if ( d.totalStProfit == 0 ) {\r\n                total += d.totalAmount;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    /// About LuckAsset Pool\r\n    using LuckAssetPool for LuckAssetPool.MainDB;\r\n    function BalanceOfLuckAssetPoolAtRID(uint256 rid) external view returns (uint256 ridTotal, uint256 rewardTotal) {\r\n\r\n        uint i = rid;\r\n\r\n        if ( rid > _controller.CurrentRoundRID() ) {\r\n            i = _controller.CurrentRoundRID();\r\n        }\r\n\r\n        return (_controller.luckAssetPool.BalanceOfRID(i), _controller.luckAssetPool.rewardAmountTotal);\r\n    }\r\n\r\n    function PoolBalanceOf(address owner) external view returns (uint256) {\r\n        return _controller.PoolBalanceOf(owner);\r\n    }\r\n\r\n    function PoolWithdraw(uint256 amount) external DAODefense {\r\n        require( _controller.PoolWithdraw(msg.sender, amount) );\r\n    }\r\n\r\n    function TotalDyAmountSum(address owner) external view returns (uint256) {\r\n        return _controller.TotalDyAmountSum(owner);\r\n    }\r\n\r\n    function Owner_SetDepositedMinLimit(uint256 a) external OwnerOnly {\r\n\r\n        require(a > 0.001 ether);\r\n\r\n        _depositMinLimit = a;\r\n    }\r\n\r\n    function Owner_SetDepositedMaxLimitProp(uint256 a) external OwnerOnly {\r\n\r\n        require( a <= 100 );\r\n\r\n        _depositMaxLimitProp = a;\r\n    }\r\n\r\n    function Owner_UpdateRoundStatus() external OwnerOnly {\r\n        _controller.UpdateRoundStatus();\r\n    }\r\n\r\n    function Owner_SetNewRIDProp(uint256 p) external OwnerOnly {\r\n        _controller.newRIDInitProp = p;\r\n    }\r\n\r\n    function Dev_QueryAchievement(address owner, uint256 oid) external view returns (uint256) {\r\n        return _levelMath.achievementMapping[oid][owner];\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"_RCMINC\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"CurrentDepositedTotalCount\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"Dev_QueryAchievement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"Owner_SetDepositedMaxLimitProp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_depositMaxLimitProp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"Owner_SetDepositedMinLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"HasPriorityabPermission\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DoDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rid\",\"type\":\"uint256\"}],\"name\":\"BalanceOfLuckAssetPoolAtRID\",\"outputs\":[{\"name\":\"ridTotal\",\"type\":\"uint256\"},{\"name\":\"rewardTotal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"RoundStatusAt\",\"outputs\":[{\"name\":\"iid\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"name\":\"currentAmount\",\"type\":\"uint256\"},{\"name\":\"createTime\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_contractOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Owner_UpdateRoundStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PoolWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RoundTotalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"AddAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"TotalDyAmountSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AuthAddresses\",\"outputs\":[{\"name\":\"authAddr\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_depositMinLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"EnableAutoRedepostied\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"DoSettlement\",\"outputs\":[{\"name\":\"originalAmount\",\"type\":\"uint256\"},{\"name\":\"staticProfix\",\"type\":\"uint256\"},{\"name\":\"dyAddrs\",\"type\":\"address[]\"},{\"name\":\"dyProfits\",\"type\":\"uint256[]\"},{\"name\":\"managers\",\"type\":\"address[]\"},{\"name\":\"managerProfits\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CurrentAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"DepositedInfo\",\"outputs\":[{\"name\":\"statuse\",\"type\":\"uint256\"},{\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"name\":\"latestDepositedTime\",\"type\":\"uint256\"},{\"name\":\"autoReDepostied\",\"type\":\"bool\"},{\"name\":\"redepositedToOID\",\"type\":\"uint256\"},{\"name\":\"totalStProfit\",\"type\":\"uint256\"},{\"name\":\"totalDyProfit\",\"type\":\"uint256\"},{\"name\":\"totalMrgProfit\",\"type\":\"uint256\"},{\"name\":\"lv\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"Owner_SetNewRIDProp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_defaultReciver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_Token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"DepositedRoundOIDS\",\"outputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"len\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PoolBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"DelAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"rinc\",\"type\":\"address\"},{\"name\":\"tinc\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MainContract","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000070eb4382752dedc55ef6c93d9c05569f89f109da000000000000000000000000c6cc22f88edae6667763f7745d4ecd297d535540","Library":"Times:ff91b8e538d5e812f6de3b54656612ffa2bf0ba0","LicenseType":"None","SwarmSource":"bzzr://6ee94b2e1bbdb0ad531b4847d3803ca708bd9851588a5a133880670c4b087887"}]}