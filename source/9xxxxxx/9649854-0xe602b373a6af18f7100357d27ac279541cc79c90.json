{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >= 0.5.16;\r\n\r\n/**\r\n * @title  ChainValidator interface\r\n * @author Nordic Energy\r\n * @notice External chain validator contract, can be used for more sophisticated validation of new validators and transactors, e.g. custom min. required conditions,\r\n *         concrete users whitelisting, etc...\r\n **/\r\ninterface ChainValidator {\r\n    /**\r\n     * @notice Validation function for new validators\r\n     * \r\n     * @param vesting               How many Nordic Energy tokens new validator wants to vest\r\n     * @param acc                   Account address of the validator\r\n     * @param mining                Flag if validator is going to mine. \r\n     *                              mining == false in case validateNewValidator is called during vestInChain method\r\n     *                              mining == true in case validateNewValidator is called during startMining method\r\n     * @param actNumOfValidators    How many active validators is currently in chain\r\n     **/\r\n    function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool);\r\n    \r\n    /**\r\n     * @notice Validation function for new transactors\r\n     * \r\n     * @param deposit               How many Nordic Energy tokens new transactor wants to deposit\r\n     * @param acc                   Account address of the transactor\r\n     * @param actNumOfTransactors   How many whitelisted transactors (their deposit balance >= min. required balance) is currently in chain\r\n     **/\r\n    function validateNewTransactor(uint256 deposit, address acc, uint256 actNumOfTransactors) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title  EnergyChainValidator for Nordic Energy chain\r\n * @author Nordic Energy\r\n * @notice External chain validator contract with specific conditions tailored for Nordic Energy chain\r\n **/\r\ncontract EnergyChainValidator is ChainValidator {\r\n    \r\n    /**************************************************************************************************************************/\r\n    /************************************************** Constants *************************************************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    // Token precision. 1 NET token = 1*10^18\r\n    uint256 constant NET_PRECISION               = 10**18;\r\n    \r\n    // Min deposit value\r\n    uint256 constant MIN_DEPOSIT                 = 1000*NET_PRECISION;\r\n    \r\n    // Min vesting value\r\n    uint256 constant MIN_VESTING                 = 1000*NET_PRECISION;\r\n    \r\n    // Min vesting value\r\n    uint256 constant MAX_VESTING                 = 500000*NET_PRECISION;\r\n    \r\n    \r\n    /**************************************************************************************************************************/\r\n    /*********************************** Structs and functions related to the list of users ***********************************/\r\n    /**************************************************************************************************************************/\r\n    \r\n    \r\n    // Iterable map that is used only together with the Users mapping as data holder\r\n    struct IterableMap {\r\n        // map of indexes to the list array\r\n        // indexes are shifted +1 compared to the real indexes of this list, because 0 means non-existing element\r\n        mapping(address => uint256) listIndex;\r\n        // list of addresses \r\n        address[]                   list;        \r\n    }    \r\n    \r\n    // Adds acc from the map\r\n    function insertAcc(IterableMap storage map, address acc) internal {\r\n        map.list.push(acc);\r\n        // indexes are stored + 1   \r\n        map.listIndex[acc] = map.list.length;\r\n    }\r\n    \r\n    // Removes acc from the map\r\n    function removeAcc(IterableMap storage map, address acc) internal {\r\n        uint256 index = map.listIndex[acc];\r\n        require(index > 0 && index <= map.list.length, \"RemoveAcc invalid index\");\r\n        \r\n        // Move an last element of array into the vacated key slot.\r\n        uint256 foundIndex = index - 1;\r\n        uint256 lastIndex  = map.list.length - 1;\r\n    \r\n        map.listIndex[map.list[lastIndex]] = foundIndex + 1;\r\n        map.list[foundIndex] = map.list[lastIndex];\r\n        map.list.length--;\r\n    \r\n        // Deletes element\r\n        map.listIndex[acc] = 0;\r\n    }\r\n    \r\n    // Returns true, if acc exists in the iterable map, otherwise false\r\n    function existAcc(IterableMap storage map, address acc) internal view returns (bool) {\r\n        return map.listIndex[acc] != 0;\r\n    }\r\n    \r\n    \r\n    /**************************************************************************************************************************/\r\n    /******************************************** Other structs and functions *************************************************/\r\n    /**************************************************************************************************************************/\r\n\r\n\r\n    // List of admins - they can add/remove whitelisted validators and users\r\n    IterableMap private admins;\r\n    \r\n    // List of whitelisted users who can deposit\r\n    IterableMap private whitelistedUsers;\r\n    \r\n    // Max allowed number of active validators at the same time \r\n    uint256     public  maxNumOfValidators;\r\n    \r\n    constructor() public {\r\n        insertAcc(admins, msg.sender);\r\n    }\r\n\r\n\r\n    /**************************************************************************************************************************/\r\n    /*********************************************** Smart Contract Interface *******************************************************/\r\n    /**************************************************************************************************************************/\r\n\r\n    \r\n    /**\r\n     * @notice Validation function for new validators. All validators with vesting in range <1000, 50000> NET tokens are allowed \r\n     * \r\n     * @param vesting               How many tokens new validator wants to vest\r\n     * @param acc                   Account address of the validator\r\n     * @param mining                Flag if validator is going to mine. \r\n     *                              mining == false in case validateNewValidator is called during vestInChain method\r\n     *                              mining == true in case validateNewValidator is called during startMining method\r\n     * @param actNumOfValidators    How many active validators is currently in chain\r\n     **/\r\n    function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool) {\r\n        if (vesting < MIN_VESTING || vesting > MAX_VESTING) {\r\n            return false;\r\n        }\r\n        if (maxNumOfValidators != 0 && mining == true && actNumOfValidators >= maxNumOfValidators) {\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @notice Validation function for new transactors. Only whitelisted accounts are allowed\r\n     * \r\n     * @param deposit               How many tokens new transactor wants to deposit\r\n     * @param acc                   Account address of the transactor\r\n     * @param actNumOfTransactors   How many whitelisted transactors (their deposit balance >= min. required balance) is currently in chain\r\n     **/\r\n    function validateNewTransactor(uint256 deposit, address acc, uint256 actNumOfTransactors) external returns (bool) {\r\n        if (existAcc(whitelistedUsers, acc) == true && deposit >= MIN_DEPOSIT) {\r\n            return  true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets allowed max num of active validators at the same time  \r\n     * \r\n     * @param num\r\n     **/\r\n    function setMaxNumOfValidators(uint256 num) external {\r\n        require(existAcc(admins, msg.sender) == true, \"Only admins can do internal changes\");\r\n        maxNumOfValidators = num;\r\n    }\r\n    \r\n    /**\r\n     * @notice Adds new whitelisted accounts that are allowed to transact on Nordic energy chain\r\n     *         Provided existing accounts are ignored\r\n     * \r\n     * @param accounts List of accounts\r\n     **/\r\n    function addWhitelistedUsers(address[] calldata accounts) external {\r\n        addUsers(whitelistedUsers, accounts);\r\n    }\r\n    \r\n    /**\r\n     * @notice Removes existing whitelisted accounts that are allowed to transact on Nordic energy chain.\r\n     *         Provided non-existing accounts are ignored\r\n     * \r\n     * @param accounts List of accounts\r\n     **/\r\n    function removeWhitelistedUsers(address[] calldata accounts) external {\r\n        require(whitelistedUsers.list.length > 0, \"There are no whitelisted users to be removed\");\r\n        \r\n        removeUsers(whitelistedUsers, accounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds new admins that are allowed to add/remove whitelisted users\r\n     *         Provided existing accounts are ignored*\r\n     * @param accounts List of accounts\r\n     **/\r\n    function addAdmins(address[] calldata accounts) external {\r\n        addUsers(admins, accounts);\r\n    }\r\n    \r\n    /**\r\n     * @notice Removes existing admin that is allowed to add/remove whitelisted users. \r\n     *         Provided account must exist as registered admin\r\n     * \r\n     * @param account List of accounts\r\n     **/\r\n    function removeAdmin(address account) external {\r\n        require(admins.list.length > 1, \"Cannot remove all admins, at least one must be always present\");\r\n        require(existAcc(admins, account) == true, \"Trying to remove non-existing admin\");\r\n        \r\n        removeAcc(admins, account);\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns list of admins (their accounts)\r\n     *\r\n     * @param batch        Batch number to be fetched. If the list is too big it cannot return all admins in one call. Instead, users are fetching batches of 100 account at a time \r\n     * \r\n     * @return accounts    List(batch of 100) of account\r\n     * @return count       How many accounts are returned in specified batch\r\n     * @return end         Flag if there are no more accounts left. To get all accounts, caller should fetch all batches until he sees end == true\r\n     **/\r\n    function getAdmins(uint256 batch) external view returns (address[100] memory accounts, uint256 count, bool end) {\r\n        return getUsers(admins, batch);\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns list of whitelisted users (their accounts)\r\n     *\r\n     * @param batch        Batch number to be fetched. If the list is too big it cannot return all admins in one call. Instead, users are fetching batches of 100 account at a time \r\n     * \r\n     * @return accounts    List(batch of 100) of account\r\n     * @return count       How many accounts are returned in specified batch\r\n     * @return end         Flag if there are no more accounts left. To get all accounts, caller should fetch all batches until he sees end == true\r\n     **/\r\n    function getWhitelistedUsers(uint256 batch) external view returns (address[100] memory accounts, uint256 count, bool end) {\r\n        return getUsers(whitelistedUsers, batch);\r\n    }\r\n    \r\n    \r\n    /*************************************************************************************************************************/\r\n    /******************************************** Smart Contract internal functions ************************************************/\r\n    /*************************************************************************************************************************/\r\n\r\n    \r\n    // Returns list of suers users\r\n    function getUsers(IterableMap storage internalUsersGroup, uint256 batch) internal view returns (address[100] memory users, uint256 count, bool end) {\r\n        count = 0;\r\n        uint256 usersTotalCount = internalUsersGroup.list.length;\r\n        \r\n        uint256 i;\r\n        for(i = batch * 100; i < (batch + 1)*100 && i < usersTotalCount; i++) {\r\n            users[count] = internalUsersGroup.list[i];\r\n            count++;\r\n        }\r\n        \r\n        if (i >= usersTotalCount) {\r\n            end = true;\r\n        }\r\n        else {\r\n            end = false;\r\n        }\r\n    }\r\n    \r\n    function addUsers(IterableMap storage internalUsersGroup, address[] memory users) internal {\r\n        require(existAcc(admins, msg.sender) == true, \"Only admins can do internal changes\");\r\n        require(users.length <= 100, \"Max number of processed users is 100\");\r\n        \r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            if (existAcc(internalUsersGroup, users[i]) == false) {\r\n                insertAcc(internalUsersGroup, users[i]);\r\n            }    \r\n        }\r\n    }\r\n    \r\n    function removeUsers(IterableMap storage internalUsersGroup, address[] memory users) internal {\r\n        require(existAcc(admins, msg.sender) == true, \"Only admins can remove whitelisted users\");\r\n        require(users.length <= 100, \"Max number of processed users is 100\");\r\n        \r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            if (existAcc(internalUsersGroup, users[i]) == true) {\r\n                removeAcc(internalUsersGroup, users[i]);\r\n            }    \r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addAdmins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addWhitelistedUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batch\",\"type\":\"uint256\"}],\"name\":\"getAdmins\",\"outputs\":[{\"internalType\":\"address[100]\",\"name\":\"accounts\",\"type\":\"address[100]\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"end\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batch\",\"type\":\"uint256\"}],\"name\":\"getWhitelistedUsers\",\"outputs\":[{\"internalType\":\"address[100]\",\"name\":\"accounts\",\"type\":\"address[100]\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"end\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumOfValidators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeWhitelistedUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setMaxNumOfValidators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"actNumOfTransactors\",\"type\":\"uint256\"}],\"name\":\"validateNewTransactor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"mining\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"actNumOfValidators\",\"type\":\"uint256\"}],\"name\":\"validateNewValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EnergyChainValidator","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://cc62ae8c0a90b3adf468885f2cc5a6a19e62a5f7384fbd280dd47a6f6996749b"}]}