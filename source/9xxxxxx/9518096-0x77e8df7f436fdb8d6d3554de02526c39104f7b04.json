{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\n\r\ncontract Context {\r\n    \r\n    \r\n    constructor () internal { }\r\n    \r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n        \r\n        \r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        \r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        \r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    \r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    \r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    \r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     \r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    \r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            \r\n            \r\n            tempBytes := mload(0x40)\r\n\r\n            \r\n            \r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            \r\n            \r\n            \r\n            let mc := add(tempBytes, 0x20)\r\n            \r\n            \r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                \r\n                \r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                \r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                \r\n                \r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            \r\n            \r\n            \r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            \r\n            \r\n            mc := end\r\n            \r\n            \r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            mstore(0x40, and(\r\n                add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                not(31) \r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            \r\n            \r\n            \r\n            let fslot := sload(_preBytes_slot)\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            \r\n            \r\n            \r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                \r\n                \r\n                \r\n                sstore(\r\n                    _preBytes_slot,\r\n                    \r\n                    \r\n                    add(\r\n                        \r\n                        \r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    \r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    \r\n                                    exp(0x100, sub(32, mlength))\r\n                        ),\r\n                        \r\n                        \r\n                        exp(0x100, sub(32, newlength))\r\n                        ),\r\n                        \r\n                        \r\n                        mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                \r\n                \r\n                \r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                \r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                    ),\r\n                    and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                \r\n                mstore(0x0, _preBytes_slot)\r\n                \r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                \r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                \r\n                \r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory) {\r\n        require(_bytes.length >= (_start + _length), \"Slice out of bounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                \r\n                \r\n                tempBytes := mload(0x40)\r\n\r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                let lengthmod := and(_length, 31)\r\n\r\n                \r\n                \r\n                \r\n                \r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    \r\n                    \r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                \r\n                \r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            \r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20), \"Address conversion out of bounds.\");\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32), \"Uint conversion out of bounds.\");\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            \r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                \r\n                \r\n                \r\n                \r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                    \r\n                    \r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    \r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        \r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                \r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            \r\n            let fslot := sload(_preBytes_slot)\r\n            \r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            \r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                \r\n                \r\n                \r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        \r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            \r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        \r\n                        \r\n                        \r\n                        \r\n                        let cb := 1\r\n\r\n                        \r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        \r\n                        \r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                \r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                \r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(_source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(_source, 32))\r\n        }\r\n    }\r\n}\r\n\r\nlibrary BTCUtils {\r\n    using BytesLib for bytes;\r\n    using SafeMath for uint256;\r\n\r\n    \r\n    uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\r\n\r\n    uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  \r\n    uint256 public constant RETARGET_PERIOD_BLOCKS = 2016;  \r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    function determineVarIntDataLength(bytes memory _flag) internal pure returns (uint8) {\r\n        if (uint8(_flag[0]) == 0xff) {\r\n            return 8;  \r\n        }\r\n        if (uint8(_flag[0]) == 0xfe) {\r\n            return 4;  \r\n        }\r\n        if (uint8(_flag[0]) == 0xfd) {\r\n            return 2;  \r\n        }\r\n\r\n        return 0;  \r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function reverseEndianness(bytes memory _b) internal pure returns (bytes memory) {\r\n        bytes memory _newValue = new bytes(_b.length);\r\n\r\n        for (uint i = 0; i < _b.length; i++) {\r\n            _newValue[_b.length - i - 1] = _b[i];\r\n        }\r\n\r\n        return _newValue;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function bytesToUint(bytes memory _b) internal pure returns (uint256) {\r\n        uint256 _number;\r\n\r\n        for (uint i = 0; i < _b.length; i++) {\r\n            _number = _number + uint8(_b[i]) * (2 ** (8 * (_b.length - (i + 1))));\r\n        }\r\n\r\n        return _number;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function lastBytes(bytes memory _b, uint256 _num) internal pure returns (bytes memory) {\r\n        uint256 _start = _b.length.sub(_num);\r\n\r\n        return _b.slice(_start, _num);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hash160(bytes memory _b) internal pure returns (bytes memory) {\r\n        return abi.encodePacked(ripemd160(abi.encodePacked(sha256(_b))));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hash256(bytes memory _b) internal pure returns (bytes32) {\r\n        return abi.encodePacked(sha256(abi.encodePacked(sha256(_b)))).toBytes32();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function extractInputAtIndex(bytes memory _vin, uint8 _index) internal pure returns (bytes memory) {\r\n        uint256 _len;\r\n        bytes memory _remaining;\r\n\r\n        uint256 _offset = 1;\r\n\r\n        for (uint8 _i = 0; _i < _index; _i ++) {\r\n            _remaining = _vin.slice(_offset, _vin.length - _offset);\r\n            _len = determineInputLength(_remaining);\r\n            _offset = _offset + _len;\r\n        }\r\n\r\n        _remaining = _vin.slice(_offset, _vin.length - _offset);\r\n        _len = determineInputLength(_remaining);\r\n        return _vin.slice(_offset, _len);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function isLegacyInput(bytes memory _input) internal pure returns (bool) {\r\n        return keccak256(_input.slice(36, 1)) != keccak256(hex\"00\");\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function determineInputLength(bytes memory _input) internal pure returns (uint256) {\r\n        uint8 _varIntDataLen;\r\n        uint256 _scriptSigLen;\r\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\r\n        return 36 + 1 + _varIntDataLen + _scriptSigLen + 4;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractSequenceLELegacy(bytes memory _input) internal pure returns (bytes memory) {\r\n        uint8 _varIntDataLen;\r\n        uint256 _scriptSigLen;\r\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\r\n        return _input.slice(36 + 1 + _varIntDataLen + _scriptSigLen, 4);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractSequenceLegacy(bytes memory _input) internal pure returns (uint32) {\r\n        bytes memory _leSeqence = extractSequenceLELegacy(_input);\r\n        bytes memory _beSequence = reverseEndianness(_leSeqence);\r\n        return uint32(bytesToUint(_beSequence));\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    function extractScriptSig(bytes memory _input) internal pure returns (bytes memory) {\r\n        uint8 _varIntDataLen;\r\n        uint256 _scriptSigLen;\r\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\r\n        return _input.slice(36, 1 + _varIntDataLen + _scriptSigLen);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractScriptSigLen(bytes memory _input) internal pure returns (uint8, uint256) {\r\n        bytes memory _varIntTag = _input.slice(36, 1);\r\n        uint8 _varIntDataLen = determineVarIntDataLength(_varIntTag);\r\n        uint256 _len;\r\n        if (_varIntDataLen == 0) {\r\n            _len = uint8(_varIntTag[0]);\r\n        } else {\r\n            _len = bytesToUint(reverseEndianness(_input.slice(36 + 1, _varIntDataLen)));\r\n        }\r\n        return (_varIntDataLen, _len);\r\n    }\r\n\r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractSequenceLEWitness(bytes memory _input) internal pure returns (bytes memory) {\r\n        return _input.slice(37, 4);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractSequenceWitness(bytes memory _input) internal pure returns (uint32) {\r\n        bytes memory _leSeqence = extractSequenceLEWitness(_input);\r\n        bytes memory _inputeSequence = reverseEndianness(_leSeqence);\r\n        return uint32(bytesToUint(_inputeSequence));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractOutpoint(bytes memory _input) internal pure returns (bytes memory) {\r\n        return _input.slice(0, 36);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractInputTxIdLE(bytes memory _input) internal pure returns (bytes32) {\r\n        return _input.slice(0, 32).toBytes32();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractInputTxId(bytes memory _input) internal pure returns (bytes32) {\r\n        bytes memory _leId = abi.encodePacked(extractInputTxIdLE(_input));\r\n        bytes memory _beId = reverseEndianness(_leId);\r\n        return _beId.toBytes32();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTxIndexLE(bytes memory _input) internal pure returns (bytes memory) {\r\n        return _input.slice(32, 4);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTxIndex(bytes memory _input) internal pure returns (uint32) {\r\n        bytes memory _leIndex = extractTxIndexLE(_input);\r\n        bytes memory _beIndex = reverseEndianness(_leIndex);\r\n        return uint32(bytesToUint(_beIndex));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    function determineOutputLength(bytes memory _output) internal pure returns (uint256) {\r\n        uint8 _len = uint8(_output.slice(8, 1)[0]);\r\n        require(_len < 0xfd, \"Multi-byte VarInts not supported\");\r\n\r\n        return _len + 8 + 1; \r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function extractOutputAtIndex(bytes memory _vout, uint8 _index) internal pure returns (bytes memory) {\r\n        uint256 _len;\r\n        bytes memory _remaining;\r\n\r\n        uint256 _offset = 1;\r\n\r\n        for (uint8 _i = 0; _i < _index; _i ++) {\r\n            _remaining = _vout.slice(_offset, _vout.length - _offset);\r\n            _len = determineOutputLength(_remaining);\r\n            _offset = _offset + _len;\r\n        }\r\n\r\n        _remaining = _vout.slice(_offset, _vout.length - _offset);\r\n        _len = determineOutputLength(_remaining);\r\n        return _vout.slice(_offset, _len);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractOutputScriptLen(bytes memory _output) internal pure returns (bytes memory) {\r\n        return _output.slice(8, 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractValueLE(bytes memory _output) internal pure returns (bytes memory) {\r\n        return _output.slice(0, 8);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractValue(bytes memory _output) internal pure returns (uint64) {\r\n        bytes memory _leValue = extractValueLE(_output);\r\n        bytes memory _beValue = reverseEndianness(_leValue);\r\n        return uint64(bytesToUint(_beValue));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractOpReturnData(bytes memory _output) internal pure returns (bytes memory) {\r\n        if (keccak256(_output.slice(9, 1)) != keccak256(hex\"6a\")) {\r\n            return hex\"\";\r\n        }\r\n        bytes memory _dataLen = _output.slice(10, 1);\r\n        return _output.slice(11, bytesToUint(_dataLen));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractHash(bytes memory _output) internal pure returns (bytes memory) {\r\n        if (uint8(_output.slice(9, 1)[0]) == 0) {\r\n            uint256 _len = uint8(extractOutputScriptLen(_output)[0]) - 2;\r\n            \r\n            if (uint8(_output.slice(10, 1)[0]) != uint8(_len)) {\r\n                return hex\"\";\r\n            }\r\n            return _output.slice(11, _len);\r\n        } else {\r\n            bytes32 _tag = keccak256(_output.slice(8, 3));\r\n            \r\n            if (_tag == keccak256(hex\"1976a9\")) {\r\n                \r\n                if (uint8(_output.slice(11, 1)[0]) != 0x14 ||\r\n                    keccak256(_output.slice(_output.length - 2, 2)) != keccak256(hex\"88ac\")) {\r\n                    return hex\"\";\r\n                }\r\n                return _output.slice(12, 20);\r\n            \r\n            } else if (_tag == keccak256(hex\"17a914\")) {\r\n                \r\n                if (uint8(_output.slice(_output.length - 1, 1)[0]) != 0x87) {\r\n                    return hex\"\";\r\n                }\r\n                return _output.slice(11, 20);\r\n            }\r\n        }\r\n        return hex\"\";  \r\n    }\r\n\r\n    \r\n    \r\n    \r\n\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function validateVin(bytes memory _vin) internal pure returns (bool) {\r\n        uint256 _offset = 1;\r\n        uint8 _nIns = uint8(_vin.slice(0, 1)[0]);\r\n\r\n        \r\n        if (_nIns >= 0xfd || _nIns == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint8 i = 0; i < _nIns; i++) {\r\n            \r\n            \r\n            _offset += determineInputLength(_vin.slice(_offset, _vin.length - _offset));\r\n\r\n            \r\n            if (_offset > _vin.length) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        \r\n        return _offset == _vin.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function validateVout(bytes memory _vout) internal pure returns (bool) {\r\n        uint256 _offset = 1;\r\n        uint8 _nOuts = uint8(_vout.slice(0, 1)[0]);\r\n\r\n        \r\n        if (_nOuts >= 0xfd || _nOuts == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint8 i = 0; i < _nOuts; i++) {\r\n            \r\n            \r\n            _offset += determineOutputLength(_vout.slice(_offset, _vout.length - _offset));\r\n\r\n            \r\n            if (_offset > _vout.length) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        \r\n        return _offset == _vout.length;\r\n    }\r\n\r\n\r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractMerkleRootLE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return _header.slice(36, 32);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractMerkleRootBE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return reverseEndianness(extractMerkleRootLE(_header));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTarget(bytes memory _header) internal pure returns (uint256) {\r\n        bytes memory _m = _header.slice(72, 3);\r\n        uint8 _e = uint8(_header[75]);\r\n        uint256 _mantissa = bytesToUint(reverseEndianness(_m));\r\n        uint _exponent = _e - 3;\r\n\r\n        return _mantissa * (256 ** _exponent);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function calculateDifficulty(uint256 _target) internal pure returns (uint256) {\r\n        \r\n        return DIFF1_TARGET.div(_target);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractPrevBlockLE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return _header.slice(4, 32);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractPrevBlockBE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return reverseEndianness(extractPrevBlockLE(_header));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTimestampLE(bytes memory _header) internal pure returns (bytes memory) {\r\n        return _header.slice(68, 4);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractTimestamp(bytes memory _header) internal pure returns (uint32) {\r\n        return uint32(bytesToUint(reverseEndianness(extractTimestampLE(_header))));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function extractDifficulty(bytes memory _header) internal pure returns (uint256) {\r\n        return calculateDifficulty(extractTarget(_header));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function _hash256MerkleStep(bytes memory _a, bytes memory _b) internal pure returns (bytes32) {\r\n        return hash256(abi.encodePacked(_a, _b));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function verifyHash256Merkle(bytes memory _proof, uint _index) internal pure returns (bool) {\r\n        \r\n        if (_proof.length % 32 != 0) {\r\n            return false;\r\n        }\r\n\r\n        \r\n        if (_proof.length == 32) {\r\n            return true;\r\n        }\r\n\r\n        \r\n        if (_proof.length == 64) {\r\n            return false;\r\n        }\r\n\r\n        uint _idx = _index;\r\n        bytes32 _root = _proof.slice(_proof.length - 32, 32).toBytes32();\r\n        bytes32 _current = _proof.slice(0, 32).toBytes32();\r\n\r\n        for (uint i = 1; i < (_proof.length.div(32)) - 1; i++) {\r\n            if (_idx % 2 == 1) {\r\n                _current = _hash256MerkleStep(_proof.slice(i * 32, 32), abi.encodePacked(_current));\r\n            } else {\r\n                _current = _hash256MerkleStep(abi.encodePacked(_current), _proof.slice(i * 32, 32));\r\n            }\r\n            _idx = _idx >> 1;\r\n        }\r\n        return _current == _root;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function retargetAlgorithm(\r\n        uint256 _previousTarget,\r\n        uint256 _firstTimestamp,\r\n        uint256 _secondTimestamp\r\n    ) internal pure returns (uint256) {\r\n        uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\r\n\r\n        \r\n        if (_elapsedTime < RETARGET_PERIOD.div(4)) {\r\n            _elapsedTime = RETARGET_PERIOD.div(4);\r\n        }\r\n        if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\r\n            _elapsedTime = RETARGET_PERIOD.mul(4);\r\n        }\r\n\r\n        \r\n\r\n        uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\r\n        return _adjusted.div(RETARGET_PERIOD).mul(65536);\r\n    }\r\n}\r\n\r\ninterface FundsInterface {\r\n    function lender(bytes32) external view returns (address);\r\n    function custom(bytes32) external view returns (bool);\r\n    function deposit(bytes32, uint256) external;\r\n    function decreaseTotalBorrow(uint256) external;\r\n    function calcGlobalInterest() external;\r\n}\r\n\r\ninterface SalesInterface {\r\n    function saleIndexByLoan(bytes32, uint256) external returns(bytes32);\r\n    function settlementExpiration(bytes32) external view returns (uint256);\r\n    function accepted(bytes32) external view returns (bool);\r\n    function next(bytes32) external view returns (uint256);\r\n    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\r\n}\r\n\r\ninterface CollateralInterface {\r\n    function onDemandSpv() external view returns(address);\r\n    function collateral(bytes32 loan) external view returns (uint256);\r\n    function refundableCollateral(bytes32 loan) external view returns (uint256);\r\n    function seizableCollateral(bytes32 loan) external view returns (uint256);\r\n    function temporaryRefundableCollateral(bytes32 loan) external view returns (uint256);\r\n    function temporarySeizableCollateral(bytes32 loan) external view returns (uint256);\r\n    function setCollateral(bytes32 loan, uint256 refundableCollateral_, uint256 seizableCollateral_) external;\r\n    function requestSpv(bytes32 loan) external;\r\n    function cancelSpv(bytes32 loan) external;\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant COL  = 10 ** 8;\r\n    uint constant WAD  = 10 ** 18;\r\n    uint constant RAY  = 10 ** 27;\r\n\r\n    function cmul(uint x, uint y) public pure returns (uint z) {\r\n        z = add(mul(x, y), COL / 2) / COL;\r\n    }\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function cdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, COL), y / 2) / y;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Medianizer {\r\n    function peek() external view returns (bytes32, bool);\r\n    function read() external returns (bytes32);\r\n    function poke() external;\r\n    function poke(bytes32) external;\r\n    function fund (uint256 amount, ERC20 token) external;\r\n}\r\n\r\ncontract Loans is DSMath {\r\n    FundsInterface funds;\r\n    Medianizer med;\r\n    SalesInterface sales;\r\n    CollateralInterface col;\r\n\r\n    uint256 public constant APPROVE_EXP_THRESHOLD = 2 hours;    \r\n    uint256 public constant ACCEPT_EXP_THRESHOLD = 2 days;      \r\n    uint256 public constant LIQUIDATION_EXP_THRESHOLD = 7 days; \r\n    uint256 public constant SEIZURE_EXP_THRESHOLD = 2 days;     \r\n    uint256 public constant LIQUIDATION_DISCOUNT = 930000000000000000; \r\n    uint256 public constant MAX_NUM_LIQUIDATIONS = 3; \r\n    uint256 public constant MAX_UINT_256 = 2**256-1;\r\n\r\n    mapping (bytes32 => Loan)                     public loans;\r\n    mapping (bytes32 => PubKeys)                  public pubKeys;             \r\n    mapping (bytes32 => SecretHashes)             public secretHashes;        \r\n    mapping (bytes32 => Bools)                    public bools;               \r\n    mapping (bytes32 => bytes32)                  public fundIndex;           \r\n    mapping (bytes32 => uint256)                  public repayments;          \r\n    mapping (address => bytes32[])                public borrowerLoans;\r\n    mapping (address => bytes32[])                public lenderLoans;\r\n    mapping (address => mapping(uint256 => bool)) public addressToTimestamp;\r\n    uint256                                       public loanIndex;           \r\n\r\n    ERC20 public token; \r\n    uint256 public decimals;\r\n\r\n    address deployer;\r\n\r\n    \r\n    struct Loan {\r\n        address borrower;\r\n        address lender;\r\n        address arbiter;\r\n        uint256 createdAt;\r\n        uint256 loanExpiration;\r\n        uint256 requestTimestamp;\r\n        uint256 closedTimestamp;\r\n        uint256 principal;\r\n        uint256 interest;\r\n        uint256 penalty;\r\n        uint256 fee;\r\n        uint256 liquidationRatio;\r\n    }\r\n\r\n    \r\n    struct PubKeys {\r\n        bytes   borrowerPubKey;\r\n        bytes   lenderPubKey;\r\n        bytes   arbiterPubKey;\r\n    }\r\n\r\n    \r\n    struct SecretHashes {\r\n        bytes32    secretHashA1;\r\n        bytes32[3] secretHashAs;\r\n        bytes32    secretHashB1;\r\n        bytes32[3] secretHashBs;\r\n        bytes32    secretHashC1;\r\n        bytes32[3] secretHashCs;\r\n        bytes32    withdrawSecret;\r\n        bytes32    acceptSecret;\r\n        bool       set;\r\n    }\r\n\r\n    \r\n    struct Bools {\r\n        bool funded;\r\n        bool approved;\r\n        bool withdrawn;\r\n        bool sale;\r\n        bool paid;\r\n        bool off;\r\n    }\r\n\r\n    event Create(bytes32 loan);\r\n\r\n    event SetSecretHashes(bytes32 loan);\r\n\r\n    event FundLoan(bytes32 loan);\r\n\r\n    event Approve(bytes32 loan);\r\n\r\n    event Withdraw(bytes32 loan, bytes32 secretA1);\r\n\r\n    event Repay(bytes32 loan, uint256 amount);\r\n\r\n    event Refund(bytes32 loan);\r\n\r\n    event Cancel(bytes32 loan, bytes32 secret);\r\n\r\n    event Accept(bytes32 loan, bytes32 secret);\r\n\r\n    event Liquidate(bytes32 loan, bytes32 secretHash, bytes20 pubKeyHash);\r\n\r\n    \r\n    function borrower(bytes32 loan) external view returns (address) {\r\n        return loans[loan].borrower;\r\n    }\r\n\r\n    \r\n    function lender(bytes32 loan) external view returns (address) {\r\n        return loans[loan].lender;\r\n    }\r\n\r\n    \r\n    function arbiter(bytes32 loan) external view returns (address) {\r\n        return loans[loan].arbiter;\r\n    }\r\n\r\n    \r\n    function approveExpiration(bytes32 loan) public view returns (uint256) { \r\n        return add(loans[loan].createdAt, APPROVE_EXP_THRESHOLD);\r\n    }\r\n\r\n    \r\n    function acceptExpiration(bytes32 loan) public view returns (uint256) { \r\n        return add(loans[loan].loanExpiration, ACCEPT_EXP_THRESHOLD);\r\n    }\r\n\r\n    \r\n    function liquidationExpiration(bytes32 loan) public view returns (uint256) { \r\n        return add(loans[loan].loanExpiration, LIQUIDATION_EXP_THRESHOLD);\r\n    }\r\n\r\n    \r\n    function seizureExpiration(bytes32 loan) public view returns (uint256) {\r\n        return add(liquidationExpiration(loan), SEIZURE_EXP_THRESHOLD);\r\n    }\r\n\r\n    \r\n    function principal(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].principal;\r\n    }\r\n\r\n    \r\n    function interest(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].interest;\r\n    }\r\n\r\n    \r\n    function fee(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].fee;\r\n    }\r\n\r\n    \r\n    function penalty(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].penalty;\r\n    }\r\n\r\n    \r\n    function collateral(bytes32 loan) public view returns (uint256) {\r\n        return col.collateral(loan);\r\n    }\r\n\r\n    \r\n    function refundableCollateral(bytes32 loan) external view returns (uint256) {\r\n        return col.refundableCollateral(loan);\r\n    }\r\n\r\n    \r\n    function seizableCollateral(bytes32 loan) external view returns (uint256) {\r\n        return col.seizableCollateral(loan);\r\n    }\r\n\r\n    \r\n    function temporaryRefundableCollateral(bytes32 loan) external view returns (uint256) {\r\n        return col.temporaryRefundableCollateral(loan);\r\n    }\r\n\r\n    \r\n    function temporarySeizableCollateral(bytes32 loan) external view returns (uint256) {\r\n        return col.temporarySeizableCollateral(loan);\r\n    }\r\n\r\n    \r\n    function repaid(bytes32 loan) public view returns (uint256) { \r\n        return repayments[loan];\r\n    }\r\n\r\n    \r\n    function liquidationRatio(bytes32 loan) public view returns (uint256) {\r\n        return loans[loan].liquidationRatio;\r\n    }\r\n\r\n    \r\n    function owedToLender(bytes32 loan) public view returns (uint256) { \r\n        return add(principal(loan), interest(loan));\r\n    }\r\n\r\n    \r\n    function owedForLoan(bytes32 loan) public view returns (uint256) { \r\n        return add(owedToLender(loan), fee(loan));\r\n    }\r\n\r\n    \r\n    function owedForLiquidation(bytes32 loan) external view returns (uint256) { \r\n        return add(owedForLoan(loan), penalty(loan));\r\n    }\r\n\r\n    \r\n    function owing(bytes32 loan) external view returns (uint256) {\r\n        return sub(owedForLoan(loan), repaid(loan));\r\n    }\r\n\r\n    \r\n    function funded(bytes32 loan) external view returns (bool) {\r\n        return bools[loan].funded;\r\n    }\r\n\r\n    \r\n    function approved(bytes32 loan) external view returns (bool) {\r\n        return bools[loan].approved;\r\n    }\r\n\r\n    \r\n    function withdrawn(bytes32 loan) external view returns (bool) {\r\n        return bools[loan].withdrawn;\r\n    }\r\n\r\n    \r\n    function sale(bytes32 loan) public view returns (bool) {\r\n        return bools[loan].sale;\r\n    }\r\n\r\n    \r\n    function paid(bytes32 loan) external view returns (bool) {\r\n        return bools[loan].paid;\r\n    }\r\n\r\n    \r\n    function off(bytes32 loan) public view returns (bool) {\r\n        return bools[loan].off;\r\n    }\r\n\r\n    \r\n    function dmul(uint x) public view returns (uint256) {\r\n        return mul(x, (10 ** sub(18, decimals)));\r\n    }\r\n\r\n    \r\n    function ddiv(uint x) public view returns (uint256) {\r\n        return div(x, (10 ** sub(18, decimals)));\r\n    }\r\n\r\n    \r\n    function borrowerLoanCount(address borrower_) external view returns (uint256) {\r\n        return borrowerLoans[borrower_].length;\r\n    }\r\n\r\n    \r\n    function lenderLoanCount(address lender_) external view returns (uint256) {\r\n        return lenderLoans[lender_].length;\r\n    }\r\n\r\n    \r\n    function minSeizableCollateral(bytes32 loan) public view returns (uint256) {\r\n        (bytes32 val, bool set) = med.peek();\r\n        require(set, \"Loans.minSeizableCollateral: Medianizer must be set\");\r\n        uint256 price = uint(val);\r\n        return div(wdiv(dmul(sub(owedForLoan(loan), repaid(loan))), price), div(WAD, COL));\r\n    }\r\n\r\n    \r\n    function collateralValue(bytes32 loan) public view returns (uint256) {\r\n        (bytes32 val, bool set) = med.peek();\r\n        require(set, \"Loans.collateralValue: Medianizer must be set\");\r\n        uint256 price = uint(val);\r\n        return cmul(price, collateral(loan));\r\n    }\r\n\r\n    \r\n    function minCollateralValue(bytes32 loan) public view returns (uint256) {\r\n        return rmul(dmul(sub(owedForLoan(loan), repaid(loan))), liquidationRatio(loan));\r\n    }\r\n\r\n    \r\n    function discountCollateralValue(bytes32 loan) public view returns (uint256) {\r\n        return wmul(collateralValue(loan), LIQUIDATION_DISCOUNT);\r\n    }\r\n\r\n    \r\n    function safe(bytes32 loan) public view returns (bool) {\r\n        return collateralValue(loan) >= minCollateralValue(loan);\r\n    }\r\n\r\n    \r\n    constructor (FundsInterface funds_, Medianizer med_, ERC20 token_, uint256 decimals_) public {\r\n        require(address(funds_) != address(0), \"Funds address must be non-zero\");\r\n        require(address(med_) != address(0), \"Medianizer address must be non-zero\");\r\n        require(address(token_) != address(0), \"Token address must be non-zero\");\r\n\r\n        deployer = msg.sender;\r\n        funds = funds_;\r\n        med = med_;\r\n        token = token_;\r\n        decimals = decimals_;\r\n        require(token.approve(address(funds), MAX_UINT_256), \"Token approve failed\");\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n    function setSales(SalesInterface sales_) external {\r\n        require(msg.sender == deployer, \"Loans.setSales: Only the deployer can perform this\");\r\n        require(address(sales) == address(0), \"Loans.setSales: The Sales address has already been set\");\r\n        require(address(sales_) != address(0), \"Loans.setSales: Sales address must be non-zero\");\r\n        sales = sales_;\r\n    }\r\n\r\n    \r\n    function setCollateral(CollateralInterface col_) external {\r\n        require(msg.sender == deployer, \"Loans.setCollateral: Only the deployer can perform this\");\r\n        require(address(col) == address(0), \"Loans.setCollateral: The Collateral address has already been set\");\r\n        require(address(col_) != address(0), \"Loans.setCollateral: Collateral address must be non-zero\");\r\n        col = col_;\r\n    }\r\n    \r\n\r\n    \r\n    function create(\r\n        uint256             loanExpiration_,\r\n        address[3] calldata usrs_,\r\n        uint256[7] calldata vals_,\r\n        bytes32             fund\r\n    ) external returns (bytes32 loan) {\r\n        if (fund != bytes32(0)) {\r\n            require(funds.lender(fund) == usrs_[1], \"Loans.create: Lender of Fund not in args\");\r\n        }\r\n        require(!addressToTimestamp[usrs_[0]][vals_[6]], \"Loans.create: Duplicate request timestamps are not allowed\");\r\n        require(loanExpiration_ > now, \"Loans.create: loanExpiration must be greater than `now`\");\r\n        require(usrs_[0] != address(0) && usrs_[1] != address(0), \"Loans.create: Borrower and Lender address must be non-zero\");\r\n        require(vals_[0] != 0 && vals_[4] != 0, \"Loans.create: Principal and Collateral must be non-zero\");\r\n        require(vals_[5] != 0 && vals_[6] != 0, \"Loans.create: Liquidation ratio and Request timestamp must be non-zero\");\r\n\r\n        loanIndex = add(loanIndex, 1);\r\n        loan = bytes32(loanIndex);\r\n        loans[loan].createdAt = now;\r\n        loans[loan].loanExpiration = loanExpiration_;\r\n        loans[loan].borrower = usrs_[0];\r\n        loans[loan].lender = usrs_[1];\r\n        loans[loan].arbiter = usrs_[2];\r\n        loans[loan].principal = vals_[0];\r\n        loans[loan].interest = vals_[1];\r\n        loans[loan].penalty = vals_[2];\r\n        loans[loan].fee = vals_[3];\r\n        uint256 minSeizableCol = minSeizableCollateral(loan);\r\n        col.setCollateral(loan, sub(vals_[4], minSeizableCol), minSeizableCol);\r\n        loans[loan].liquidationRatio = vals_[5];\r\n        loans[loan].requestTimestamp = vals_[6];\r\n        fundIndex[loan] = fund;\r\n        secretHashes[loan].set = false;\r\n        borrowerLoans[usrs_[0]].push(bytes32(loanIndex));\r\n        lenderLoans[usrs_[1]].push(bytes32(loanIndex));\r\n        addressToTimestamp[usrs_[0]][vals_[6]] = true;\r\n\r\n        emit Create(loan);\r\n    }\r\n\r\n    \r\n    function setSecretHashes(\r\n        bytes32             loan,\r\n        bytes32[4] calldata borrowerSecretHashes,\r\n        bytes32[4] calldata lenderSecretHashes,\r\n        bytes32[4] calldata arbiterSecretHashes,\r\n        bytes      calldata borrowerPubKey_,\r\n        bytes      calldata lenderPubKey_,\r\n        bytes      calldata arbiterPubKey_\r\n    ) external {\r\n        require(!secretHashes[loan].set, \"Loans.setSecretHashes: Secret hashes must not already be set\");\r\n        require(\r\n            msg.sender == loans[loan].borrower || msg.sender == loans[loan].lender || msg.sender == address(funds),\r\n            \"Loans.setSecretHashes: msg.sender must be Borrower, Lender or Funds Address\"\r\n        );\r\n        secretHashes[loan].secretHashA1 = borrowerSecretHashes[0];\r\n        secretHashes[loan].secretHashAs = [ borrowerSecretHashes[1], borrowerSecretHashes[2], borrowerSecretHashes[3] ];\r\n        secretHashes[loan].secretHashB1 = lenderSecretHashes[0];\r\n        secretHashes[loan].secretHashBs = [ lenderSecretHashes[1], lenderSecretHashes[2], lenderSecretHashes[3] ];\r\n        secretHashes[loan].secretHashC1 = arbiterSecretHashes[0];\r\n        secretHashes[loan].secretHashCs = [ arbiterSecretHashes[1], arbiterSecretHashes[2], arbiterSecretHashes[3] ];\r\n        pubKeys[loan].borrowerPubKey = borrowerPubKey_;\r\n        pubKeys[loan].lenderPubKey = lenderPubKey_;\r\n        pubKeys[loan].arbiterPubKey = arbiterPubKey_;\r\n        secretHashes[loan].set = true;\r\n    }\r\n\r\n    \r\n    function fund(bytes32 loan) external {\r\n        require(secretHashes[loan].set, \"Loans.fund: Secret hashes must be set\");\r\n        require(bools[loan].funded == false, \"Loans.fund: Loan is already funded\");\r\n        bools[loan].funded = true;\r\n        require(token.transferFrom(msg.sender, address(this), principal(loan)), \"Loans.fund: Failed to transfer tokens\");\r\n\r\n        emit FundLoan(loan);\r\n    }\r\n\r\n    \r\n    function approve(bytes32 loan) external { \r\n    \trequire(bools[loan].funded == true, \"Loans.approve: Loan must be funded\");\r\n    \trequire(loans[loan].lender == msg.sender, \"Loans.approve: Only the lender can approve the loan\");\r\n        require(now <= approveExpiration(loan), \"Loans.approve: Loan is past the approve deadline\");\r\n    \tbools[loan].approved = true;\r\n\r\n        emit Approve(loan);\r\n    }\r\n\r\n    \r\n    function withdraw(bytes32 loan, bytes32 secretA1) external {\r\n        require(!off(loan), \"Loans.withdraw: Loan cannot be inactive\");\r\n        require(bools[loan].funded == true, \"Loans.withdraw: Loan must be funded\");\r\n        require(bools[loan].approved == true, \"Loans.withdraw: Loan must be approved\");\r\n        require(bools[loan].withdrawn == false, \"Loans.withdraw: Loan principal has already been withdrawn\");\r\n        require(sha256(abi.encodePacked(secretA1)) == secretHashes[loan].secretHashA1, \"Loans.withdraw: Secret does not match\");\r\n        bools[loan].withdrawn = true;\r\n        require(token.transfer(loans[loan].borrower, principal(loan)), \"Loans.withdraw: Failed to transfer tokens\");\r\n\r\n        secretHashes[loan].withdrawSecret = secretA1;\r\n        if (address(col.onDemandSpv()) != address(0)) {col.requestSpv(loan);}\r\n\r\n        emit Withdraw(loan, secretA1);\r\n    }\r\n\r\n    \r\n    function repay(bytes32 loan, uint256 amount) external {\r\n        require(!off(loan), \"Loans.repay: Loan cannot be inactive\");\r\n        require(!sale(loan), \"Loans.repay: Loan cannot be undergoing a liquidation\");\r\n        require(bools[loan].withdrawn == true, \"Loans.repay: Loan principal must be withdrawn\");\r\n        require(now <= loans[loan].loanExpiration, \"Loans.repay: Loan cannot have expired\");\r\n        require(add(amount, repaid(loan)) <= owedForLoan(loan), \"Loans.repay: Cannot repay more than the owed amount\");\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"Loans.repay: Failed to transfer tokens\");\r\n        repayments[loan] = add(amount, repayments[loan]);\r\n        if (repaid(loan) == owedForLoan(loan)) {\r\n            bools[loan].paid = true;\r\n            if (address(col.onDemandSpv()) != address(0)) {col.cancelSpv(loan);}\r\n        }\r\n\r\n        emit Repay(loan, amount);\r\n    }\r\n\r\n    \r\n    function refund(bytes32 loan) external {\r\n        require(!off(loan), \"Loans.refund: Loan cannot be inactive\");\r\n        require(!sale(loan), \"Loans.refund: Loan cannot be undergoing a liquidation\");\r\n        require(now > acceptExpiration(loan), \"Loans.refund: Cannot request refund until after acceptExpiration\");\r\n        require(bools[loan].paid == true, \"Loans.refund: The loan must be repaid\");\r\n        require(msg.sender == loans[loan].borrower, \"Loans.refund: Only the borrower can request a refund\");\r\n        bools[loan].off = true;\r\n        loans[loan].closedTimestamp = now;\r\n        if (funds.custom(fundIndex[loan]) == false) {\r\n            funds.decreaseTotalBorrow(loans[loan].principal);\r\n            funds.calcGlobalInterest();\r\n        }\r\n        require(token.transfer(loans[loan].borrower, owedForLoan(loan)), \"Loans.refund: Failed to transfer tokens\");\r\n\r\n        emit Refund(loan);\r\n    }\r\n\r\n    \r\n    function cancel(bytes32 loan, bytes32 secret) external {\r\n        accept(loan, secret);\r\n\r\n        emit Cancel(loan, secret);\r\n    }\r\n\r\n    \r\n    function cancel(bytes32 loan) external {\r\n        require(!off(loan), \"Loans.cancel: Loan must not be inactive\");\r\n        require(bools[loan].withdrawn == false, \"Loans.cancel: Loan principal must not be withdrawn\");\r\n        require(now >= seizureExpiration(loan), \"Loans.cancel: Seizure deadline has not been reached\");\r\n        require(bools[loan].sale == false, \"Loans.cancel: Loan must not be undergoing liquidation\");\r\n        close(loan);\r\n\r\n        emit Cancel(loan, bytes32(0));\r\n    }\r\n\r\n    \r\n    function accept(bytes32 loan, bytes32 secret) public {\r\n        require(!off(loan), \"Loans.accept: Loan must not be inactive\");\r\n        require(bools[loan].withdrawn == false || bools[loan].paid == true, \"Loans.accept: Loan must be either not withdrawn or repaid\");\r\n        require(msg.sender == loans[loan].lender || msg.sender == loans[loan].arbiter, \"Loans.accept: msg.sender must be lender or arbiter\");\r\n        require(now <= acceptExpiration(loan), \"Loans.accept: Acceptance deadline has past\");\r\n        require(bools[loan].sale == false, \"Loans.accept: Loan must not be going under liquidation\");\r\n        require(\r\n            sha256(abi.encodePacked(secret)) == secretHashes[loan].secretHashB1 || sha256(abi.encodePacked(secret)) == secretHashes[loan].secretHashC1,\r\n            \"Loans.accept: Invalid secret\"\r\n        );\r\n        secretHashes[loan].acceptSecret = secret;\r\n        close(loan);\r\n\r\n        emit Accept(loan, secret);\r\n    }\r\n\r\n    \r\n    function close(bytes32 loan) private {\r\n        bools[loan].off = true;\r\n        loans[loan].closedTimestamp = now;\r\n        \r\n        if (bools[loan].withdrawn == false) {\r\n            if (fundIndex[loan] == bytes32(0)) {\r\n                require(token.transfer(loans[loan].lender, loans[loan].principal), \"Loans.close: Failed to transfer principal to Lender\");\r\n            } else {\r\n                if (funds.custom(fundIndex[loan]) == false) {\r\n                    funds.decreaseTotalBorrow(loans[loan].principal);\r\n                }\r\n                funds.deposit(fundIndex[loan], loans[loan].principal);\r\n            }\r\n        }\r\n        \r\n        else {\r\n            if (fundIndex[loan] == bytes32(0)) {\r\n                require(token.transfer(loans[loan].lender, owedToLender(loan)), \"Loans.close: Failed to transfer owedToLender to Lender\");\r\n            } else {\r\n                if (funds.custom(fundIndex[loan]) == false) {\r\n                    funds.decreaseTotalBorrow(loans[loan].principal);\r\n                }\r\n                funds.deposit(fundIndex[loan], owedToLender(loan));\r\n            }\r\n            require(token.transfer(loans[loan].arbiter, fee(loan)), \"Loans.close: Failed to transfer fee to Arbiter\");\r\n        }\r\n    }\r\n\r\n    \r\n    function liquidate(bytes32 loan, bytes32 secretHash, bytes20 pubKeyHash) external returns (bytes32 sale_) {\r\n        require(!off(loan), \"Loans.liquidate: Loan must not be inactive\");\r\n        require(bools[loan].withdrawn == true, \"Loans.liquidate: Loan principal must be withdrawn\");\r\n        require(msg.sender != loans[loan].borrower && msg.sender != loans[loan].lender, \"Loans.liquidate: Liquidator must be a third-party\");\r\n        require(secretHash != bytes32(0) && pubKeyHash != bytes20(0), \"Loans.liquidate: secretHash and pubKeyHash must be non-zero\");\r\n        \r\n        if (sales.next(loan) == 0) {\r\n            \r\n            if (now > loans[loan].loanExpiration) {\r\n                require(bools[loan].paid == false, \"Loans.liquidate: loan must not have already been repaid\");\r\n            } else {\r\n                require(!safe(loan), \"Loans.liquidate: collateralization must be below min-collateralization ratio\");\r\n            }\r\n            \r\n            if (funds.custom(fundIndex[loan]) == false) {\r\n                funds.decreaseTotalBorrow(loans[loan].principal);\r\n                funds.calcGlobalInterest();\r\n            }\r\n        } else {\r\n            \r\n            require(sales.next(loan) < MAX_NUM_LIQUIDATIONS, \"Loans.liquidate: Max number of liquidations reached\");\r\n            require(!sales.accepted(sales.saleIndexByLoan(loan, sales.next(loan) - 1)), \"Loans.liquidate: Previous liquidation already accepted\");\r\n            require(\r\n                now > sales.settlementExpiration(sales.saleIndexByLoan(loan, sales.next(loan) - 1)),\r\n                \"Loans.liquidate: Previous liquidation settlement expiration hasn't expired\"\r\n            );\r\n        }\r\n        require(token.balanceOf(msg.sender) >= ddiv(discountCollateralValue(loan)), \"Loans.liquidate: insufficient balance to liquidate\");\r\n        require(token.transferFrom(msg.sender, address(sales), ddiv(discountCollateralValue(loan))), \"Loans.liquidate: Token transfer failed\");\r\n        SecretHashes storage h = secretHashes[loan];\r\n        uint256 i = sales.next(loan);\r\n        \r\n        sale_ = sales.create(\r\n            loan, loans[loan].borrower, loans[loan].lender, loans[loan].arbiter, msg.sender,\r\n            h.secretHashAs[i], h.secretHashBs[i], h.secretHashCs[i], secretHash, pubKeyHash\r\n        );\r\n        if (bools[loan].sale == false) {\r\n            bools[loan].sale = true;\r\n            require(token.transfer(address(sales), repaid(loan)), \"Loans.liquidate: Token transfer to Sales contract failed\");\r\n        }\r\n        \r\n        if (address(col.onDemandSpv()) != address(0)) {col.cancelSpv(loan);}\r\n\r\n        emit Liquidate(loan, secretHash, pubKeyHash);\r\n    }\r\n}\r\n\r\ninterface CTokenInterface {\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalReserves() external view returns (uint);\r\n    function reserveFactorMantissa() external view returns (uint);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface CERC20Interface {\r\n    function mint(uint mintAmount) external returns (uint); \r\n    function repayBorrow(uint repayAmount) external returns (uint); \r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); \r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\ninterface ERC20Interface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface TrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n}\r\n\r\ncontract Helpers is DSMath {\r\n\r\n    address public comptroller;\r\n\r\n    \r\n    function getComptrollerAddress() public view returns (address) {\r\n        \r\n        \r\n        \r\n        return comptroller;\r\n    }\r\n\r\n    function enterMarket(address cErc20) internal {\r\n        TrollerInterface troller = TrollerInterface(getComptrollerAddress());\r\n        address[] memory markets = troller.getAssetsIn(address(this));\r\n        bool isEntered = false;\r\n        for (uint i = 0; i < markets.length; i++) {\r\n            if (markets[i] == cErc20) {\r\n                isEntered = true;\r\n            }\r\n        }\r\n        if (!isEntered) {\r\n            address[] memory toEnter = new address[](1);\r\n            toEnter[0] = cErc20;\r\n            troller.enterMarkets(toEnter);\r\n        }\r\n    }\r\n\r\n    \r\n    function setApproval(address erc20, uint srcAmt, address to) internal {\r\n        ERC20Interface erc20Contract = ERC20Interface(erc20);\r\n        uint tokenAllowance = erc20Contract.allowance(address(this), to);\r\n        if (srcAmt > tokenAllowance) {\r\n            erc20Contract.approve(to, 2**255);\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract ALCompound is Helpers {\r\n    \r\n    function mintCToken(address erc20, address cErc20, uint tokenAmt) internal {\r\n        enterMarket(cErc20);\r\n        ERC20Interface token = ERC20Interface(erc20);\r\n        uint toDeposit = token.balanceOf(address(this));\r\n        if (toDeposit > tokenAmt) {\r\n            toDeposit = tokenAmt;\r\n        }\r\n        CERC20Interface cToken = CERC20Interface(cErc20);\r\n        setApproval(erc20, toDeposit, cErc20);\r\n        assert(cToken.mint(toDeposit) == 0);\r\n    }\r\n\r\n    \r\n    function redeemUnderlying(address cErc20, uint tokenAmt) internal {\r\n        CTokenInterface cToken = CTokenInterface(cErc20);\r\n        setApproval(cErc20, 10**50, cErc20);\r\n        uint toBurn = cToken.balanceOf(address(this));\r\n        uint tokenToReturn = wmul(toBurn, cToken.exchangeRateCurrent());\r\n        if (tokenToReturn > tokenAmt) {\r\n            tokenToReturn = tokenAmt;\r\n        }\r\n        require(cToken.redeemUnderlying(tokenToReturn) == 0, \"something went wrong\");\r\n    }\r\n\r\n    \r\n    function redeemCToken(address cErc20, uint cTokenAmt) internal {\r\n        CTokenInterface cToken = CTokenInterface(cErc20);\r\n        uint toBurn = cToken.balanceOf(address(this));\r\n        if (toBurn > cTokenAmt) {\r\n            toBurn = cTokenAmt;\r\n        }\r\n        setApproval(cErc20, toBurn, cErc20);\r\n        require(cToken.redeem(toBurn) == 0, \"something went wrong\");\r\n    }\r\n}\r\n\r\ncontract Funds is DSMath, ALCompound {\r\n    Loans loans;\r\n\r\n    uint256 public constant DEFAULT_LIQUIDATION_RATIO = 1400000000000000000000000000;   \r\n    uint256 public constant DEFAULT_LIQUIDATION_PENALTY = 1000000000937303470807876289; \r\n    uint256 public constant DEFAULT_MIN_LOAN_AMT = 25 ether; \r\n    uint256 public constant DEFAULT_MAX_LOAN_AMT = 2**256-1; \r\n    uint256 public constant DEFAULT_MIN_LOAN_DUR = 6 hours;  \r\n    uint256 public constant NUM_SECONDS_IN_YEAR = 365 days;\r\n    uint256 public constant MAX_LOAN_LENGTH = 10 * NUM_SECONDS_IN_YEAR;\r\n    uint256 public constant MAX_UINT_256 = 2**256-1;\r\n\r\n    mapping (address => bytes32[]) public secretHashes;    \r\n    mapping (address => uint256)   public secretHashIndex; \r\n\r\n    mapping (address => bytes)     public pubKeys;  \r\n\r\n    mapping (bytes32 => Fund)      public funds;\r\n    mapping (address => bytes32)   public fundOwner;\r\n    mapping (bytes32 => Bools)     public bools;\r\n    uint256                        public fundIndex;\r\n\r\n    uint256 public lastGlobalInterestUpdated;\r\n    uint256 public tokenMarketLiquidity;\r\n    uint256 public cTokenMarketLiquidity;\r\n    uint256 public marketLiquidity;\r\n    uint256 public totalBorrow;\r\n    uint256 public globalInterestRateNumerator;\r\n    uint256 public lastUtilizationRatio;\r\n    uint256 public globalInterestRate;\r\n    uint256 public maxUtilizationDelta;\r\n    uint256 public utilizationInterestDivisor;\r\n    uint256 public maxInterestRateNumerator;\r\n    uint256 public minInterestRateNumerator;\r\n    uint256 public interestUpdateDelay;\r\n    uint256 public defaultArbiterFee;\r\n\r\n    ERC20 public token;\r\n    uint256 public decimals;\r\n    CTokenInterface public cToken;\r\n    bool compoundSet;\r\n\r\n    address deployer;\r\n\r\n    \r\n    struct Fund {\r\n        address  lender;\r\n        uint256  minLoanAmt;\r\n        uint256  maxLoanAmt;\r\n        uint256  minLoanDur;\r\n        uint256  maxLoanDur;\r\n        uint256  fundExpiry;\r\n        uint256  interest;\r\n        uint256  penalty;\r\n        uint256  fee;\r\n        uint256  liquidationRatio;\r\n        address  arbiter;\r\n        uint256  balance;\r\n        uint256  cBalance;\r\n    }\r\n\r\n    \r\n    struct Bools {\r\n        bool     custom;\r\n        bool     compoundEnabled;\r\n    }\r\n\r\n    event Create(bytes32 fund);\r\n\r\n    event Deposit(bytes32 fund, uint256 amount_);\r\n\r\n    event Update(bytes32  fund, uint256  maxLoanDur_, uint256  fundExpiry_, address  arbiter_);\r\n\r\n    event Request(bytes32 fund, address borrower_, uint256 amount_, uint256 collateral_, uint256 loanDur_, uint256 requestTimestamp_);\r\n\r\n    event Withdraw(bytes32 fund, uint256 amount_, address recipient_);\r\n\r\n    event EnableCompound(bytes32 fund);\r\n\r\n    event DisableCompound(bytes32 fund);\r\n\r\n    \r\n    \r\n    constructor(\r\n        ERC20   token_,\r\n        uint256 decimals_\r\n    ) public {\r\n        require(address(token_) != address(0), \"Funds.constructor: Token address must be non-zero\");\r\n        require(decimals_ != 0, \"Funds.constructor: Decimals must be non-zero\");\r\n\r\n        deployer = msg.sender;\r\n        token = token_;\r\n        decimals = decimals_;\r\n        utilizationInterestDivisor = 10531702972595856680093239305; \r\n        maxUtilizationDelta = 95310179948351216961192521; \r\n        globalInterestRateNumerator = 95310179948351216961192521; \r\n        maxInterestRateNumerator = 182321557320989604265864303; \r\n        minInterestRateNumerator = 24692612600038629323181834; \r\n        interestUpdateDelay = 86400; \r\n        defaultArbiterFee = 1000000000236936036262880196; \r\n        globalInterestRate = add(RAY, div(globalInterestRateNumerator, NUM_SECONDS_IN_YEAR)); \r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n    function setLoans(Loans loans_) external {\r\n        require(msg.sender == deployer, \"Funds.setLoans: Only the deployer can perform this\");\r\n        require(address(loans) == address(0), \"Funds.setLoans: Loans address has already been set\");\r\n        require(address(loans_) != address(0), \"Funds.setLoans: Loans address must be non-zero\");\r\n        loans = loans_;\r\n        require(token.approve(address(loans_), MAX_UINT_256), \"Funds.setLoans: Tokens cannot be approved\");\r\n    }\r\n\r\n    \r\n    function setCompound(CTokenInterface cToken_, address comptroller_) external {\r\n        require(msg.sender == deployer, \"Funds.setCompound: Only the deployer can enable Compound lending\");\r\n        require(!compoundSet, \"Funds.setCompound: Compound address has already been set\");\r\n        require(address(cToken_) != address(0), \"Funds.setCompound: cToken address must be non-zero\");\r\n        require(comptroller_ != address(0), \"Funds.setCompound: comptroller address must be non-zero\");\r\n        cToken = cToken_;\r\n        comptroller = comptroller_;\r\n        compoundSet = true;\r\n    }\r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n    function setUtilizationInterestDivisor(uint256 utilizationInterestDivisor_) external {\r\n        require(msg.sender == deployer, \"Funds.setUtilizationInterestDivisor: Only the deployer can perform this\");\r\n        require(utilizationInterestDivisor_ != 0, \"Funds.setUtilizationInterestDivisor: utilizationInterestDivisor is zero\");\r\n        utilizationInterestDivisor = utilizationInterestDivisor_;\r\n    }\r\n\r\n    \r\n    function setMaxUtilizationDelta(uint256 maxUtilizationDelta_) external {\r\n        require(msg.sender == deployer, \"Funds.setMaxUtilizationDelta: Only the deployer can perform this\");\r\n        require(maxUtilizationDelta_ != 0, \"Funds.setMaxUtilizationDelta: maxUtilizationDelta is zero\");\r\n        maxUtilizationDelta = maxUtilizationDelta_;\r\n    }\r\n\r\n    \r\n    function setGlobalInterestRateNumerator(uint256 globalInterestRateNumerator_) external {\r\n        require(msg.sender == deployer, \"Funds.setGlobalInterestRateNumerator: Only the deployer can perform this\");\r\n        require(globalInterestRateNumerator_ != 0, \"Funds.setGlobalInterestRateNumerator: globalInterestRateNumerator is zero\");\r\n        globalInterestRateNumerator = globalInterestRateNumerator_;\r\n    }\r\n\r\n    \r\n    function setGlobalInterestRate(uint256 globalInterestRate_) external {\r\n        require(msg.sender == deployer, \"Funds.setGlobalInterestRate: Only the deployer can perform this\");\r\n        require(globalInterestRate_ != 0, \"Funds.setGlobalInterestRate: globalInterestRate is zero\");\r\n        globalInterestRate = globalInterestRate_;\r\n    }\r\n\r\n    \r\n    function setMaxInterestRateNumerator(uint256 maxInterestRateNumerator_) external {\r\n        require(msg.sender == deployer, \"Funds.setMaxInterestRateNumerator: Only the deployer can perform this\");\r\n        require(maxInterestRateNumerator_ != 0, \"Funds.setMaxInterestRateNumerator: maxInterestRateNumerator is zero\");\r\n        maxInterestRateNumerator = maxInterestRateNumerator_;\r\n    }\r\n\r\n    \r\n    function setMinInterestRateNumerator(uint256 minInterestRateNumerator_) external {\r\n        require(msg.sender == deployer, \"Funds.setMinInterestRateNumerator: Only the deployer can perform this\");\r\n        require(minInterestRateNumerator_ != 0, \"Funds.setMinInterestRateNumerator: minInterestRateNumerator is zero\");\r\n        minInterestRateNumerator = minInterestRateNumerator_;\r\n    }\r\n\r\n    \r\n    function setInterestUpdateDelay(uint256 interestUpdateDelay_) external {\r\n        require(msg.sender == deployer, \"Funds.setInterestUpdateDelay: Only the deployer can perform this\");\r\n        require(interestUpdateDelay_ != 0, \"Funds.setInterestUpdateDelay: interestUpdateDelay is zero\");\r\n        interestUpdateDelay = interestUpdateDelay_;\r\n    }\r\n\r\n    \r\n    function setDefaultArbiterFee(uint256 defaultArbiterFee_) external {\r\n        require(msg.sender == deployer, \"Funds.setDefaultArbiterFee: Only the deployer can perform this\");\r\n        require(defaultArbiterFee_ <= 1000000000315522921573372069, \"Funds.setDefaultArbiterFee: defaultArbiterFee cannot be less than -1%\"); \r\n        defaultArbiterFee = defaultArbiterFee_;\r\n    }\r\n    \r\n\r\n    \r\n    function lender(bytes32 fund) public view returns (address) {\r\n        return funds[fund].lender;\r\n    }\r\n\r\n    \r\n    function minLoanAmt(bytes32 fund) public view returns (uint256) {\r\n        if (bools[fund].custom) {return funds[fund].minLoanAmt;}\r\n        else                    {return div(DEFAULT_MIN_LOAN_AMT, (10 ** sub(18, decimals)));}\r\n    }\r\n\r\n    \r\n    function maxLoanAmt(bytes32 fund) public view returns (uint256) {\r\n        if (bools[fund].custom) {return funds[fund].maxLoanAmt;}\r\n        else                    {return DEFAULT_MAX_LOAN_AMT;}\r\n    }\r\n\r\n    \r\n    function minLoanDur(bytes32 fund) public view returns (uint256) {\r\n        if (bools[fund].custom) {return funds[fund].minLoanDur;}\r\n        else                    {return DEFAULT_MIN_LOAN_DUR;}\r\n    }\r\n\r\n    \r\n    function maxLoanDur(bytes32 fund) public view returns (uint256) {\r\n        return funds[fund].maxLoanDur;\r\n    }\r\n\r\n    \r\n    function fundExpiry(bytes32 fund) public view returns (uint256) {\r\n        return funds[fund].fundExpiry;\r\n    }\r\n\r\n    \r\n    function interest(bytes32 fund) public view returns (uint256) {\r\n        if (bools[fund].custom) {return funds[fund].interest;}\r\n        else                    {return globalInterestRate;}\r\n    }\r\n\r\n    \r\n    function penalty(bytes32 fund) public view returns (uint256) {\r\n        if (bools[fund].custom) {return funds[fund].penalty;}\r\n        else                    {return DEFAULT_LIQUIDATION_PENALTY;}\r\n    }\r\n\r\n    \r\n    function fee(bytes32 fund) public view returns (uint256) {\r\n        if (bools[fund].custom) {return funds[fund].fee;}\r\n        else                    {return defaultArbiterFee;}\r\n    }\r\n\r\n    \r\n    function liquidationRatio(bytes32 fund) public view returns (uint256) {\r\n        if (bools[fund].custom) {return funds[fund].liquidationRatio;}\r\n        else                    {return DEFAULT_LIQUIDATION_RATIO;}\r\n    }\r\n\r\n    \r\n    function arbiter(bytes32 fund) public view returns (address) {\r\n        return funds[fund].arbiter;\r\n    }\r\n\r\n    \r\n    function balance(bytes32 fund) public returns (uint256) {\r\n        if (bools[fund].compoundEnabled) {\r\n            return wmul(funds[fund].cBalance, cToken.exchangeRateCurrent());\r\n        } else {\r\n            return funds[fund].balance;\r\n        }\r\n    }\r\n\r\n    function cTokenExchangeRate() public returns (uint256) {\r\n        if (compoundSet) {\r\n            return cToken.exchangeRateCurrent();\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    \r\n    function custom(bytes32 fund) public view returns (bool) {\r\n        return bools[fund].custom;\r\n    }\r\n\r\n    \r\n    function secretHashesCount(address addr_) public view returns (uint256) {\r\n        return secretHashes[addr_].length;\r\n    }\r\n\r\n    \r\n    function create(\r\n        uint256  maxLoanDur_,\r\n        uint256  fundExpiry_,\r\n        address  arbiter_,\r\n        bool     compoundEnabled_,\r\n        uint256  amount_\r\n    ) external returns (bytes32 fund) {\r\n        \r\n        \r\n        \r\n        require(funds[fundOwner[msg.sender]].lender != msg.sender, \"Funds.create: Only one loan fund allowed per address\"); \r\n        \r\n        require(\r\n            ensureNotZero(maxLoanDur_, false) < MAX_LOAN_LENGTH && ensureNotZero(fundExpiry_, true) < now + MAX_LOAN_LENGTH,\r\n            \"Funds.create: fundExpiry and maxLoanDur cannot exceed 10 years\"\r\n        ); \r\n        if (!compoundSet) {require(compoundEnabled_ == false, \"Funds.create: Cannot enable Compound as it has not been configured\");}\r\n        fundIndex = add(fundIndex, 1);\r\n        fund = bytes32(fundIndex);\r\n        funds[fund].lender = msg.sender;\r\n        funds[fund].maxLoanDur = ensureNotZero(maxLoanDur_, false);\r\n        funds[fund].fundExpiry = ensureNotZero(fundExpiry_, true);\r\n        funds[fund].arbiter = arbiter_;\r\n        bools[fund].custom = false;\r\n        bools[fund].compoundEnabled = compoundEnabled_;\r\n        fundOwner[msg.sender] = bytes32(fundIndex);\r\n        if (amount_ > 0) {deposit(fund, amount_);}\r\n\r\n        emit Create(fund);\r\n    }\r\n\r\n    \r\n    function createCustom(\r\n        uint256  minLoanAmt_,\r\n        uint256  maxLoanAmt_,\r\n        uint256  minLoanDur_,\r\n        uint256  maxLoanDur_,\r\n        uint256  fundExpiry_,\r\n        uint256  liquidationRatio_,\r\n        uint256  interest_,\r\n        uint256  penalty_,\r\n        uint256  fee_,\r\n        address  arbiter_,\r\n        bool     compoundEnabled_,\r\n        uint256  amount_\r\n    ) external returns (bytes32 fund) {\r\n        \r\n        \r\n        \r\n        require(funds[fundOwner[msg.sender]].lender != msg.sender, \"Funds.create: Only one loan fund allowed per address\"); \r\n        \r\n        require(\r\n            ensureNotZero(maxLoanDur_, false) < MAX_LOAN_LENGTH && ensureNotZero(fundExpiry_, true) < now + MAX_LOAN_LENGTH,\r\n            \"Funds.createCustom: fundExpiry and maxLoanDur cannot exceed 10 years\"\r\n        ); \r\n        require(maxLoanAmt_ >= minLoanAmt_, \"Funds.createCustom: maxLoanAmt must be greater than or equal to minLoanAmt\");\r\n        require(ensureNotZero(maxLoanDur_, false) >= minLoanDur_, \"Funds.createCustom: maxLoanDur must be greater than or equal to minLoanDur\");\r\n\r\n        if (!compoundSet) {require(compoundEnabled_ == false, \"Funds.createCustom: Cannot enable Compound as it has not been configured\");}\r\n        fundIndex = add(fundIndex, 1);\r\n        fund = bytes32(fundIndex);\r\n        funds[fund].lender = msg.sender;\r\n        funds[fund].minLoanAmt = minLoanAmt_;\r\n        funds[fund].maxLoanAmt = maxLoanAmt_;\r\n        funds[fund].minLoanDur = minLoanDur_;\r\n        funds[fund].maxLoanDur = ensureNotZero(maxLoanDur_, false);\r\n        funds[fund].fundExpiry = ensureNotZero(fundExpiry_, true);\r\n        funds[fund].interest = interest_;\r\n        funds[fund].penalty = penalty_;\r\n        funds[fund].fee = fee_;\r\n        funds[fund].liquidationRatio = liquidationRatio_;\r\n        funds[fund].arbiter = arbiter_;\r\n        bools[fund].custom = true;\r\n        bools[fund].compoundEnabled = compoundEnabled_;\r\n        fundOwner[msg.sender] = bytes32(fundIndex);\r\n        if (amount_ > 0) {deposit(fund, amount_);}\r\n\r\n        emit Create(fund);\r\n    }\r\n\r\n    \r\n    function deposit(bytes32 fund, uint256 amount_) public {\r\n        require(token.transferFrom(msg.sender, address(this), amount_), \"Funds.deposit: Failed to transfer tokens\");\r\n        if (bools[fund].compoundEnabled) {\r\n            mintCToken(address(token), address(cToken), amount_);\r\n            uint256 cTokenToAdd = div(mul(amount_, WAD), cToken.exchangeRateCurrent());\r\n            funds[fund].cBalance = add(funds[fund].cBalance, cTokenToAdd);\r\n            if (!custom(fund)) {cTokenMarketLiquidity = add(cTokenMarketLiquidity, cTokenToAdd);}\r\n        } else {\r\n            funds[fund].balance = add(funds[fund].balance, amount_);\r\n            if (!custom(fund)) {tokenMarketLiquidity = add(tokenMarketLiquidity, amount_);}\r\n        }\r\n        if (!custom(fund)) {calcGlobalInterest();}\r\n\r\n        emit Deposit(fund, amount_);\r\n    }\r\n\r\n    \r\n    function update(\r\n        bytes32  fund,\r\n        uint256  maxLoanDur_,\r\n        uint256  fundExpiry_,\r\n        address  arbiter_\r\n    ) public {\r\n        require(msg.sender == lender(fund), \"Funds.update: Only the lender can update the fund\");\r\n        require(\r\n            ensureNotZero(maxLoanDur_, false) <= MAX_LOAN_LENGTH && ensureNotZero(fundExpiry_, true) <= now + MAX_LOAN_LENGTH,\r\n            \"Funds.update: fundExpiry and maxLoanDur cannot exceed 10 years\"\r\n        );  \r\n        funds[fund].maxLoanDur = maxLoanDur_;\r\n        funds[fund].fundExpiry = fundExpiry_;\r\n        funds[fund].arbiter = arbiter_;\r\n\r\n        emit Update(fund, maxLoanDur_, fundExpiry_, arbiter_);\r\n    }\r\n\r\n    \r\n    function updateCustom(\r\n        bytes32  fund,\r\n        uint256  minLoanAmt_,\r\n        uint256  maxLoanAmt_,\r\n        uint256  minLoanDur_,\r\n        uint256  maxLoanDur_,\r\n        uint256  fundExpiry_,\r\n        uint256  interest_,\r\n        uint256  penalty_,\r\n        uint256  fee_,\r\n        uint256  liquidationRatio_,\r\n        address  arbiter_\r\n    ) external {\r\n        require(bools[fund].custom, \"Funds.updateCustom: Fund must be a custom fund\");\r\n        require(maxLoanAmt_ >= minLoanAmt_, \"Funds.updateCustom: maxLoanAmt must be greater than or equal to minLoanAmt\");\r\n        require(ensureNotZero(maxLoanDur_, false) >= minLoanDur_, \"Funds.updateCustom: maxLoanDur must be greater than or equal to minLoanDur\");\r\n        update(fund, maxLoanDur_, fundExpiry_, arbiter_);\r\n        funds[fund].minLoanAmt = minLoanAmt_;\r\n        funds[fund].maxLoanAmt = maxLoanAmt_;\r\n        funds[fund].minLoanDur = minLoanDur_;\r\n        funds[fund].interest = interest_;\r\n        funds[fund].penalty = penalty_;\r\n        funds[fund].fee = fee_;\r\n        funds[fund].liquidationRatio = liquidationRatio_;\r\n    }\r\n\r\n    \r\n    function request(\r\n        bytes32             fund,\r\n        address             borrower_,\r\n        uint256             amount_,\r\n        uint256             collateral_,\r\n        uint256             loanDur_,\r\n        uint256             requestTimestamp_,\r\n        bytes32[8] calldata secretHashes_,\r\n        bytes      calldata pubKeyA_,\r\n        bytes      calldata pubKeyB_\r\n    ) external returns (bytes32 loanIndex) {\r\n        require(msg.sender == lender(fund), \"Funds.request: Only the lender can fulfill a loan request\");\r\n        require(amount_ <= balance(fund), \"Funds.request: Insufficient balance\");\r\n        require(amount_ >= minLoanAmt(fund), \"Funds.request: Amount requested must be greater than minLoanAmt\");\r\n        require(amount_ <= maxLoanAmt(fund), \"Funds.request: Amount requested must be less than maxLoanAmt\");\r\n        require(loanDur_ >= minLoanDur(fund), \"Funds.request: Loan duration must be greater than minLoanDur\");\r\n        require(loanDur_ <= sub(fundExpiry(fund), now) && loanDur_ <= maxLoanDur(fund), \"Funds.request: Loan duration must be less than maxLoanDur and expiry\");\r\n        require(borrower_ != address(0), \"Funds.request: Borrower address must be non-zero\");\r\n        require(secretHashes_[0] != bytes32(0) && secretHashes_[1] != bytes32(0), \"Funds.request: SecretHash1 & SecretHash2 should be non-zero\");\r\n        require(secretHashes_[2] != bytes32(0) && secretHashes_[3] != bytes32(0), \"Funds.request: SecretHash3 & SecretHash4 should be non-zero\");\r\n        require(secretHashes_[4] != bytes32(0) && secretHashes_[5] != bytes32(0), \"Funds.request: SecretHash5 & SecretHash6 should be non-zero\");\r\n        require(secretHashes_[6] != bytes32(0) && secretHashes_[7] != bytes32(0), \"Funds.request: SecretHash7 & SecretHash8 should be non-zero\");\r\n\r\n        loanIndex = createLoan(fund, borrower_, amount_, collateral_, loanDur_, requestTimestamp_);\r\n        loanSetSecretHashes(fund, loanIndex, secretHashes_, pubKeyA_, pubKeyB_);\r\n        loanUpdateMarketLiquidity(fund, amount_);\r\n        loans.fund(loanIndex);\r\n\r\n        emit Request(fund, borrower_, amount_, collateral_, loanDur_, requestTimestamp_);\r\n    }\r\n\r\n    \r\n    function withdraw(bytes32 fund, uint256 amount_) external {\r\n        withdrawTo(fund, amount_, msg.sender);\r\n    }\r\n\r\n    \r\n    function withdrawTo(bytes32 fund, uint256 amount_, address recipient_) public {\r\n        require(msg.sender == lender(fund), \"Funds.withdrawTo: Only the lender can withdraw tokens\");\r\n        require(balance(fund) >= amount_, \"Funds.withdrawTo: Insufficient balance\");\r\n        if (bools[fund].compoundEnabled) {\r\n            uint256 cBalanceBefore = cToken.balanceOf(address(this));\r\n            redeemUnderlying(address(cToken), amount_);\r\n            uint256 cBalanceAfter = cToken.balanceOf(address(this));\r\n            uint256 cTokenToRemove = sub(cBalanceBefore, cBalanceAfter);\r\n            funds[fund].cBalance = sub(funds[fund].cBalance, cTokenToRemove);\r\n            require(token.transfer(recipient_, amount_), \"Funds.withdrawTo: Token transfer failed\");\r\n            if (!custom(fund)) {cTokenMarketLiquidity = sub(cTokenMarketLiquidity, cTokenToRemove);}\r\n        } else {\r\n            funds[fund].balance = sub(funds[fund].balance, amount_);\r\n            require(token.transfer(recipient_, amount_), \"Funds.withdrawTo: Token transfer failed\");\r\n            if (!custom(fund)) {tokenMarketLiquidity = sub(tokenMarketLiquidity, amount_);}\r\n        }\r\n        if (!custom(fund)) {calcGlobalInterest();}\r\n\r\n        emit Withdraw(fund, amount_, recipient_);\r\n    }\r\n\r\n    \r\n    function generate(bytes32[] calldata secretHashes_) external {\r\n        for (uint i = 0; i < secretHashes_.length; i++) {\r\n            secretHashes[msg.sender].push(secretHashes_[i]);\r\n        }\r\n    }\r\n\r\n    \r\n    function setPubKey(bytes calldata pubKey_) external { \r\n        pubKeys[msg.sender] = pubKey_;\r\n    }\r\n\r\n    \r\n    function enableCompound(bytes32 fund) external {\r\n        require(compoundSet, \"Funds.enableCompound: Cannot enable Compound as it has not been configured\");\r\n        require(bools[fund].compoundEnabled == false, \"Funds.enableCompound: Compound is already enabled\");\r\n        require(msg.sender == lender(fund), \"Funds.enableCompound: Only the lender can enable Compound\");\r\n        uint256 cBalanceBefore = cToken.balanceOf(address(this));\r\n        mintCToken(address(token), address(cToken), funds[fund].balance);\r\n        uint256 cBalanceAfter = cToken.balanceOf(address(this));\r\n        uint256 cTokenToReturn = sub(cBalanceAfter, cBalanceBefore);\r\n        tokenMarketLiquidity = sub(tokenMarketLiquidity, funds[fund].balance);\r\n        cTokenMarketLiquidity = add(cTokenMarketLiquidity, cTokenToReturn);\r\n        bools[fund].compoundEnabled = true;\r\n        funds[fund].balance = 0;\r\n        funds[fund].cBalance = cTokenToReturn;\r\n\r\n        emit EnableCompound(fund);\r\n    }\r\n\r\n    \r\n    function disableCompound(bytes32 fund) external {\r\n        require(bools[fund].compoundEnabled, \"Funds.disableCompound: Compound is already disabled\");\r\n        require(msg.sender == lender(fund), \"Funds.disableCompound: Only the lender can disable Compound\");\r\n        uint256 balanceBefore = token.balanceOf(address(this));\r\n        redeemCToken(address(cToken), funds[fund].cBalance);\r\n        uint256 balanceAfter = token.balanceOf(address(this));\r\n        uint256 tokenToReturn = sub(balanceAfter, balanceBefore);\r\n        tokenMarketLiquidity = add(tokenMarketLiquidity, tokenToReturn);\r\n        cTokenMarketLiquidity = sub(cTokenMarketLiquidity, funds[fund].cBalance);\r\n        bools[fund].compoundEnabled = false;\r\n        funds[fund].cBalance = 0;\r\n        funds[fund].balance = tokenToReturn;\r\n\r\n        emit DisableCompound(fund);\r\n    }\r\n\r\n    \r\n    function decreaseTotalBorrow(uint256 amount_) external {\r\n        require(msg.sender == address(loans), \"Funds.decreaseTotalBorrow: Only the Loans contract can perform this\");\r\n        totalBorrow = sub(totalBorrow, amount_);\r\n    }\r\n\r\n    \r\n    function calcGlobalInterest() public {\r\n        marketLiquidity = add(tokenMarketLiquidity, wmul(cTokenMarketLiquidity, cTokenExchangeRate()));\r\n\r\n        if (now > (add(lastGlobalInterestUpdated, interestUpdateDelay))) {\r\n            uint256 utilizationRatio;\r\n            if (totalBorrow != 0) {utilizationRatio = rdiv(totalBorrow, add(marketLiquidity, totalBorrow));}\r\n\r\n            if (utilizationRatio > lastUtilizationRatio) {\r\n                uint256 changeUtilizationRatio = sub(utilizationRatio, lastUtilizationRatio);\r\n                globalInterestRateNumerator = min(maxInterestRateNumerator, add(globalInterestRateNumerator, rdiv(min(maxUtilizationDelta, changeUtilizationRatio), utilizationInterestDivisor)));\r\n            } else {\r\n                uint256 changeUtilizationRatio = sub(lastUtilizationRatio, utilizationRatio);\r\n                globalInterestRateNumerator = max(minInterestRateNumerator, sub(globalInterestRateNumerator, rdiv(min(maxUtilizationDelta, changeUtilizationRatio), utilizationInterestDivisor)));\r\n            }\r\n\r\n            globalInterestRate = add(RAY, div(globalInterestRateNumerator, NUM_SECONDS_IN_YEAR));\r\n\r\n            lastGlobalInterestUpdated = now;\r\n            lastUtilizationRatio = utilizationRatio;\r\n        }\r\n    }\r\n\r\n    \r\n    function calcInterest(uint256 amount_, uint256 rate_, uint256 loanDur_) public pure returns (uint256) {\r\n        return sub(rmul(amount_, rpow(rate_, loanDur_)), amount_);\r\n    }\r\n\r\n    \r\n    function ensureNotZero(uint256 value, bool addNow) public view returns (uint256) {\r\n        if (value == 0) {\r\n            if (addNow) {\r\n                return now + MAX_LOAN_LENGTH;\r\n            }\r\n            return MAX_LOAN_LENGTH;\r\n        }\r\n        return value;\r\n    }\r\n\r\n    \r\n    function createLoan(\r\n        bytes32  fund,\r\n        address  borrower_,\r\n        uint256  amount_,\r\n        uint256  collateral_,\r\n        uint256  loanDur_,\r\n        uint256  requestTimestamp_\r\n    ) private returns (bytes32 loanIndex) {\r\n        loanIndex = loans.create(\r\n            now + loanDur_,\r\n            [borrower_, lender(fund), funds[fund].arbiter],\r\n            [\r\n                amount_,\r\n                calcInterest(amount_, interest(fund), loanDur_),\r\n                calcInterest(amount_, penalty(fund), loanDur_),\r\n                calcInterest(amount_, fee(fund), loanDur_),\r\n                collateral_,\r\n                liquidationRatio(fund),\r\n                requestTimestamp_\r\n            ],\r\n            fund\r\n        );\r\n    }\r\n\r\n    \r\n    function loanSetSecretHashes(\r\n        bytes32           fund,\r\n        bytes32           loan,\r\n        bytes32[8] memory secretHashes_,\r\n        bytes      memory pubKeyA_,\r\n        bytes      memory pubKeyB_\r\n    ) private {\r\n        loans.setSecretHashes(\r\n            loan,\r\n            [ secretHashes_[0], secretHashes_[1], secretHashes_[2], secretHashes_[3] ],\r\n            [ secretHashes_[4], secretHashes_[5], secretHashes_[6], secretHashes_[7] ],\r\n            getSecretHashesForLoan(arbiter(fund)),\r\n            pubKeyA_,\r\n            pubKeyB_,\r\n            pubKeys[arbiter(fund)]\r\n        );\r\n    }\r\n\r\n    \r\n    function loanUpdateMarketLiquidity(bytes32 fund, uint256 amount_) private {\r\n        if (bools[fund].compoundEnabled) {\r\n            uint256 cBalanceBefore = cToken.balanceOf(address(this));\r\n            redeemUnderlying(address(cToken), amount_);\r\n            uint256 cBalanceAfter = cToken.balanceOf(address(this));\r\n            uint256 cTokenToRemove = sub(cBalanceBefore, cBalanceAfter);\r\n            funds[fund].cBalance = sub(funds[fund].cBalance, cTokenToRemove);\r\n            if (!custom(fund)) {cTokenMarketLiquidity = sub(cTokenMarketLiquidity, cTokenToRemove);}\r\n        } else {\r\n            funds[fund].balance = sub(funds[fund].balance, amount_);\r\n            if (!custom(fund)) {tokenMarketLiquidity = sub(tokenMarketLiquidity, amount_);}\r\n        }\r\n        if (!custom(fund)) {\r\n            totalBorrow = add(totalBorrow, amount_);\r\n            calcGlobalInterest();\r\n        }\r\n    }\r\n\r\n    \r\n    function getSecretHashesForLoan(address addr_) private returns (bytes32[4] memory) {\r\n        secretHashIndex[addr_] = add(secretHashIndex[addr_], 4);\r\n        require(secretHashesCount(addr_) >= secretHashIndex[addr_], \"Funds.getSecretHashesForLoan: Not enough secrets generated\");\r\n        return [\r\n            secretHashes[addr_][sub(secretHashIndex[addr_], 4)],\r\n            secretHashes[addr_][sub(secretHashIndex[addr_], 3)],\r\n            secretHashes[addr_][sub(secretHashIndex[addr_], 2)],\r\n            secretHashes[addr_][sub(secretHashIndex[addr_], 1)]\r\n        ];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"secretHashIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxUtilizationDelta\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"minLoanAmt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"},{\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultArbiterFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cTokenMarketLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_LIQUIDATION_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"defaultArbiterFee_\",\"type\":\"uint256\"}],\"name\":\"setDefaultArbiterFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalInterestRateNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"globalInterestRateNumerator_\",\"type\":\"uint256\"}],\"name\":\"setGlobalInterestRateNumerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"},{\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"fundOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"penalty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastGlobalInterestUpdated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calcGlobalInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_UINT_256\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"maxLoanAmt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"arbiter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_MIN_LOAN_AMT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"},{\"name\":\"maxLoanDur_\",\"type\":\"uint256\"},{\"name\":\"fundExpiry_\",\"type\":\"uint256\"},{\"name\":\"arbiter_\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getComptrollerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"utilizationInterestDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"},{\"name\":\"minLoanAmt_\",\"type\":\"uint256\"},{\"name\":\"maxLoanAmt_\",\"type\":\"uint256\"},{\"name\":\"minLoanDur_\",\"type\":\"uint256\"},{\"name\":\"maxLoanDur_\",\"type\":\"uint256\"},{\"name\":\"fundExpiry_\",\"type\":\"uint256\"},{\"name\":\"interest_\",\"type\":\"uint256\"},{\"name\":\"penalty_\",\"type\":\"uint256\"},{\"name\":\"fee_\",\"type\":\"uint256\"},{\"name\":\"liquidationRatio_\",\"type\":\"uint256\"},{\"name\":\"arbiter_\",\"type\":\"address\"}],\"name\":\"updateCustom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"interestUpdateDelay_\",\"type\":\"uint256\"}],\"name\":\"setInterestUpdateDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"secretHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comptroller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_LOAN_LENGTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"addNow\",\"type\":\"bool\"}],\"name\":\"ensureNotZero\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInterestRateNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"funds\",\"outputs\":[{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"minLoanAmt\",\"type\":\"uint256\"},{\"name\":\"maxLoanAmt\",\"type\":\"uint256\"},{\"name\":\"minLoanDur\",\"type\":\"uint256\"},{\"name\":\"maxLoanDur\",\"type\":\"uint256\"},{\"name\":\"fundExpiry\",\"type\":\"uint256\"},{\"name\":\"interest\",\"type\":\"uint256\"},{\"name\":\"penalty\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"liquidationRatio\",\"type\":\"uint256\"},{\"name\":\"arbiter\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"cBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxLoanDur_\",\"type\":\"uint256\"},{\"name\":\"fundExpiry_\",\"type\":\"uint256\"},{\"name\":\"arbiter_\",\"type\":\"address\"},{\"name\":\"compoundEnabled_\",\"type\":\"bool\"},{\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"bools\",\"outputs\":[{\"name\":\"custom\",\"type\":\"bool\"},{\"name\":\"compoundEnabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"maxLoanDur\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"liquidationRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"disableCompound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBorrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"globalInterestRate_\",\"type\":\"uint256\"}],\"name\":\"setGlobalInterestRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount_\",\"type\":\"uint256\"},{\"name\":\"rate_\",\"type\":\"uint256\"},{\"name\":\"loanDur_\",\"type\":\"uint256\"}],\"name\":\"calcInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"loans_\",\"type\":\"address\"}],\"name\":\"setLoans\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"lender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"custom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxUtilizationDelta_\",\"type\":\"uint256\"}],\"name\":\"setMaxUtilizationDelta\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"enableCompound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"minLoanDur\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_MIN_LOAN_DUR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"fundExpiry\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"utilizationInterestDivisor_\",\"type\":\"uint256\"}],\"name\":\"setUtilizationInterestDivisor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_LIQUIDATION_PENALTY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_MAX_LOAN_AMT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pubKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"secretHashesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minInterestRateNumerator_\",\"type\":\"uint256\"}],\"name\":\"setMinInterestRateNumerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secretHashes_\",\"type\":\"bytes32[]\"}],\"name\":\"generate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cToken_\",\"type\":\"address\"},{\"name\":\"comptroller_\",\"type\":\"address\"}],\"name\":\"setCompound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NUM_SECONDS_IN_YEAR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestUpdateDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"},{\"name\":\"amount_\",\"type\":\"uint256\"},{\"name\":\"recipient_\",\"type\":\"address\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pubKey_\",\"type\":\"bytes\"}],\"name\":\"setPubKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"decreaseTotalBorrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"interest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxInterestRateNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUtilizationRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cTokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"},{\"name\":\"borrower_\",\"type\":\"address\"},{\"name\":\"amount_\",\"type\":\"uint256\"},{\"name\":\"collateral_\",\"type\":\"uint256\"},{\"name\":\"loanDur_\",\"type\":\"uint256\"},{\"name\":\"requestTimestamp_\",\"type\":\"uint256\"},{\"name\":\"secretHashes_\",\"type\":\"bytes32[8]\"},{\"name\":\"pubKeyA_\",\"type\":\"bytes\"},{\"name\":\"pubKeyB_\",\"type\":\"bytes\"}],\"name\":\"request\",\"outputs\":[{\"name\":\"loanIndex\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minLoanAmt_\",\"type\":\"uint256\"},{\"name\":\"maxLoanAmt_\",\"type\":\"uint256\"},{\"name\":\"minLoanDur_\",\"type\":\"uint256\"},{\"name\":\"maxLoanDur_\",\"type\":\"uint256\"},{\"name\":\"fundExpiry_\",\"type\":\"uint256\"},{\"name\":\"liquidationRatio_\",\"type\":\"uint256\"},{\"name\":\"interest_\",\"type\":\"uint256\"},{\"name\":\"penalty_\",\"type\":\"uint256\"},{\"name\":\"fee_\",\"type\":\"uint256\"},{\"name\":\"arbiter_\",\"type\":\"address\"},{\"name\":\"compoundEnabled_\",\"type\":\"bool\"},{\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"createCustom\",\"outputs\":[{\"name\":\"fund\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"cmul\",\"outputs\":[{\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxInterestRateNumerator_\",\"type\":\"uint256\"}],\"name\":\"setMaxInterestRateNumerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenMarketLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"},{\"name\":\"decimals_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fund\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fund\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"maxLoanDur_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundExpiry_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"arbiter_\",\"type\":\"address\"}],\"name\":\"Update\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fund\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"borrower_\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collateral_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"loanDur_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestTimestamp_\",\"type\":\"uint256\"}],\"name\":\"Request\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fund\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient_\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"EnableCompound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fund\",\"type\":\"bytes32\"}],\"name\":\"DisableCompound\",\"type\":\"event\"}]","ContractName":"Funds","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000012","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://7340788eb0b340c882f3abdd399eb978a1738c6f7ed33dbf1bd1fef4c3d684b0"}]}