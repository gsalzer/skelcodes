{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/*\r\nPAYSPEC: Generic global invoicing contract\r\n\r\n\r\n*/\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PaySpec  {\r\n\r\n   using SafeMath for uint;\r\n\r\n\r\n   mapping(bytes32 => Invoice) invoices;\r\n\r\n\r\n\r\n  event CreatedInvoice(bytes32 uuid);\r\n  event PaidInvoice(bytes32 uuid, address from);\r\n\r\n\r\n  struct Invoice {\r\n    bytes32 uuid;\r\n    string description;\r\n    uint256 refNumber;\r\n\r\n\r\n    address token;\r\n    uint256 amountDue;\r\n    address payTo;\r\n    uint256 ethBlockCreatedAt;\r\n\r\n\r\n    address paidBy;\r\n    uint256 amountPaid;\r\n    uint256 ethBlockPaidAt;\r\n\r\n\r\n    uint256 ethBlockExpiresAt;\r\n\r\n  }\r\n\r\n\r\n\r\n  constructor(  ) public {\r\n\r\n\r\n  }\r\n\r\n\r\n  //do not allow ether to enter\r\n  function() external    payable {\r\n      revert();\r\n  }\r\n\r\n\r\n  function getContractVersion( ) public pure returns (uint)\r\n  {\r\n      return 3;\r\n  }\r\n\r\n\r\n  function createInvoice(uint256 refNumber, string memory description,  address token, uint256 amountDue, address payTo, uint256 ethBlockExpiresAt ) public returns (bytes32 uuid) {\r\n      return _createInvoiceInternal(false, refNumber,description,token,amountDue,payTo,ethBlockExpiresAt);\r\n  }\r\n\r\n  //why doesnt this work ?\r\n  function createAndPayInvoice(uint256 refNumber, string memory description,  address token, uint256 amountDue, address payTo, uint256 ethBlockExpiresAt ) public returns (bool) {\r\n      bytes32 invoiceUUID =  _createInvoiceInternal(true, refNumber,description,token,amountDue,payTo,ethBlockExpiresAt) ;\r\n\r\n      require( ERC20Interface(  invoices[invoiceUUID].token ).transferFrom(msg.sender, address(this),  invoices[invoiceUUID].amountDue )   );\r\n\r\n      return _payInvoiceInternal( invoiceUUID, msg.sender);\r\n  }\r\n\r\n   function _createInvoiceInternal( bool optional, uint256 refNumber, string memory description,  address token, uint256 amountDue, address payTo, uint256 ethBlockExpiresAt ) private returns (bytes32 uuid) {\r\n\r\n      uint256 ethBlockCreatedAt = block.number;\r\n\r\n      bytes32 newuuid = keccak256( abi.encodePacked( refNumber, description,  token, amountDue, payTo, ethBlockExpiresAt ) );\r\n\r\n      bool invoiceSlotEmpty = (invoices[newuuid].uuid == 0);\r\n\r\n      if(!optional){\r\n        require( invoiceSlotEmpty );  //make sure you do not overwrite invoices unless optional\r\n      }\r\n\r\n      if(invoiceSlotEmpty)\r\n      {\r\n          invoices[newuuid] = Invoice({\r\n           uuid: newuuid,\r\n           description: description,\r\n           refNumber: refNumber,\r\n           token: token,\r\n           amountDue: amountDue,\r\n           payTo: payTo,\r\n           ethBlockCreatedAt: ethBlockCreatedAt,\r\n           paidBy: address(0),\r\n           amountPaid: 0,\r\n           ethBlockPaidAt: 0,\r\n           ethBlockExpiresAt: ethBlockExpiresAt\r\n\r\n          });\r\n\r\n          emit CreatedInvoice(newuuid);\r\n       }\r\n\r\n       return newuuid;\r\n   }\r\n\r\n   function payInvoice(bytes32 invoiceUUID) public returns (bool)\r\n   {\r\n     //transfer the tokens into escrow into this contract to stage for paying the invoice\r\n     require( ERC20Interface(  invoices[invoiceUUID].token ).transferFrom(msg.sender, address(this),  invoices[invoiceUUID].amountDue )   );\r\n\r\n     return _payInvoiceInternal( invoiceUUID, msg.sender);\r\n\r\n\r\n   }\r\n\r\n   function _payInvoiceInternal( bytes32 invoiceUUID, address from ) private returns (bool) {\r\n\r\n       require( invoices[invoiceUUID].uuid == invoiceUUID ); //make sure invoice exists\r\n       require( invoiceWasPaid(invoiceUUID) == false );\r\n       require( invoiceHasExpired(invoiceUUID) == false);\r\n\r\n       //Transfer the tokens. Always transfer from this contracts escrow (not wildcard) so tokens only approved to this universal contract cannot be spent by others.\r\n       require( ERC20Interface( invoices[invoiceUUID].token  ).transfer(  invoices[invoiceUUID].payTo, invoices[invoiceUUID].amountDue   ) );\r\n\r\n       invoices[invoiceUUID].amountPaid = invoices[invoiceUUID].amountDue;\r\n\r\n       invoices[invoiceUUID].paidBy = from;\r\n\r\n       invoices[invoiceUUID].ethBlockPaidAt = block.number;\r\n\r\n\r\n\r\n       emit PaidInvoice(invoiceUUID, from);\r\n\r\n       return true;\r\n\r\n\r\n   }\r\n\r\n   function getDescription( bytes32 invoiceUUID ) public view returns ( string  memory )\r\n   {\r\n       return invoices[invoiceUUID].description;\r\n   }\r\n\r\n   function getRefNumber( bytes32 invoiceUUID ) public view returns (uint)\r\n   {\r\n       return invoices[invoiceUUID].refNumber;\r\n   }\r\n\r\n   function getEthBlockExpiresAt( bytes32 invoiceUUID ) public view returns (uint)\r\n   {\r\n       return invoices[invoiceUUID].ethBlockExpiresAt;\r\n   }\r\n\r\n   function getTokenAddress( bytes32 invoiceUUID ) public view returns (address)\r\n   {\r\n       return invoices[invoiceUUID].token;\r\n   }\r\n\r\n   function getRecipientAddress( bytes32 invoiceUUID ) public view returns (address)\r\n   {\r\n       return invoices[invoiceUUID].payTo;\r\n   }\r\n\r\n   function invoiceExists ( bytes32 invoiceUUID ) public view returns (bool)\r\n   {\r\n     return invoices[invoiceUUID].uuid == invoiceUUID;\r\n   }\r\n\r\n\r\n   function getAmountDue( bytes32 invoiceUUID ) public view returns (uint)\r\n   {\r\n       return invoices[invoiceUUID].amountDue;\r\n   }\r\n\r\n   function getAmountPaid( bytes32 invoiceUUID ) public view returns (uint)\r\n   {\r\n       return invoices[invoiceUUID].amountPaid;\r\n   }\r\n\r\n   function getEthBlockPaidAt( bytes32 invoiceUUID ) public view returns (uint)\r\n   {\r\n       return invoices[invoiceUUID].ethBlockPaidAt;\r\n   }\r\n\r\n\r\n   function invoiceWasPaid( bytes32 invoiceUUID ) public view returns (bool)\r\n   {\r\n       return getEthBlockPaidAt(invoiceUUID) > 0;\r\n   }\r\n\r\n\r\n   function invoiceHasExpired( bytes32 invoiceUUID ) public view returns (bool)\r\n   {\r\n       return (getEthBlockExpiresAt(invoiceUUID) != 0 && block.number >= getEthBlockExpiresAt(invoiceUUID));\r\n   }\r\n\r\n\r\n\r\n   /*\r\n     Receive approval from ApproveAndCall() to pay invoice.  The first 32 bytes of the data array are used for the invoice UUID bytes32.\r\n\r\n   */\r\n     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public returns (bool) {\r\n\r\n        //can only be called by the token contract\r\n        require(msg.sender == token);\r\n\r\n        //transfer the tokens into escrow into this contract to stage for paying the invoice\r\n        require( ERC20Interface(token).transferFrom(from, address(this), tokens)   );\r\n\r\n        require(  _payInvoiceInternal(bytesToBytes32(data,0), from)  );\r\n\r\n        return true;\r\n\r\n     }\r\n\r\n    function bytesToBytes32(bytes memory b, uint offset) private pure returns (bytes32) {\r\n      bytes32 out;\r\n\r\n      for (uint i = 0; i < 32; i++) {\r\n        out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\r\n      }\r\n      return out;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"refNumber\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amountDue\",\"type\":\"uint256\"},{\"name\":\"payTo\",\"type\":\"address\"},{\"name\":\"ethBlockExpiresAt\",\"type\":\"uint256\"}],\"name\":\"createAndPayInvoice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"getAmountDue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"invoiceHasExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"invoiceExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"payInvoice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"refNumber\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amountDue\",\"type\":\"uint256\"},{\"name\":\"payTo\",\"type\":\"address\"},{\"name\":\"ethBlockExpiresAt\",\"type\":\"uint256\"}],\"name\":\"createInvoice\",\"outputs\":[{\"name\":\"uuid\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"getAmountPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"getRefNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"getEthBlockPaidAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"getDescription\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"invoiceWasPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"getEthBlockExpiresAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"invoiceUUID\",\"type\":\"bytes32\"}],\"name\":\"getRecipientAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes32\"}],\"name\":\"CreatedInvoice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"PaidInvoice\",\"type\":\"event\"}]","ContractName":"PaySpec","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://d25bebb9eb21b4be69c604348948b245428666dba2d5d8087cda2bae3ec01222"}]}