{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n\r\n/*\r\n0x5c5cA8c79bf69a5449F1F621215E9Cfc91189Cc5\r\n\r\n\r\nLAVAWALLET is a Meta Transaction Solution using EIP 712\r\n\r\n\r\nSimply approve your tokens to this contract to give them super powers!\r\n\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes memory sig) internal  pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n\r\ncontract RelayAuthorityInterface {\r\n    function getRelayAuthority() public returns (address);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LavaWallet is ECRecovery{\r\n\r\n  using SafeMath for uint;\r\n\r\n   mapping(bytes32 => uint256) burnedSignatures;\r\n\r\n\r\n\r\n  struct LavaPacket {\r\n    string methodName;\r\n    address relayAuthority; //either a contract or an account\r\n    address from;\r\n    address to;\r\n    address wallet;  //this contract address\r\n    address token;\r\n    uint256 tokens;\r\n    uint256 relayerRewardTokens;\r\n    uint256 expires;\r\n    uint256 nonce;\r\n  }\r\n\r\n\r\n  /*\r\n      MUST update these if architecture changes !!\r\n      MAKE SURE there are NO spaces !\r\n  */\r\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n          \"EIP712Domain(string contractName,string version,uint256 chainId,address verifyingContract)\"\r\n      );\r\n\r\n   function getLavaDomainTypehash() public pure returns (bytes32) {\r\n      return EIP712DOMAIN_TYPEHASH;\r\n   }\r\n\r\n    function getEIP712DomainHash(string memory contractName, string memory version, uint256 chainId, address verifyingContract) public pure returns (bytes32) {\r\n\r\n      return keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(bytes(contractName)),\r\n            keccak256(bytes(version)),\r\n            chainId,\r\n            verifyingContract\r\n        ));\r\n    }\r\n\r\n\r\n\r\n\r\n  bytes32 constant LAVAPACKET_TYPEHASH = keccak256(\r\n      \"LavaPacket(string methodName,address relayAuthority,address from,address to,address wallet,address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce)\"\r\n  );\r\n\r\n\r\n\r\n    function getLavaPacketTypehash()  public pure returns (bytes32) {\r\n      return LAVAPACKET_TYPEHASH;\r\n  }\r\n\r\n\r\n\r\n   function getLavaPacketHash(string memory methodName, address relayAuthority,address from,address to, address wallet, address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce) public pure returns (bytes32) {\r\n          return keccak256(abi.encode(\r\n              LAVAPACKET_TYPEHASH,\r\n              keccak256(bytes(methodName)),\r\n              relayAuthority,\r\n              from,\r\n              to,\r\n              wallet,\r\n              token,\r\n              tokens,\r\n              relayerRewardTokens,\r\n              expires,\r\n              nonce\r\n          ));\r\n      }\r\n\r\n\r\n   constructor(  ) public {\r\n\r\n\r\n  }\r\n\r\n\r\n  //do not allow ether to enter\r\n  function() external payable {\r\n      revert();\r\n  }\r\n\r\n\r\n\r\n    // Make sure the change the chainID here if deploying to a testnet\r\n      function getLavaTypedDataHash(string memory methodName, address relayAuthority,address from,address to, address wallet,address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce) public view returns (bytes32) {\r\n\r\n\r\n              // Note: we need to use `encodePacked` here instead of `encode`.\r\n              bytes32 digest = keccak256(abi.encodePacked(\r\n                  \"\\x19\\x01\",\r\n                  getEIP712DomainHash('Lava Wallet','1',1,address(this)),\r\n                  getLavaPacketHash(methodName,relayAuthority,from,to,wallet,token,tokens,relayerRewardTokens,expires,nonce)\r\n              ));\r\n              return digest;\r\n          }\r\n\r\n\r\n\r\n        /*\r\n        This uses the metaTX signature and the fact that the ERC20 tokens are Approved to this contract to send them out via the relays eth TX.\r\n\r\n        */\r\n\r\n   function _validatePacketSignature(  string memory methodName, address relayAuthority,address from,address to, address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce,  bytes memory signature) internal returns (bool success)\r\n   {\r\n       address wallet = address(this);\r\n\r\n\r\n\r\n       /*\r\n        Always allow relaying if the specified relayAuthority is 0.\r\n        If the authority address is not a contract, allow it to relay\r\n        If the authority address is a contract, allow its defined 'getAuthority()' delegate to relay\r\n       */\r\n\r\n       require( relayAuthority == address(0x0)\r\n         || (!addressContainsContract(relayAuthority) && msg.sender == relayAuthority)\r\n         || (addressContainsContract(relayAuthority) && msg.sender == RelayAuthorityInterface(relayAuthority).getRelayAuthority())  );\r\n\r\n\r\n         //check to make sure that signature == ecrecover signature\r\n         bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,token,tokens,relayerRewardTokens,expires,nonce);\r\n\r\n\r\n         address recoveredSignatureSigner = recover(sigHash,signature);\r\n\r\n\r\n          //make sure the signer is the depositor of the tokens\r\n          require(from == recoveredSignatureSigner);\r\n\r\n\r\n          //make sure the signature has not expired\r\n          require(block.number < expires || expires == 0);\r\n\r\n          uint burnedSignature = burnedSignatures[sigHash];\r\n          burnedSignatures[sigHash] = 0x1; //spent\r\n          require(burnedSignature == 0x0 );\r\n\r\n\r\n         //remember to tip your relayer!\r\n         require( ERC20Interface(token).transferFrom(from, msg.sender, relayerRewardTokens )  );\r\n\r\n\r\n\r\n       return true;\r\n   }\r\n\r\n   //why wont this work w approve ??\r\n   function _transferTokens(address to, address token, uint tokens) internal returns (bool success) {\r\n         ERC20Interface(token).transfer(to, tokens );\r\n\r\n         return true;\r\n    }\r\n\r\n\r\n    ///transfer tokens within the lava balances\r\n    //Requires approval\r\n   function _transferTokensFrom( address from, address to,address token,  uint tokens) internal returns (bool success) {\r\n        ERC20Interface(token).transferFrom(from, to, tokens );  //??\r\n\r\n       return true;\r\n   }\r\n\r\n\r\n\r\n   /*\r\n    Approves lava tokens for another smart contract ('TO field') and call the contracts receiveApproval method all in one fell swoop\r\n\r\n    */\r\n\r\n    function approveAndCallWithSignature( string memory methodName, address relayAuthority,address from,address to,   address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature ) public returns (bool success)   {\r\n\r\n       require(!bytesEqual('transfer',bytes(methodName)));\r\n\r\n\r\n       require(_validatePacketSignature(methodName,relayAuthority,from,to, token,tokens,relayerRewardTokens,expires,nonce, signature));\r\n\r\n       bytes memory method = bytes(methodName);\r\n\r\n       _sendApproveAndCall(from,to,token,tokens,method);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _sendApproveAndCall(address from, address to, address token, uint tokens, bytes memory methodName) internal\r\n    {\r\n        ApproveAndCallFallBack(to).receiveApproval(from, tokens, token, bytes(methodName));\r\n    }\r\n\r\n\r\n\r\n   function transferTokensWithSignature(string memory methodName, address relayAuthority, address from, address to, address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature) public returns (bool success)\r\n {\r\n\r\n     require(bytesEqual('transfer',bytes(methodName)));\r\n\r\n\r\n     require(_validatePacketSignature(methodName,relayAuthority,from,to, token,tokens,relayerRewardTokens,expires,nonce, signature));\r\n\r\n     require( ERC20Interface(token).transferFrom(from,  to, tokens )  );\r\n\r\n\r\n     return true;\r\n\r\n }\r\n\r\n function burnSignature(string memory methodName, address relayAuthority, address from, address to, address wallet,address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce,  bytes memory signature) public returns (bool success)\r\n      {\r\n\r\n\r\n         bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,token, tokens,relayerRewardTokens,expires,nonce);\r\n\r\n          address recoveredSignatureSigner = recover(sigHash,signature);\r\n\r\n          //make sure the invalidator is the signer\r\n          require(recoveredSignatureSigner == from);\r\n\r\n          //only the original packet owner can burn signature, not a relay\r\n          require(from == msg.sender);\r\n\r\n          //make sure this signature has never been used\r\n          uint burnedSignature = burnedSignatures[sigHash];\r\n          burnedSignatures[sigHash] = 0x2; //invalidated\r\n          require(burnedSignature == 0x0);\r\n\r\n          return true;\r\n      }\r\n\r\n\r\n\r\n     function signatureBurnStatus(bytes32 digest) public view returns (uint)\r\n     {\r\n       return (burnedSignatures[digest]);\r\n     }\r\n\r\n     function signatureIsValid(string memory methodName, address relayAuthority,address from,address to, address wallet,address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature) public view returns (bool success)\r\n   {\r\n\r\n        //check to make sure that signature == ecrecover signature\r\n       bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,token, tokens,relayerRewardTokens,expires,nonce);\r\n\r\n\r\n       address recoveredSignatureSigner = recover(sigHash,signature);\r\n\r\n\r\n       return  (from == recoveredSignatureSigner) ;\r\n\r\n   }\r\n\r\n\r\n       /*\r\n         Receive approval to spend tokens and perform any action all in one transaction\r\n       */\r\n     /*function receiveApproval(address from, uint256 tokens, address token, bytes data) public returns (bool success) {\r\n\r\n\r\n        // do something ?\r\n\r\n     }*/\r\n \r\n\r\n\r\n     function addressContainsContract(address _to) view internal returns (bool)\r\n     {\r\n       uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n         return (codeLength>0);\r\n     }\r\n\r\n\r\n     function bytesEqual(bytes memory b1,bytes memory b2) pure internal returns (bool)\r\n        {\r\n          if(b1.length != b2.length) return false;\r\n\r\n          for (uint i=0; i<b1.length; i++) {\r\n            if(b1[i] != b2[i]) return false;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"relayAuthority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"approveAndCallWithSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"relayAuthority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"burnSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"}],\"name\":\"getEIP712DomainHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLavaDomainTypehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"relayAuthority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getLavaPacketHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLavaPacketTypehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"relayAuthority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getLavaTypedDataHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"signatureBurnStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"relayAuthority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"signatureIsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"relayAuthority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferTokensWithSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LavaWallet","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://608421ca71d0c3f32b57dc88735f8f85c46e47c014d4098de6e2c69c64fff354"}]}