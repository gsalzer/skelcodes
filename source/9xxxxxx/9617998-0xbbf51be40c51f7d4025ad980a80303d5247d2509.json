{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: 0.5-contracts/normal_deployment/racing/RacingAdmins.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ncontract RacingAdmins is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event AdminAdded(address indexed account);\r\n    event AdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _admins;\r\n\r\n    constructor () internal {\r\n        _addAdmin(_msgSender());\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(_msgSender()), \"AdminRole: caller does not have the Admin role\");\r\n        _;\r\n    }\r\n\r\n    function isAdmin(address account) public view returns (bool) {\r\n        return _admins.has(account);\r\n    }\r\n\r\n    function addAdmin(address account) public onlyAdmin {\r\n        _addAdmin(account);\r\n    }\r\n\r\n    function renounceAdmin(address account) public onlyAdmin {\r\n        _removeAdmin(account);\r\n    }\r\n\r\n    function _addAdmin(address account) internal {\r\n        _admins.add(account);\r\n        emit AdminAdded(account);\r\n    }\r\n\r\n    function _removeAdmin(address account) internal {\r\n        _admins.remove(account);\r\n        emit AdminRemoved(account);\r\n    }\r\n}\r\n\r\n// File: 0.5-contracts/normal_deployment/racing/RacingFeeReceiver.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ncontract RacingFeeReceiver is RacingAdmins {\r\n    address payable private _feeWallet;\r\n\r\n    event FeeWalletTransferred(address indexed previousFeeWallet, address indexed newFeeWallet);\r\n\r\n    /**\r\n     * @dev Returns the address of the current fee receiver.\r\n     */\r\n    function feeWallet() public view returns (address payable) {\r\n        return _feeWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the fee receiver wallet.\r\n     */\r\n    modifier onlyFeeWallet() {\r\n        require(isFeeWallet(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current fee receiver wallet.\r\n     */\r\n    function isFeeWallet() public view returns (bool) {\r\n        return _msgSender() == _feeWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without fee receiver wallet.\r\n     *\r\n     * NOTE: Renouncing will leave the contract without an fee receiver wallet.\r\n     * It means that fee will be transferred to the zero address.\r\n     */\r\n    function renounceFeeWallet() public onlyAdmin {\r\n        emit FeeWalletTransferred(_feeWallet, address(0));\r\n        _feeWallet = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers address of the fee receiver to a new address (`newFeeWallet`).\r\n     * Can only be called by admins.\r\n     */\r\n    function transferFeeWalletOwnership(address payable newFeeWallet) public onlyAdmin {\r\n        _transferFeeWalletOwnership(newFeeWallet);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers address of the fee receiver to a new address (`newFeeWallet`).\r\n     */\r\n    function _transferFeeWalletOwnership(address payable newFeeWallet) internal {\r\n        require(newFeeWallet != address(0), \"Ownable: new owner is the zero address\");\r\n        emit FeeWalletTransferred(_feeWallet, newFeeWallet);\r\n        _feeWallet = newFeeWallet;\r\n    }\r\n}\r\n\r\n// File: 0.5-contracts/normal_deployment/racing/RacingStorage.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ncontract RacingStorage is RacingFeeReceiver, ReentrancyGuard {\r\n    // --\r\n    // Permanent Storage Variables\r\n    // --\r\n\r\n    mapping(bytes32 => Race) public Races; // The race mapping structure.\r\n    mapping(uint256 => address) public Owner_Horse; // Owner of the Horse ID.\r\n    mapping(uint256 => uint256) public Horse_Active_Races; // Number of races the horse is registered for.\r\n    mapping(bytes32 => bool) public ID_Saved; // Returns whether or not the race ID is present on storage already.\r\n    mapping(uint256 => uint256) public Position_To_Payment; // Returns the percentage of the payment depending on horse's position in a race.\r\n    mapping(address => bool) public Is_Authorized; // Returns whether an address is authorized or not.\r\n    mapping(bytes32 => string) public Cancelled_Races; // Returns a cancelled race and its reason to be cancelled.\r\n    mapping(bytes32 => bool) public Has_Zed_Claimed; // Returns whether or not winnings for a race have been claimed for Zed.\r\n\r\n    address BB; // Blockchain Brain\r\n    address Core; // Core contract.\r\n\r\n    struct Race {\r\n        string Track_Name; // Name of the track or event.\r\n        bytes32 Race_ID; // Key provided for Race ID.\r\n        uint256 Length; // Length of the track (m).\r\n        uint256 Horses_Registered; // Current number of horses registered.\r\n        uint256 Unix_Start; // Timestamp the race starts.\r\n        uint256 Entrance_Fee; // Entrance fee for a particular race (10^18).\r\n        uint256 Prize_Pool; // Total bets in the prize pool (10^18).\r\n        uint256 Horses_Allowed; // Total number of horses allowed for a race.\r\n        uint256[] Horses; // List of Horse IDs on Race.\r\n        State Race_State; // Current state of the race.\r\n        mapping(uint256 => Horse) Lineup; // Mapping of the Horse ID => Horse struct.\r\n        mapping(uint256 => uint256) Gate_To_ID; // Mapping of the Gate # => Horse ID.\r\n        mapping(uint256 => bool) Is_Gate_Taken; // Whether or not a gate number has been taken.\r\n    }\r\n\r\n    struct Horse {\r\n        uint256 Gate; // Gate this horse is currently at.\r\n        uint256 Total_Bet; // Total amount bet on this horse.\r\n        uint256 Final_Position; // Final position of the horse (1 to Horses allowed in race).\r\n        mapping(address => uint256) Bet_Placed; // Amount a specific address bet on this horse.\r\n        mapping(address => bool) Bet_Claimed; // Whether or not that specific address claimed their bet.\r\n    }\r\n\r\n    enum State {Null, Registration, Betting, Final, Fail_Safe}\r\n}\r\n\r\n// File: 0.5-contracts/normal_deployment/racing/proxy/Proxy.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\ncontract Proxy is RacingStorage {\r\n\t/**\r\n\t * @dev Fallback function.\r\n\t * Implemented entirely in `_fallback`.\r\n\t */\r\n\tfunction () payable external {\r\n\t\t_fallback();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev fallback implementation.\r\n\t * Extracted to enable manual triggering.\r\n\t */\r\n\tfunction _fallback() internal {\r\n\t\t_willFallback();\r\n\t\t_delegate(_implementation());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that is run as the first thing in the fallback function.\r\n\t * Can be redefined in derived contracts to add functionality.\r\n\t * Redefinitions must call super._willFallback().\r\n\t */\r\n\tfunction _willFallback() internal {}\r\n\r\n\t/**\r\n\t * @dev Delegates execution to an implementation contract.\r\n\t * This is a low level function that doesn't return to its internal call site.\r\n\t * It will return to the external caller whatever the implementation returns.\r\n\t * @param implementation Address to delegate.\r\n\t */\r\n\tfunction _delegate(address implementation) internal {\r\n\t\tassembly {\r\n\t\t\t// Copy msg.data. We take full control of memory in this inline assembly\r\n\t\t\t// block because it will not return to Solidity code. We overwrite the\r\n\t\t\t// Solidity scratch pad at memory position 0.\r\n\t\t\tcalldatacopy(0, 0, calldatasize)\r\n\r\n\t\t\t// Call the implementation.\r\n\t\t\t// out and outsize are 0 because we don't know the size yet.\r\n\t\t\tlet result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n\t\t\t// Copy the returned data.\r\n\t\t\treturndatacopy(0, 0, returndatasize)\r\n\r\n\t\t\tswitch result\r\n\t\t\t// delegatecall returns 0 on error.\r\n\t\t\tcase 0 { revert(0, returndatasize) }\r\n\t\t\tdefault { return(0, returndatasize) }\r\n\t\t}\r\n  \t}\r\n\r\n\t/**\r\n\t * @return The Address of the implementation.\r\n\t */\r\n\tfunction _implementation() internal view returns (address);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: 0.5-contracts/normal_deployment/racing/proxy/BaseUpgradeabilityProxy.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BaseUpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n\tusing Address for address;\r\n\r\n\t/**\r\n\t * @dev The version of current(active) logic contract\r\n\t */\r\n    string internal _version;\r\n\r\n\t/**\r\n\t * @dev Storage slot with the address of the current implementation.\r\n\t * This is the keccak-256 hash of \"org.zeppelinos.proxy.implementation\", and is\r\n\t * validated in the constructor.\r\n\t */\r\n\tbytes32 internal constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\r\n\r\n\t/**\r\n\t * @dev Emitted when the implementation is upgraded.\r\n\t * @param implementation Address of the new implementation.\r\n\t */\r\n\tevent Upgraded(address indexed implementation);\r\n\r\n\t/**\r\n\t * @dev Returns the current implementation.\r\n\t * @return Address of the current implementation\r\n\t */\r\n\tfunction _implementation() internal view returns (address impl) {\r\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\r\n\t\tassembly {\r\n\t\t    impl := sload(slot)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Upgrades the proxy to a new implementation.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t * @param newVersion of proxied contract.\r\n\t */\r\n\tfunction _upgradeProxyTo(address newImplementation, string memory newVersion) internal {\r\n\t\t_setProxyImplementation(newImplementation, newVersion);\r\n\r\n\t\temit Upgraded(newImplementation);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets the implementation address of the proxy.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t * @param newVersion of proxied contract.\r\n\t */\r\n\tfunction _setProxyImplementation(address newImplementation, string memory newVersion) internal {\r\n\t\trequire(newImplementation.isContract(), \"Cannot set a proxy implementation to a non-contract address\");\r\n\r\n \t\t_version = newVersion;\r\n\r\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n\t\tassembly {\r\n\t\t    sstore(slot, newImplementation)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File: 0.5-contracts/normal_deployment/racing/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\r\n * implementation and init data.\r\n */\r\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n\t/**\r\n\t * @dev Contract constructor.\r\n\t * @param _logic Address of the initial implementation.\r\n\t */\r\n\tconstructor(address _logic) public payable {\r\n\t\tassert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\"));\r\n\t\t_setProxyImplementation(_logic, \"1.0.0\");\r\n\t}\r\n}\r\n\r\n// File: 0.5-contracts/normal_deployment/racing/proxy/BaseAdminUpgradeabilityProxy.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title BaseAdminUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks.\r\n * All external functions in this contract must be guarded by the\r\n * `ifProxyAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n\t/**\r\n\t * @dev Emitted when the administration has been transferred.\r\n\t * @param previousAdmin Address of the previous admin.\r\n\t * @param newProxyAdmin Address of the new admin.\r\n\t */\r\n\tevent ProxyAdminChanged(address previousAdmin, address newProxyAdmin);\r\n\r\n\t/**\r\n\t * @dev Storage slot with the admin of the contract.\r\n\t * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\r\n\t * validated in the constructor.\r\n\t */\r\n  \tbytes32 internal constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\r\n\r\n  \t/**\r\n\t * @dev Modifier to check whether the `msg.sender` is the admin.\r\n\t * If it is, it will run the function. Otherwise, it will delegate the call\r\n\t * to the implementation.\r\n\t */\r\n\tmodifier ifProxyAdmin() {\r\n\t\tif (msg.sender == _proxyAdmin()) {\r\n\t\t    _;\r\n\t\t} else {\r\n\t\t    _fallback();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return The address of the proxy admin.\r\n\t */\r\n\tfunction proxyAdmin() external view returns (address) {\r\n\t\treturn _proxyAdmin();\r\n\t}\r\n\r\n\t/**\r\n\t * @return The version of logic contract\r\n\t */\r\n\tfunction proxyVersion() external view returns (string memory) {\r\n\t\treturn _version;\r\n\t}\r\n\r\n\t/**\r\n\t * @return The address of the implementation.\r\n\t */\r\n\tfunction proxyImplementation() external view returns (address) {\r\n\t\treturn _implementation();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Changes the admin of the proxy.\r\n\t * Only the current admin can call this function.\r\n\t * @param newProxyAdmin Address to transfer proxy administration to.\r\n\t */\r\n\tfunction changeProxyAdmin(address newProxyAdmin) external ifProxyAdmin {\r\n\t\trequire(newProxyAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\r\n\t\temit ProxyAdminChanged(_proxyAdmin(), newProxyAdmin);\r\n\t\t_setProxyAdmin(newProxyAdmin);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Upgrade the backing implementation of the proxy.\r\n\t * Only the admin can call this function.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t * @param newVersion of proxied contract.\r\n\t */\r\n\tfunction upgradeProxyTo(address newImplementation, string calldata newVersion) external ifProxyAdmin {\r\n\t\t_upgradeProxyTo(newImplementation, newVersion);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Upgrade the backing implementation of the proxy and call a function\r\n\t * on the new implementation.\r\n\t * This is useful to initialize the proxied contract.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t * @param newVersion of proxied contract.\r\n\t * @param data Data to send as msg.data in the low level call.\r\n\t * It should include the signature and the parameters of the function to be called, as described in\r\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n\t */\r\n\tfunction upgradeProxyToAndCall(address newImplementation, string calldata newVersion, bytes calldata data) payable external ifProxyAdmin {\r\n\t\t_upgradeProxyTo(newImplementation, newVersion);\r\n\t\t(bool success,) = newImplementation.delegatecall(data);\r\n\t\trequire(success);\r\n\t}\r\n\r\n\t/**\r\n\t * @return The admin slot.\r\n\t */\r\n\tfunction _proxyAdmin() internal view returns (address adm) {\r\n\t\tbytes32 slot = ADMIN_SLOT;\r\n\t\tassembly {\r\n    \t\tadm := sload(slot)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets the address of the proxy admin.\r\n\t * @param newProxyAdmin Address of the new proxy admin.\r\n\t */\r\n\tfunction _setProxyAdmin(address newProxyAdmin) internal {\r\n\t\tbytes32 slot = ADMIN_SLOT;\r\n\r\n\t\tassembly {\r\n\t\t\tsstore(slot, newProxyAdmin)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Only fall back when the sender is not the admin.\r\n\t */\r\n\tfunction _willFallback() internal {\r\n\t\trequire(msg.sender != _proxyAdmin(), \"Cannot call fallback function from the proxy admin\");\r\n\t\tsuper._willFallback();\r\n\t}\r\n}\r\n\r\n// File: 0.5-contracts/normal_deployment/racing/RacingProxy.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n/**\r\n * @title RacingProxy\r\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\r\n * initializing the implementation, admin, and init data.\r\n */\r\ncontract RacingProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\r\n\t/**\r\n\t * Contract constructor.\r\n\t * @param _logic address of the initial implementation.\r\n\t * @param _admin Address of the proxy administrator.\r\n\t */\r\n\tconstructor(address _logic, address _admin) UpgradeabilityProxy(_logic) public payable {\r\n\t\tassert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\r\n\t\t_setProxyAdmin(_admin);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"proxyImplementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Cancelled_Races\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ID_Saved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"},{\"name\":\"newVersion\",\"type\":\"string\"}],\"name\":\"upgradeProxyTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceFeeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Is_Authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Races\",\"outputs\":[{\"name\":\"Track_Name\",\"type\":\"string\"},{\"name\":\"Race_ID\",\"type\":\"bytes32\"},{\"name\":\"Length\",\"type\":\"uint256\"},{\"name\":\"Horses_Registered\",\"type\":\"uint256\"},{\"name\":\"Unix_Start\",\"type\":\"uint256\"},{\"name\":\"Entrance_Fee\",\"type\":\"uint256\"},{\"name\":\"Prize_Pool\",\"type\":\"uint256\"},{\"name\":\"Horses_Allowed\",\"type\":\"uint256\"},{\"name\":\"Race_State\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newProxyAdmin\",\"type\":\"address\"}],\"name\":\"changeProxyAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFeeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Owner_Horse\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFeeWallet\",\"type\":\"address\"}],\"name\":\"transferFeeWalletOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Horse_Active_Races\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Position_To_Payment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"},{\"name\":\"newVersion\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeProxyToAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Has_Zed_Claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_logic\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newProxyAdmin\",\"type\":\"address\"}],\"name\":\"ProxyAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousFeeWallet\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newFeeWallet\",\"type\":\"address\"}],\"name\":\"FeeWalletTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"}]","ContractName":"RacingProxy","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d82556c2470c3d4331e6ea6ab9543581db6bcedd000000000000000000000000528c53dcbf0cc7530f6cd0b4a11934af209bb82a","Library":"","LicenseType":"None","SwarmSource":"bzzr://8b35abd98c52eef8a35d3d805b8ea37b7949fc75702ddd5bbda5eebb0c4faa95"}]}