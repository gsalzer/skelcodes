{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\r\n\r\n/**\r\n * @dev ERC20200206, another Non-Fungible Token Standard interface, JUST for Doctor Li\r\n * https://etherscan.io/address/0x6e46d3ab7335fffb0d14927e0b418cc08fe60505#code\r\n * https://shimo.im/docs/rW99CpvkTVxGwcV6\r\n * https://ipfs.io/ipfs/QmQZC741wpPjDNWJnMDMxFjsBnxsvXSBAVwSmSwXTJfv8z\r\n */\r\ncontract ERC20200206  {\r\n    event Mint(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n\r\n    function name()   external view returns (string memory _name);\r\n    function symbol() external view returns (string memory _symbol);\r\n\r\n    function totalSupply() public view returns (uint256);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n    function minerOf(uint256 _tokenId) public view returns (address _miner);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory _uri);\r\n\r\n    function amountOf(address _miner) public view returns (uint256 _amount);\r\n    function tokenOfMinerByIndex(\r\n        address _miner,\r\n        uint256 _index\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 _tokenId);\r\n    function tokenByIndex(uint256 _index) public view returns (uint256 _tokenId);\r\n\r\n    function setTokenURI(uint256 _tokenId, string memory _uri) public;\r\n    function mint(string memory _uri) public;\r\n}\r\n\r\ncontract NFT {\r\n    using SafeMath for uint256;\r\n\r\n    // Token name\r\n    string internal name_;\r\n\r\n    // Token symbol\r\n    string internal symbol_;\r\n\r\n    // Mapping from miner to list of minted token IDs\r\n    mapping(address => uint256[]) internal mintedTokens;\r\n\r\n    // Mapping from token ID to index of the miner tokens list\r\n    mapping(uint256 => uint256) internal mintedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] internal allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) internal tokenURIs;\r\n\r\n    // Mapping from token ID to miner\r\n    mapping (uint256 => address) internal tokenMiner;\r\n\r\n    // Mapping from miner to number of minted token\r\n    mapping (address => uint256) internal mintedTokensCount;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) internal tokenOwner;\r\n\r\n    //\r\n    mapping (address => uint256) internal lastMintMoment;\r\n\r\n    event Mint(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor(string memory _name, string memory _symbol) \r\n        public \r\n    {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return _name string representing the token name\r\n     */\r\n    function name() external  view returns (string memory _name) \r\n    {\r\n        _name = name_;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return _symbol string representing the token symbol\r\n     */\r\n    function symbol() \r\n        external \r\n        view \r\n        returns (string memory _symbol) \r\n    {\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract\r\n     * @return _amount uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() \r\n        public \r\n        view \r\n        returns (uint256 _amount) \r\n    {\r\n        _amount = allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param _tokenId uint256 ID of the token to query the existence of\r\n     * @return _exists whether the token exists\r\n     */\r\n    function exists(uint256 _tokenId) \r\n        public \r\n        view \r\n        returns (bool _exists) \r\n    {\r\n        address miner = tokenMiner[_tokenId];\r\n        _exists = (miner != address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the miner of the specified token ID\r\n     * @param _tokenId uint256 ID of the token to query the miner of\r\n     * @return _miner miner address currently marked as the miner of the given token ID\r\n     */\r\n    function minerOf(uint256 _tokenId) \r\n        public \r\n        view \r\n        returns (address _miner) \r\n    {\r\n        _miner = tokenMiner[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param _tokenId uint256 ID of the token to query the owner of\r\n     * @return _owner owner address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 _tokenId) \r\n        public \r\n        view \r\n        returns (address _owner) \r\n    {\r\n        require(exists(_tokenId));\r\n        _owner = tokenOwner[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param _tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(uint256 _tokenId) \r\n        public \r\n        view \r\n        returns (string memory _uri) \r\n    {\r\n        require(exists(_tokenId));\r\n        _uri = tokenURIs[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the amount of the specified address\r\n     * @param _miner address to query the balance of\r\n     * @return _amount uint256 representing the amount minted by the passed address\r\n     */\r\n    function amountOf(address _miner) \r\n        public \r\n        view \r\n        returns (uint256 _amount) \r\n    {\r\n        require(_miner != address(0));\r\n        _amount = mintedTokensCount[_miner];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested miner\r\n     * @param _miner address mining the tokens list to be accessed\r\n     * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return _tokenId uint256 token ID at the given index of the tokens list minted by the requested address\r\n     */\r\n    function tokenOfMinerByIndex(\r\n        address _miner,\r\n        uint256 _index\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 _tokenId)\r\n    {\r\n        require(_index < amountOf(_miner));\r\n        _tokenId = mintedTokens[_miner][_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens\r\n     * @param _index uint256 representing the index to be accessed of the tokens list\r\n     * @return _tokenId uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 _index) \r\n        public \r\n        view \r\n        returns (uint256 _tokenId) \r\n    {\r\n        require(_index < totalSupply());\r\n        _tokenId = allTokens[_index];\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev public function to set the token URI for a given token\r\n     * Reverts if the token ID does not exist\r\n     * @param _tokenId uint256 ID of the token to set its URI\r\n     * @param _uri string URI to assign\r\n     */\r\n    function setTokenURI(uint256 _tokenId, string memory _uri) \r\n        public\r\n    {\r\n        require(exists(_tokenId),\"TokenId is not exist\");\r\n        require(minerOf(_tokenId) == msg.sender,\"Only Miner can reset URI\");\r\n        tokenURIs[_tokenId] = _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev public function to mint a new token\r\n     * Reverts if the msg.sender already have minted in a day.\r\n     * @param _uri  the token's URI string.\r\n     */\r\n    function mint(string memory _uri) \r\n        public\r\n    {\r\n        require(canMint(msg.sender));\r\n\r\n        uint256 _tokenId = totalSupply().add(1);\r\n        require(tokenMiner[_tokenId] == address(0));\r\n        tokenMiner[_tokenId] = msg.sender;\r\n        mintedTokensCount[msg.sender] = mintedTokensCount[msg.sender].add(1);\r\n\r\n        uint256 length = mintedTokens[msg.sender].length;\r\n        mintedTokens[msg.sender].push(_tokenId);\r\n        mintedTokensIndex[_tokenId] = length;\r\n        tokenOwner[_tokenId] = address(0);\r\n\r\n        allTokensIndex[_tokenId] = allTokens.length;\r\n        allTokens.push(_tokenId);\r\n        tokenURIs[_tokenId] = _uri;\r\n\r\n        lastMintMoment[msg.sender] = now;\r\n\r\n        emit Mint(msg.sender, address(0), _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev public function to revert eth transfer to this contract.\r\n     * Reverts if any eth transfer to this contract\r\n     */\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * @dev public function to judge whether the address can mint\r\n     * every address can minted once a day.\r\n     * 1581264000 2020/02/10/00:00:00\r\n     * 24*3600 = 86400\r\n     * @param _miner the address to be judged\r\n     * @return _canmint the bool.\r\n     */\r\n    function canMint(address _miner) \r\n        public \r\n        view \r\n        returns(bool _canmint) \r\n    {\r\n        if (lastMintMoment[_miner] == 0) {\r\n            _canmint = true;\r\n        } else {\r\n            uint256 _last = lastMintMoment[_miner];\r\n            uint256 _lastutc_8 = _last.sub(1581264000);\r\n            uint256 _lastspec = _lastutc_8 % 86400;\r\n            if (now.sub(_last).add(_lastspec) > 86400) {\r\n                _canmint = true;\r\n            } else {\r\n                _canmint = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"}],\"name\":\"amountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"}],\"name\":\"canMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_canmint\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"minerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfMinerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NFT","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000011446f63746f72204c6920466f7265766572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a57686973746c656d616e00000000000000000000000000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://79f3e4326a714c9d2f5ea35125634928f737461f6087b874b1e6d818e569c34d"}]}