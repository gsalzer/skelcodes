{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\interfaces\\proxy\\IProxyManager.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IProxyManager {\r\n    function proxyActions() external view returns (address);\r\n    function proxyActionsStorage() external view returns (address);\r\n}\r\n\r\n// File: contracts\\interfaces\\proxy\\IProxyActions.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IProxyActions {\r\n    function setup() external;\r\n}\r\n\r\n// File: contracts\\interfaces\\dss\\IVat.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IVat {\r\n    function hope(address usr) external;\r\n    function gem(bytes32, address) external view returns (uint);\r\n    function dai(address) external view returns (uint);\r\n}\r\n\r\n// File: contracts\\interfaces\\dss\\IETHJoin.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IETHJoin {\r\n    function join(address usr) external payable;\r\n    function exit(address payable usr, uint wad) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\dss\\ITokenJoin.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface ITokenJoin {\r\n    function join(address usr, uint wad) external;\r\n    function exit(address usr, uint wad) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\dss\\IFlip.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract IFlip {\r\n    function tick(uint id) external;\r\n    function tend(uint id, uint lot, uint bid) external;\r\n    function dent(uint id, uint lot, uint bid) external;\r\n    function deal(uint id) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\dss\\IFlap.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract IFlap {\r\n    function tick(uint id) external;\r\n    function tend(uint id, uint lot, uint bid) external;\r\n    function deal(uint id) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\dss\\IFlop.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract IFlop {\r\n    function tick(uint id) external;\r\n    function dent(uint id, uint lot, uint bid) external;\r\n    function deal(uint id) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\token\\IERC20.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\interfaces\\proxy\\IProxyActionsStorage.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IProxyActionsStorage  {\r\n\r\n    function vat() external view returns (IVat);\r\n    function flap() external view returns (IFlap);\r\n    function flop() external view returns (IFlop);\r\n\r\n    function tokens(bytes32) external view returns (IERC20);\r\n    function decimals(bytes32) external view returns (uint);\r\n    function ilks(bytes32) external view returns (bytes32);\r\n    function tokenJoins(bytes32) external view returns (ITokenJoin);\r\n    function flips(bytes32) external view returns (IFlip);\r\n}\r\n\r\n// File: contracts\\proxy\\Proxy.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n/*\r\n    A per-user delegatecall proxy.\r\n    When called with data it delegatecalls into ProxyActions.\r\n    Authentication checks are performed in ProxyActions.\r\n */\r\ncontract Proxy {\r\n\r\n    IProxyManager private manager;\r\n    IProxyActionsStorage private store;\r\n    address private owner;\r\n\r\n    /*\r\n        Constructor is called by ProxyManager.\r\n        After the constructor is done, ProxyManager will call setup()\r\n        which delegatecalls into the actions contract\r\n    */\r\n    constructor(address _owner) public {\r\n        manager = IProxyManager(msg.sender);\r\n        store = IProxyActionsStorage(manager.proxyActionsStorage());\r\n        owner = _owner;\r\n    }\r\n\r\n    /*\r\n        When called with data the current addresses for actions and storage\r\n        are requested from ProxyManager. Afterwards a delegatecall is performed\r\n        into the actions contract. In case the delegatecall fails the contract reverts.\r\n    */\r\n    function() external payable {\r\n        if(msg.data.length != 0) {\r\n            address target = manager.proxyActions();\r\n            store = IProxyActionsStorage(manager.proxyActionsStorage());\r\n\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                calldatacopy(0, 0, calldatasize())\r\n                let result := delegatecall(gas, target, 0, calldatasize(), 0, 0)\r\n                returndatacopy(0, 0, returndatasize())\r\n                switch result\r\n                case 0 { revert(0, returndatasize()) }\r\n                default { return (0, returndatasize()) }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\proxy\\ProxyManager.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n/*\r\n    Manages and deploys user's proxies.\r\n    Stores actions and storage contracts.\r\n\r\n    Storage and actions can be upgraded\r\n    but have to go through a timelock first.\r\n*/\r\ncontract ProxyManager {\r\n\r\n    address public owner;\r\n    address public proxyActions;\r\n    address public proxyActionsStorage;\r\n\r\n    uint public timelockDuration;\r\n    uint public currentTimelock;\r\n\r\n    uint public pendingTimelockDuration;\r\n    address public pendingProxyActions;\r\n    address public pendingProxyActionsStorage;\r\n\r\n    mapping(address => address) public proxies;\r\n\r\n    event ValuesSubmittedForTimelock(uint pendingTimelockDuration, address pendingProxyActions, address pendingProxyActionsStorage);\r\n    event NewTimelockDuration(uint old, uint updated);\r\n    event NewProxyActions(address old, address updated);\r\n    event NewProxyActionsStorage(address old, address updated);\r\n\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"ProxyManager / onlyOwner: not allowed\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _proxyActions, address _proxyActionsStorage) public {\r\n        owner = msg.sender;\r\n        proxyActions = _proxyActions;\r\n        proxyActionsStorage = _proxyActionsStorage;\r\n        timelockDuration = 3 days;\r\n\r\n        emit NewTimelockDuration(0, timelockDuration);\r\n        emit NewProxyActions(address(0), _proxyActions);\r\n        emit NewProxyActionsStorage(address(0), _proxyActionsStorage);\r\n    }\r\n\r\n    /*\r\n        Submit new values for the timelock.\r\n    */\r\n    function submitTimelockValues(\r\n        uint _pendingTimelockDuration,\r\n        address _pendingProxyActions,\r\n        address _pendingProxyActionsStorage\r\n    ) external onlyOwner {\r\n        require(_pendingTimelockDuration <= 7 days, \"ProxyManager / submitTimelockValues: duration too high\");\r\n\r\n        pendingTimelockDuration = _pendingTimelockDuration;\r\n        pendingProxyActions = _pendingProxyActions;\r\n        pendingProxyActionsStorage = _pendingProxyActionsStorage;\r\n\r\n        // solium-disable-next-line security/no-block-members\r\n        currentTimelock = now + timelockDuration;\r\n\r\n        emit ValuesSubmittedForTimelock(_pendingTimelockDuration, _pendingProxyActions, _pendingProxyActionsStorage);\r\n    }\r\n\r\n    /*\r\n        Implement the values which have\r\n        gone through the timelock.\r\n    */\r\n    function implementTimelockValues() external onlyOwner {\r\n        // solium-disable-next-line security/no-block-members\r\n        require(now > currentTimelock, \"ProxyManager / implementTimelockValues: timelock not over\");\r\n\r\n        if(pendingTimelockDuration != 0) {\r\n            emit NewTimelockDuration(timelockDuration, pendingTimelockDuration);\r\n            timelockDuration = pendingTimelockDuration;\r\n            pendingTimelockDuration = 0;\r\n        }\r\n\r\n        if(pendingProxyActions != address(0)) {\r\n            emit NewProxyActions(proxyActions, pendingProxyActions);\r\n            proxyActions = pendingProxyActions;\r\n            pendingProxyActions = address(0);\r\n        }\r\n\r\n        if(pendingProxyActionsStorage != address(0)) {\r\n            emit NewProxyActionsStorage(proxyActionsStorage, pendingProxyActionsStorage);\r\n            proxyActionsStorage = pendingProxyActionsStorage;\r\n            pendingProxyActionsStorage = address(0);\r\n        }\r\n\r\n        currentTimelock = 0;\r\n    }\r\n\r\n    /*\r\n        Deploy a proxy for a user\r\n        and initialize it.\r\n    */\r\n    function deploy() external {\r\n        require(proxies[msg.sender] == address(0), \"ProxyManager / deploy: already deployed\");\r\n        address newProxy = address(new Proxy(msg.sender));\r\n        proxies[msg.sender] = newProxy;\r\n        IProxyActions(newProxy).setup();\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proxyActionsStorage\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"updated\",\"type\":\"address\"}],\"name\":\"NewProxyActions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"updated\",\"type\":\"address\"}],\"name\":\"NewProxyActionsStorage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"old\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updated\",\"type\":\"uint256\"}],\"name\":\"NewTimelockDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingTimelockDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingProxyActions\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingProxyActionsStorage\",\"type\":\"address\"}],\"name\":\"ValuesSubmittedForTimelock\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deploy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"implementTimelockValues\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingProxyActions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingProxyActionsStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingTimelockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proxies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyActions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyActionsStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingTimelockDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pendingProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pendingProxyActionsStorage\",\"type\":\"address\"}],\"name\":\"submitTimelockValues\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timelockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProxyManager","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d935aa2c93266d2c9b64f9879e74fbe7b11267ab000000000000000000000000b7cb190beda5b5c671d111194c27d553106dc662","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://f639bb126771548e9a700b210b4633368713f74580a0b4659441ee4932ecfc9d"}]}