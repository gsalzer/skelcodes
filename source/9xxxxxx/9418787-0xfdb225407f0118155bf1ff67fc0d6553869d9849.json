{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n// File: openzeppelin-solidity\\contracts\\math\\Math.sol\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\HORSEMigrator.sol\r\n\r\ncontract IERC20Mintable is IERC20 {\r\n    function mint(address account, uint256 amount) external returns (bool);\r\n    function isMinter(address account) external view returns (bool);\r\n    function renounceMinter() external;\r\n}\r\n\r\ncontract IERC20Burnable is IERC20 {\r\n    function burn(uint256 _value) external;\r\n}\r\n\r\n/// heavily inspired by ERC20Migrator in openzeppelin-solidity/contracts/drafts\r\ncontract HORSEMigrator {\r\n    /// Address of the old token contract\r\n    IERC20Burnable public legacyToken = IERC20Burnable(0x5B0751713b2527d7f002c0c4e2a37e1219610A6B);\r\n\r\n    /// Address of the TRIBE token contract\r\n    IERC20Mintable public TRIBEToken;\r\n\r\n    /// Address of the DECENT token contract\r\n    IERC20Mintable public DECENTToken;\r\n\r\n    uint256 horseToTribeRatio = 0.1 ether; // you'll get 1 tribe for 10 horse\r\n    uint256 horseToDecentRatio = 0.000001 ether; //you'll get 1 DECENT for 1M HORSE\r\n\r\n    uint256 public migrationTime = 5 weeks;\r\n    uint256 public migrationEnds;\r\n\r\n    /**\r\n     * @dev Begins the migration by setting both tokens to be\r\n     * minted. This contract must be a minter for the new tokens.\r\n     * @param tribeContract the tribe token to be minted\r\n     * @param decentContract the decent token to be minted\r\n     */\r\n    function beginMigration(IERC20Mintable tribeContract, IERC20Mintable decentContract) public {\r\n        require(migrationEnds == 0, \"migration already started\");\r\n        require((address(tribeContract) != address(0)) && (address(decentContract) != address(0)), \"new token is the zero address\");\r\n\r\n        require(tribeContract.isMinter(address(this)), \"not a minter for tribe\");\r\n        require(decentContract.isMinter(address(this)), \"not a minter for decent\");\r\n\r\n        migrationEnds = now + migrationTime;\r\n\r\n        TRIBEToken = tribeContract;\r\n        DECENTToken = decentContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers part of an account's balance in the old token to this\r\n     * contract, and mints the corrent amount of new tokens for that account.\r\n     * @param account whose tokens will be migrated\r\n     * @param amount amount of tokens to be migrated\r\n     */\r\n    function migrate(address account, uint256 amount) notEnded() public {\r\n        require(address(TRIBEToken) != address(0), \"migration not started\");\r\n        legacyToken.transferFrom(account, address(this), amount);\r\n        legacyToken.burn(amount);\r\n        TRIBEToken.mint(account, amount * horseToTribeRatio / 1 ether);\r\n        DECENTToken.mint(account, amount * horseToDecentRatio / 1 ether);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers all of an account's allowed balance in the old token to\r\n     * this contract, and mints the same amount of new tokens for that account.\r\n     * @param account whose tokens will be migrated\r\n     */\r\n    function migrateAll(address account) public {\r\n        uint256 balance = legacyToken.balanceOf(account);\r\n        uint256 allowance = legacyToken.allowance(account, address(this));\r\n        uint256 amount = Math.min(balance, allowance);\r\n        migrate(account, amount);\r\n    }\r\n\r\n    modifier notEnded() {\r\n        require(now < migrationEnds, \"Swapping ended\");\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"DECENTToken\",\"outputs\":[{\"internalType\":\"contract IERC20Mintable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TRIBEToken\",\"outputs\":[{\"internalType\":\"contract IERC20Mintable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20Mintable\",\"name\":\"tribeContract\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Mintable\",\"name\":\"decentContract\",\"type\":\"address\"}],\"name\":\"beginMigration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"legacyToken\",\"outputs\":[{\"internalType\":\"contract IERC20Burnable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"migrateAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationEnds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"HORSEMigrator","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://2656d5a11bbf7815c94fa4a7f6d06ce0b2e99bf4ecffa5e1189fda37260a365c"}]}