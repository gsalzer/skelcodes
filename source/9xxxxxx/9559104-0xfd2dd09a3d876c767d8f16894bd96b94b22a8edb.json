{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nlibrary Address {\\r\\n \\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"},\"AuthModule.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ncontract AuthModule {\\r\\n\\r\\n    address primaryAdmin;\\r\\n    address primaryIssuer;\\r\\n    address primaryExchange;\\r\\n\\r\\n    event JobshipTransferred(\\r\\n        string  strType,\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner,\\r\\n        address indexed caller\\r\\n      );\\r\\n\\r\\n    constructor(\\r\\n        address _admin, \\r\\n        address _issuer, \\r\\n        address _exchange\\r\\n    ) \\r\\n        public \\r\\n    {\\r\\n        primaryAdmin = _admin;\\r\\n        primaryIssuer = _issuer;\\r\\n        primaryExchange = _exchange;\\r\\n    }\\r\\n\\r\\n    function isAdmin(address _admin) public view returns (bool) {\\r\\n        return primaryAdmin == _admin;\\r\\n    }\\r\\n\\r\\n    function isIssuer(address _issuer) public view returns (bool) {\\r\\n        return primaryIssuer == _issuer;\\r\\n    }\\r\\n\\r\\n    function isExchange(address _exchange) public view returns (bool) {\\r\\n        return primaryExchange == _exchange;\\r\\n    }\\r\\n\\r\\n    function transferIssuer(address _addr) public returns (bool) {\\r\\n        require (_addr != address(0) \\u0026\\u0026 _addr != primaryIssuer, \\\"_addr invalid\\\");\\r\\n        require (isIssuer(msg.sender) || isAdmin(msg.sender), \\\"only issuer or admin\\\");\\r\\n\\r\\n        emit JobshipTransferred(\\\"issuer\\\", primaryIssuer, _addr, msg.sender);\\r\\n        primaryIssuer = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferExchange(address _addr) public returns(bool) {\\r\\n        require (_addr != address(0) \\u0026\\u0026 _addr != primaryExchange, \\\"_addr invalid\\\");\\r\\n        require (isExchange(msg.sender) || isAdmin(msg.sender), \\\"only exchange or admin\\\");\\r\\n\\r\\n        emit JobshipTransferred(\\\"exchange\\\", primaryExchange, _addr, msg.sender);\\r\\n        primaryExchange = _addr;\\r\\n        return true;\\r\\n    }\\r\\n}\"},\"Authorization.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport \\\"ContractBase.sol\\\";\\r\\nimport \\\"Pausable.sol\\\";\\r\\nimport \\\"AuthModule.sol\\\";\\r\\n\\r\\ncontract Authorization is ContractBase, Pausable{\\r\\n    \\r\\n    constructor(address _proxy) public ContractBase(_proxy) {\\r\\n\\r\\n    }\\r\\n\\r\\n    modifier onlyInside(address _sender) {\\r\\n        require(proxy.isInsideContract(_sender), \\\"Can only be called inside\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyIssuer(address _sender) {\\r\\n        AuthModule auth = AuthModule(proxy.getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isIssuer(_sender), \\\"Need to be issuer\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin(address _sender) {\\r\\n        AuthModule auth = AuthModule(proxy.getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isAdmin(_sender), \\\"Need to be admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyExchange(address _sender) {\\r\\n        AuthModule auth = AuthModule(proxy.getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isExchange(_sender), \\\"Need to be exchange\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyIssuerOrExchange(address _sender) {\\r\\n        AuthModule auth = AuthModule(proxy.getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isIssuer(_sender) || auth.isExchange(_sender), \\\"Need to be issuer or exchange\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyTokenModule(address _sender) {\\r\\n        require(_sender == proxy.getModule(\\\"TokenModule\\\"), \\\"Need to be tokenModule\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function unpause() public onlyAdmin(msg.sender)  {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    function pause() public onlyAdmin(msg.sender) {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n}\"},\"ComplianceModule.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"Proxy.sol\\\";\\r\\nimport \\\"StorageModule.sol\\\";\\r\\nimport \\\"TokenModule.sol\\\";\\r\\nimport \\\"Authorization.sol\\\";\\r\\nimport \\\"ICompliance.sol\\\";\\r\\n\\r\\ncontract ComplianceModule is Authorization {\\r\\n\\r\\n    mapping (bytes32 =\\u003e ICompliance[] ) public nationalCompliances;\\r\\n    ICompliance[] generalCompliances;\\r\\n\\r\\n    event UpdateNationalCompliance(bytes32 _country, address _compliance);\\r\\n    event RemoveNationalCompliance(bytes32 _country, address _compliance);\\r\\n    event UpdateGeneralCompliance(address _compliance);\\r\\n    event RemoveGeneralCompliance(address _compliance);\\r\\n\\r\\n    constructor(address _proxy) public Authorization(_proxy) {\\r\\n        \\r\\n    }\\r\\n\\r\\n    function mintCheck(address[] _investors, uint256[] _amounts) public view returns (bool) {\\r\\n        StorageModule sm = StorageModule(proxy.getModule(\\\"StorageModule\\\"));\\r\\n        \\r\\n        if(sm.shareholderExceeded(_investors.length) || sm.isTXFrozen())\\r\\n            return false;\\r\\n        for(uint i = 0; i\\u003c_investors.length; i++) \\r\\n        {\\r\\n            if(sm.isInvestorInWhitelist(_investors[i]) == false || sm.isInBlacklist(_investors[i]))\\r\\n                return false;\\r\\n\\r\\n            // general compliance\\r\\n            for(uint j = 0; j\\u003c generalCompliances.length; j++) \\r\\n            {\\r\\n                if(generalCompliances[j] != address(0) \\u0026\\u0026 generalCompliances[j].mintCheck(_investors[i], _amounts[i]) == false)\\r\\n                    return false;\\r\\n            }\\r\\n\\r\\n            // national compliance\\r\\n            bytes32 country = sm.getInvestorCountry(_investors[i]);\\r\\n            for(j = 0; j\\u003c nationalCompliances[country].length; j++) \\r\\n            {\\r\\n                if(nationalCompliances[country][j] != address(0) \\u0026\\u0026 nationalCompliances[country][j].mintCheck(_investors[i], _amounts[i]) == false)\\r\\n                    return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // TODO: should return result code not bool\\r\\n    // will be called while mint, burn and transaction\\r\\n    function txCheck(\\r\\n        address _from, \\r\\n        address _to, \\r\\n        uint256 _amount\\r\\n    ) \\r\\n        public \\r\\n        view\\r\\n        whenNotPaused \\r\\n        returns (bool) \\r\\n    {\\r\\n        StorageModule sm = StorageModule(proxy.getModule(\\\"StorageModule\\\"));\\r\\n        if(sm.isInvestorInWhitelist(_to) == false || sm.isInBlacklist(_from) || sm.isInBlacklist(_to) || sm.isTXFrozen())\\r\\n            return false;\\r\\n\\r\\n        // general compliance\\r\\n        for(uint i = 0; i\\u003c generalCompliances.length; i++) \\r\\n        {\\r\\n            if(generalCompliances[i] != address(0) \\u0026\\u0026 generalCompliances[i].txCheck(_to, _amount) == false)\\r\\n                return false;\\r\\n        }\\r\\n\\r\\n        // national compliance\\r\\n        bytes32 country = sm.getInvestorCountry(_to);\\r\\n        \\r\\n        for( i = 0; i\\u003c nationalCompliances[country].length; i++) \\r\\n        {\\r\\n            if(nationalCompliances[country][i] != address(0) \\u0026\\u0026 nationalCompliances[country][i].txCheck(_to, _amount) == false)\\r\\n                return false;\\r\\n        }\\r\\n            \\r\\n        if(sm.shareholderExceeded(1) == false) \\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n        else \\r\\n        {\\r\\n            TokenModule token = TokenModule(proxy.getModule(\\\"TokenModule\\\"));\\r\\n            uint256 balance = token.balanceOf(_from);\\r\\n            if(balance == _amount) {\\r\\n                // if the balance of _from is 0 after transaction, the new shareholder can swap out _from\\r\\n                // even if there is no available quota for new shareholder.\\r\\n                return true;    \\r\\n            }         \\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateNationalCompliance\\r\\n    (\\r\\n        bytes32 _country,\\r\\n        address _compliance\\r\\n    )\\r\\n        public\\r\\n        whenNotPaused\\r\\n        onlyAdmin(msg.sender)\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint length = nationalCompliances[_country].length;\\r\\n        uint firstAvaiPlace = length;\\r\\n        for(uint i = 0; i\\u003c length; i++) \\r\\n        {\\r\\n            if(nationalCompliances[_country][i] == _compliance) // just return\\r\\n            {\\r\\n                return false;\\r\\n            }\\r\\n            if (nationalCompliances[_country][i] == address(0) \\u0026\\u0026 firstAvaiPlace == length)\\r\\n            {\\r\\n                firstAvaiPlace = i;\\r\\n            }\\r\\n        }\\r\\n        if (firstAvaiPlace \\u003c length) \\r\\n        {\\r\\n            nationalCompliances[_country][firstAvaiPlace] = ICompliance(_compliance);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            nationalCompliances[_country].push(ICompliance(_compliance));\\r\\n        }\\r\\n        emit UpdateNationalCompliance(_country, _compliance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeNationalCompliance\\r\\n    (\\r\\n        bytes32 _country,\\r\\n        address _compliance\\r\\n    )\\r\\n        public\\r\\n        whenNotPaused\\r\\n        onlyAdmin(msg.sender)\\r\\n        returns(bool result)\\r\\n    {\\r\\n        uint length = nationalCompliances[_country].length;\\r\\n\\r\\n        for(uint i = 0; i\\u003c length; i++) \\r\\n        {\\r\\n            if(nationalCompliances[_country][i] == _compliance)\\r\\n            {\\r\\n                delete nationalCompliances[_country][i];\\r\\n                emit RemoveNationalCompliance(_country, _compliance);\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function updateGeneralCompliance\\r\\n    (\\r\\n        address _compliance\\r\\n    )\\r\\n        public\\r\\n        whenNotPaused\\r\\n        onlyAdmin(msg.sender)\\r\\n        returns(bool result)\\r\\n    {\\r\\n        uint length = generalCompliances.length;\\r\\n        uint firstAvaiPlace = length;\\r\\n        for(uint i = 0; i \\u003c length; i++) \\r\\n        {\\r\\n            if(generalCompliances[i] == _compliance)\\r\\n            {\\r\\n                return false;\\r\\n            }\\r\\n            if (generalCompliances[i] == address(0) \\u0026\\u0026 firstAvaiPlace == length)\\r\\n            {\\r\\n                firstAvaiPlace = i;\\r\\n            }\\r\\n        }\\r\\n        if (firstAvaiPlace \\u003c length)\\r\\n        {\\r\\n            generalCompliances[firstAvaiPlace] = ICompliance(_compliance);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            generalCompliances.push(ICompliance(_compliance));\\r\\n        }\\r\\n        \\r\\n        emit UpdateGeneralCompliance(_compliance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeGeneralCompliance\\r\\n    (\\r\\n        address _compliance\\r\\n    )\\r\\n        public\\r\\n        whenNotPaused\\r\\n        onlyAdmin(msg.sender)\\r\\n        returns(bool result)\\r\\n    {\\r\\n        uint length = generalCompliances.length;\\r\\n\\r\\n        for(uint i = 0; i \\u003c length; i++) \\r\\n        {\\r\\n            if(generalCompliances[i] == _compliance)\\r\\n            {\\r\\n                delete generalCompliances[i];\\r\\n                emit RemoveGeneralCompliance(_compliance);\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n}\"},\"ContractBase.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport \\\"Proxy.sol\\\";\\r\\n\\r\\ncontract ContractBase {\\r\\n    \\r\\n    Proxy proxy;\\r\\n\\r\\n    constructor(address _proxy) public {\\r\\n        proxy = Proxy(_proxy);\\r\\n    }\\r\\n    \\r\\n}\"},\"ERC20Authorization.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport \\\"ComplianceModule.sol\\\";\\r\\nimport \\\"StorageModule.sol\\\";\\r\\nimport \\\"Authorization.sol\\\";\\r\\n\\r\\ncontract ERC20Authorization is Authorization{\\r\\n    \\r\\n    constructor(address _proxy) public Authorization(_proxy) {\\r\\n\\r\\n    }\\r\\n\\r\\n    modifier onlyTxCheck(address _from, address _to, uint256 _amount) {\\r\\n        ComplianceModule comp = ComplianceModule(proxy.getModule(\\\"ComplianceModule\\\"));\\r\\n        require(comp.txCheck(_from, _to, _amount), \\\"Need to be txCheck\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyMintCheck(address[] _to, uint256[] _amounts) {\\r\\n        require(ComplianceModule(proxy.getModule(\\\"ComplianceModule\\\")).mintCheck(_to, _amounts), \\\"Need to be mintCheck\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function updateShareholders(address _from, address _to) internal {\\r\\n        StorageModule stor = StorageModule(proxy.getModule(\\\"StorageModule\\\"));\\r\\n        stor.updateShareholders(_from, _to);\\r\\n    }\\r\\n\\r\\n}\"},\"ERC20Impl.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"ERC20Proxy.sol\\\";\\r\\nimport \\\"ERC20Store.sol\\\";\\r\\nimport \\\"ERC20Authorization.sol\\\";\\r\\nimport \\\"LockRequestable.sol\\\";\\r\\n\\r\\ncontract ERC20Impl is ERC20Authorization, LockRequestable {\\r\\n\\r\\n    struct PendingTransfer{\\r\\n        address sender;\\r\\n        address from;\\r\\n        address to;\\r\\n        uint value;\\r\\n    }\\r\\n\\r\\n    mapping (bytes32=\\u003ePendingTransfer) pendingTransferMap;\\r\\n\\r\\n    ERC20Proxy public erc20Proxy;\\r\\n    ERC20Store public erc20Store;\\r\\n\\r\\n    event TransferRequest(bytes32 lockId, address _sender, address _from, address _to, uint _amount);\\r\\n\\r\\n    constructor(\\r\\n        address _erc20Proxy, \\r\\n        address _erc20Store, \\r\\n        address _proxy\\r\\n    ) \\r\\n        public \\r\\n        ERC20Authorization(_proxy) \\r\\n        LockRequestable()\\r\\n    {\\r\\n        erc20Proxy = ERC20Proxy(_erc20Proxy);\\r\\n        erc20Store = ERC20Store(_erc20Store);\\r\\n    }\\r\\n\\r\\n    modifier onlyProxy {\\r\\n        require(msg.sender == address(erc20Proxy), \\\"Only ERC20Proxy can call\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return erc20Store.totalSupply();\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\r\\n        return erc20Store.getBalance(_owner);\\r\\n    }\\r\\n\\r\\n    function balanceOfLock(address _owner) public view returns (uint256[] lockBalanceTimestamps, uint256[] lockBalanceValues) {\\r\\n        return erc20Store.getAllLockBalances(_owner);\\r\\n    }\\r\\n\\r\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\\r\\n        return erc20Store.allowed(_owner, _spender);\\r\\n    }\\r\\n\\r\\n    function approveWithSender(\\r\\n        address _sender, \\r\\n        address _spender, \\r\\n        uint256 _value\\r\\n    ) \\r\\n        public \\r\\n        whenNotPaused\\r\\n        onlyProxy \\r\\n        returns (bool)\\r\\n    {\\r\\n        require(_spender != address(0), \\\"_spender can not be 0\\\");\\r\\n        erc20Store.setAllowance(_sender, _spender, _value);\\r\\n        erc20Proxy.emitApproval(_sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseApprovalWithSender(\\r\\n        address _sender,\\r\\n        address _spender,\\r\\n        uint256 _addedValue\\r\\n    )\\r\\n        public \\r\\n        whenNotPaused\\r\\n        onlyProxy \\r\\n        returns (bool success)\\r\\n    {\\r\\n        require(_spender != address(0), \\\"_spender can not be 0\\\");\\r\\n        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\\r\\n        uint256 newAllowance = currentAllowance + _addedValue;\\r\\n\\r\\n        require(newAllowance \\u003e= currentAllowance, \\\"newAllowance should greater equal then currentAllowance\\\");\\r\\n\\r\\n        erc20Store.setAllowance(_sender, _spender, newAllowance);\\r\\n        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseApprovalWithSender(\\r\\n        address _sender,\\r\\n        address _spender,\\r\\n        uint256 _subtractedValue\\r\\n    )\\r\\n        public\\r\\n        whenNotPaused \\r\\n        onlyProxy \\r\\n        returns (bool success)\\r\\n    {\\r\\n        require(_spender != address(0), \\\"_spender can not be 0\\\");\\r\\n        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\\r\\n        uint256 newAllowance = currentAllowance - _subtractedValue;\\r\\n\\r\\n        require(newAllowance \\u003c= currentAllowance, \\\"newAllowance should greater equal then currentAllowance\\\");\\r\\n\\r\\n        erc20Store.setAllowance(_sender, _spender, newAllowance);\\r\\n        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFromWithSender(\\r\\n        address _sender,\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    )\\r\\n        public \\r\\n        whenNotPaused\\r\\n        onlyProxy \\r\\n        onlyTxCheck(_from, _to, _value) \\r\\n        returns (bool)\\r\\n    {\\r\\n        require(_to != address(0), \\\"_to can not be 0\\\");\\r\\n\\r\\n        erc20Store.adjustLockBalance(_from);\\r\\n        uint256 balanceOfFrom = erc20Store.balances(_from);\\r\\n        require(_value \\u003c= balanceOfFrom, \\\"_value should less equal balanceOfFrom\\\");\\r\\n\\r\\n        uint256 senderAllowance = erc20Store.allowed(_from, _sender);\\r\\n        require(_value \\u003c= senderAllowance, \\\"_value should less equal senderAllowance\\\");\\r\\n\\r\\n        bytes32 lockId = generateLockId();\\r\\n        pendingTransferMap[lockId] = PendingTransfer({\\r\\n            sender : _sender,\\r\\n            from: _from,\\r\\n            to: _to,\\r\\n            value: _value\\r\\n        });\\r\\n\\r\\n        emit TransferRequest(lockId, _sender, _from, _to, _value);\\r\\n\\r\\n        //自动审批\\r\\n        _transferConfirm(lockId);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function transferWithSender(\\r\\n        address _sender,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    )\\r\\n        public\\r\\n        onlyProxy \\r\\n        whenNotPaused\\r\\n        onlyTxCheck(_sender, _to, _value) \\r\\n        returns (bool success)\\r\\n    {\\r\\n        require(_to != address(0), \\\"_to can not be 0\\\");\\r\\n\\r\\n        erc20Store.adjustLockBalance(_sender);\\r\\n        uint256 balanceOfSender = erc20Store.balances(_sender);\\r\\n        require(_value \\u003c= balanceOfSender, \\\"balance not enouth\\\");\\r\\n\\r\\n        bytes32 lockId = generateLockId();\\r\\n        pendingTransferMap[lockId] = PendingTransfer({\\r\\n            sender : _sender,\\r\\n            from: _sender,\\r\\n            to: _to,\\r\\n            value: _value\\r\\n        });\\r\\n\\r\\n        emit TransferRequest(lockId, _sender, _sender, _to, _value);\\r\\n\\r\\n        //自动审批\\r\\n        _transferConfirm(lockId);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferConfirm(bytes32 _lockId) \\r\\n        public \\r\\n        whenNotPaused\\r\\n        onlyIssuer(msg.sender) \\r\\n    {\\r\\n        _transferConfirm(_lockId);\\r\\n    }\\r\\n\\r\\n    // 自动审批单独提出来，去掉 onlyIssuer modifier\\r\\n    function _transferConfirm(bytes32 _lockId) \\r\\n        private \\r\\n        whenNotPaused\\r\\n    {\\r\\n        PendingTransfer storage pending = pendingTransferMap[_lockId];\\r\\n        require(pending.sender != address(0), \\\"lockId not found\\\");\\r\\n        erc20Store.adjustLockBalance(pending.from);\\r\\n        uint256 balanceOfFrom = erc20Store.balances(pending.from);\\r\\n        require(pending.value \\u003c= balanceOfFrom, \\\"pending value should less equal balanceOfFrom\\\");\\r\\n\\r\\n        if(pending.from != pending.sender){\\r\\n            uint256 senderAllowance = erc20Store.allowed(pending.from, pending.sender);\\r\\n            require(pending.value \\u003c= senderAllowance, \\\"pending value should less equal senderAllowance\\\");\\r\\n        }\\r\\n\\r\\n        PendingTransfer memory _pending = pending;\\r\\n\\r\\n        delete pendingTransferMap[_lockId];\\r\\n\\r\\n        erc20Store.setBalance(_pending.from, balanceOfFrom - _pending.value);\\r\\n        erc20Store.addBalance(_pending.to, _pending.value);\\r\\n\\r\\n        if(_pending.from != _pending.sender) {\\r\\n            erc20Store.setAllowance(_pending.from, _pending.sender, senderAllowance - _pending.value);\\r\\n        }\\r\\n\\r\\n        updateShareholders(_pending.from, _pending.to);\\r\\n\\r\\n        erc20Proxy.emitTransfer(_pending.from, _pending.to, _pending.value);\\r\\n    }\\r\\n\\r\\n    function revertTransfer\\r\\n    (\\r\\n        uint _tx,\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint _value\\r\\n    ) \\r\\n        public \\r\\n        whenNotPaused\\r\\n        onlyProxy\\r\\n    {\\r\\n        if(_from != address(0)) {\\r\\n            erc20Store.adjustLockBalance(_from);\\r\\n            uint256 balanceOfFrom = erc20Store.balances(_from);\\r\\n            require(_value \\u003c= balanceOfFrom, \\\"value should less equal balanceOfFrom\\\");\\r\\n            erc20Store.setBalance(_from, balanceOfFrom - _value);\\r\\n        }\\r\\n        \\r\\n        if(_to != address(0)) {\\r\\n            erc20Store.addBalance(_to, _value);\\r\\n        }\\r\\n\\r\\n        updateShareholders(_from, _to);\\r\\n        erc20Proxy.emitTransfer(_from, _to, _value);\\r\\n        erc20Proxy.emitRevertTransfer(_tx);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"},\"ERC20ImplUpgradeable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"IERC20ImplUpgradeable.sol\\\";\\r\\nimport \\\"ERC20Impl.sol\\\";\\r\\nimport \\\"ERC20MintBurn.sol\\\";\\r\\nimport \\\"Authorization.sol\\\";\\r\\n\\r\\ncontract ERC20ImplUpgradeable is IERC20ImplUpgradeable, Authorization {\\r\\n\\r\\n    ERC20Impl public erc20Impl;\\r\\n    ERC20MintBurn public erc20MintBurn;\\r\\n\\r\\n    event UpdateImpl(address _old, address _new);\\r\\n    event UpdateMintBurn(address _old, address _new);\\r\\n\\r\\n    modifier onlyImpl {\\r\\n        require(this.isImplAddress(msg.sender), \\\"Only Impl can call\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _proxy) public Authorization(_proxy) {\\r\\n    }\\r\\n\\r\\n    function isImplAddress(address sender) view external returns(bool) {\\r\\n        return sender == address(erc20Impl) || sender == address(erc20MintBurn);\\r\\n    }\\r\\n\\r\\n    function updateImpl(address _erc20Impl) external onlyAdmin(msg.sender) {\\r\\n        require(_erc20Impl != 0x0, \\\"address is zero\\\"); \\r\\n\\r\\n        address _old = erc20Impl;\\r\\n        erc20Impl = ERC20Impl(_erc20Impl);\\r\\n        emit UpdateImpl(_old, _erc20Impl);\\r\\n    }\\r\\n\\r\\n    function getImplAddress() view external returns(address) {\\r\\n        return erc20Impl;\\r\\n    }\\r\\n\\r\\n    function updateMintBurn(address _erc20Impl) external onlyAdmin(msg.sender) {\\r\\n        require(_erc20Impl != 0x0, \\\"address is zero\\\"); \\r\\n        \\r\\n        address _old = erc20MintBurn;\\r\\n        erc20MintBurn = ERC20MintBurn(_erc20Impl);\\r\\n        emit UpdateMintBurn(_old, _erc20Impl);\\r\\n    }\\r\\n\\r\\n    function getMintBurnAddress() view external returns(address) {\\r\\n        return erc20MintBurn;\\r\\n    }\\r\\n    \\r\\n}\"},\"ERC20MintBurn.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"ERC20Proxy.sol\\\";\\r\\nimport \\\"ERC20Store.sol\\\";\\r\\nimport \\\"ERC20Authorization.sol\\\";\\r\\n\\r\\ncontract ERC20MintBurn is ERC20Authorization, IERC20Mintable, IERC20Burnable {\\r\\n\\r\\n    ERC20Proxy public erc20Proxy;\\r\\n    ERC20Store public erc20Store;\\r\\n\\r\\n    event Mint(address[] _investors, uint256[] _values, uint256[] _timestamps);\\r\\n\\r\\n    constructor (\\r\\n        address _erc20Proxy, \\r\\n        address _erc20Store, \\r\\n        address _proxy\\r\\n    ) \\r\\n        public \\r\\n        ERC20Authorization(_proxy) \\r\\n    {\\r\\n        erc20Proxy = ERC20Proxy(_erc20Proxy);\\r\\n        erc20Store = ERC20Store(_erc20Store);\\r\\n    }\\r\\n\\r\\n    function mint(\\r\\n        address[] _receivers, \\r\\n        uint256[] _values, \\r\\n        uint256[] _timestamps\\r\\n    ) \\r\\n        external \\r\\n        whenNotPaused\\r\\n        onlyTokenModule(msg.sender)\\r\\n        onlyMintCheck(_receivers, _values)\\r\\n    {\\r\\n        require (_receivers.length == _values.length \\u0026\\u0026 _values.length == _timestamps.length, \\\"param arrays length not equal\\\");\\r\\n        \\r\\n        uint256 oldSupply;\\r\\n        uint256 newSupply = erc20Store.totalSupply();\\r\\n\\r\\n        for(uint i = 0; i \\u003c _receivers.length; ++i) {\\r\\n            oldSupply = newSupply;\\r\\n            newSupply = oldSupply + _values[i];\\r\\n            require (newSupply \\u003e= oldSupply, \\\"uint overflow\\\");\\r\\n            if(_timestamps[i] \\u003e 0)\\r\\n                erc20Store.addLockBalance(_receivers[i], _values[i], _timestamps[i]);\\r\\n            else \\r\\n                erc20Store.addBalance(_receivers[i], _values[i]);\\r\\n            erc20Proxy.emitTransfer(address(0), _receivers[i], _values[i]);\\r\\n        }\\r\\n        erc20Store.setTotalSupply(newSupply);\\r\\n        emit Mint(_receivers, _values, _timestamps);\\r\\n    }\\r\\n\\r\\n    function burn(\\r\\n        address[] _owners, \\r\\n        uint256[] _values,\\r\\n        uint256[] _timestamps\\r\\n    ) \\r\\n        external \\r\\n        whenNotPaused\\r\\n        onlyTokenModule(msg.sender)\\r\\n    {\\r\\n        require ((_owners.length == _values.length) \\u0026\\u0026 (_owners.length == _timestamps.length), \\\"param arrays length not equal\\\");\\r\\n        uint256 balanceOfOwner = 0;\\r\\n        for(uint i = 0; i \\u003c _owners.length; ++i) {\\r\\n            if(_timestamps[i] == 0 || now \\u003e= _timestamps[i]) {\\r\\n                erc20Store.adjustLockBalance(_owners[i]);\\r\\n                balanceOfOwner = erc20Store.balances(_owners[i]);\\r\\n                require(_values[i] \\u003c= balanceOfOwner, \\\"burn vale should less equal balance\\\");\\r\\n                erc20Store.setBalance(_owners[i], balanceOfOwner - _values[i]);\\r\\n            } else {\\r\\n                balanceOfOwner = erc20Store.getLockBalance(_owners[i], _timestamps[i]);\\r\\n                require(_values[i] \\u003c= balanceOfOwner, \\\"burn vale should less equal balance\\\");\\r\\n                erc20Store.setLockBalance(_owners[i], _timestamps[i], balanceOfOwner - _values[i]);\\r\\n            }\\r\\n            erc20Store.setTotalSupply(erc20Store.totalSupply() - _values[i]);\\r\\n            erc20Proxy.emitTransfer(_owners[i], address(0), _values[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function burnAll(address[] _owners) external whenNotPaused onlyTokenModule(msg.sender) {\\r\\n        require (_owners.length != 0, \\\"param _owners is null\\\");\\r\\n        uint balanceOfOwner;\\r\\n        for(uint i = 0; i \\u003c _owners.length; ++i) {\\r\\n            balanceOfOwner = erc20Store.sweep(_owners[i]);\\r\\n            if(balanceOfOwner != 0) {\\r\\n              erc20Store.setTotalSupply(erc20Store.totalSupply() - balanceOfOwner);\\r\\n              erc20Proxy.emitTransfer(_owners[i], address(0), balanceOfOwner);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"ERC20Proxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"ERC20ImplUpgradeable.sol\\\";\\r\\nimport \\\"IERC20.sol\\\";\\r\\n\\r\\ncontract ERC20Proxy is IERC20, ERC20ImplUpgradeable {\\r\\n   \\r\\n    string public name;    \\r\\n    string public symbol;\\r\\n    uint8 public decimals;\\r\\n    string public tokenDetails;\\r\\n\\r\\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\\r\\n    event RevertTransfer(uint _tx);\\r\\n\\r\\n    constructor(\\r\\n        string _name,\\r\\n        string _symbol,\\r\\n        uint8 _decimals,\\r\\n        string _tokenDetails,\\r\\n        address _proxy\\r\\n    )\\r\\n        public \\r\\n        ERC20ImplUpgradeable(_proxy) \\r\\n    {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        decimals = _decimals;\\r\\n        tokenDetails = _tokenDetails;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return erc20Impl.totalSupply();\\r\\n    }\\r\\n    \\r\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\r\\n        return erc20Impl.balanceOf(_owner);\\r\\n    }\\r\\n\\r\\n    function balanceOfLock(address _owner) public view returns (uint256[] lockBalanceTimestamps, uint256[] lockBalanceValues) {\\r\\n        return erc20Impl.balanceOfLock(_owner);\\r\\n    }\\r\\n    \\r\\n    function emitTransfer(address _from, address _to, uint256 _value) public onlyImpl {\\r\\n        emit Transfer(_from, _to, _value);\\r\\n    }\\r\\n    \\r\\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success) {\\r\\n        return erc20Impl.transferWithSender(msg.sender, _to, _value);\\r\\n    }\\r\\n    \\r\\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success) {\\r\\n        return erc20Impl.transferFromWithSender(msg.sender, _from, _to, _value);\\r\\n    }\\r\\n    \\r\\n    function emitApproval(address _owner, address _spender, uint256 _value) public onlyImpl {\\r\\n        emit Approval(_owner, _spender, _value);\\r\\n    }\\r\\n\\r\\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool success) {\\r\\n        return erc20Impl.approveWithSender(msg.sender, _spender, _value);\\r\\n    }\\r\\n\\r\\n    function increaseApproval(address _spender, uint256 _addedValue) whenNotPaused public returns (bool success) {\\r\\n        return erc20Impl.increaseApprovalWithSender(msg.sender, _spender, _addedValue);\\r\\n    }\\r\\n    \\r\\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public whenNotPaused returns (bool success) {\\r\\n        return erc20Impl.decreaseApprovalWithSender(msg.sender, _spender, _subtractedValue);\\r\\n    }\\r\\n\\r\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\\r\\n        return erc20Impl.allowance(_owner, _spender);\\r\\n    }\\r\\n\\r\\n    function revertTransfer\\r\\n    (\\r\\n        uint _tx,\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint _value\\r\\n    ) \\r\\n        public \\r\\n        whenNotPaused\\r\\n        onlyIssuer(msg.sender)\\r\\n    {\\r\\n        erc20Impl.revertTransfer(_tx, _from, _to, _value);\\r\\n    }\\r\\n\\r\\n    function emitRevertTransfer(uint _tx) public onlyImpl {\\r\\n        emit RevertTransfer(_tx);\\r\\n    }\\r\\n\\r\\n    function updateTokenDetails(string _newTokenDetails) public whenNotPaused onlyIssuer(msg.sender) {\\r\\n        emit UpdateTokenDetails(tokenDetails, _newTokenDetails);\\r\\n        tokenDetails = _newTokenDetails;\\r\\n    }\\r\\n\\r\\n}\"},\"ERC20Store.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"IERC20ImplUpgradeable.sol\\\";\\r\\nimport \\\"Authorization.sol\\\";\\r\\nimport \\\"SafeMath.sol\\\";\\r\\n\\r\\ncontract ERC20Store is Authorization {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    struct Balance {\\r\\n        uint256 timestamp;\\r\\n        uint256 value;\\r\\n    }\\r\\n    \\r\\n    IERC20ImplUpgradeable public erc20Proxy;\\r\\n\\r\\n    uint256 public totalSupply;    \\r\\n    mapping (address =\\u003e uint256) public balances;\\r\\n    mapping (address =\\u003e Balance[]) public lockBalances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowed;\\r\\n\\r\\n    event UpdateProxy(address _old, address _new);\\r\\n\\r\\n    constructor(address _proxy) public Authorization(_proxy) {\\r\\n        totalSupply = 0;\\r\\n    }\\r\\n\\r\\n    function updateProxy(address _erc20Proxy) external onlyAdmin(msg.sender) {\\r\\n        address _old = erc20Proxy;\\r\\n        erc20Proxy = IERC20ImplUpgradeable(_erc20Proxy);\\r\\n        emit UpdateProxy(_old, _erc20Proxy);\\r\\n    }\\r\\n\\r\\n    modifier onlyImpl {\\r\\n        require(erc20Proxy.isImplAddress(msg.sender), \\\"Only Impl can call\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setTotalSupply(uint256 _newTotalSupply) public onlyImpl {\\r\\n        totalSupply = _newTotalSupply;\\r\\n    }\\r\\n\\r\\n    function setAllowance(\\r\\n        address _owner, \\r\\n        address _spender, \\r\\n        uint256 _value) \\r\\n        public \\r\\n        onlyImpl \\r\\n    {\\r\\n        allowed[_owner][_spender] = _value;\\r\\n    }\\r\\n\\r\\n    function setBalance(address _owner, uint256 _newBalance) public onlyImpl {\\r\\n        balances[_owner] = _newBalance;\\r\\n    }\\r\\n\\r\\n    function addBalance(address _owner, uint256 _balanceIncrease) public onlyImpl {\\r\\n        balances[_owner] = balances[_owner].add(_balanceIncrease);\\r\\n    }\\r\\n\\r\\n    function setLockBalance(\\r\\n        address _owner, \\r\\n        uint256 _newBalance, \\r\\n        uint256 _timestamp\\r\\n    ) \\r\\n        public \\r\\n        onlyImpl \\r\\n    {\\r\\n        Balance[] storage lockbalance = lockBalances[_owner];\\r\\n        for(uint i = 0; i \\u003c lockbalance.length; ++i){\\r\\n            if(_timestamp == lockbalance[i].timestamp) {\\r\\n                if(now \\u003e= _timestamp){\\r\\n                    uint newBalance = balances[_owner];\\r\\n                    newBalance = newBalance.add(lockbalance[i].value);\\r\\n                    balances[_owner] = newBalance;\\r\\n                }\\r\\n                lockbalance[i].value = _newBalance;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addLockBalance(\\r\\n        address _owner, \\r\\n        uint256 _balanceIncrease, \\r\\n        uint256 _timestamp\\r\\n    ) \\r\\n        public \\r\\n        onlyImpl \\r\\n    {\\r\\n        require(_timestamp \\u003e 0, \\\"_timestamp need greater than 0\\\");\\r\\n\\r\\n        Balance[] storage balance = lockBalances[_owner];\\r\\n        uint insertIndex = balance.length;\\r\\n        for(uint i = 0; i \\u003c balance.length; ++i){\\r\\n            if(insertIndex == balance.length \\u0026\\u0026 balance[i].timestamp == 0) {\\r\\n                insertIndex = i;\\r\\n                continue;\\r\\n            }\\r\\n            if(balance[i].timestamp == _timestamp) {\\r\\n                balance[i].value = balance[i].value.add(_balanceIncrease);\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        if(insertIndex == balance.length)\\r\\n            balance.push(Balance(_timestamp, _balanceIncrease));\\r\\n        else {\\r\\n            balance[insertIndex].timestamp = _timestamp;\\r\\n            balance[insertIndex].value = _balanceIncrease;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function adjustLockBalance(address _owner) public onlyImpl {\\r\\n        Balance[] storage lockbalance = lockBalances[_owner];\\r\\n        uint newBalance = balances[_owner];\\r\\n        for(uint i = 0; i \\u003c lockbalance.length; ++i){\\r\\n            if(now \\u003e= lockbalance[i].timestamp) {\\r\\n                newBalance = newBalance.add(lockbalance[i].value);\\r\\n                delete lockbalance[i];\\r\\n            }\\r\\n        }\\r\\n        balances[_owner] = newBalance;\\r\\n    }\\r\\n\\r\\n    function sweep(address _owner) public onlyImpl returns(uint256 balance) {\\r\\n        balance = balances[_owner];\\r\\n        Balance[] storage lockbalance = lockBalances[_owner];\\r\\n        for(uint i = 0; i \\u003c lockbalance.length; ++i){\\r\\n            balance += lockbalance[i].value;\\r\\n        }\\r\\n        \\r\\n        delete lockBalances[_owner];\\r\\n        delete balances[_owner];\\r\\n    }\\r\\n\\r\\n    function getBalance(address _owner) public view returns(uint256 balance) {\\r\\n        balance = balances[_owner];\\r\\n        Balance[] storage lockBalance = lockBalances[_owner];\\r\\n        for(uint i = 0; i \\u003c lockBalance.length; ++i){\\r\\n            if(now \\u003e= lockBalance[i].timestamp) {\\r\\n                balance += lockBalance[i].value;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getLockBalance(address _owner, uint256 _timestamp) public view returns(uint256) {\\r\\n        if(now \\u003e= _timestamp) {\\r\\n            return 0;\\r\\n        }\\r\\n        Balance[] storage lockBalance = lockBalances[_owner];\\r\\n        for(uint i = 0; i \\u003c lockBalance.length; ++i){\\r\\n            if(_timestamp == lockBalance[i].timestamp) {\\r\\n                return lockBalance[i].value;\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function getAllLockBalances(address _owner) \\r\\n        public \\r\\n        view \\r\\n        returns(\\r\\n            uint256[] lockBalanceTimestamps, \\r\\n            uint256[] lockBalanceValues\\r\\n        ) \\r\\n    {\\r\\n        Balance[] storage lockBalance = lockBalances[_owner];\\r\\n        lockBalanceTimestamps = new uint256[](lockBalance.length);\\r\\n        lockBalanceValues = new uint256[](lockBalance.length);\\r\\n        uint j = 0;\\r\\n        for(uint i = 0; i \\u003c lockBalance.length; ++i){\\r\\n            if(now \\u003c lockBalance[i].timestamp) {\\r\\n                lockBalanceTimestamps[j] = lockBalance[i].timestamp;\\r\\n                lockBalanceValues [j] = lockBalance[i].value;\\r\\n                ++j;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"ICompliance.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ninterface ICompliance {\\r\\n    function mintCheck(address _investor, uint _amount) external view returns(bool result);\\r\\n    function txCheck(address _from, uint256 _amount) external view returns(bool result);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n    external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function approve(address spender, uint256 value)\\r\\n    external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value)\\r\\n    external returns (bool);\\r\\n\\r\\n    event Transfer(\\r\\n    address indexed from,\\r\\n    address indexed to,\\r\\n    uint256 value\\r\\n    );\\r\\n\\r\\n    event Approval(\\r\\n    address indexed owner,\\r\\n    address indexed spender,\\r\\n    uint256 value\\r\\n    );\\r\\n}\\r\\n\"},\"IERC20Burnable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ninterface IERC20Burnable {\\r\\n    function burn(address[] _receiver, uint256[] _value, uint256[] _timestamp) external;\\r\\n    function burnAll(address[] _receiver) external;\\r\\n}\"},\"IERC20ImplUpgradeable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ninterface IERC20ImplUpgradeable {\\r\\n    function getImplAddress() view external returns(address);\\r\\n    function getMintBurnAddress() view external returns(address);\\r\\n    function isImplAddress(address) view external returns(bool);\\r\\n}\"},\"IERC20Mintable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ninterface IERC20Mintable {\\r\\n    function mint(address[] _receiver, uint256[] _value, uint256[] _timestamp) external;\\r\\n}\"},\"ItMapUintAddress.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nlibrary ItMapUintAddress\\r\\n{\\r\\n    struct MapUintAddress\\r\\n    {\\r\\n        mapping(uint =\\u003e MapValue) data;\\r\\n        KeyFlag[] keys;\\r\\n        uint size;\\r\\n    }\\r\\n\\r\\n    struct MapValue { uint keyIndex; address value; }\\r\\n\\r\\n    struct KeyFlag { uint key; bool deleted; }\\r\\n\\r\\n    function add(MapUintAddress storage self, uint key, address value) public returns (bool replaced)\\r\\n    {\\r\\n        uint keyIndex = self.data[key].keyIndex;\\r\\n        self.data[key].value = value;\\r\\n        if (keyIndex \\u003e 0)\\r\\n            return true;\\r\\n        else\\r\\n        {\\r\\n            self.keys.push(KeyFlag(key, false));\\r\\n            self.data[key].keyIndex = self.keys.length;\\r\\n            self.size++;\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function remove(MapUintAddress storage self, uint key) public returns (bool success)\\r\\n    {\\r\\n        uint keyIndex = self.data[key].keyIndex;\\r\\n        if (keyIndex == 0)\\r\\n            return false;\\r\\n        delete self.data[key];\\r\\n        self.keys[keyIndex - 1].deleted = true;\\r\\n        self.size --;\\r\\n    }\\r\\n\\r\\n    function contain(MapUintAddress storage self, uint key) public view returns (bool)\\r\\n    {\\r\\n        return self.data[key].keyIndex \\u003e 0;\\r\\n    }\\r\\n\\r\\n    function startIndex(MapUintAddress storage self) public view returns (uint keyIndex)\\r\\n    {\\r\\n        return nextIndex(self, uint(-1));\\r\\n    }\\r\\n\\r\\n    function validIndex(MapUintAddress storage self, uint keyIndex) public view returns (bool)\\r\\n    {\\r\\n        return keyIndex \\u003c self.keys.length;\\r\\n    }\\r\\n\\r\\n    function nextIndex(MapUintAddress storage self, uint _keyIndex) public view returns (uint)\\r\\n    {\\r\\n        uint keyIndex = _keyIndex;\\r\\n        keyIndex++;\\r\\n        while (keyIndex \\u003c self.keys.length \\u0026\\u0026 self.keys[keyIndex].deleted)\\r\\n            keyIndex++;\\r\\n        return keyIndex;\\r\\n    }\\r\\n\\r\\n    function getByIndex(MapUintAddress storage self, uint keyIndex) public view returns (address value)\\r\\n    {\\r\\n        uint key = self.keys[keyIndex].key;\\r\\n        value = self.data[key].value;\\r\\n    }\\r\\n\\r\\n    function getByKey(MapUintAddress storage self, uint key) public view returns (address value) {\\r\\n        return self.data[key].value;\\r\\n    }\\r\\n}\"},\"LibMapAddressBool.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nlibrary LibMapAddressBool {\\r\\n\\r\\n    struct MapAddressBool {\\r\\n        mapping(address =\\u003e MapValue) data;  // do not modify this variable outside\\r\\n        uint256 length;\\r\\n    }\\r\\n\\r\\n    struct MapValue {\\r\\n        bool value;\\r\\n        bool inited;\\r\\n    }\\r\\n\\r\\n    function add(MapAddressBool storage self, address _key, bool _val) public returns (bool newAdded) {\\r\\n        if(!self.data[_key].inited) {\\r\\n            self.data[_key].inited = true;\\r\\n            self.length++;\\r\\n            newAdded = true;\\r\\n        }\\r\\n        self.data[_key].value = _val;\\r\\n    }\\r\\n\\r\\n    function remove(MapAddressBool storage self, address _key) public returns (bool removed) {\\r\\n        if(self.data[_key].inited) {\\r\\n            self.data[_key].inited = false;\\r\\n            // self.data[_key].value = false;  // no need to reset value here\\r\\n            self.length--;\\r\\n            removed = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function contain(MapAddressBool storage self, address _key) public view returns (bool) {\\r\\n        return self.data[_key].inited;\\r\\n    }\\r\\n\\r\\n    function get(MapAddressBool storage self, address _key) public view returns (bool) {\\r\\n        if(!self.data[_key].inited)\\r\\n            return false;\\r\\n        return self.data[_key].value; \\r\\n    }\\r\\n\\r\\n    // function getLength(AddressBool storage self) public view returns (uint) {\\r\\n    //     return self.length;\\r\\n    // }\\r\\n}\\r\\n\\r\\n\"},\"LockRequestable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ncontract LockRequestable {\\r\\n\\r\\n    // MEMBERS\\r\\n    uint256 public lockRequestCount;\\r\\n\\r\\n    // CONSTRUCTOR\\r\\n    constructor() public {\\r\\n        lockRequestCount = 0;\\r\\n    }\\r\\n\\r\\n    // FUNCTIONS\\r\\n    function generateLockId() internal returns (bytes32 lockId) {\\r\\n        return keccak256(\\r\\n            abi.encodePacked(blockhash(block.number - 1), address(this), ++lockRequestCount)\\r\\n        );\\r\\n    }\\r\\n}\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\ncontract Pausable {\\r\\n\\r\\n    event Pause();\\r\\n    event Unpause();\\r\\n\\r\\n    bool public paused = false;\\r\\n\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused, \\\"Contract is paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier whenPaused() {\\r\\n        require(paused, \\\"Contract is not paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _pause() internal whenNotPaused {\\r\\n        paused = true;\\r\\n        emit Pause();\\r\\n    }\\r\\n\\r\\n    function _unpause() internal whenPaused {\\r\\n        paused = false;\\r\\n        emit Unpause();\\r\\n    }\\r\\n\\r\\n}\\r\\n\"},\"Proxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport { AuthModule } from \\\"AuthModule.sol\\\";\\r\\n\\r\\nimport \\\"Address.sol\\\";\\r\\n\\r\\ncontract Proxy {\\r\\n    using Address for address;\\r\\n\\r\\n    mapping(string =\\u003e address) moduleMap;\\r\\n    mapping(address =\\u003e bool) insideContracts;   // all internal contract address, used to make sure only called from inside\\r\\n\\r\\n    event AddInsideContract(address _contract);\\r\\n    event AddInsideContracts(address[] _contracts);\\r\\n    event RemoveInsideContract(address _contract);\\r\\n    event UpdateModule(string _moduleName, address _preModule, address _newModule);\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        AuthModule auth = AuthModule(getModule(\\\"AuthModule\\\"));\\r\\n        require(auth.isAdmin(msg.sender), \\\"Need be admin\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    constructor(address authModule) public {\\r\\n        _updateModule(\\\"AuthModule\\\", authModule, true);\\r\\n    }\\r\\n\\r\\n    function addInsideContract(address _contract) public onlyAdmin {\\r\\n        _addInsideContract(_contract);\\r\\n    }\\r\\n\\r\\n    function _addInsideContract(address _contract) private {\\r\\n        // require(insideContracts[_contract] == false, \\\"Inside contract already exists\\\");\\r\\n        insideContracts[_contract] = true;\\r\\n        emit AddInsideContract(_contract);\\r\\n    }\\r\\n    \\r\\n    function addInsideContracts(address[] _contracts) public onlyAdmin {\\r\\n        for(uint i = 0; i \\u003c _contracts.length; i++) {\\r\\n            // require(insideContracts[_contracts[i]] == false, \\\"Inside contract already exists\\\");\\r\\n            insideContracts[_contracts[i]] = true;\\r\\n        }\\r\\n        emit AddInsideContracts(_contracts);\\r\\n    }\\r\\n\\r\\n    function removeInsideContract(address _contract) public onlyAdmin {\\r\\n        _removeInsideContract(_contract);\\r\\n    }\\r\\n\\r\\n    function _removeInsideContract(address _contract) private {\\r\\n        delete insideContracts[_contract];\\r\\n        emit RemoveInsideContract(_contract);\\r\\n    }\\r\\n\\r\\n    // TODO: need to check if the address is a contract\\r\\n    function isInsideContract(address _contract) public view returns (bool) {\\r\\n        return _contract.isContract() \\u0026\\u0026 insideContracts[_contract] == true;\\r\\n    }\\r\\n\\r\\n    function updateModule(string _moduleName, address _module, bool _insideContract) public onlyAdmin {\\r\\n        _updateModule(_moduleName, _module, _insideContract);\\r\\n    }\\r\\n\\r\\n    function _updateModule(string _moduleName, address _module, bool _insideContract) private {\\r\\n        address preModule = moduleMap[_moduleName];\\r\\n        if(preModule != address(0))\\r\\n            _removeInsideContract(preModule);\\r\\n        moduleMap[_moduleName] = _module;\\r\\n        if(_insideContract \\u0026\\u0026 _module != address(0))\\r\\n            _addInsideContract(_module);\\r\\n        emit UpdateModule(_moduleName, preModule, _module);\\r\\n    }\\r\\n\\r\\n    function getModule(string _moduleName) public view returns (address) {\\r\\n        return moduleMap[_moduleName];\\r\\n    } \\r\\n    \\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"StorageModule.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"Proxy.sol\\\";\\r\\nimport \\\"AuthModule.sol\\\";\\r\\nimport \\\"TokenModule.sol\\\";\\r\\nimport \\\"Authorization.sol\\\";\\r\\nimport \\\"SafeMath.sol\\\";\\r\\nimport \\\"LibMapAddressBool.sol\\\";\\r\\nimport \\\"StringUtils.sol\\\";\\r\\n\\r\\n\\r\\ncontract StorageModule is Authorization {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using LibMapAddressBool for LibMapAddressBool.MapAddressBool;\\r\\n    using StringUtils for string;\\r\\n\\r\\n    LibMapAddressBool.MapAddressBool shareholders;\\r\\n    mapping(address =\\u003e bool) investorWhitelist;\\r\\n    mapping(address =\\u003e bool) investorBlacklist;\\r\\n    mapping(address =\\u003e InvestorInfo) investorInfo;\\r\\n    mapping(address =\\u003e InvestorDocument) investorDocuments;\\r\\n    mapping(uint =\\u003e address) usedHashid;\\r\\n\\r\\n    mapping(bytes32 =\\u003e uint256) retailInvestorCounts;\\r\\n    mapping(bytes32 =\\u003e mapping(address =\\u003e uint256)) retailInvestors;\\r\\n    \\r\\n    bool public isTXFrozen;\\r\\n    uint256 public shareholderMaxAmount;\\r\\n    string[] public allowCountrys;\\r\\n\\r\\n    event AddInvestorToWhitelist(address _investor);\\r\\n    event AddInvestorsToWhitelist(address[] _investors);\\r\\n    event RemoveInvestorFromWhitelist(address _investor);\\r\\n    event UpdateBlacklist(address[] _investors, bool _black);\\r\\n    event SetShareholderMaxAmount(uint _oldValue, uint _newValue);\\r\\n    event InitShareholders(address[] _shareholders, bool _original);\\r\\n    event AddShareholder(address _shareholder, uint _balance);\\r\\n    event RemoveShareholder(address _shareholder, uint _balance);\\r\\n    // event AddInvestorInfo(address _investor, uint hashid, string _country, bool _kyc, uint _validDate);\\r\\n    event UpdateInvestorInfo(address _investor, uint hashid, string _country, bool _kyc, uint _validDate, bool _pi);\\r\\n    // event AddDocument(address _investor, string _url, uint _hash);\\r\\n    event UpdateDocument(address _investor, string _url, uint _hash);\\r\\n\\r\\n    struct Shareholder {\\r\\n        bool inited;\\r\\n        bool original;\\r\\n    }\\r\\n\\r\\n    //专业投资者 Pi,合规投资者,前x名合规投资者\\r\\n    struct InvestorInfo {\\r\\n        bool inited;\\r\\n        uint hashid; //是投资者所有资料串在一起的hash值\\r\\n        string country;//地区\\r\\n        bool kyc;// 合规投资者认证\\r\\n        uint validDate;\\r\\n        bool pi; //is professional, pi和kyc必须要有一个是true\\r\\n    }\\r\\n\\r\\n    struct InvestorDocument {\\r\\n        string url;\\r\\n        uint hash;\\r\\n    }\\r\\n\\r\\n    constructor(address _proxy) public Authorization(_proxy) {\\r\\n        \\r\\n    }\\r\\n\\r\\n    function freezeTX(bool _freeze) public onlyAdmin(msg.sender) whenNotPaused {\\r\\n        isTXFrozen = _freeze;\\r\\n    }\\r\\n\\r\\n    function addInvestorToWhitelist(address _investor) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        investorWhitelist[_investor] = true;\\r\\n        emit AddInvestorToWhitelist(_investor);\\r\\n    }\\r\\n\\r\\n    function addInvestorsToWhitelist(address[] _investors) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        for(uint i = 0; i \\u003c _investors.length; i++) {\\r\\n            investorWhitelist[_investors[i]] = true;\\r\\n        }\\r\\n        emit AddInvestorsToWhitelist(_investors);\\r\\n    }\\r\\n\\r\\n    function updateBlacklist(address[] _investors, bool _black) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        for(uint i = 0; i \\u003c _investors.length; i++) {\\r\\n            investorBlacklist[_investors[i]] = _black;\\r\\n        }\\r\\n        emit UpdateBlacklist(_investors, _black);\\r\\n    }\\r\\n\\r\\n    function removeInvestorFromWhitelist(address _investor) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        delete investorWhitelist[_investor];\\r\\n        emit RemoveInvestorFromWhitelist(_investor);\\r\\n    }\\r\\n\\r\\n    function addRetailInvestor(address _investor) external onlyIssuerOrExchange(msg.sender) whenNotPaused {\\r\\n        bytes32 _country= getInvestorCountry(_investor);\\r\\n        if(retailInvestors[_country][_investor] != 0)\\r\\n            return;\\r\\n        retailInvestors[_country][_investor] = ++retailInvestorCounts[_country];\\r\\n    }\\r\\n\\r\\n    function getRetailInvestorCount(bytes32 _country) external view returns (uint256) {\\r\\n        return retailInvestorCounts[_country];\\r\\n    }\\r\\n\\r\\n    function getRetailInvestor(address _investor) external view returns (uint256) {\\r\\n        bytes32 _country= getInvestorCountry(_investor);\\r\\n        return retailInvestors[_country][_investor];\\r\\n    }\\r\\n\\r\\n    function isInvestorInWhitelist(address _investor) external view returns (bool) {\\r\\n        return investorWhitelist[_investor];\\r\\n    }\\r\\n\\r\\n    function isInBlacklist(address _investor) external view returns (bool) {\\r\\n        return investorBlacklist[_investor];\\r\\n    }\\r\\n\\r\\n    function isProfessionalInvestor(address _investor) external view returns (bool) {\\r\\n        return investorInfo[_investor].pi;\\r\\n    }\\r\\n\\r\\n    function setShareholderMaxAmount(uint256 _shareholderMaxAmount) public onlyIssuer(msg.sender) whenNotPaused {\\r\\n        uint256 preValue = shareholderMaxAmount;\\r\\n        shareholderMaxAmount = _shareholderMaxAmount;\\r\\n        emit SetShareholderMaxAmount(preValue, shareholderMaxAmount);\\r\\n    }\\r\\n\\r\\n    // called after mint\\r\\n    function initShareholders(address[] _shareholders, bool _original) public onlyInside(msg.sender) whenNotPaused {\\r\\n        for(uint i = 0; i \\u003c _shareholders.length; i++) {\\r\\n            shareholders.add(_shareholders[i], _original);\\r\\n        }\\r\\n        emit InitShareholders(_shareholders, _original);\\r\\n    }\\r\\n\\r\\n    // called after transaction or burn\\r\\n    function updateShareholders(address _from, address _to) public onlyInside(msg.sender) whenNotPaused {\\r\\n        TokenModule token = TokenModule(proxy.getModule(\\\"TokenModule\\\"));\\r\\n        uint balanceFrom = token.balanceOf(_from);\\r\\n        uint balanceTo = token.balanceOf(_to);\\r\\n        if(balanceFrom == 0)\\r\\n            removeShareholder(_from, 0);\\r\\n        // no need to check investors amount here, cause ComplicanceModule will do the job.\\r\\n        // _to will be 0 while burn\\r\\n        if(_to != address(0))\\r\\n            addShareholder(_to, balanceTo); \\r\\n    }  \\r\\n\\r\\n    function addShareholder(address _shareholder, uint _balance) private {\\r\\n        bool newAdded = shareholders.add(_shareholder, false);\\r\\n        if(newAdded)\\r\\n            emit AddShareholder(_shareholder, _balance);\\r\\n    }\\r\\n\\r\\n    function removeShareholder(address _shareholder, uint _balance) private {\\r\\n        bool removed = shareholders.remove(_shareholder);\\r\\n        if(removed)\\r\\n            emit RemoveShareholder(_shareholder, _balance);\\r\\n    }\\r\\n\\r\\n    function shareholderAmount() public view returns (uint256) {\\r\\n        return shareholders.length;\\r\\n    }\\r\\n\\r\\n    function isShareholder(address _address) public view returns (bool) {\\r\\n        return shareholders.contain(_address);\\r\\n    }\\r\\n    \\r\\n    function shareholderExceeded(uint amount) public view returns (bool) {\\r\\n        return shareholders.length + amount \\u003e shareholderMaxAmount;\\r\\n    }\\r\\n\\r\\n    function getInvestorCountry(address _address) public view returns (bytes32 result) {\\r\\n        string memory country = investorInfo[_address].country;\\r\\n        assembly {\\r\\n            result := mload(add(country, 32))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // function addInvestorInfo(\\r\\n    //     address _investor, \\r\\n    //     uint _investorHash,\\r\\n    //     string _country, \\r\\n    //     bool _kyc, \\r\\n    //     uint _validDate\\r\\n    // ) \\r\\n    //     external \\r\\n    //     onlyIssuerOrExchange(msg.sender) \\r\\n    // {\\r\\n    //     require(investorInfo[_investor].inited == false, \\\"Investor already exists\\\");\\r\\n    //     investorInfo[_investor] = InvestorInfo(true, _investorHash, _country, _kyc, _validDate);\\r\\n    //     emit AddInvestorInfo(_investor, _investorHash, _country, _kyc, _validDate);\\r\\n    // }\\r\\n\\r\\n    function updateInvestorInfo(\\r\\n        address _investor, \\r\\n        uint _hashid,\\r\\n        string _country, \\r\\n        bool _kyc, \\r\\n        uint _validDate ,\\r\\n        bool _pi\\r\\n    ) \\r\\n        external \\r\\n        onlyIssuerOrExchange(msg.sender) \\r\\n        whenNotPaused\\r\\n        returns(bool)\\r\\n    {\\r\\n        // require(investorInfo[_investor].inited == true, \\\"Investor do not exist\\\");\\r\\n        bool temp_pi = true; //temp_pi = _pi; // force set all guys is professional.\\r\\n        require (_kyc || temp_pi, \\\"require _kyc or _pi at less one be true\\\");\\r\\n        require (isAllowCountry(_country), \\\"country not allow\\\");\\r\\n        require (_hashid != 0);\\r\\n        require (usedHashid[_hashid] == address(0) || usedHashid[_hashid] == _investor);\\r\\n        \\r\\n        //uint oldhashid = investorInfo[_investor].hashid;\\r\\n        investorInfo[_investor] = InvestorInfo(true, _hashid, _country, _kyc, _validDate, temp_pi);\\r\\n        usedHashid[_hashid] = _investor;\\r\\n        //if (oldhashid != _hashid) //\\r\\n        //    delete usedHashid[oldhashid];\\r\\n        emit UpdateInvestorInfo(_investor, _hashid, _country, _kyc, _validDate, temp_pi);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getInvestorInfo(address _investor) public view returns (uint, string, bool, uint, bool) {\\r\\n        InvestorInfo storage info = investorInfo[_investor];\\r\\n        return (info.hashid, info.country, info.kyc, info.validDate, info.pi);\\r\\n    }\\r\\n\\r\\n    // function addDocument(\\r\\n    //     address _investor, \\r\\n    //     string _url, \\r\\n    //     uint _hash\\r\\n    // ) \\r\\n    //     external \\r\\n    //     onlyIssuerOrExchange(msg.sender) \\r\\n    // {\\r\\n    //     InvestorDocument storage doc = investorDocuments[_investor];\\r\\n    //     require(doc.hash == 0, \\\"Investor document already exists\\\");\\r\\n    //     investorDocuments[_investor] = InvestorDocument(_url, _hash);\\r\\n    //     emit AddDocument(_investor, _url, _hash);\\r\\n    // }\\r\\n\\r\\n    function updateDocument(\\r\\n        address _investor, \\r\\n        string _url, \\r\\n        uint _hash\\r\\n    ) \\r\\n        external \\r\\n        onlyIssuerOrExchange(msg.sender) \\r\\n        whenNotPaused\\r\\n    {\\r\\n        // InvestorDocument storage doc = investorDocuments[_investor];\\r\\n        // require(doc.hash != 0, \\\"Investor document do not exists\\\");\\r\\n        investorDocuments[_investor] = InvestorDocument(_url, _hash);\\r\\n        emit UpdateDocument(_investor, _url, _hash);\\r\\n    }\\r\\n\\r\\n    function getDocument(address _investor) external view returns (string, uint) {\\r\\n        InvestorDocument storage doc = investorDocuments[_investor];\\r\\n        return (doc.url, doc.hash);\\r\\n    }\\r\\n\\r\\n    function addAllowCountrys(string _country)\\r\\n        external \\r\\n        onlyIssuerOrExchange(msg.sender)\\r\\n        returns (bool)\\r\\n    {\\r\\n        bytes memory strmemct = bytes(_country);\\r\\n        require (strmemct.length \\u003e 0, \\\"country can not empty\\\");\\r\\n\\r\\n        uint aclen = allowCountrys.length;\\r\\n        uint firstEmptyPlace = aclen;\\r\\n        for (uint i=0; i \\u003c aclen; i++)\\r\\n        {\\r\\n            if (allowCountrys[i].equal(_country))\\r\\n                return false;\\r\\n            bytes memory strmem = bytes(allowCountrys[i]);\\r\\n            if (strmem.length == 0 \\u0026\\u0026 firstEmptyPlace == aclen)\\r\\n                firstEmptyPlace = i;\\r\\n        }\\r\\n        if (firstEmptyPlace != aclen)\\r\\n            allowCountrys[firstEmptyPlace] = _country;\\r\\n        else\\r\\n            allowCountrys.push(_country);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeAllowCountrys(string _country) \\r\\n        external\\r\\n        onlyIssuerOrExchange(msg.sender)\\r\\n        returns (bool) \\r\\n    {\\r\\n        uint aclen = allowCountrys.length;\\r\\n        for (uint i=0; i \\u003c aclen; i++)\\r\\n        {\\r\\n            if (allowCountrys[i].equal(_country))\\r\\n            {\\r\\n                delete allowCountrys[i];\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function isAllowCountry(string _country)\\r\\n        public\\r\\n        returns(bool)\\r\\n    {\\r\\n        uint aclen = allowCountrys.length;\\r\\n        for (uint i=0; i \\u003c aclen; i++)\\r\\n        {\\r\\n            if (allowCountrys[i].equal(_country)) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n}\"},\"StringUtils.sol\":{\"content\":\"library StringUtils {\\r\\n    /// @dev Does a byte-by-byte lexicographical comparison of two strings.\\r\\n    /// @return a negative number if `_a` is smaller, zero if they are equal\\r\\n    /// and a positive numbe if `_b` is smaller.\\r\\n    function compare(string _a, string _b) returns (int) {\\r\\n        bytes memory a = bytes(_a);\\r\\n        bytes memory b = bytes(_b);\\r\\n        uint minLength = a.length;\\r\\n        if (b.length \\u003c minLength) minLength = b.length;\\r\\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\\r\\n        for (uint i = 0; i \\u003c minLength; i ++)\\r\\n            if (a[i] \\u003c b[i])\\r\\n                return -1;\\r\\n            else if (a[i] \\u003e b[i])\\r\\n                return 1;\\r\\n        if (a.length \\u003c b.length)\\r\\n            return -1;\\r\\n        else if (a.length \\u003e b.length)\\r\\n            return 1;\\r\\n        else\\r\\n            return 0;\\r\\n    }\\r\\n    /// @dev Compares two strings and returns true iff they are equal.\\r\\n    function equal(string _a, string _b) returns (bool) {\\r\\n        return compare(_a, _b) == 0;\\r\\n    }\\r\\n    /// @dev Finds the index of the first occurrence of _needle in _haystack\\r\\n    function indexOf(string _haystack, string _needle) returns (int)\\r\\n    {\\r\\n    \\tbytes memory h = bytes(_haystack);\\r\\n    \\tbytes memory n = bytes(_needle);\\r\\n    \\tif(h.length \\u003c 1 || n.length \\u003c 1 || (n.length \\u003e h.length)) \\r\\n    \\t\\treturn -1;\\r\\n    \\telse if(h.length \\u003e (2**128 -1)) // since we have to be able to return -1 (if the char isn\\u0027t found or input error), this function must return an \\\"int\\\" type with a max length of (2^128 - 1)\\r\\n    \\t\\treturn -1;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n    \\telse\\r\\n    \\t{\\r\\n    \\t\\tuint subindex = 0;\\r\\n    \\t\\tfor (uint i = 0; i \\u003c h.length; i ++)\\r\\n    \\t\\t{\\r\\n    \\t\\t\\tif (h[i] == n[0]) // found the first char of b\\r\\n    \\t\\t\\t{\\r\\n    \\t\\t\\t\\tsubindex = 1;\\r\\n    \\t\\t\\t\\twhile(subindex \\u003c n.length \\u0026\\u0026 (i + subindex) \\u003c h.length \\u0026\\u0026 h[i + subindex] == n[subindex]) // search until the chars don\\u0027t match or until we reach the end of a or b\\r\\n    \\t\\t\\t\\t{\\r\\n    \\t\\t\\t\\t\\tsubindex++;\\r\\n    \\t\\t\\t\\t}\\t\\r\\n    \\t\\t\\t\\tif(subindex == n.length)\\r\\n    \\t\\t\\t\\t\\treturn int(i);\\r\\n    \\t\\t\\t}\\r\\n    \\t\\t}\\r\\n    \\t\\treturn -1;\\r\\n    \\t}\\t\\r\\n    }\\r\\n}\"},\"TokenModule.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\nimport { Proxy } from \\\"Proxy.sol\\\";\\r\\nimport { StorageModule } from \\\"StorageModule.sol\\\";\\r\\nimport { AuthModule } from \\\"AuthModule.sol\\\";\\r\\nimport \\\"ItMapUintAddress.sol\\\";\\r\\nimport \\\"IERC20.sol\\\";\\r\\nimport \\\"IERC20Mintable.sol\\\";\\r\\nimport \\\"IERC20Burnable.sol\\\";\\r\\nimport \\\"IERC20ImplUpgradeable.sol\\\";\\r\\nimport \\\"Authorization.sol\\\";\\r\\n\\r\\ncontract TokenModule is Authorization {\\r\\n    \\r\\n    using ItMapUintAddress for ItMapUintAddress.MapUintAddress;\\r\\n\\r\\n    ItMapUintAddress.MapUintAddress tokenMap;\\r\\n\\r\\n    event UpdateToken(uint _tag, address _old, address _new);\\r\\n\\r\\n    constructor(address _proxy) public Authorization(_proxy) {\\r\\n       \\r\\n    }\\r\\n\\r\\n    function addToken(uint _tag, address _token) external whenNotPaused onlyAdmin(msg.sender) {\\r\\n        require(tokenMap.data[_tag].value == address(0), \\\"Token already exists\\\");\\r\\n        tokenMap.add(_tag, _token);\\r\\n        emit UpdateToken(_tag, address(0), _token);\\r\\n    }\\r\\n\\r\\n    function updateToken(uint _tag, address _token) external whenNotPaused onlyAdmin(msg.sender) {\\r\\n        require(tokenMap.data[_tag].value != address(0), \\\"Token not exists\\\");\\r\\n        address _old = tokenMap.data[_tag].value;\\r\\n        tokenMap.add(_tag, _token);\\r\\n        emit UpdateToken(_tag, _old, _token);\\r\\n    }\\r\\n\\r\\n    function getToken(uint _tag) external view returns (address) {\\r\\n        return tokenMap.getByKey(_tag);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _from) external view returns (uint256 sum) {\\r\\n        for(uint i = tokenMap.startIndex(); tokenMap.validIndex(i); i = tokenMap.nextIndex(i)) {\\r\\n            IERC20 _token = IERC20(tokenMap.getByIndex(i));\\r\\n            if(_token != address(0))\\r\\n                sum += _token.balanceOf(_from);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mint(uint _tokenTag, address[] _investors, uint[] _balances, uint[] _timestamps, bool _originals) external whenNotPaused onlyIssuer(msg.sender) {\\r\\n        IERC20ImplUpgradeable token = IERC20ImplUpgradeable(tokenMap.getByKey(_tokenTag));\\r\\n        IERC20Mintable impl = IERC20Mintable(token.getMintBurnAddress());\\r\\n        require(impl != address(0), \\\"mint impl require not 0\\\");\\r\\n\\r\\n        impl.mint(_investors, _balances, _timestamps);\\r\\n\\r\\n        StorageModule sm = StorageModule(proxy.getModule(\\\"StorageModule\\\"));\\r\\n        sm.initShareholders(_investors, _originals);\\r\\n    }\\r\\n\\r\\n    function burn(uint _tokenTag, address[] _investors, uint256[] _values, uint256[] _timestamps) external whenNotPaused onlyIssuer(msg.sender) {\\r\\n        IERC20ImplUpgradeable token = IERC20ImplUpgradeable(tokenMap.getByKey(_tokenTag));\\r\\n        IERC20Burnable impl = IERC20Burnable(token.getMintBurnAddress());\\r\\n        require(impl != address(0), \\\"burn impl require not 0\\\");\\r\\n        impl.burn(_investors, _values, _timestamps);\\r\\n    }\\r\\n\\r\\n    function burnAll(uint _tokenTag, address[] _investors) external whenNotPaused onlyIssuer(msg.sender) {\\r\\n        IERC20ImplUpgradeable token = IERC20ImplUpgradeable(tokenMap.getByKey(_tokenTag));\\r\\n        IERC20Burnable impl = IERC20Burnable(token.getMintBurnAddress());\\r\\n        require(impl != address(0), \\\"burn impl require not 0\\\");\\r\\n        impl.burnAll(_investors);\\r\\n    }\\r\\n\\r\\n    function getTokenTags() external view returns(uint[] tags){\\r\\n        tags = new uint[](tokenMap.size);\\r\\n        uint j = 0;\\r\\n        for(uint i = tokenMap.startIndex(); tokenMap.validIndex(i); i = tokenMap.nextIndex(i)) {\\r\\n            tags[j] = tokenMap.keys[i].key;\\r\\n            ++j;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApprovalWithSender\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockId\",\"type\":\"bytes32\"}],\"name\":\"transferConfirm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOfLock\",\"outputs\":[{\"name\":\"lockBalanceTimestamps\",\"type\":\"uint256[]\"},{\"name\":\"lockBalanceValues\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromWithSender\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApprovalWithSender\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20Proxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveWithSender\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tx\",\"type\":\"uint256\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"revertTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockRequestCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferWithSender\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20Store\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_erc20Proxy\",\"type\":\"address\"},{\"name\":\"_erc20Store\",\"type\":\"address\"},{\"name\":\"_proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"ERC20Impl","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008469e5158fb3c043cf88ce769c94e4b9fc8d79b5000000000000000000000000e2ece29f3f63a1ea13b7ee04d47e11a4b76f829d0000000000000000000000002be753dd5f5400f5ffc896d6cad195b5db56f857","Library":"","LicenseType":"None","SwarmSource":"bzzr://9685793f9bc5c359b2b8261dbb6218be0eba220d65890f204d3dc91cde5e91d5"}]}