{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.13;\r\n\r\n/*\r\n-------------------------------------------------------------------\r\n Contract designed with ❤ by EtherAuthority ( https://EtherAuthority.io )\r\n-------------------------------------------------------------------\r\n*/ \r\n\r\n//*******************************************************************//\r\n//------------------------ SafeMath Library -------------------------//\r\n//*******************************************************************//\r\n/**\r\n    * @title SafeMath\r\n    * @dev Math operations with safety checks that throw on error\r\n    */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath mul failed');\r\n    return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, 'SafeMath sub failed');\r\n    return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath add failed');\r\n    return c;\r\n    }\r\n}\r\n\r\n\r\n//*******************************************************************//\r\n//------------------ Contract to Manage Ownership -------------------//\r\n//*******************************************************************//\r\n    \r\ncontract owned {\r\n    address payable public owner;\r\n    address payable internal newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) external onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\r\n    function acceptOwnership() external {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\ninterface ERC20Essential \r\n{\r\n\tfunction balanceOf(address _tokenHolder) external view returns (uint256);\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\ninterface ERC777Essential \r\n{\r\n\tfunction balanceOf(address _tokenHolder) external view returns (uint256);\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n}\r\n\r\n\r\n\r\ncontract tokenSwapping is owned {\r\n  using SafeMath for uint256;\r\n  uint public exchangeRate;\r\n  address public oldTokenContract;\r\n  address public newTokenContract;\r\n  address public ERC777OwnerAddress;\r\n  uint256 internal tokenAmount;\r\n  uint256 internal newTokenAmount;\r\n  \r\n  // This will log swapping of token\r\n  event Exchanged(uint256 curTime, address oldToken, address newToken, address user, uint oldAmount, uint newAmount);\r\n  \r\n  constructor() public {\r\n    exchangeRate=500; // 1 erc 777 token = ? erc 20 token. Here the conversion is: 1 erc777 = 500 erc20\r\n  }\r\n  \r\n  function updateERC20ContractAddress(address ERC20Contract) external onlyOwner {\r\n    require(ERC20Contract != address(0), 'Invalid ERC20 token address');\r\n    require(ERC20Contract != newTokenContract, 'ERC20 and ERC777 token addresses cannot be same');\r\n\toldTokenContract = ERC20Contract;\r\n  }\r\n  \r\n  function updateERC777ContractAddress(address ERC777Contract) external onlyOwner {\r\n    require(ERC777Contract != address(0), 'Invalid ERC777 token address');\r\n    require(ERC777Contract != oldTokenContract, 'ERC20 and ERC777 token addresses cannot be same');\r\n\tnewTokenContract = ERC777Contract;\r\n  }\r\n  \r\n  function updateERC777OwnerAddress(address ERC777Owner) external onlyOwner {\r\n    require(ERC777Owner != address(0), 'Invalid ERC20 token address');\r\n    require(ERC777Owner != newTokenContract, 'Owner address cannot be a Contract Address');\r\n    require(ERC777Owner != oldTokenContract, 'Owner address cannot be a Contract Address');\r\n\tERC777OwnerAddress = ERC777Owner;\r\n  }\r\n  \r\n  function updateExchangeRate(uint256 _exchangeRate) external onlyOwner {\r\n\texchangeRate = _exchangeRate;\r\n  }\r\n  \r\n  function tokenSwap() external {\r\n    //remember to call Token(address).approve(address(this), amount) or this contract will not be able to do the transfer on your behalf.\r\n\ttokenAmount = ERC20Essential(oldTokenContract).balanceOf(msg.sender);\r\n\trequire(tokenAmount > 0, \"Insufficient Old Token Balance\");\r\n\tnewTokenAmount = tokenAmount.div(exchangeRate);\r\n\trequire(newTokenAmount <= ERC777Essential(newTokenContract).balanceOf(ERC777OwnerAddress), \"Insufficient New Token Balance\");\r\n    require(ERC20Essential(oldTokenContract).transferFrom(msg.sender, address(this), tokenAmount), 'old tokens could not be transferred');\r\n    require(ERC777Essential(newTokenContract).transferFrom(ERC777OwnerAddress, msg.sender, newTokenAmount), 'new tokens could not be transferred');\r\n    emit Exchanged(now, oldTokenContract, newTokenContract, msg.sender, tokenAmount, newTokenAmount);\r\n\t\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"Exchanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC777OwnerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ERC20Contract\",\"type\":\"address\"}],\"name\":\"updateERC20ContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ERC777Contract\",\"type\":\"address\"}],\"name\":\"updateERC777ContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ERC777Owner\",\"type\":\"address\"}],\"name\":\"updateERC777OwnerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"updateExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"tokenSwapping","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://142e0b9688bef58c7463e5f2cd8aa3a9ae146abc7dc5a7f3c5c0b8d8dd19450c"}]}