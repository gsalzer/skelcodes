{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.7.0;\r\n\r\n/// @title Enum - Collection of enums\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n\r\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\r\n/// @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SignatureDecoder {\r\n    \r\n    /// @dev Recovers address who signed the message\r\n    /// @param messageHash operation ethereum signed message hash\r\n    /// @param messageSignature message `txHash` signature\r\n    /// @param pos which signature to read\r\n    function recoverKey (\r\n        bytes32 messageHash,\r\n        bytes memory messageSignature,\r\n        uint256 pos\r\n    )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        (v, r, s) = signatureSplit(messageSignature, pos);\r\n        return ecrecover(messageHash, v, r, s);\r\n    }\r\n\r\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\r\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\r\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\r\n    /// @param signatures concatenated rsv signatures\r\n    function signatureSplit(bytes memory signatures, uint256 pos)\r\n        internal\r\n        pure\r\n        returns (uint8 v, bytes32 r, bytes32 s)\r\n    {\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let signaturePos := mul(0x41, pos)\r\n            r := mload(add(signatures, add(signaturePos, 0x20)))\r\n            s := mload(add(signatures, add(signaturePos, 0x40)))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\r\n        }\r\n    }\r\n}\r\n\r\ncontract ISignatureValidatorConstants {\r\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\r\n}\r\n\r\ncontract ISignatureValidator is ISignatureValidatorConstants {\r\n\r\n    /**\r\n    * @dev Should return whether the signature provided is valid for the provided data\r\n    * @param _data Arbitrary length data signed on the behalf of address(this)\r\n    * @param _signature Signature byte array associated with _data\r\n    *\r\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\r\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n    * MUST allow external calls\r\n    */\r\n    function isValidSignature(\r\n        bytes memory _data,\r\n        bytes memory _signature)\r\n        public\r\n        view\r\n        returns (bytes4);\r\n}\r\n\r\ninterface GnosisSafe {\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes calldata data, Enum.Operation operation)\r\n        external\r\n        returns (bool success);\r\n}\r\n\r\ncontract AllowanceModule is SignatureDecoder, ISignatureValidatorConstants {\r\n\r\n    string public constant NAME = \"Allowance Module\";\r\n    string public constant VERSION = \"0.1.0\";\r\n\r\n    //keccak256(\r\n    //    \"EIP712Domain(address verifyingContract)\"\r\n    //);\r\n    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\r\n\r\n    // TODO: Fix hardcode hash\r\n    bytes32 public constant ALLOWANCE_TRANSFER_TYPEHASH = keccak256(\r\n        \"AllowanceTransfer(address safe,address token,uint96 amount,address paymentToken,uint96 payment,uint16 nonce)\"\r\n    );\r\n\r\n    // Safe -> Delegate -> Allowance\r\n    mapping(address => mapping (address => mapping(address => Allowance))) public allowances;\r\n    mapping(address => mapping (address => address[])) public tokens;\r\n    mapping(address => mapping (uint48 => Delegate)) public delegates;\r\n    mapping(address => uint48) public delegatesStart;\r\n    bytes32 public domainSeparator;\r\n\r\n    struct Delegate {\r\n        address delegate;\r\n        uint48 prev;\r\n        uint48 next;\r\n    }\r\n\r\n    struct Allowance {\r\n        uint96 amount;\r\n        uint96 spent;\r\n        uint16 resetTimeMin; // reset time span is 65k minutes\r\n        uint32 lastResetMin;\r\n        uint16 nonce;\r\n    }\r\n\r\n    event AddDelegate(address indexed safe, address delegate);\r\n    event RemoveDelegate(address indexed safe, address delegate);\r\n    event ExecuteAllowanceTransfer(address indexed safe, address delegate, address token, address to, uint96 value, uint16 nonce);\r\n    event SetAllowance(address indexed safe, address delegate, address token, uint96 allowanceAmount, uint16 resetTime);\r\n\r\n    constructor() public {\r\n        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\r\n    }\r\n\r\n    /// @dev Allows to update the allowance for a specified token. This can only be done via a Safe transaction.\r\n    /// @param delegate Delegate whose allowance should be updated.\r\n    /// @param token Token contract address.\r\n    /// @param allowanceAmount allowance in smallest token unit.\r\n    /// @param resetTimeMin Time after which the allowance should reset\r\n    /// @param resetBaseMin Time based on which the reset time should be increased\r\n    function setAllowance(address delegate, address token, uint96 allowanceAmount, uint16 resetTimeMin, uint32 resetBaseMin)\r\n        public\r\n    {\r\n        require(delegates[msg.sender][uint48(delegate)].delegate == delegate, \"delegates[msg.sender][uint48(delegate)].delegate == delegate\");\r\n        Allowance memory allowance = getAllowance(msg.sender, delegate, token);\r\n        if (allowance.nonce == 0) { // New token\r\n            // Nonce should never be 0 once allowance has been activated\r\n            allowance.nonce = 1;\r\n            tokens[msg.sender][delegate].push(token);\r\n        }\r\n        // solium-disable-next-line security/no-block-members\r\n        uint32 currentMin = uint32(now / 60);\r\n        if (resetBaseMin > 0) {\r\n            require(resetBaseMin <= currentMin, \"resetBaseMin <= currentMin\");\r\n            allowance.lastResetMin = currentMin - ((currentMin - resetBaseMin) % resetTimeMin);\r\n        } else if (allowance.lastResetMin == 0) {\r\n            allowance.lastResetMin = currentMin;\r\n        }\r\n        allowance.resetTimeMin = resetTimeMin;\r\n        allowance.amount = allowanceAmount;\r\n        updateAllowance(msg.sender, delegate, token, allowance);\r\n        emit SetAllowance(msg.sender, delegate, token, allowanceAmount, resetTimeMin);\r\n    }\r\n\r\n    function getAllowance(address safe, address delegate, address token) private view returns (Allowance memory allowance) {\r\n        allowance = allowances[safe][delegate][token];\r\n        // solium-disable-next-line security/no-block-members\r\n        uint32 currentMin = uint32(now / 60);\r\n        if (allowance.resetTimeMin > 0 && allowance.lastResetMin <= currentMin - allowance.resetTimeMin) {\r\n            allowance.spent = 0;\r\n            allowance.lastResetMin = currentMin - ((currentMin - allowance.lastResetMin) % allowance.resetTimeMin);\r\n        }\r\n        return allowance;\r\n    }\r\n\r\n    function updateAllowance(address safe, address delegate, address token, Allowance memory allowance) private {\r\n        allowances[safe][delegate][token] = allowance;\r\n    }\r\n\r\n    function resetAllowance(address delegate, address token) public {\r\n        Allowance memory allowance = getAllowance(msg.sender, delegate, token);\r\n        allowance.spent = 0;\r\n        updateAllowance(msg.sender, delegate, token, allowance);\r\n    }\r\n\r\n    function executeAllowanceTransfer(\r\n        GnosisSafe safe,\r\n        address token,\r\n        address payable to,\r\n        uint96 amount,\r\n        address paymentToken,\r\n        uint96 payment,\r\n        address delegate,\r\n        bytes memory signature\r\n    ) public {\r\n        // Get current state\r\n        Allowance memory allowance = getAllowance(address(safe), delegate, token);\r\n        bytes memory transferHashData = generateTransferHashData(address(safe), token, to, amount, paymentToken, payment, allowance.nonce);\r\n        // Update state\r\n        allowance.nonce = allowance.nonce + 1;\r\n        uint96 newSpent = allowance.spent + amount;\r\n        // Check new spent amount and overflow\r\n        require(newSpent > allowance.spent && newSpent <= allowance.amount, \"newSpent > allowance.spent && newSpent <= allowance.amount\");\r\n        allowance.spent = newSpent;\r\n        if (payment > 0) {\r\n            // Use updated allowance if token and paymentToken are the same\r\n            Allowance memory paymentAllowance = paymentToken == token ? allowance : getAllowance(address(safe), delegate, paymentToken);\r\n            newSpent = paymentAllowance.spent + payment;\r\n            // Check new spent amount and overflowf\r\n            require(newSpent > paymentAllowance.spent && newSpent <= paymentAllowance.amount, \"newSpent > paymentAllowance.spent && newSpent <= paymentAllowance.amount\");\r\n            paymentAllowance.spent = newSpent;\r\n            // Update payment allowance if different from allowance\r\n            if (paymentToken != token) updateAllowance(address(safe), delegate, paymentToken, paymentAllowance);\r\n        }\r\n        updateAllowance(address(safe), delegate, token, allowance);\r\n        // Check signature (this contains a potential call -> EIP-1271)\r\n        checkSignature(delegate, signature, transferHashData, safe);\r\n        // Perform\r\n        if (payment > 0) {\r\n            // Transfer payment\r\n            // solium-disable-next-line security/no-tx-origin\r\n            transfer(safe, paymentToken, tx.origin, payment);\r\n        }\r\n        // Transfer token\r\n        transfer(safe, token, to, amount);\r\n        emit ExecuteAllowanceTransfer(address(safe), delegate, token, to, amount, allowance.nonce - 1);\r\n    }\r\n\r\n    function generateTransferHashData(\r\n        address safe,\r\n        address token,\r\n        address to,\r\n        uint96 amount,\r\n        address paymentToken,\r\n        uint96 payment,\r\n        uint16 nonce\r\n    ) private view returns (bytes memory) {\r\n        bytes32 transferHash = keccak256(\r\n            abi.encode(ALLOWANCE_TRANSFER_TYPEHASH, safe, token, to, amount, paymentToken, payment, nonce)\r\n        );\r\n        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, transferHash);\r\n    }\r\n\r\n    function generateTransferHash(\r\n        address safe,\r\n        address token,\r\n        address to,\r\n        uint96 amount,\r\n        address paymentToken,\r\n        uint96 payment,\r\n        uint16 nonce\r\n    ) public view returns (bytes32) {\r\n        return keccak256(generateTransferHashData(\r\n            safe, token, to, amount, paymentToken, payment, nonce\r\n        ));\r\n    }\r\n\r\n    function checkSignature(address expectedDelegate, bytes memory signature, bytes memory transferHashData, GnosisSafe safe) private {\r\n        address signer = recoverSignature(signature, transferHashData);\r\n        require(\r\n            expectedDelegate == signer && delegates[address(safe)][uint48(signer)].delegate == signer,\r\n            \"expectedDelegate == signer && delegates[address(safe)][uint48(signer)].delegate == signer\"\r\n        );\r\n    }\r\n\r\n    function recoverSignature(bytes memory signature, bytes memory transferHashData) private view returns (address owner) {\r\n        // If there is no signature data msg.sender should be used\r\n        if (signature.length == 0) return msg.sender;\r\n        // Check that the provided signature data is not too short\r\n        require(signature.length >= 65, \"signatures.length >= 65\");\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        (v, r, s) = signatureSplit(signature, 0);\r\n        // If v is 0 then it is a contract signature\r\n        if (v == 0) {\r\n            // When handling contract signatures the address of the contract is encoded into r\r\n            owner = address(uint256(r));\r\n            bytes memory contractSignature;\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\r\n                contractSignature := add(add(signature, s), 0x20)\r\n            }\r\n            require(\r\n                ISignatureValidator(owner).isValidSignature(transferHashData, contractSignature) == EIP1271_MAGIC_VALUE,\r\n                \"Could not validate EIP-1271 signature\"\r\n            );\r\n        } else if (v > 30) {\r\n            // To support eth_sign and similar we adjust v and hash the transferHashData with the Ethereum message prefix before applying ecrecover\r\n            owner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(transferHashData))), v - 4, r, s);\r\n        } else {\r\n            // Use ecrecover with the messageHash for EOA signatures\r\n            owner = ecrecover(keccak256(transferHashData), v, r, s);\r\n        }\r\n    }\r\n\r\n    function transfer(GnosisSafe safe, address token, address payable to, uint96 amount) private {\r\n        if (token == address(0)) {\r\n            // solium-disable-next-line security/no-send\r\n            require(safe.execTransactionFromModule(to, amount, \"\", Enum.Operation.Call), \"Could not execute ether transfer\");\r\n        } else {\r\n            bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount);\r\n            require(safe.execTransactionFromModule(token, 0, data, Enum.Operation.Call), \"Could not execute token transfer\");\r\n        }\r\n    }\r\n\r\n    function getTokens(address safe, address delegate) public view returns (address[] memory) {\r\n        return tokens[safe][delegate];\r\n    }\r\n\r\n    function getTokenAllowance(address safe, address delegate, address token) public view returns (uint256[5] memory) {\r\n        Allowance memory allowance = getAllowance(safe, delegate, token);\r\n        return [\r\n            uint256(allowance.amount),\r\n            uint256(allowance.spent),\r\n            uint256(allowance.resetTimeMin),\r\n            uint256(allowance.lastResetMin),\r\n            uint256(allowance.nonce)\r\n        ];\r\n    }\r\n\r\n    function addDelegate(address delegate) public {\r\n        require(delegate != address(0), \"Invalid delegate address\");\r\n        uint48 index = uint48(delegate);\r\n        // Delegate already exists, nothing to do\r\n        if(delegates[msg.sender][index].delegate != address(0)) return;\r\n        uint48 startIndex = delegatesStart[msg.sender];\r\n        delegates[msg.sender][index] = Delegate(delegate, 0, startIndex);\r\n        delegates[msg.sender][startIndex].prev = index;\r\n        delegatesStart[msg.sender] = index;\r\n        emit AddDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    function removeDelegate(address delegate) public {\r\n        Delegate memory current = delegates[msg.sender][uint48(delegate)];\r\n        // Delegate doesn't exists, nothing to do\r\n        if(current.delegate == address(0)) return;\r\n        address[] storage delegateTokens = tokens[msg.sender][delegate];\r\n        for (uint256 i = 0; i < delegateTokens.length; i++) {\r\n            address token = delegateTokens[i];\r\n            // Set all allowance params except the nonce to 0\r\n            Allowance memory allowance = getAllowance(msg.sender, delegate, token);\r\n            allowance.amount = 0;\r\n            allowance.spent = 0;\r\n            allowance.resetTimeMin = 0;\r\n            allowance.lastResetMin = 0;\r\n            updateAllowance(msg.sender, delegate, token, allowance);\r\n        }\r\n        delegates[msg.sender][current.prev].next = current.next;\r\n        delegates[msg.sender][current.next].prev = current.prev;\r\n        emit RemoveDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    function getDelegates(address safe, uint48 start, uint8 pageSize) public view returns (address[] memory results, uint48 next) {\r\n        results = new address[](pageSize);\r\n        uint8 i = 0;\r\n        uint48 initialIndex = (start != 0) ? start : delegatesStart[safe];\r\n        Delegate memory current = delegates[safe][initialIndex];\r\n        while(current.delegate != address(0) && i < pageSize) {\r\n            results[i] = current.delegate;\r\n            i++;\r\n            current = delegates[safe][current.next];\r\n        }\r\n        next = uint48(current.delegate);\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            mstore(results, i)\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegatesStart\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ALLOWANCE_TRANSFER_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract GnosisSafe\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"payment\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"executeAllowanceTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"removeDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenAllowance\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowances\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"spent\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"resetTimeMin\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"lastResetMin\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"nonce\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"allowanceAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"resetTimeMin\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"resetBaseMin\",\"type\":\"uint32\"}],\"name\":\"setAllowance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"resetAllowance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"prev\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"next\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"payment\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"nonce\",\"type\":\"uint16\"}],\"name\":\"generateTransferHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"addDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint8\",\"name\":\"pageSize\",\"type\":\"uint8\"}],\"name\":\"getDelegates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"results\",\"type\":\"address[]\"},{\"internalType\":\"uint48\",\"name\":\"next\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"AddDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"RemoveDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"nonce\",\"type\":\"uint16\"}],\"name\":\"ExecuteAllowanceTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"allowanceAmount\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"resetTime\",\"type\":\"uint16\"}],\"name\":\"SetAllowance\",\"type\":\"event\"}]","ContractName":"AllowanceModule","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://ad139af9dcf4139a742f899c13f22deb5b5d54544fa4c83dd00793e356e5bafe"}]}