{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n// **INTERFACES**\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\ninterface ICEther {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n}\r\n\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\ninterface ICToken {\r\n    function mint(uint256 mintAmount) external returns (uint256);\r\n\r\n    function mint() external payable;\r\n\r\n    function redeem(uint256 redeemTokens) external returns (uint256);\r\n\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n    function borrow(uint256 borrowAmount) external returns (uint256);\r\n\r\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\r\n\r\n    function repayBorrow() external payable;\r\n\r\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\r\n\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n\r\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\r\n        external\r\n        returns (uint256);\r\n\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n\r\n    function exchangeRateCurrent() external returns (uint256);\r\n\r\n    function supplyRatePerBlock() external returns (uint256);\r\n\r\n    function borrowRatePerBlock() external returns (uint256);\r\n\r\n    function totalReserves() external returns (uint256);\r\n\r\n    function reserveFactorMantissa() external returns (uint256);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint256);\r\n\r\n    function borrowBalanceStored(address account) external view returns (uint256);\r\n\r\n    function totalBorrowsCurrent() external returns (uint256);\r\n\r\n    function getCash() external returns (uint256);\r\n\r\n    function balanceOfUnderlying(address owner) external returns (uint256);\r\n\r\n    function underlying() external returns (address);\r\n}\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\ninterface IComptroller {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\r\n\r\n    function exitMarket(address cToken) external returns (uint256);\r\n\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n\r\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256);\r\n\r\n    function markets(address cTokenAddress) external view returns (bool, uint);\r\n}\r\n\r\n\r\n\r\n// DfWallet - logic of user's wallet for cTokens\r\ncontract DfWallet {\r\n\r\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n\r\n    address public constant DF_FINANCE_OPEN = address(0xBA3EEeb0cf1584eE565F34fCaBa74d3e73268c0b);  // TODO: DfFinanceCompound address\r\n    address public constant DF_FINANCE_CLOSE = address(0x558AcEa066267883973D8c8Bcc07E79715B3e93e);  // TODO: DfFinanceCloseCompound address\r\n\r\n\r\n    // **MODIFIERS**\r\n\r\n    modifier authDeposit {\r\n        require(msg.sender == DF_FINANCE_OPEN, \"Permission denied\");\r\n        _;\r\n    }\r\n\r\n    modifier authWithdraw {\r\n        require(msg.sender == DF_FINANCE_CLOSE, \"Permission denied\");\r\n        _;\r\n    }\r\n\r\n\r\n    // **PUBLIC PAYABLE functions**\r\n\r\n    // Example: _collToken = Eth, _borrowToken = USDC\r\n    function deposit(\r\n        address _collToken, address _cCollToken, uint _collAmount, address _borrowToken, address _cBorrowToken, uint _borrowAmount\r\n    ) public payable authDeposit {\r\n        // add _cCollToken to market\r\n        enterMarketInternal(_cCollToken);\r\n\r\n        // mint _cCollToken\r\n        mintInternal(_collToken, _cCollToken, _collAmount);\r\n\r\n        // borrow and withdraw _borrowToken\r\n        borrowInternal(_borrowToken, _cBorrowToken, _borrowAmount);\r\n    }\r\n\r\n    // Example: _collToken = Eth, _borrowToken = USDC\r\n    function withdraw(\r\n        address _collToken, address _cCollToken, address _borrowToken, address _cBorrowToken\r\n    ) public payable authWithdraw {\r\n        // repayBorrow _cBorrowToken\r\n        paybackInternal(_borrowToken, _cBorrowToken);\r\n\r\n        // redeem _cCollToken\r\n        redeemInternal(_collToken, _cCollToken);\r\n    }\r\n\r\n\r\n    // **INTERNAL functions**\r\n\r\n    function approveCTokenInternal(address _tokenAddr, address _cTokenAddr) internal {\r\n        if (_tokenAddr != ETH_ADDRESS) {\r\n            if (IERC20(_tokenAddr).allowance(address(this), address(_cTokenAddr)) != uint256(-1)) {\r\n                IERC20(_tokenAddr).approve(_cTokenAddr, uint(-1));\r\n            }\r\n        }\r\n    }\r\n\r\n    function enterMarketInternal(address _cTokenAddr) internal {\r\n        address[] memory markets = new address[](1);\r\n        markets[0] = _cTokenAddr;\r\n\r\n        IComptroller(COMPTROLLER).enterMarkets(markets);\r\n    }\r\n\r\n    function mintInternal(address _tokenAddr, address _cTokenAddr, uint _amount) internal {\r\n        // approve _cTokenAddr to pull the _tokenAddr tokens\r\n        approveCTokenInternal(_tokenAddr, _cTokenAddr);\r\n\r\n        if (_tokenAddr != ETH_ADDRESS) {\r\n            require(ICToken(_cTokenAddr).mint(_amount) == 0);\r\n        } else {\r\n            ICEther(_cTokenAddr).mint.value(msg.value)(); // reverts on fail\r\n        }\r\n    }\r\n\r\n    function borrowInternal(address _tokenAddr, address _cTokenAddr, uint _amount) internal {\r\n        require(ICToken(_cTokenAddr).borrow(_amount) == 0);\r\n\r\n        // withdraw funds to msg.sender (DfFinance contract)\r\n        if (_tokenAddr != ETH_ADDRESS) {\r\n            IERC20(_tokenAddr).transfer(msg.sender, IERC20(_tokenAddr).balanceOf(address(this)));\r\n        } else {\r\n            transferEthInternal(msg.sender, address(this).balance);\r\n        }\r\n    }\r\n\r\n    function paybackInternal(address _tokenAddr, address _cTokenAddr) internal {\r\n        // approve _cTokenAddr to pull the _tokenAddr tokens\r\n        approveCTokenInternal(_tokenAddr, _cTokenAddr);\r\n\r\n        if (_tokenAddr != ETH_ADDRESS) {\r\n            uint amount = ICToken(_cTokenAddr).borrowBalanceCurrent(address(this));\r\n\r\n            IERC20(_tokenAddr).transferFrom(msg.sender, address(this), amount);\r\n            require(ICToken(_cTokenAddr).repayBorrow(amount) == 0);\r\n        } else {\r\n            ICEther(_cTokenAddr).repayBorrow.value(msg.value)();\r\n            if (address(this).balance > 0) {\r\n                transferEthInternal(msg.sender, address(this).balance);  // send back the extra eth\r\n            }\r\n        }\r\n    }\r\n\r\n    function redeemInternal(address _tokenAddr, address _cTokenAddr) internal {\r\n        // converts all _cTokenAddr into the underlying asset (_tokenAddr)\r\n        require(ICToken(_cTokenAddr).redeem(IERC20(_cTokenAddr).balanceOf(address(this))) == 0);\r\n\r\n        // withdraw funds to msg.sender\r\n        if (_tokenAddr != ETH_ADDRESS) {\r\n            IERC20(_tokenAddr).transfer(msg.sender, IERC20(_tokenAddr).balanceOf(address(this)));\r\n        } else {\r\n            transferEthInternal(msg.sender, address(this).balance);\r\n        }\r\n    }\r\n\r\n    function transferEthInternal(address _receiver, uint _amount) internal {\r\n        address payable receiverPayable = address(uint160(_receiver));\r\n        (bool result, ) = receiverPayable.call.value(_amount)(\"\");\r\n        require(result, \"Transfer of ETH failed\");\r\n    }\r\n\r\n\r\n    // **FALLBACK functions**\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPTROLLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DF_FINANCE_CLOSE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DF_FINANCE_OPEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cCollToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cBorrowToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_borrowAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cCollToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cBorrowToken\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"DfWallet","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://3238651b0b50305447e84d0546fe0b8dc9ef9389cad5f29a3c0fadb9e039fd78"}]}