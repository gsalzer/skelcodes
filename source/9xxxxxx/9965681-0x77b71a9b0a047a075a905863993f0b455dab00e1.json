{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\ncontract CToken {\r\n    address public underlying;\r\n    function transfer(address dst, uint256 amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, CToken cTokenCollateral) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external view returns (uint);\r\n    function totalSupply() external view returns(uint);\r\n    function balanceOfUnderlying(address account) external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n}\r\ncontract ITokensTypeStorage {\r\n  mapping(address => bool) public isRegistred;\r\n\r\n  mapping(address => bytes32) public getType;\r\n\r\n  mapping(address => bool) public isPermittedAddress;\r\n\r\n  address public owner;\r\n\r\n  function addNewTokenType(address _token, string _type) public;\r\n\r\n  function setTokenTypeAsOwner(address _token, string _type) public;\r\n}\r\n\r\n\r\ncontract PoolPortalInterface {\r\n  function buyPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  external\r\n  payable;\r\n\r\n  function sellPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    ERC20 _poolToken\r\n  )\r\n  external\r\n  payable;\r\n\r\n  function getBacorConverterAddressByRelay(address relay)\r\n  public\r\n  view\r\n  returns(address converter);\r\n\r\n  function getBancorConnectorsAmountByRelayAmount\r\n  (\r\n    uint256 _amount,\r\n    ERC20 _relay\r\n  )\r\n  public view returns(uint256 bancorAmount, uint256 connectorAmount);\r\n\r\n  function getBancorConnectorsByRelay(address relay)\r\n  public\r\n  view\r\n  returns(\r\n    ERC20 BNTConnector,\r\n    ERC20 ERCConnector\r\n  );\r\n\r\n  function getBancorRatio(address _from, address _to, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256);\r\n\r\n  function getUniswapConnectorsAmountByPoolAmount(\r\n    uint256 _amount,\r\n    address _exchange\r\n  )\r\n  public\r\n  view\r\n  returns(uint256 ethAmount, uint256 ercAmount);\r\n\r\n  function getUniswapTokenAmountByETH(address _token, uint256 _amount)\r\n  public\r\n  view\r\n  returns(uint256);\r\n\r\n  function getTokenByUniswapExchange(address _exchange)\r\n  public\r\n  view\r\n  returns(address);\r\n}\r\n\r\n\r\ncontract ExchangePortalInterface {\r\n\r\n  event Trade(address src, uint256 srcAmount, address dest, uint256 destReceived);\r\n\r\n  function trade(\r\n    ERC20 _source,\r\n    uint256 _sourceAmount,\r\n    ERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] _additionalArgs,\r\n    bytes _additionalData\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256);\r\n\r\n  function compoundRedeemByPercent(uint _percent, address _cToken) external returns(uint256);\r\n\r\n  function compoundMint(uint256 _amount, address _cToken) external payable returns(uint256);\r\n\r\n  function getPercentFromCTokenBalance(uint _percent, address _cToken, address _holder)\r\n   public\r\n   view\r\n   returns(uint256);\r\n\r\n  function getValue(address _from, address _to, uint256 _amount) public view returns (uint256);\r\n\r\n  function getTotalValue(address[] _fromAddresses, uint256[] _amounts, address _to)\r\n   public\r\n   view\r\n   returns (uint256);\r\n\r\n   function getCTokenUnderlying(address _cToken) public view returns(address);\r\n}\r\n\r\n/**\r\n* This contract convert source ERC20 token to destanation token\r\n* support sources 1INCH, COMPOUND, BANCOR/UNISWAP pools\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\ncontract ConvertPortal {\r\n  address constant private ETH_TOKEN_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n  bytes32[] private BYTES32_EMPTY_ARRAY = new bytes32[](0);\r\n  address public CEther;\r\n  address public sUSD;\r\n  ExchangePortalInterface public exchangePortal;\r\n  PoolPortalInterface public poolPortal;\r\n  ITokensTypeStorage  public tokensTypes;\r\n\r\n  /**\r\n  * @dev contructor\r\n  *\r\n  * @param _exchangePortal         address of exchange portal\r\n  * @param _poolPortal             address of pool portal\r\n  * @param _tokensTypes            address of the tokens type storage\r\n  * @param _CEther                 address of Compound ETH wrapper\r\n  */\r\n  constructor(\r\n    address _exchangePortal,\r\n    address _poolPortal,\r\n    address _tokensTypes,\r\n    address _CEther\r\n    )\r\n    public\r\n  {\r\n    exchangePortal = ExchangePortalInterface(_exchangePortal);\r\n    poolPortal = PoolPortalInterface(_poolPortal);\r\n    tokensTypes = ITokensTypeStorage(_tokensTypes);\r\n    CEther = _CEther;\r\n  }\r\n\r\n  // convert CRYPTOCURRENCY, COMPOUND, BANCOR/UNISWAP pools to _destination asset\r\n  function convert(\r\n    address _source,\r\n    uint256 _sourceAmount,\r\n    address _destination,\r\n    address _receiver\r\n  )\r\n    external\r\n    payable\r\n  {\r\n    // no need continue convert for not correct input data\r\n    if(_sourceAmount <= 0 || _source == _destination)\r\n      return;\r\n\r\n    uint256 receivedAmount = 0;\r\n    // convert assets\r\n    if(tokensTypes.getType(_source) == bytes32(\"CRYPTOCURRENCY\")){\r\n      receivedAmount = convertCryptocurency(_source, _sourceAmount, _destination);\r\n    }\r\n    else if (tokensTypes.getType(_source) == bytes32(\"BANCOR POOL\")){\r\n      receivedAmount = convertBancorPool(_source, _sourceAmount, _destination);\r\n    }\r\n    else if (tokensTypes.getType(_source) == bytes32(\"UNISWAP POOL\")){\r\n      receivedAmount = convertUniswapPool(_source, _sourceAmount, _destination);\r\n    }\r\n    else if (tokensTypes.getType(_source) == bytes32(\"COMPOUND\")){\r\n      receivedAmount = convertCompound(_source, _sourceAmount, _destination);\r\n    }\r\n    else {\r\n      // Unknown type\r\n      revert(\"Unknown token type\");\r\n    }\r\n\r\n    // send assets to _receiver\r\n    if (_destination == ETH_TOKEN_ADDRESS) {\r\n      (_receiver).transfer(receivedAmount);\r\n    } else {\r\n      // transfer tokens received to sender\r\n      ERC20(_destination).transfer(_receiver, receivedAmount);\r\n    }\r\n\r\n    // After the trade, any _source that exchangePortal holds will be sent back to msg.sender\r\n    uint256 endAmount = (_source == ETH_TOKEN_ADDRESS)\r\n    ? address(this).balance\r\n    : ERC20(_source).balanceOf(address(this));\r\n\r\n    // Check if we hold a positive amount of _source\r\n    if (endAmount > 0) {\r\n      if (_source == ETH_TOKEN_ADDRESS) {\r\n        (_receiver).transfer(endAmount);\r\n      } else {\r\n        ERC20(_source).transfer(_receiver, endAmount);\r\n      }\r\n    }\r\n  }\r\n\r\n  // helper for convert Compound asset\r\n  // _source - should be Compound token\r\n  function convertCompound(address _source, uint256 _sourceAmount, address _destination)\r\n    private\r\n    returns(uint256)\r\n  {\r\n    // step 0 transfer compound asset from sender\r\n    ERC20(_source).transferFrom(msg.sender, address(this), _sourceAmount);\r\n\r\n    // step 1 convert cToken to underlying\r\n    CToken(_source).redeem(_sourceAmount);\r\n\r\n    // step 2 get underlying address and received underlying amount\r\n    address underlyingAddress = (_source == CEther)\r\n    ? ETH_TOKEN_ADDRESS\r\n    : CToken(_source).underlying();\r\n\r\n    uint256 underlyingAmount = (_source == CEther)\r\n    ? address(this).balance\r\n    : ERC20(underlyingAddress).balanceOf(address(this));\r\n\r\n    // step 3 convert underlying to destination if _destination != underlyingAddress\r\n    if(_destination != underlyingAddress){\r\n      uint256 destAmount = 0;\r\n      // convert via 1inch\r\n      // Convert ETH\r\n      if(underlyingAddress == ETH_TOKEN_ADDRESS){\r\n        destAmount = exchangePortal.trade.value(underlyingAmount)(\r\n          ERC20(underlyingAddress),\r\n          underlyingAmount,\r\n          ERC20(_destination),\r\n          2,\r\n          BYTES32_EMPTY_ARRAY,\r\n          \"0x\"\r\n        );\r\n      }\r\n      // Convert ERC20\r\n      else{\r\n        ERC20(underlyingAddress).approve(address(exchangePortal), underlyingAmount);\r\n        destAmount = exchangePortal.trade(\r\n          ERC20(underlyingAddress),\r\n          underlyingAmount,\r\n          ERC20(_destination),\r\n          2,\r\n          BYTES32_EMPTY_ARRAY,\r\n          \"0x\"\r\n        );\r\n      }\r\n      return destAmount;\r\n    }\r\n    else{\r\n      return underlyingAmount;\r\n    }\r\n\r\n  }\r\n\r\n  // helper for convert Unswap asset\r\n  // _source - should be Uni pool\r\n  function convertUniswapPool(address _source, uint256 _sourceAmount, address _destination)\r\n    private\r\n    returns(uint256)\r\n  {\r\n    // sell pool\r\n    _transferFromSenderAndApproveTo(ERC20(_source), _sourceAmount, address(poolPortal));\r\n\r\n    poolPortal.sellPool(\r\n      _sourceAmount,\r\n      1, // type Uniswap\r\n      ERC20(_source)\r\n    );\r\n\r\n    // convert pool connectors to destanation\r\n    // get erc20 connector address\r\n    address ERCConnector = poolPortal.getTokenByUniswapExchange(_source);\r\n    uint256 ERCAmount = ERC20(ERCConnector).balanceOf(address(this));\r\n\r\n    // convert ERC20 connector via 1inch if destination != ERC20 connector\r\n    if(ERCConnector != _destination){\r\n      ERC20(ERCConnector).approve(address(exchangePortal), ERCAmount);\r\n      exchangePortal.trade(\r\n        ERC20(ERCConnector),\r\n        ERCAmount,\r\n        ERC20(_destination),\r\n        2, // type 1inch\r\n        BYTES32_EMPTY_ARRAY,\r\n        \"0x\"\r\n      );\r\n    }\r\n\r\n    // if destanation != ETH, convert ETH also\r\n    if(_destination != ETH_TOKEN_ADDRESS){\r\n      uint256 ETHAmount = address(this).balance;\r\n      exchangePortal.trade.value(ETHAmount)(\r\n        ERC20(ETH_TOKEN_ADDRESS),\r\n        ETHAmount,\r\n        ERC20(_destination),\r\n        2, // type 1inch\r\n        BYTES32_EMPTY_ARRAY,\r\n        \"0x\"\r\n      );\r\n    }\r\n\r\n    // return received amount\r\n    if(_destination == ETH_TOKEN_ADDRESS){\r\n      return address(this).balance;\r\n    }else{\r\n      return ERC20(_destination).balanceOf(address(this));\r\n    }\r\n  }\r\n\r\n  // helper for convert standrad crypto assets\r\n  function convertCryptocurency(address _source, uint256 _sourceAmount, address _destination)\r\n    private\r\n    returns(uint256)\r\n  {\r\n    // Convert crypto via 1inch aggregator\r\n    uint256 destAmount = 0;\r\n    if(_source == ETH_TOKEN_ADDRESS){\r\n      destAmount = exchangePortal.trade.value(_sourceAmount)(\r\n        ERC20(_source),\r\n        _sourceAmount,\r\n        ERC20(_destination),\r\n        2,\r\n        BYTES32_EMPTY_ARRAY,\r\n        \"0x\"\r\n      );\r\n    }else{\r\n      _transferFromSenderAndApproveTo(ERC20(_source), _sourceAmount, address(exchangePortal));\r\n      destAmount = exchangePortal.trade(\r\n        ERC20(_source),\r\n        _sourceAmount,\r\n        ERC20(_destination),\r\n        2,\r\n        BYTES32_EMPTY_ARRAY,\r\n        \"0x\"\r\n      );\r\n    }\r\n    return destAmount;\r\n  }\r\n\r\n  // helper for convert Bancor pools asset\r\n  // _source - should be Bancor pool\r\n  function convertBancorPool(address _source, uint256 _sourceAmount, address _destination)\r\n    private\r\n    returns(uint256)\r\n  {\r\n    _transferFromSenderAndApproveTo(ERC20(_source), _sourceAmount, address(exchangePortal));\r\n    // Convert BNT pools just via Bancor DEX\r\n    uint256 destAmount = exchangePortal.trade(\r\n      ERC20(_source),\r\n      _sourceAmount,\r\n      ERC20(_destination),\r\n      1,\r\n      BYTES32_EMPTY_ARRAY,\r\n      \"0x\"\r\n    );\r\n\r\n    return destAmount;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfers tokens to this contract and approves them to another address\r\n  *\r\n  * @param _source          Token to transfer and approve\r\n  * @param _sourceAmount    The amount to transfer and approve (in _source token)\r\n  * @param _to              Address to approve to\r\n  */\r\n  function _transferFromSenderAndApproveTo(ERC20 _source, uint256 _sourceAmount, address _to) private {\r\n    require(_source.transferFrom(msg.sender, address(this), _sourceAmount), \"Can not transfer from\");\r\n\r\n    _source.approve(_to, _sourceAmount);\r\n  }\r\n\r\n  // fallback payable function to receive ether from other contract addresses\r\n  function() public payable {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"poolPortal\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CEther\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangePortal\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_source\",\"type\":\"address\"},{\"name\":\"_sourceAmount\",\"type\":\"uint256\"},{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"convert\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_exchangePortal\",\"type\":\"address\"},{\"name\":\"_poolPortal\",\"type\":\"address\"},{\"name\":\"_tokensTypes\",\"type\":\"address\"},{\"name\":\"_CEther\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ConvertPortal","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dabb0a62894a19c0d4cb86bed6cfdfee7c4652c200000000000000000000000001fa1b31766c0e58a2c66b6fba3c36128aea60e400000000000000000000000067d635a86d5bff3d3742a93761be0e272bb7541e0000000000000000000000004ddc2d193948926d02f9b1fe9e1daa0718270ed5","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://48b9cc8e986962c35f4403012a0de380db32088e7bff7a3c755bb4658524eda8"}]}