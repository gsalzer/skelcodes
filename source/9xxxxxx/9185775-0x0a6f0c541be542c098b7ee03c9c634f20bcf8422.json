{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\ncontract ERC20Interface {\r\n\r\n    function name() public view returns (string memory);\r\n\r\n    function symbol() public view returns (string memory);\r\n\r\n    function decimals() public view returns (uint8);\r\n\r\n    function totalSupply() public view returns (uint);\r\n\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    function burn(uint256 amount) public;\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n}\r\n\r\ncontract MerkleDrop {\r\n\r\n    bytes32 public root;\r\n    ERC20Interface public droppedToken;\r\n    uint public decayStartTime;\r\n    uint public decayDurationInSeconds;\r\n\r\n    uint public initialBalance;\r\n    uint public remainingValue;  // The total of not withdrawn entitlements, not considering decay\r\n    uint public spentTokens;  // The total tokens spent by the contract, burnt or withdrawn\r\n\r\n    mapping (address => bool) public withdrawn;\r\n\r\n    event Withdraw(address recipient, uint value, uint originalValue);\r\n    event Burn(uint value);\r\n\r\n    constructor(ERC20Interface _droppedToken, uint _initialBalance, bytes32 _root, uint _decayStartTime, uint _decayDurationInSeconds) public {\r\n        // The _initialBalance should be equal to the sum of airdropped tokens\r\n        droppedToken = _droppedToken;\r\n        initialBalance = _initialBalance;\r\n        remainingValue = _initialBalance;\r\n        root = _root;\r\n        decayStartTime = _decayStartTime;\r\n        decayDurationInSeconds = _decayDurationInSeconds;\r\n    }\r\n\r\n    function withdraw(uint value, bytes32[] memory proof) public {\r\n        require(verifyEntitled(msg.sender, value, proof), \"The proof could not be verified.\");\r\n        require(! withdrawn[msg.sender], \"You have already withdrawn your entitled token.\");\r\n\r\n        burnUnusableTokens();\r\n\r\n        uint valueToSend = decayedEntitlementAtTime(value, now, false);\r\n        assert(valueToSend <= value);\r\n        require(droppedToken.balanceOf(address(this)) >= valueToSend, \"The MerkleDrop does not have tokens to drop yet / anymore.\");\r\n        require(valueToSend != 0, \"The decayed entitled value is now zero.\");\r\n\r\n        withdrawn[msg.sender] = true;\r\n        remainingValue -= value;\r\n        spentTokens += valueToSend;\r\n\r\n        require(droppedToken.transfer(msg.sender, valueToSend));\r\n        emit Withdraw(msg.sender, valueToSend, value);\r\n    }\r\n\r\n    function verifyEntitled(address recipient, uint value, bytes32[] memory proof) public view returns (bool) {\r\n        // We need to pack the 20 bytes address to the 32 bytes value\r\n        // to match with the proof made with the python merkle-drop package\r\n        bytes32 leaf = keccak256(abi.encodePacked(recipient, value));\r\n        return verifyProof(leaf, proof);\r\n    }\r\n\r\n    function decayedEntitlementAtTime(uint value, uint time, bool roundUp) public view returns (uint) {\r\n        if (time <= decayStartTime) {\r\n            return value;\r\n        } else if (time >= decayStartTime + decayDurationInSeconds) {\r\n            return 0;\r\n        } else {\r\n            uint timeDecayed = time - decayStartTime;\r\n            uint valueDecay = decay(value, timeDecayed, decayDurationInSeconds, !roundUp);\r\n            assert(valueDecay <= value);\r\n            return value - valueDecay;\r\n        }\r\n    }\r\n\r\n    function burnUnusableTokens() public {\r\n        if (now <= decayStartTime) {\r\n            return;\r\n        }\r\n\r\n        // The amount of tokens that should be held within the contract after burning\r\n        uint targetBalance = decayedEntitlementAtTime(remainingValue, now, true);\r\n\r\n        // toBurn = (initial balance - target balance) - what we already removed from initial balance\r\n        uint currentBalance = initialBalance - spentTokens;\r\n        assert(targetBalance <= currentBalance);\r\n        uint toBurn = currentBalance - targetBalance;\r\n\r\n        spentTokens += toBurn;\r\n        burn(toBurn);\r\n    }\r\n\r\n    function deleteContract() public {\r\n        require(now >= decayStartTime + decayDurationInSeconds, \"The storage cannot be deleted before the end of the merkle drop.\");\r\n        burnUnusableTokens();\r\n\r\n        selfdestruct(address(0));\r\n    }\r\n\r\n    function verifyProof(bytes32 leaf, bytes32[] memory proof) internal view returns (bool) {\r\n        bytes32 currentHash = leaf;\r\n\r\n        for (uint i = 0; i < proof.length; i += 1) {\r\n            currentHash = parentHash(currentHash, proof[i]);\r\n        }\r\n\r\n        return currentHash == root;\r\n    }\r\n\r\n    function parentHash(bytes32 a, bytes32 b) internal pure returns (bytes32) {\r\n        if (a < b) {\r\n            return keccak256(abi.encode(a, b));\r\n        } else {\r\n            return keccak256(abi.encode(b, a));\r\n        }\r\n    }\r\n\r\n    function burn(uint value) internal {\r\n        if (value == 0) {\r\n            return;\r\n        }\r\n        emit Burn(value);\r\n        droppedToken.burn(value);\r\n    }\r\n\r\n    function decay(uint value, uint timeToDecay, uint totalDecayTime, bool roundUp) internal pure returns (uint) {\r\n        uint decay;\r\n\r\n        if (roundUp) {\r\n            decay = (value*timeToDecay+totalDecayTime-1)/totalDecayTime;\r\n        } else {\r\n            decay = value*timeToDecay/totalDecayTime;\r\n        }\r\n        return decay >= value ? value : decay;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"roundUp\",\"type\":\"bool\"}],\"name\":\"decayedEntitlementAtTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deleteContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decayStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyEntitled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnUnusableTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decayDurationInSeconds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"droppedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spentTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_droppedToken\",\"type\":\"address\"},{\"name\":\"_initialBalance\",\"type\":\"uint256\"},{\"name\":\"_root\",\"type\":\"bytes32\"},{\"name\":\"_decayStartTime\",\"type\":\"uint256\"},{\"name\":\"_decayDurationInSeconds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"originalValue\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"MerkleDrop","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"5000","ConstructorArguments":"000000000000000000000000679131f591b4f369acb8cd8c51e68596806c3916000000000000000000000000000000000000000000211654663a9467a7ebd00023aefae04ed373d0de991f6220a536e67c4a84dac6065a16d5445c0eed8a5eaf000000000000000000000000000000000000000000000000000000005e0bd2b40000000000000000000000000000000000000000000000000000000003c3b880","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://1d09d48e627765528b71a4ef83baffaae0258e4f2d01067899699d5f17ed6aec"}]}