{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16; \r\n/*** @title SafeMath * @dev Math operations with safety checks that throw on error */ \r\n\r\nlibrary SafeMath { //knownsec //安全的算法 \r\n\t\r\n\t/** * @dev Multiplies two numbers, throws on overflow. */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) { \r\n\t\tif (a == 0) { return 0; }uint256 c = a * b; assert(c / a == b); return c; \r\n\t}\r\n\t\r\n\t/** * @dev Integer division of two numbers, truncating the quotient. */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) { \r\n\t\t// assert(b > 0); \r\n\t\t// Solidity automatically throws when dividing by 0 uint256 c = a / b; \r\n\t\t// assert(a == b * c + a % b); \r\n\t\t// There is no case in which this doesn't hold return c; \r\n\t}\r\n\t\r\n\t/** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) { \r\n\t\tassert(b <= a); return a - b; \r\n\t}\r\n\t\r\n\t/** * @dev Adds two numbers, throws on overflow. */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) { \r\n\t\tuint256 c = a + b; assert(c >= a); return c; \r\n\t} \r\n}\r\n\r\ncontract owned { //knownsec //认证 \r\n\taddress public owner; \r\n\tfunction owned() public { \r\n\t\towner = msg.sender; \r\n\t}\r\n\t\r\n\tmodifier onlyOwner { \r\n\t\trequire(msg.sender == owner); _; \r\n\t}\r\n\t\r\n\tfunction transferOwnership(address newOwner) onlyOwner public { \r\n\t\towner = newOwner;\r\n\t} \r\n}\r\n\r\ninterface tokenRecipient { \r\n\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; \r\n} \r\n\r\ncontract TokenERC20 { \r\n\tusing SafeMath for uint256; \r\n\t\r\n\t// Public variables of the token \r\n\tstring public name; \r\n\tstring public symbol; \r\n\tuint8 public decimals = 18; \r\n\t\r\n\t// 18 decimals is the strongly suggested default, avoid changing it \r\n\tuint256 public totalSupply; \r\n\t\r\n\t// This creates an array with all balances \r\n\tmapping (address => uint256) public balanceOf; \r\n\tmapping (address => mapping (address => uint256)) public allowance; \r\n\t\r\n\t// This generates a public event on the blockchain that will notify clients \r\n\tevent Transfer(address indexed from, address indexed to, uint256 value); \r\n\t\r\n\t// This notifies clients about the amount burnt \r\n\tevent Burn(address indexed from, uint256 value); \r\n\t\r\n\t/*** Constrctor function \r\n\t** Initializes contract with initial supply tokens to the creator of the contract \r\n\t*/ \r\n\tfunction TokenERC20( //knownsec /初始化代币 \r\n\t\tuint256 initialSupply, \r\n\t\tstring tokenName, \r\n\t\tstring tokenSymbol \r\n\t) public { \r\n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount \r\n\t\tbalanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens \r\n\t\tname = tokenName; // Set the name for display purposes \r\n\t\tsymbol = tokenSymbol; // Set the symbol for display purposes \r\n\t}\r\n\t\r\n\t/*** Internal transfer, only can be called by this contract \r\n\t*/ \r\n\tfunction _transfer(address _from, address _to, uint _value) internal { \r\n\t\t// Prevent transfer to 0x0 address. Use burn() instead \r\n\t\trequire(_to != 0x0);\r\n\t\t// Check if the sender has enough \r\n\t\trequire(balanceOf[_from] >= _value); \r\n\t\t// Check for overflows \r\n\t\trequire(balanceOf[_to].add(_value) > balanceOf[_to]); \r\n\t\t// Save this for an assertion in the future \r\n\t\tuint previousBalances = balanceOf[_from].add(balanceOf[_to]); \r\n\t\t// Subtract from the sender \r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value); \r\n\t\t// Add the same to the recipient \r\n\t\tbalanceOf[_to] = balanceOf[_to].add(_value); \r\n\t\temit Transfer(_from, _to, _value); \r\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail \r\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances); //knownsec //此句为检查交易后是否溢出，建议放在Transfer前。但是由于所⽤算法均为安全算法，所以⽆影响。 \r\n\t}\r\n\t\r\n\t/*** Transfer tokens \r\n\t** Send `_value` tokens to `_to` from your account \r\n\t** @param _to The address of the recipient \r\n\t* @param _value the amount to send \r\n\t*/\r\n\tfunction transfer(address _to, uint256 _value) public { //knownsec //公开的交易 \r\n\t\t_transfer(msg.sender, _to, _value); \r\n\t}\r\n\t\r\n\t/*** Transfer tokens from other address \r\n\t** Send `_value` tokens to `_to` in behalf of `_from` \r\n\t** @param _from The address of the sender \r\n\t* @param _to The address of the recipient \r\n\t* @param _value the amount to send \r\n\t*/ \r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { //knownsec //代转 \r\n\t\trequire(_value <= allowance[_from][msg.sender]); \r\n\t\t// Check allowance \r\n\t\tallowance[_from][msg.sender ] = allowance[_from][msg.sender].sub(_value); \r\n\t\t_transfer(_from, _to, _value); return true; \r\n\t}\r\n\t\r\n\t/*** Set allowance for other address \r\n\t** Allows `_spender` to spend no more than `_value` tokens in your behalf \r\n\t** @param _spender The address authorized to spend \r\n\t* @param _value the max amount they can spend \r\n\t*/ \r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) { \r\n\t\tallowance[msg.sender][_spender] = _value; //knownsec //事务顺序依赖⻛险 \r\n\t\treturn true; \r\n\t}\r\n\t\r\n\t/*** Set allowance for other address and notify \r\n\t** Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it \r\n\t** @param _spender The address authorized to spend \r\n\t* @param _value the max amount they can spend \r\n\t* @param _extraData some extra information to send to the approved contract \r\n\t*/ \r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData ) public returns (bool success) { \r\n\t\ttokenRecipient spender = tokenRecipient(_spender); \r\n\t\tif (approve(_spender, _value)) { \r\n\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData); return true; \r\n\t\t} \r\n\t}\r\n\t\r\n\t/*** Destroy tokens ** Remove `_value` tokens from the system irreversibly \r\n\t** @param _value the amount of money to burn \r\n\t*/ \r\n\tfunction burn(uint256 _value) public returns (bool success) { //knownsec //销毁 \r\n\t\trequire(balanceOf[msg.sender] >= _value); \r\n\t\t// Check if the sender has enough \r\n\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); \r\n\t\t// Subtract from the sender \r\n\t\ttotalSupply = totalSupply.sub(_value); \r\n\t\t// Updates totalSupply \r\n\t\temit Burn(msg.sender, _value); \r\n\t\treturn true;\t\t\r\n\t}\r\n\t\r\n\t/*** Destroy tokens from other account \r\n\t** Remove `_value` tokens from the system irreversibly on behalf of `_from`. \r\n\t* @param _from the address of the sender \r\n\t* @param _value the amount of money to burn \r\n\t*/ \r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) { //knownsec //销毁他⼈的代币 \r\n\t\trequire(balanceOf[_from] >= _value); \r\n\t\t// Check if the targeted balance is enough \r\n\t\trequire(_value <= allowance[_from][msg.sender]); \r\n\t\t// Check allowance \r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value); \r\n\t\t// Subtract from the targeted balance \r\n\t\tallowance[_from][msg.sender ] = allowance[_from][msg.sender].sub(_value); \r\n\t\t// Subtract from the sender's allowance \r\n\t\ttotalSupply = totalSupply.sub(_value); \r\n\t\t// Update totalSupply \r\n\t\temit Burn(_from, _value); \r\n\t\treturn true; \r\n\t} \r\n\t\r\n\t// 批量转账\r\n\tfunction batchTransfer(address[] _receivers, uint256 _value) public returns (bool success) {\r\n\t\tuint receiverCount = _receivers.length;\r\n\t\tuint256 amount = _value.mul(uint256(receiverCount));\r\n\t\t/* require(receiverCount > 0 && receiverCount <= 20); */\r\n\t\trequire(receiverCount > 0);\r\n\t\trequire(_value > 0 && balanceOf[msg.sender] >= amount);\r\n\r\n\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\r\n\t\tfor (uint i = 0; i < receiverCount; i++) {\r\n\t\t\tbalanceOf[_receivers[i]] = balanceOf[_receivers[i]].add(_value);\r\n\t\t\t_transfer(msg.sender, _receivers[i], _value);\r\n\t\t}\r\n\t\treturn true;\r\n\t  }\r\n}\r\n/******************************************/ \r\n/* ADVANCED TOKEN STARTS HERE */\r\n/******************************************/ \r\ncontract MyAdvancedToken is owned, TokenERC20 { \r\n\tusing SafeMath for uint256; \r\n\tuint256 public sellPrice ; \r\n\tuint256 public buyPrice; \r\n\t\r\n\tmapping (address => bool) public frozenAccount; \r\n\t\r\n\t/* This generates a public event on the blockchain that will notify clients */ \r\n\tevent FrozenFunds(address target, bool frozen); \r\n\t\r\n\t/* Initializes contract with initial supply tokens to the creator of the contract */ \r\n\tfunction MyAdvancedToken( \r\n\t\tuint256 initialSupply, \r\n\t\tstring tokenName, \r\n\t\tstring tokenSymbol \r\n\t) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} \r\n\t\r\n\t/* Internal transfer, only can be called by this contract */ \r\n\tfunction _transfer(address _from, address _to, uint _value) internal { \r\n\t\trequire (_to != 0x0); \r\n\t\t\r\n\t\t// Prevent transfer to 0x0 address. Use burn() instead \r\n\t\trequire (balanceOf[_from] >= _value); \r\n\t\t\r\n\t\t// Check if the sender has enough \r\n\t\trequire (balanceOf[_to].add (_value) >= balanceOf[_to]); \r\n\t\t\r\n\t\t// Check for overflows \r\n\t\trequire(!frozenAccount[_from]); \r\n\t\t\r\n\t\t// Check if sender is frozen \r\n\t\trequire(!frozenAccount[_to]); \r\n\t\t\r\n\t\t// Check if recipient is frozen \r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value); \r\n\t\t\r\n\t\t// Subtract from the sender \r\n\t\tbalanceOf[_to] = balanceOf[_to ].add (_value); \r\n\t\t\r\n\t\t// Add the same to the recipient \r\n\t\temit Transfer(_from, _to, _value); \r\n\t}\r\n\t\r\n\t/// @notice Create `mintedAmount` tokens and send it to `target` \r\n\t/// @param target Address to receive the tokens \r\n\t/// @param mintedAmount the amount of tokens it will receive \r\n\tfunction mintToken(address target, uint256 mintedAmount) onlyOwner public { //knownsec //增发代币\r\n\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount); \r\n\t\ttotalSupply = totalSupply.add(mintedAmount); \r\n\t\temit Transfer(0, this, mintedAmount); \r\n\t\temit Transfer(this, target, mintedAmount); \r\n\t}\r\n\t\r\n\t/// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens \r\n\t/// @param target Address to be frozen \r\n\t/// @param freeze either to freeze it or not \r\n\tfunction freezeAccount(address target, bool freeze) onlyOwner public { //knownsec // 冻结账户 \r\n\t\tfrozenAccount[target] = freeze; emit FrozenFunds(target, freeze); \r\n\t}\r\n\t\r\n\t/// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth \r\n\t/// @param newSellPrice Price the users can sell to the contract \r\n\t/// @param newBuyPrice Price users can buy from the contract \r\n\tfunction setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { //knownsec //代币买卖价格 \r\n\t\tsellPrice = newSellPrice; \r\n\t\tbuyPrice = newBuyPrice; \r\n\t}\r\n\t\r\n\t/// @notice Buy tokens from contract by sending ether \r\n\tfunction buy() payable public { //knownsec //买代币 \r\n\t\tuint amount = msg.value.div(buyPrice); // calculates the amount\r\n\t\t_transfer(this, msg.sender, amount); // makes the transfers \r\n\t}\r\n\t\r\n\t/// @notice Sell `amount` tokens to contract \r\n\t/// @param amount amount of tokens to be sold \r\n\tfunction sell(uint256 amount) public { //knownsec //卖代币 \r\n\t\trequire(address(this).balance >= amount.mul(sellPrice)); // checks if the contract has enough ether to buy \r\n\t\t_transfer(msg.sender, this, amount); // makes the transfers \r\n\t\tmsg.sender.transfer(amount.mul(sellPrice)); // sends ether to the seller. It's important to do this last to avoid recursion attacks \r\n\t} \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newSellPrice\",\"type\":\"uint256\"},{\"name\":\"newBuyPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"MyAdvancedToken","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000012a05f200000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000144348494e412043554c545552414c20434849414e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000034349430000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://120fb88baf479a9d4c32ac8aae7c96a8b5002d18a3764e6be775b8639cea92a1"}]}