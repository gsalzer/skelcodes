{"status":"1","message":"OK","result":[{"SourceCode":"// File: @laborx/solidity-shared-contracts/contracts/ERC223ReceivingInterface.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/// @title Contract that will work with ERC223 tokens.\r\ninterface ERC223ReceivingInterface {\r\n\r\n\t/// @notice Standard ERC223 function that will handle incoming token transfers.\r\n\t/// @param _from  Token sender address.\r\n\t/// @param _value Amount of tokens.\r\n\t/// @param _data  Transaction metadata.\r\n    function tokenFallback(address _from, uint _value, bytes _data) external;\r\n}\r\n\r\n// File: @laborx/solidity-shared-contracts/contracts/ERC20Interface.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/// @title Defines an interface for EIP20 token smart contract\r\ncontract ERC20Interface {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n    string public symbol;\r\n\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n}\r\n\r\n// File: @laborx/solidity-shared-contracts/contracts/Owned.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/// @title Owned contract with safe ownership pass.\r\n///\r\n/// Note: all the non constant functions return false instead of throwing in case if state change\r\n/// didn't happen yet.\r\ncontract Owned {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    address public contractOwner;\r\n    address public pendingContractOwner;\r\n\r\n    modifier onlyContractOwner {\r\n        if (msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /// @notice Prepares ownership pass.\r\n    /// Can only be called by current owner.\r\n    /// @param _to address of the next owner.\r\n    /// @return success.\r\n    function changeContractOwnership(address _to)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (_to == 0x0) {\r\n            return false;\r\n        }\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Finalize ownership pass.\r\n    /// Can only be called by pending owner.\r\n    /// @return success.\r\n    function claimContractOwnership()\r\n    public\r\n    returns (bool)\r\n    {\r\n        if (msg.sender != pendingContractOwner) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, pendingContractOwner);\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (newOwner == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, newOwner);\r\n        contractOwner = newOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @dev Backward compatibility only.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferContractOwnership(address newOwner)\r\n    public\r\n    returns (bool)\r\n    {\r\n        return transferOwnership(newOwner);\r\n    }\r\n\r\n    /// @notice Withdraw given tokens from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawTokens(address[] tokens)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        address _contractOwner = contractOwner;\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20Interface token = ERC20Interface(tokens[i]);\r\n            uint balance = token.balanceOf(this);\r\n            if (balance > 0) {\r\n                token.transfer(_contractOwner, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw ether from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawEther()\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        uint balance = address(this).balance;\r\n        if (balance > 0)  {\r\n            contractOwner.transfer(balance);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers ether to another address.\r\n    /// Allowed only for contract owners.\r\n    /// @param _to recepient address\r\n    /// @param _value wei to transfer; must be less or equal to total balance on the contract\r\n    function transferEther(address _to, uint256 _value)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        require(_to != 0x0, \"INVALID_ETHER_RECEPIENT_ADDRESS\");\r\n        if (_value > address(this).balance) {\r\n            revert(\"INVALID_VALUE_TO_TRANSFER_ETHER\");\r\n        }\r\n\r\n        _to.transfer(_value);\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-storage-contracts/contracts/Storage.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract Manager {\r\n    function isAllowed(address _actor, bytes32 _role) public view returns (bool);\r\n    function hasAccess(address _actor) public view returns (bool);\r\n}\r\n\r\n\r\ncontract Storage is Owned {\r\n    struct Crate {\r\n        mapping(bytes32 => uint) uints;\r\n        mapping(bytes32 => address) addresses;\r\n        mapping(bytes32 => bool) bools;\r\n        mapping(bytes32 => int) ints;\r\n        mapping(bytes32 => uint8) uint8s;\r\n        mapping(bytes32 => bytes32) bytes32s;\r\n        mapping(bytes32 => AddressUInt8) addressUInt8s;\r\n        mapping(bytes32 => string) strings;\r\n        mapping(bytes32 => bytes) bytesSequences;\r\n    }\r\n\r\n    struct AddressUInt8 {\r\n        address _address;\r\n        uint8 _uint8;\r\n    }\r\n\r\n    mapping(bytes32 => Crate) internal crates;\r\n    Manager public manager;\r\n\r\n    modifier onlyAllowed(bytes32 _role) {\r\n        if (!(msg.sender == address(this) || manager.isAllowed(msg.sender, _role))) {\r\n            revert(\"STORAGE_FAILED_TO_ACCESS_PROTECTED_FUNCTION\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function setManager(Manager _manager)\r\n    external\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        manager = _manager;\r\n        return true;\r\n    }\r\n\r\n    function setUInt(bytes32 _crate, bytes32 _key, uint _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setUInt(_crate, _key, _value);\r\n    }\r\n\r\n    function _setUInt(bytes32 _crate, bytes32 _key, uint _value)\r\n    internal\r\n    {\r\n        crates[_crate].uints[_key] = _value;\r\n    }\r\n\r\n\r\n    function getUInt(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (uint)\r\n    {\r\n        return crates[_crate].uints[_key];\r\n    }\r\n\r\n    function setAddress(bytes32 _crate, bytes32 _key, address _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setAddress(_crate, _key, _value);\r\n    }\r\n\r\n    function _setAddress(bytes32 _crate, bytes32 _key, address _value)\r\n    internal\r\n    {\r\n        crates[_crate].addresses[_key] = _value;\r\n    }\r\n\r\n    function getAddress(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return crates[_crate].addresses[_key];\r\n    }\r\n\r\n    function setBool(bytes32 _crate, bytes32 _key, bool _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setBool(_crate, _key, _value);\r\n    }\r\n\r\n    function _setBool(bytes32 _crate, bytes32 _key, bool _value)\r\n    internal\r\n    {\r\n        crates[_crate].bools[_key] = _value;\r\n    }\r\n\r\n    function getBool(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return crates[_crate].bools[_key];\r\n    }\r\n\r\n    function setInt(bytes32 _crate, bytes32 _key, int _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setInt(_crate, _key, _value);\r\n    }\r\n\r\n    function _setInt(bytes32 _crate, bytes32 _key, int _value)\r\n    internal\r\n    {\r\n        crates[_crate].ints[_key] = _value;\r\n    }\r\n\r\n    function getInt(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (int)\r\n    {\r\n        return crates[_crate].ints[_key];\r\n    }\r\n\r\n    function setUInt8(bytes32 _crate, bytes32 _key, uint8 _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setUInt8(_crate, _key, _value);\r\n    }\r\n\r\n    function _setUInt8(bytes32 _crate, bytes32 _key, uint8 _value)\r\n    internal\r\n    {\r\n        crates[_crate].uint8s[_key] = _value;\r\n    }\r\n\r\n    function getUInt8(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (uint8)\r\n    {\r\n        return crates[_crate].uint8s[_key];\r\n    }\r\n\r\n    function setBytes32(bytes32 _crate, bytes32 _key, bytes32 _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setBytes32(_crate, _key, _value);\r\n    }\r\n\r\n    function _setBytes32(bytes32 _crate, bytes32 _key, bytes32 _value)\r\n    internal\r\n    {\r\n        crates[_crate].bytes32s[_key] = _value;\r\n    }\r\n\r\n    function getBytes32(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        return crates[_crate].bytes32s[_key];\r\n    }\r\n\r\n    function setAddressUInt8(\r\n        bytes32 _crate,\r\n        bytes32 _key,\r\n        address _value,\r\n        uint8 _value2\r\n    )\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setAddressUInt8(_crate, _key, _value, _value2);\r\n    }\r\n\r\n    function _setAddressUInt8(\r\n        bytes32 _crate,\r\n        bytes32 _key,\r\n        address _value,\r\n        uint8 _value2\r\n    )\r\n    internal\r\n    {\r\n        crates[_crate].addressUInt8s[_key] = AddressUInt8(_value, _value2);\r\n    }\r\n\r\n    function getAddressUInt8(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (address, uint8)\r\n    {\r\n        return (crates[_crate].addressUInt8s[_key]._address, crates[_crate].addressUInt8s[_key]._uint8);\r\n    }\r\n\r\n    function setString(bytes32 _crate, bytes32 _key, string _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setString(_crate, _key, _value);\r\n    }\r\n\r\n    function _setString(bytes32 _crate, bytes32 _key, string _value)\r\n    internal\r\n    {\r\n        crates[_crate].strings[_key] = _value;\r\n    }\r\n\r\n    function getString(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (string)\r\n    {\r\n        return crates[_crate].strings[_key];\r\n    }\r\n\r\n    function setBytesSequence(bytes32 _crate, bytes32 _key, bytes _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setBytesSequence(_crate, _key, _value);\r\n    }\r\n\r\n    function _setBytesSequence(bytes32 _crate, bytes32 _key, bytes _value)\r\n    internal\r\n    {\r\n        crates[_crate].bytesSequences[_key] = _value;\r\n    }\r\n\r\n    function getBytesSequence(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (bytes)\r\n    {\r\n        return crates[_crate].bytesSequences[_key];\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-storage-contracts/contracts/StorageInterface.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\nlibrary StorageInterface {\r\n    struct Config {\r\n        Storage store;\r\n        bytes32 crate;\r\n    }\r\n\r\n    struct UInt {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct UInt8 {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Int {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Address {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Bool {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Bytes32 {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct String {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct BytesSequence {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Mapping {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct StringMapping {\r\n        String id;\r\n    }\r\n\r\n    struct BytesSequenceMapping {\r\n        BytesSequence id;\r\n    }\r\n\r\n    struct UIntBoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct UIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntEnumMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBoolMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUInt8Mapping {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct AddressUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UInt8Mapping {\r\n        UInt8 innerMapping;\r\n    }\r\n\r\n    struct Bytes32BoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct Bytes32Bytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32AddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntBoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct AddressAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressAddressUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes32Bytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes4BoolMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes4Bytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressBoolMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntUIntAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntUIntBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressAddressBoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct UIntUIntUIntBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    bytes32 constant SET_IDENTIFIER = \"set\";\r\n\r\n    struct Set {\r\n        UInt count;\r\n        Mapping indexes;\r\n        Mapping values;\r\n    }\r\n\r\n    struct AddressesSet {\r\n        Set innerSet;\r\n    }\r\n\r\n    struct CounterSet {\r\n        Set innerSet;\r\n    }\r\n\r\n    bytes32 constant ORDERED_SET_IDENTIFIER = \"ordered_set\";\r\n\r\n    struct OrderedSet {\r\n        UInt count;\r\n        Bytes32 first;\r\n        Bytes32 last;\r\n        Mapping nextValues;\r\n        Mapping previousValues;\r\n    }\r\n\r\n    struct OrderedUIntSet {\r\n        OrderedSet innerSet;\r\n    }\r\n\r\n    struct OrderedAddressesSet {\r\n        OrderedSet innerSet;\r\n    }\r\n\r\n    struct Bytes32SetMapping {\r\n        Set innerMapping;\r\n    }\r\n\r\n    struct AddressesSetMapping {\r\n        Bytes32SetMapping innerMapping;\r\n    }\r\n\r\n    struct UIntSetMapping {\r\n        Bytes32SetMapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32OrderedSetMapping {\r\n        OrderedSet innerMapping;\r\n    }\r\n\r\n    struct UIntOrderedSetMapping {\r\n        Bytes32OrderedSetMapping innerMapping;\r\n    }\r\n\r\n    struct AddressOrderedSetMapping {\r\n        Bytes32OrderedSetMapping innerMapping;\r\n    }\r\n\r\n    // Can't use modifier due to a Solidity bug.\r\n    function sanityCheck(bytes32 _currentId, bytes32 _newId) internal pure {\r\n        if (_currentId != 0 || _newId == 0) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function init(Config storage self, Storage _store, bytes32 _crate) internal {\r\n        self.store = _store;\r\n        self.crate = _crate;\r\n    }\r\n\r\n    function init(UInt8 storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(UInt storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Int storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Address storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Bool storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Bytes32 storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(String storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(BytesSequence storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Mapping storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(StringMapping storage self, bytes32 _id) internal {\r\n        init(self.id, _id);\r\n    }\r\n\r\n    function init(BytesSequenceMapping storage self, bytes32 _id) internal {\r\n        init(self.id, _id);\r\n    }\r\n\r\n    function init(UIntAddressMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntEnumMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressAddressUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes32Bytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntAddressMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressAddressMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressAddressBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntUIntBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(AddressUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressAddressMapping  storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes4BoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes4Bytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32BoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32Bytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32AddressMapping  storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntBoolMapping  storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Set storage self, bytes32 _id) internal {\r\n        init(self.count, keccak256(abi.encodePacked(_id, \"count\")));\r\n        init(self.indexes, keccak256(abi.encodePacked(_id, \"indexes\")));\r\n        init(self.values, keccak256(abi.encodePacked(_id, \"values\")));\r\n    }\r\n\r\n    function init(AddressesSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(CounterSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(OrderedSet storage self, bytes32 _id) internal {\r\n        init(self.count, keccak256(abi.encodePacked(_id, \"uint/count\")));\r\n        init(self.first, keccak256(abi.encodePacked(_id, \"uint/first\")));\r\n        init(self.last, keccak256(abi.encodePacked(_id, \"uint/last\")));\r\n        init(self.nextValues, keccak256(abi.encodePacked(_id, \"uint/next\")));\r\n        init(self.previousValues, keccak256(abi.encodePacked(_id, \"uint/prev\")));\r\n    }\r\n\r\n    function init(OrderedUIntSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(OrderedAddressesSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(Bytes32SetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressesSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32OrderedSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntOrderedSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressOrderedSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    /** `set` operation */\r\n\r\n    function set(Config storage self, UInt storage item, uint _value) internal {\r\n        self.store.setUInt(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, UInt storage item, bytes32 _salt, uint _value) internal {\r\n        self.store.setUInt(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, UInt8 storage item, uint8 _value) internal {\r\n        self.store.setUInt8(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, UInt8 storage item, bytes32 _salt, uint8 _value) internal {\r\n        self.store.setUInt8(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Int storage item, int _value) internal {\r\n        self.store.setInt(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Int storage item, bytes32 _salt, int _value) internal {\r\n        self.store.setInt(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Address storage item, address _value) internal {\r\n        self.store.setAddress(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Address storage item, bytes32 _salt, address _value) internal {\r\n        self.store.setAddress(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bool storage item, bool _value) internal {\r\n        self.store.setBool(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bool storage item, bytes32 _salt, bool _value) internal {\r\n        self.store.setBool(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32 storage item, bytes32 _value) internal {\r\n        self.store.setBytes32(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32 storage item, bytes32 _salt, bytes32 _value) internal {\r\n        self.store.setBytes32(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, String storage item, string _value) internal {\r\n        self.store.setString(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, String storage item, bytes32 _salt, string _value) internal {\r\n        self.store.setString(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, BytesSequence storage item,  bytes _value) internal {\r\n        self.store.setBytesSequence(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, BytesSequence storage item, bytes32 _salt, bytes _value) internal {\r\n        self.store.setBytesSequence(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, uint _key, uint _value) internal {\r\n        self.store.setUInt(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        self.store.setBytes32(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value);\r\n    }\r\n\r\n    function set(Config storage self, StringMapping storage item, bytes32 _key, string _value) internal {\r\n        set(self, item.id, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, BytesSequenceMapping storage item, bytes32 _key, bytes _value) internal {\r\n        set(self, item.id, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, AddressUInt8Mapping storage item, bytes32 _key, address _value1, uint8 _value2) internal {\r\n        self.store.setAddressUInt8(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value1, _value2);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _value) internal {\r\n        set(self, item, keccak256(abi.encodePacked(_key, _key2)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _key3, bytes32 _value) internal {\r\n        set(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bool storage item, bytes32 _key, bytes32 _key2, bytes32 _key3, bool _value) internal {\r\n        set(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressMapping storage item, uint _key, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntMapping storage item, uint _key, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntBoolMapping storage item, uint _key, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntEnumMapping storage item, uint _key, uint8 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntBytes32Mapping storage item, uint _key, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntMapping storage item, bytes32 _key, uint _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UInt8Mapping storage item, bytes32 _key, uint8 _value) internal {\r\n        set(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32BoolMapping storage item, bytes32 _key, bool _value) internal {\r\n        set(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32Bytes32Mapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        set(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32AddressMapping storage item, bytes32 _key, address _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntBoolMapping storage item, bytes32 _key, uint _key2, bool _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)), _value);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntMapping storage item, address _key, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBoolMapping storage item, address _key, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), toBytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes32Mapping storage item, address _key, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _value);\r\n    }\r\n\r\n    function set(Config storage self, AddressAddressMapping storage item, address _key, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressAddressUIntMapping storage item, address _key, address _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntMapping storage item, address _key, uint _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressAddressUInt8Mapping storage item, address _key, address _key2, uint8 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUInt8Mapping storage item, address _key, uint _key2, uint8 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes32Bytes32Mapping storage item, address _key, bytes32 _key2, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _key2, _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressUIntMapping storage item, uint _key, address _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressBoolMapping storage item, uint _key, address _key2, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), toBytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressAddressMapping storage item, uint _key, address _key2, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntAddressMapping storage item, uint _key, uint _key2, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntBytes32Mapping storage item, uint _key, uint _key2, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntUIntMapping storage item, uint _key, uint _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressAddressBoolMapping storage item, uint _key, address _key2, address _key3, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntUIntBytes32Mapping storage item, uint _key, uint _key2,  uint _key3, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntUIntMapping storage item, bytes32 _key, uint _key2, uint _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntUIntUIntMapping storage item, bytes32 _key, uint _key2,  uint _key3, uint _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_key2), bytes32(_key3), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntMapping storage item, address _key, uint _key2,  uint _key3, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, uint _key5, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntAddressUInt8Mapping storage item, address _key, uint _key2, address _key3, uint8 _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _key4, uint8 _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, address _key5, uint8 _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes4BoolMapping storage item, address _key, bytes4 _key2, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), toBytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes4Bytes32Mapping storage item, address _key, bytes4 _key2, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), _value);\r\n    }\r\n\r\n\r\n    /** `add` operation */\r\n\r\n    function add(Config storage self, Set storage item, bytes32 _value) internal {\r\n        add(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function add(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (includes(self, item, _salt, _value)) {\r\n            return;\r\n        }\r\n        uint newCount = count(self, item, _salt) + 1;\r\n        set(self, item.values, _salt, bytes32(newCount), _value);\r\n        set(self, item.indexes, _salt, _value, bytes32(newCount));\r\n        set(self, item.count, _salt, newCount);\r\n    }\r\n\r\n    function add(Config storage self, AddressesSet storage item, address _value) internal {\r\n        add(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, CounterSet storage item) internal {\r\n        add(self, item.innerSet, bytes32(count(self, item) + 1));\r\n    }\r\n\r\n    function add(Config storage self, OrderedSet storage item, bytes32 _value) internal {\r\n        add(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function add(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (_value == 0x0) { revert(); }\r\n\r\n        if (includes(self, item, _salt, _value)) { return; }\r\n\r\n        if (count(self, item, _salt) == 0x0) {\r\n            set(self, item.first, _salt, _value);\r\n        }\r\n\r\n        if (get(self, item.last, _salt) != 0x0) {\r\n            _setOrderedSetLink(self, item.nextValues, _salt, get(self, item.last, _salt), _value);\r\n            _setOrderedSetLink(self, item.previousValues, _salt, _value, get(self, item.last, _salt));\r\n        }\r\n\r\n        _setOrderedSetLink(self, item.nextValues, _salt,  _value, 0x0);\r\n        set(self, item.last, _salt, _value);\r\n        set(self, item.count, _salt, get(self, item.count, _salt) + 1);\r\n    }\r\n\r\n    function add(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        add(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function add(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        add(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function add(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key, address _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, OrderedUIntSet storage item, uint _value) internal {\r\n        add(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, OrderedAddressesSet storage item, address _value) internal {\r\n        add(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Set storage item, bytes32 _oldValue, bytes32 _newValue) internal {\r\n        set(self, item, SET_IDENTIFIER, _oldValue, _newValue);\r\n    }\r\n\r\n    function set(Config storage self, Set storage item, bytes32 _salt, bytes32 _oldValue, bytes32 _newValue) private {\r\n        if (!includes(self, item, _salt, _oldValue)) {\r\n            return;\r\n        }\r\n        uint index = uint(get(self, item.indexes, _salt, _oldValue));\r\n        set(self, item.values, _salt, bytes32(index), _newValue);\r\n        set(self, item.indexes, _salt, _newValue, bytes32(index));\r\n        set(self, item.indexes, _salt, _oldValue, bytes32(0));\r\n    }\r\n\r\n    function set(Config storage self, AddressesSet storage item, address _oldValue, address _newValue) internal {\r\n        set(self, item.innerSet, bytes32(_oldValue), bytes32(_newValue));\r\n    }\r\n\r\n    /** `remove` operation */\r\n\r\n    function remove(Config storage self, Set storage item, bytes32 _value) internal {\r\n        remove(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function remove(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (!includes(self, item, _salt, _value)) {\r\n            return;\r\n        }\r\n        uint lastIndex = count(self, item, _salt);\r\n        bytes32 lastValue = get(self, item.values, _salt, bytes32(lastIndex));\r\n        uint index = uint(get(self, item.indexes, _salt, _value));\r\n        if (index < lastIndex) {\r\n            set(self, item.indexes, _salt, lastValue, bytes32(index));\r\n            set(self, item.values, _salt, bytes32(index), lastValue);\r\n        }\r\n        set(self, item.indexes, _salt, _value, bytes32(0));\r\n        set(self, item.values, _salt, bytes32(lastIndex), bytes32(0));\r\n        set(self, item.count, _salt, lastIndex - 1);\r\n    }\r\n\r\n    function remove(Config storage self, AddressesSet storage item, address _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, CounterSet storage item, uint _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, OrderedSet storage item, bytes32 _value) internal {\r\n        remove(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function remove(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (!includes(self, item, _salt, _value)) { return; }\r\n\r\n        _setOrderedSetLink(self, item.nextValues, _salt, get(self, item.previousValues, _salt, _value), get(self, item.nextValues, _salt, _value));\r\n        _setOrderedSetLink(self, item.previousValues, _salt, get(self, item.nextValues, _salt, _value), get(self, item.previousValues, _salt, _value));\r\n\r\n        if (_value == get(self, item.first, _salt)) {\r\n            set(self, item.first, _salt, get(self, item.nextValues, _salt, _value));\r\n        }\r\n\r\n        if (_value == get(self, item.last, _salt)) {\r\n            set(self, item.last, _salt, get(self, item.previousValues, _salt, _value));\r\n        }\r\n\r\n        _deleteOrderedSetLink(self, item.nextValues, _salt, _value);\r\n        _deleteOrderedSetLink(self, item.previousValues, _salt, _value);\r\n\r\n        set(self, item.count, _salt, get(self, item.count, _salt) - 1);\r\n    }\r\n\r\n    function remove(Config storage self, OrderedUIntSet storage item, uint _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, OrderedAddressesSet storage item, address _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        remove(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function remove(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        remove(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function remove(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key, address _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    /** 'copy` operation */\r\n\r\n    function copy(Config storage self, Set storage source, Set storage dest) internal {\r\n        uint _destCount = count(self, dest);\r\n        bytes32[] memory _toRemoveFromDest = new bytes32[](_destCount);\r\n        uint _idx;\r\n        uint _pointer = 0;\r\n        for (_idx = 0; _idx < _destCount; ++_idx) {\r\n            bytes32 _destValue = get(self, dest, _idx);\r\n            if (!includes(self, source, _destValue)) {\r\n                _toRemoveFromDest[_pointer++] = _destValue;\r\n            }\r\n        }\r\n\r\n        uint _sourceCount = count(self, source);\r\n        for (_idx = 0; _idx < _sourceCount; ++_idx) {\r\n            add(self, dest, get(self, source, _idx));\r\n        }\r\n\r\n        for (_idx = 0; _idx < _pointer; ++_idx) {\r\n            remove(self, dest, _toRemoveFromDest[_idx]);\r\n        }\r\n    }\r\n\r\n    function copy(Config storage self, AddressesSet storage source, AddressesSet storage dest) internal {\r\n        copy(self, source.innerSet, dest.innerSet);\r\n    }\r\n\r\n    function copy(Config storage self, CounterSet storage source, CounterSet storage dest) internal {\r\n        copy(self, source.innerSet, dest.innerSet);\r\n    }\r\n\r\n    /** `get` operation */\r\n\r\n    function get(Config storage self, UInt storage item) internal view returns (uint) {\r\n        return self.store.getUInt(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, UInt storage item, bytes32 salt) internal view returns (uint) {\r\n        return self.store.getUInt(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, UInt8 storage item) internal view returns (uint8) {\r\n        return self.store.getUInt8(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, UInt8 storage item, bytes32 salt) internal view returns (uint8) {\r\n        return self.store.getUInt8(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Int storage item) internal view returns (int) {\r\n        return self.store.getInt(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Int storage item, bytes32 salt) internal view returns (int) {\r\n        return self.store.getInt(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Address storage item) internal view returns (address) {\r\n        return self.store.getAddress(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Address storage item, bytes32 salt) internal view returns (address) {\r\n        return self.store.getAddress(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Bool storage item) internal view returns (bool) {\r\n        return self.store.getBool(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Bool storage item, bytes32 salt) internal view returns (bool) {\r\n        return self.store.getBool(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32 storage item) internal view returns (bytes32) {\r\n        return self.store.getBytes32(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32 storage item, bytes32 salt) internal view returns (bytes32) {\r\n        return self.store.getBytes32(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, String storage item) internal view returns (string) {\r\n        return self.store.getString(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, String storage item, bytes32 salt) internal view returns (string) {\r\n        return self.store.getString(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, BytesSequence storage item) internal view returns (bytes) {\r\n        return self.store.getBytesSequence(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, BytesSequence storage item, bytes32 salt) internal view returns (bytes) {\r\n        return self.store.getBytesSequence(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, uint _key) internal view returns (uint) {\r\n        return self.store.getUInt(self.crate, keccak256(abi.encodePacked(item.id, _key)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, bytes32 _key) internal view returns (bytes32) {\r\n        return self.store.getBytes32(self.crate, keccak256(abi.encodePacked(item.id, _key)));\r\n    }\r\n\r\n    function get(Config storage self, StringMapping storage item, bytes32 _key) internal view returns (string) {\r\n        return get(self, item.id, _key);\r\n    }\r\n\r\n    function get(Config storage self, BytesSequenceMapping storage item, bytes32 _key) internal view returns (bytes) {\r\n        return get(self, item.id, _key);\r\n    }\r\n\r\n    function get(Config storage self, AddressUInt8Mapping storage item, bytes32 _key) internal view returns (address, uint8) {\r\n        return self.store.getAddressUInt8(self.crate, keccak256(abi.encodePacked(item.id, _key)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2) internal view returns (bytes32) {\r\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _key3) internal view returns (bytes32) {\r\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)));\r\n    }\r\n\r\n    function get(Config storage self, Bool storage item, bytes32 _key, bytes32 _key2, bytes32 _key3) internal view returns (bool) {\r\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)));\r\n    }\r\n\r\n    function get(Config storage self, UIntBoolMapping storage item, uint _key) internal view returns (bool) {\r\n        return get(self, item.innerMapping, bytes32(_key));\r\n    }\r\n\r\n    function get(Config storage self, UIntEnumMapping storage item, uint _key) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntMapping storage item, uint _key) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressMapping storage item, uint _key) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32AddressMapping storage item, bytes32 _key) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UInt8Mapping storage item, bytes32 _key) internal view returns (uint8) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32BoolMapping storage item, bytes32 _key) internal view returns (bool) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32Bytes32Mapping storage item, bytes32 _key) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntBoolMapping storage item, bytes32 _key, uint _key2) internal view returns (bool) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntBytes32Mapping storage item, uint _key) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntMapping storage item, address _key) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBoolMapping storage item, address _key) internal view returns (bool) {\r\n        return toBool(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, AddressAddressMapping storage item, address _key) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes32Mapping storage item, address _key) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntBytes32Mapping storage item, uint _key, uint _key2) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntAddressMapping storage item, uint _key, uint _key2) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntUIntMapping storage item, uint _key, uint _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntUIntMapping storage item, bytes32 _key, uint _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key, bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntUIntUIntMapping storage item, bytes32 _key, uint _key2, uint _key3) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key, bytes32(_key2), bytes32(_key3)));\r\n    }\r\n\r\n    function get(Config storage self, AddressAddressUIntMapping storage item, address _key, address _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressAddressUInt8Mapping storage item, address _key, address _key2) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntMapping storage item, address _key, uint _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUInt8Mapping storage item, address _key, uint _key2) internal view returns (uint) {\r\n        return uint8(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes32Bytes32Mapping storage item, address _key, bytes32 _key2) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), _key2);\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes4BoolMapping storage item, address _key, bytes4 _key2) internal view returns (bool) {\r\n        return toBool(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes4Bytes32Mapping storage item, address _key, bytes4 _key2) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressUIntMapping storage item, uint _key, address _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressBoolMapping storage item, uint _key, address _key2) internal view returns (bool) {\r\n        return toBool(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressAddressMapping storage item, uint _key, address _key2) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressAddressBoolMapping storage item, uint _key, address _key2, address _key3) internal view returns (bool) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntUIntBytes32Mapping storage item, uint _key, uint _key2, uint _key3) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntMapping storage item, address _key, uint _key2, uint _key3) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntStructAddressUInt8Mapping storage item, address _key, uint _key2) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4, uint _key5) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntAddressUInt8Mapping storage item, address _key, uint _key2, address _key3) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3))));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _key4) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4))));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4, address _key5) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5))));\r\n    }\r\n\r\n    /** `includes` operation */\r\n\r\n    function includes(Config storage self, Set storage item, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function includes(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) internal view returns (bool) {\r\n        return get(self, item.indexes, _salt, _value) != 0;\r\n    }\r\n\r\n    function includes(Config storage self, AddressesSet storage item, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, CounterSet storage item, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, OrderedSet storage item, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function includes(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private view returns (bool) {\r\n        return _value != 0x0 && (get(self, item.nextValues, _salt, _value) != 0x0 || get(self, item.last, _salt) == _value);\r\n    }\r\n\r\n    function includes(Config storage self, OrderedUIntSet storage item, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, OrderedAddressesSet storage item, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function includes(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function includes(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, Set storage item, bytes32 _value) internal view returns (uint) {\r\n        return getIndex(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function getIndex(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) private view returns (uint) {\r\n        return uint(get(self, item.indexes, _salt, _value));\r\n    }\r\n\r\n    function getIndex(Config storage self, AddressesSet storage item, address _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, CounterSet storage item, uint _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function getIndex(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    /** `count` operation */\r\n\r\n    function count(Config storage self, Set storage item) internal view returns (uint) {\r\n        return count(self, item, SET_IDENTIFIER);\r\n    }\r\n\r\n    function count(Config storage self, Set storage item, bytes32 _salt) internal view returns (uint) {\r\n        return get(self, item.count, _salt);\r\n    }\r\n\r\n    function count(Config storage self, AddressesSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, CounterSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, OrderedSet storage item) internal view returns (uint) {\r\n        return count(self, item, ORDERED_SET_IDENTIFIER);\r\n    }\r\n\r\n    function count(Config storage self, OrderedSet storage item, bytes32 _salt) private view returns (uint) {\r\n        return get(self, item.count, _salt);\r\n    }\r\n\r\n    function count(Config storage self, OrderedUIntSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, OrderedAddressesSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, Bytes32SetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, AddressesSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, UIntSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Set storage item) internal view returns (bytes32[] result) {\r\n        result = get(self, item, SET_IDENTIFIER);\r\n    }\r\n\r\n    function get(Config storage self, Set storage item, bytes32 _salt) private view returns (bytes32[] result) {\r\n        uint valuesCount = count(self, item, _salt);\r\n        result = new bytes32[](valuesCount);\r\n        for (uint i = 0; i < valuesCount; i++) {\r\n            result[i] = get(self, item, _salt, i);\r\n        }\r\n    }\r\n\r\n    function get(Config storage self, AddressesSet storage item) internal view returns (address[]) {\r\n        return toAddresses(get(self, item.innerSet));\r\n    }\r\n\r\n    function get(Config storage self, CounterSet storage item) internal view returns (uint[]) {\r\n        return toUInt(get(self, item.innerSet));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32SetMapping storage item, bytes32 _key) internal view returns (bytes32[]) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, AddressesSetMapping storage item, bytes32 _key) internal view returns (address[]) {\r\n        return toAddresses(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, UIntSetMapping storage item, bytes32 _key) internal view returns (uint[]) {\r\n        return toUInt(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, Set storage item, uint _index) internal view returns (bytes32) {\r\n        return get(self, item, SET_IDENTIFIER, _index);\r\n    }\r\n\r\n    function get(Config storage self, Set storage item, bytes32 _salt, uint _index) private view returns (bytes32) {\r\n        return get(self, item.values, _salt, bytes32(_index+1));\r\n    }\r\n\r\n    function get(Config storage self, AddressesSet storage item, uint _index) internal view returns (address) {\r\n        return address(get(self, item.innerSet, _index));\r\n    }\r\n\r\n    function get(Config storage self, CounterSet storage item, uint _index) internal view returns (uint) {\r\n        return uint(get(self, item.innerSet, _index));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32SetMapping storage item, bytes32 _key, uint _index) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, _key, _index);\r\n    }\r\n\r\n    function get(Config storage self, AddressesSetMapping storage item, bytes32 _key, uint _index) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, _key, _index));\r\n    }\r\n\r\n    function get(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _index) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key, _index));\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedSet storage item, bytes32 _value) internal view returns (bytes32) {\r\n        return getNextValue(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private view returns (bytes32) {\r\n        return get(self, item.nextValues, _salt, _value);\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedUIntSet storage item, uint _value) internal view returns (uint) {\r\n        return uint(getNextValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedAddressesSet storage item, address _value) internal view returns (address) {\r\n        return address(getNextValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedSet storage item, bytes32 _value) internal view returns (bytes32) {\r\n        return getPreviousValue(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private view returns (bytes32) {\r\n        return get(self, item.previousValues, _salt, _value);\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedUIntSet storage item, uint _value) internal view returns (uint) {\r\n        return uint(getPreviousValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedAddressesSet storage item, address _value) internal view returns (address) {\r\n        return address(getPreviousValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function toBool(bytes32 self) internal pure returns (bool) {\r\n        return self != bytes32(0);\r\n    }\r\n\r\n    function toBytes32(bool self) internal pure returns (bytes32) {\r\n        return bytes32(self ? 1 : 0);\r\n    }\r\n\r\n    function toAddresses(bytes32[] memory self) internal pure returns (address[]) {\r\n        address[] memory result = new address[](self.length);\r\n        for (uint i = 0; i < self.length; i++) {\r\n            result[i] = address(self[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function toUInt(bytes32[] memory self) internal pure returns (uint[]) {\r\n        uint[] memory result = new uint[](self.length);\r\n        for (uint i = 0; i < self.length; i++) {\r\n            result[i] = uint(self[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _setOrderedSetLink(Config storage self, Mapping storage link, bytes32 _salt, bytes32 from, bytes32 to) private {\r\n        if (from != 0x0) {\r\n            set(self, link, _salt, from, to);\r\n        }\r\n    }\r\n\r\n    function _deleteOrderedSetLink(Config storage self, Mapping storage link, bytes32 _salt, bytes32 from) private {\r\n        if (from != 0x0) {\r\n            set(self, link, _salt, from, 0x0);\r\n        }\r\n    }\r\n\r\n    /** @title Structure to incapsulate and organize iteration through different kinds of collections */\r\n    struct Iterator {\r\n        uint limit;\r\n        uint valuesLeft;\r\n        bytes32 currentValue;\r\n        bytes32 anchorKey;\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, bytes32 anchorKey, bytes32 startValue, uint limit) internal view returns (Iterator) {\r\n        if (startValue == 0x0) {\r\n            return listIterator(self, item, anchorKey, limit);\r\n        }\r\n\r\n        return createIterator(anchorKey, startValue, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, bytes32 anchorKey, uint startValue, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, bytes32(startValue), limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, bytes32 anchorKey, address startValue, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, bytes32(startValue), limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item, ORDERED_SET_IDENTIFIER, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, bytes32 anchorKey, uint limit) internal view returns (Iterator) {\r\n        return createIterator(anchorKey, get(self, item.first, anchorKey), limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, bytes32 anchorKey, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, uint limit, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item) internal view returns (Iterator) {\r\n        return listIterator(self, item, ORDERED_SET_IDENTIFIER);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item, anchorKey, get(self, item.count, anchorKey));\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey);\r\n    }\r\n\r\n    function listIterator(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function listIterator(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function listIterator(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function createIterator(bytes32 anchorKey, bytes32 startValue, uint limit) internal pure returns (Iterator) {\r\n        return Iterator({\r\n            currentValue: startValue,\r\n            limit: limit,\r\n            valuesLeft: limit,\r\n            anchorKey: anchorKey\r\n        });\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, OrderedSet storage item, Iterator iterator) internal view returns (bytes32 _nextValue) {\r\n        if (!canGetNextWithIterator(self, item, iterator)) { revert(); }\r\n\r\n        _nextValue = iterator.currentValue;\r\n\r\n        iterator.currentValue = getNextValue(self, item, iterator.anchorKey, iterator.currentValue);\r\n        iterator.valuesLeft -= 1;\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, OrderedUIntSet storage item, Iterator iterator) internal view returns (uint _nextValue) {\r\n        return uint(getNextWithIterator(self, item.innerSet, iterator));\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, OrderedAddressesSet storage item, Iterator iterator) internal view returns (address _nextValue) {\r\n        return address(getNextWithIterator(self, item.innerSet, iterator));\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, Bytes32OrderedSetMapping storage item, Iterator iterator) internal view returns (bytes32 _nextValue) {\r\n        return getNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, UIntOrderedSetMapping storage item, Iterator iterator) internal view returns (uint _nextValue) {\r\n        return uint(getNextWithIterator(self, item.innerMapping, iterator));\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, AddressOrderedSetMapping storage item, Iterator iterator) internal view returns (address _nextValue) {\r\n        return address(getNextWithIterator(self, item.innerMapping, iterator));\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, OrderedSet storage item, Iterator iterator) internal view returns (bool) {\r\n        if (iterator.valuesLeft == 0 || !includes(self, item, iterator.anchorKey, iterator.currentValue)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, OrderedUIntSet storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerSet, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, OrderedAddressesSet storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerSet, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, Bytes32OrderedSetMapping storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, UIntOrderedSetMapping storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, AddressOrderedSetMapping storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function count(Iterator iterator) internal pure returns (uint) {\r\n        return iterator.valuesLeft;\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-storage-contracts/contracts/StorageAdapter.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract StorageAdapter {\r\n\r\n    using StorageInterface for *;\r\n\r\n    StorageInterface.Config internal store;\r\n\r\n    constructor(Storage _store, bytes32 _crate) public {\r\n        store.init(_store, _crate);\r\n    }\r\n}\r\n\r\n// File: contracts/common/Object.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned {\r\n    /**\r\n    *  Common result code. Means everything is fine.\r\n    */\r\n    uint constant OK = 1;\r\n}\r\n\r\n// File: @laborx/solidity-eventshistory-contracts/contracts/EventsHistorySourceAdapter.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title EventsHistory Source Adapter.\r\n */\r\ncontract EventsHistorySourceAdapter {\r\n\r\n    // It is address of MultiEventsHistory caller assuming we are inside of delegate call.\r\n    function _self()\r\n    internal\r\n    view\r\n    returns (address)\r\n    {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/erc20/ERC20ManagerEmitter.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/// @title ERC20 Manager emitter contract\r\n///\r\n/// Contains all the original event emitting function definitions and events.\r\n/// In case of new events needed later, additional emitters can be developed.\r\n/// All the functions is meant to be called using delegatecall.\r\ncontract ERC20ManagerEmitter is EventsHistorySourceAdapter {\r\n    \r\n    event LogAddToken (\r\n        address indexed self,\r\n        address token,\r\n        bytes32 name,\r\n        bytes32 symbol,\r\n        bytes32 url,\r\n        uint8 decimals,\r\n        bytes32 ipfsHash,\r\n        bytes32 swarmHash\r\n    );\r\n\r\n    event LogTokenChange (\r\n        address indexed self,\r\n        address oldToken,\r\n        address token,\r\n        bytes32 name,\r\n        bytes32 symbol,\r\n        bytes32 url,\r\n        uint8 decimals,\r\n        bytes32 ipfsHash,\r\n        bytes32 swarmHash\r\n    );\r\n\r\n    event LogRemoveToken (\r\n        address indexed self,\r\n        address token,\r\n        bytes32 name,\r\n        bytes32 symbol,\r\n        bytes32 url,\r\n        uint8 decimals,\r\n        bytes32 ipfsHash,\r\n        bytes32 swarmHash\r\n    );\r\n\r\n    event Error(address indexed self, uint errorCode);\r\n\r\n    function _emitLogAddToken (\r\n        address token,\r\n        bytes32 name,\r\n        bytes32 symbol,\r\n        bytes32 url,\r\n        uint8 decimals,\r\n        bytes32 ipfsHash,\r\n        bytes32 swarmHash\r\n    ) internal {\r\n        emit LogAddToken(_self(), token, name, symbol, url, decimals, ipfsHash, swarmHash);\r\n    }\r\n\r\n    function _emitLogTokenChange (\r\n        address oldToken,\r\n        address token,\r\n        bytes32 name,\r\n        bytes32 symbol,\r\n        bytes32 url,\r\n        uint8 decimals,\r\n        bytes32 ipfsHash,\r\n        bytes32 swarmHash\r\n    ) internal {\r\n        emit LogTokenChange(_self(), oldToken, token, name, symbol, url, decimals, ipfsHash, swarmHash);\r\n    }\r\n\r\n    function _emitLogRemoveToken (\r\n        address token,\r\n        bytes32 name,\r\n        bytes32 symbol,\r\n        bytes32 url,\r\n        uint8 decimals,\r\n        bytes32 ipfsHash,\r\n        bytes32 swarmHash\r\n    ) internal {\r\n        emit LogRemoveToken(_self(), token, name, symbol, url, decimals, ipfsHash, swarmHash);\r\n    }\r\n\r\n    function _emitError(uint error) internal returns (uint) {\r\n        emit Error(_self(), error);\r\n        return error;\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/erc20/ERC20Manager.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC20TokenVerifier {\r\n    function verify(address token) public view returns (bool);\r\n}\r\n\r\n/// @title ERC20Manager\r\n///\r\n/// @notice ERC20Manager contract which keeps track of all ERC20-based tokens\r\n/// registered in a system.\r\ncontract ERC20Manager is ERC20ManagerEmitter, StorageAdapter, Object {\r\n\r\n    uint constant ERROR_ERCMANAGER_INVALID_INVOCATION = 13000;\r\n    uint constant ERROR_ERCMANAGER_TOKEN_SYMBOL_NOT_EXISTS = 13002;\r\n    uint constant ERROR_ERCMANAGER_TOKEN_NOT_EXISTS = 13003;\r\n    uint constant ERROR_ERCMANAGER_TOKEN_SYMBOL_ALREADY_EXISTS = 13004;\r\n    uint constant ERROR_ERCMANAGER_TOKEN_ALREADY_EXISTS = 13005;\r\n    uint constant ERROR_ERCMANAGER_TOKEN_UNCHANGED = 13006;\r\n\r\n    StorageInterface.AddressesSet tokenAddresses;\r\n    StorageInterface.Bytes32AddressMapping tokenBySymbol;\r\n    StorageInterface.AddressBytes32Mapping name;\r\n    StorageInterface.AddressBytes32Mapping symbol;\r\n    StorageInterface.AddressBytes32Mapping url;\r\n    StorageInterface.AddressBytes32Mapping ipfsHash;\r\n    StorageInterface.AddressBytes32Mapping swarmHash;\r\n    StorageInterface.AddressUIntMapping decimals;\r\n    StorageInterface.Address tokenVerifier;\r\n\r\n    constructor(address _storage, bytes32 _crate) public StorageAdapter(Storage(_storage), _crate) {\r\n        tokenAddresses.init(\"tokenAddresses\");\r\n        tokenBySymbol.init(\"tokeBySymbol\");\r\n        name.init(\"name\");\r\n        symbol.init(\"symbol\");\r\n        url.init(\"url\");\r\n        ipfsHash.init(\"ipfsHash\");\r\n        swarmHash.init(\"swarmHash\");\r\n        decimals.init(\"decimals\");\r\n        tokenVerifier.init(\"tokenVerifier\");\r\n    }\r\n\r\n    /// @notice Set ERC20 token verifier\r\n    function setTokenVerifier(address _tokenVerifier) public onlyContractOwner {\r\n        store.set(tokenVerifier, _tokenVerifier);\r\n    }\r\n\r\n    /// @notice Allows trusted account/constract to add a new token to the registry.\r\n    /// @param _token Address of new token.\r\n    /// @param _name Name of new token.\r\n    /// @param _symbol Symbol for new token.\r\n    /// @param _url Token's project URL.\r\n    /// @param _decimals Number of decimals, divisibility of new token.\r\n    /// @param _ipfsHash IPFS hash of token icon.\r\n    /// @param _swarmHash Swarm hash of token icon.\r\n    function addToken(\r\n        address _token,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes32 _url,\r\n        uint8 _decimals,\r\n        bytes32 _ipfsHash,\r\n        bytes32 _swarmHash\r\n    ) public returns (uint) {\r\n        if (isTokenExists(_token)) {\r\n            return _emitError(ERROR_ERCMANAGER_TOKEN_ALREADY_EXISTS);\r\n        }\r\n\r\n        if (isTokenSymbolExists(_symbol)) {\r\n            return _emitError(ERROR_ERCMANAGER_TOKEN_SYMBOL_ALREADY_EXISTS);\r\n        }\r\n\r\n        if (!isTokenValid(_token)) {\r\n            return _emitError(ERROR_ERCMANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        store.add(tokenAddresses, _token);\r\n        store.set(tokenBySymbol, _symbol, _token);\r\n        store.set(name, _token, _name);\r\n        store.set(symbol, _token, _symbol);\r\n        store.set(url, _token, _url);\r\n        store.set(decimals, _token, _decimals);\r\n        store.set(ipfsHash, _token, _ipfsHash);\r\n        store.set(swarmHash, _token, _swarmHash);\r\n\r\n        _emitLogAddToken(_token, _name, _symbol, _url, _decimals, _ipfsHash, _swarmHash);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Allows owner to alter a token\r\n    /// @param _token Address of old token.\r\n    /// @param _newToken Address of new token.\r\n    /// @param _name Name of new token.\r\n    /// @param _symbol Symbol for new token.\r\n    /// @param _url Token's project URL.\r\n    /// @param _decimals Number of decimals, divisibility of new token.\r\n    /// @param _ipfsHash IPFS hash of token icon.\r\n    /// @param _swarmHash Swarm hash of token icon.\r\n    function setToken(\r\n        address _token,\r\n        address _newToken,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes32 _url,\r\n        uint8 _decimals,\r\n        bytes32 _ipfsHash,\r\n        bytes32 _swarmHash\r\n    ) public onlyContractOwner returns (uint) {\r\n        if (!isTokenExists(_token)) {\r\n            return _emitError(ERROR_ERCMANAGER_TOKEN_NOT_EXISTS);\r\n        }\r\n\r\n        if (!isTokenValid(_newToken)) {\r\n            return _emitError(ERROR_ERCMANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        bool changed;\r\n        if (_symbol != store.get(symbol, _token)) {\r\n            if (store.get(tokenBySymbol, _symbol) == 0x0) {\r\n                store.set(tokenBySymbol, store.get(symbol, _token), 0x0);\r\n\r\n                if (_token != _newToken) {\r\n                    store.set(tokenBySymbol, _symbol, _newToken);\r\n                    store.set(symbol, _newToken, _symbol);\r\n                } else {\r\n                    store.set(tokenBySymbol,_symbol, _token);\r\n                    store.set(symbol, _token, _symbol);\r\n                }\r\n                changed = true;\r\n            } else {\r\n                return _emitError(ERROR_ERCMANAGER_TOKEN_UNCHANGED);\r\n            }\r\n        }\r\n\r\n        if (_token != _newToken) {\r\n            ERC20Interface(_newToken).totalSupply();\r\n            store.set(tokenAddresses, _token, _newToken);\r\n\r\n            if(!changed) {\r\n                store.set(tokenBySymbol, _symbol, _newToken);\r\n                store.set(symbol, _newToken, _symbol);\r\n            }\r\n            store.set(name, _newToken, _name);\r\n            store.set(url, _newToken, _url);\r\n            store.set(decimals, _newToken, _decimals);\r\n            store.set(ipfsHash, _newToken, _ipfsHash);\r\n            store.set(swarmHash, _newToken, _swarmHash);\r\n            _token = _newToken;\r\n            changed = true;\r\n        }\r\n\r\n        if (store.get(name, _token) != _name) {\r\n            store.set(name, _token, _name);\r\n            changed = true;\r\n        }\r\n\r\n        if (store.get(decimals, _token) != _decimals) {\r\n            store.set(decimals, _token, _decimals);\r\n            changed = true;\r\n        }\r\n\r\n        if (store.get(url, _token) != _url) {\r\n            store.set(url, _token, _url);\r\n            changed = true;\r\n        }\r\n\r\n        if (store.get(ipfsHash, _token) != _ipfsHash) {\r\n            store.set(ipfsHash, _token, _ipfsHash);\r\n            changed = true;\r\n        }\r\n\r\n        if (store.get(swarmHash, _token) != _swarmHash) {\r\n            store.set(swarmHash, _token, _swarmHash);\r\n            changed = true;\r\n        }\r\n\r\n        if (changed) {\r\n            _emitLogTokenChange(_token, _newToken, _name, _symbol, _url, _decimals, _ipfsHash, _swarmHash);\r\n            return OK;\r\n        }\r\n\r\n        return _emitError(ERROR_ERCMANAGER_TOKEN_UNCHANGED);\r\n    }\r\n\r\n    /// @notice Allows CBE to remove an existing token from the registry.\r\n    /// @param _token Address of existing token.\r\n    function removeTokenByAddress(address _token) public onlyContractOwner returns (uint) {\r\n        if (!isTokenExists(_token)) {\r\n            return _emitError(ERROR_ERCMANAGER_TOKEN_NOT_EXISTS);\r\n        }\r\n\r\n        return removeToken(_token);\r\n    }\r\n\r\n    /// @notice Allows CBE to remove an existing token from the registry.\r\n    /// @param _symbol Symbol of existing token.\r\n    function removeTokenBySymbol(bytes32 _symbol) public onlyContractOwner returns (uint) {\r\n        if (!isTokenSymbolExists(_symbol)) {\r\n            return _emitError(ERROR_ERCMANAGER_TOKEN_SYMBOL_NOT_EXISTS);\r\n        }\r\n\r\n        return removeToken(store.get(tokenBySymbol,_symbol));\r\n    }\r\n\r\n    /// @notice Returns token's address by given id\r\n    function getAddressById(uint _id) public  view returns (address) {\r\n        return store.get(tokenAddresses, _id);\r\n    }\r\n\r\n    /// @notice Provides a registered token's address when given the token symbol.\r\n    /// @param _symbol Symbol of registered token.\r\n    /// @return Token's address.\r\n    function getTokenAddressBySymbol(bytes32 _symbol) public view returns (address tokenAddress) {\r\n        return store.get(tokenBySymbol, _symbol);\r\n    }\r\n\r\n    /// @notice Provides a registered token's metadata, looked up by address.\r\n    /// @param _token Address of registered token.\r\n    /// @return Token metadata.\r\n    function getTokenMetaData(address _token) public view returns (\r\n        address _tokenAddress,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes32 _url,\r\n        uint8 _decimals,\r\n        bytes32 _ipfsHash,\r\n        bytes32 _swarmHash\r\n    ) {\r\n        if (!isTokenExists(_token)) {\r\n            return;\r\n        }\r\n\r\n        _name = store.get(name, _token);\r\n        _symbol = store.get(symbol, _token);\r\n        _url = store.get(url, _token);\r\n        _decimals = uint8(store.get(decimals, _token));\r\n        _ipfsHash = store.get(ipfsHash, _token);\r\n        _swarmHash = store.get(swarmHash, _token);\r\n\r\n        return (_token, _name, _symbol, _url, _decimals, _ipfsHash, _swarmHash);\r\n    }\r\n\r\n    /// @notice Returns count of registred ERC20 tokens\r\n    /// @return token count\r\n    function tokensCount() public view returns (uint) {\r\n        return store.count(tokenAddresses);\r\n    }\r\n\r\n    /// @notice Returns an array containing all token addresses.\r\n    /// @return Array of token addresses.\r\n    function getTokenAddresses() public view returns (address[] _tokenAddresses) {\r\n        _tokenAddresses = new address[](tokensCount());\r\n        for (uint _tokenIdx = 0; _tokenIdx < _tokenAddresses.length; ++_tokenIdx) {\r\n            _tokenAddresses[_tokenIdx] = getAddressById(_tokenIdx);\r\n        }\r\n    }\r\n\r\n    /// @notice Provides details of a given tokens\r\n    function getTokens(address[] _addresses) public view returns (\r\n        address[] _tokensAddresses,\r\n        bytes32[] _names,\r\n        bytes32[] _symbols,\r\n        bytes32[] _urls,\r\n        uint8[] _decimalsArr,\r\n        bytes32[] _ipfsHashes,\r\n        bytes32[] _swarmHashes\r\n    ) {\r\n        if (_addresses.length == 0) {\r\n            _addresses = getTokenAddresses();\r\n        }\r\n        _tokensAddresses = _addresses;\r\n        _names = new bytes32[](_addresses.length);\r\n        _symbols = new bytes32[](_addresses.length);\r\n        _urls = new bytes32[](_addresses.length);\r\n        _decimalsArr = new uint8[](_addresses.length);\r\n        _ipfsHashes = new bytes32[](_addresses.length);\r\n        _swarmHashes = new bytes32[](_addresses.length);\r\n\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            _names[i] = store.get(name, _addresses[i]);\r\n            _symbols[i] = store.get(symbol, _addresses[i]);\r\n            _urls[i] = store.get(url, _addresses[i]);\r\n            _decimalsArr[i] = uint8(store.get(decimals, _addresses[i]));\r\n            _ipfsHashes[i] = store.get(ipfsHash, _addresses[i]);\r\n            _swarmHashes[i] = store.get(swarmHash, _addresses[i]);\r\n        }\r\n\r\n        return (_tokensAddresses, _names, _symbols, _urls, _decimalsArr, _ipfsHashes, _swarmHashes);\r\n    }\r\n\r\n    /// @notice Provides a registered token's metadata, looked up by symbol.\r\n    /// @param _symbol Symbol of registered token.\r\n    /// @return Token metadata.\r\n    function getTokenBySymbol(bytes32 _smbl) public view returns (\r\n        address _tokenAddress,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes32 _url,\r\n        uint8 _decimals,\r\n        bytes32 _ipfsHash,\r\n        bytes32 _swarmHash\r\n    ) {\r\n        if (!isTokenSymbolExists(_smbl)) {\r\n            return;\r\n        }\r\n\r\n        address _token = store.get(tokenBySymbol, _smbl);\r\n        return getTokenMetaData(_token);\r\n    }\r\n\r\n    /// @notice Tells whether a given token exists or not\r\n    function isTokenExists(address _token) public view returns (bool) {\r\n        return store.includes(tokenAddresses, _token);\r\n    }\r\n\r\n    /// @notice Tells whether a given token exists or not\r\n    function isTokenSymbolExists(bytes32 _symbol) public view returns (bool) {\r\n        return (store.get(tokenBySymbol, _symbol) != address(0));\r\n    }\r\n\r\n    /// @notice Tells whether a given token valid or not\r\n    function isTokenValid(address _token) public view returns (bool) {\r\n        if (store.get(tokenVerifier) != 0x0) {\r\n            ERC20TokenVerifier verifier = ERC20TokenVerifier(store.get(tokenVerifier));\r\n            return verifier.verify(_token);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows owner to remove an existing token from the registry.\r\n    /// @param _token Address of existing token.\r\n    function removeToken(address _token) internal returns (uint) {\r\n        _emitLogRemoveToken(\r\n            _token,\r\n            store.get(name, _token),\r\n            store.get(symbol, _token),\r\n            store.get(url, _token),\r\n            uint8(store.get(decimals, _token)),\r\n            store.get(ipfsHash, _token),\r\n            store.get(swarmHash, _token)\r\n        );\r\n\r\n        store.set(tokenBySymbol, store.get(symbol,_token), address(0));\r\n\r\n        store.remove(tokenAddresses, _token);\r\n        // TODO: ahiatsevich clean up url, decimals, ipfsHash, swarmHash\r\n\r\n        return OK;\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/EscrowBaseInterface.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ninterface EscrowBaseInterface {\r\n\r\n\tfunction hasCurrencySupport(bytes32 _symbol) public view returns (bool);\r\n\r\n\tfunction getServiceFeeInfo() external view returns (address, uint16, uint);\r\n\tfunction setServiceFee(uint16 _feeValue) external returns (uint);\r\n\tfunction setServiceFeeAddress(address _feeReceiver) external returns (uint);\r\n\r\n\t/// @notice Gets balance locked on escrow.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @return currency symbol\r\n    /// @return currence balance on escrow\r\n    function getBalanceOf(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external view returns (bytes32, uint);\r\n\r\n\t/// @notice Creates an escrow record for provided symbol \"`_symbol`\"\r\n\t/// @dev Escrow is reusable so the same tradeRecordId could be reused after an escrow\r\n\t///\t\twith the same identifier is resolved.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _symbol symbol of payment currency\r\n\t/// @param _value amount to initially deposit to escrow; could be 0\r\n\t/// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction createEscrow(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tbytes32 _symbol,\r\n\t\tuint _value,\r\n\t\tuint _transferImmediatelyToBuyerAmount,\r\n\t\tuint8 _feeStatus\r\n\t) external payable returns (uint);\r\n\r\n\t/// @notice Deposits to an escrow provided amount `_value`\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to deposit\r\n\t/// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction deposit(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _transferImmediatelyToBuyerAmount, // transfers _transferImmediatelyToBuyerAmount directly to _buyer.\r\n\t\tuint8 _feeStatus\r\n\t) external payable returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to buyer `_buyer`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to withdraw from escrow\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _sellerSignature signature produced by seller\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction releaseBuyerPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _sellerSignature,\r\n\t\tuint8 _feeStatus\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to seller `_seller`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Buyer shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to withdraw from escrow\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _buyerSignature signature produced by buyer\r\n\t/// @return result code of an operation\r\n\tfunction sendSellerPayback(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _buyerSignature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to seller `_seller` and buyer `_buyer`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _sellerValue, _buyerValue, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _sellerValue amount to withdraw from escrow to the seller\r\n\t/// @param _buyerValue amount to withdraw from escrow to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signatures concatenated signatures produced by seller and buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction releaseNegotiatedPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _sellerValue,\r\n\t\tuint _buyerValue,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signatures,\r\n\t\tuint8 _feeStatus\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Starts a dispute process between seller `_seller` and buyer `_buyer`.\r\n\t/// \tCould start only if an arbiter was specified.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n\tfunction initiateDispute(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Cancels an initiated dispute process\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n\tfunction cancelDispute(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers disputed value from escrow to the seller `_seller` and the buyer `_buyer` according\r\n\t/// \tto provided buyer value `_buyerValue`. The value of escrow - _buyerValue will be transferred to the seller.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Arbiter should sign hash of (message, escrow address, msg.sig, _buyerValue, _expireAtBlock) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _buyerValue value that will be transferred to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _arbiterSignature signature of an arbiter\r\n\t/// @return result code of an operation\r\n\tfunction releaseDisputedPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _buyerValue,\r\n\t\tuint _expireAtBlock,\r\n\t\tbytes _arbiterSignature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Deletes escrow record when it is no more needed.\r\n    ///     Escrow should be empty to be deleted.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    function deleteEscrow(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external returns (uint);\r\n\r\n\tfunction getArbiter(bytes32 _tradeRecordId, address _seller, address _buyer) external view returns (address);\r\n\r\n\t/// @notice Sets a new arbiter `_arbiter`. His address should be approved by both parties.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _arbiter, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _bothSignatures signatures of seller and buyer\r\n\tfunction setArbiter(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\taddress _arbiter,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _bothSignatures\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Performs transfer of a currency `_symbol`\r\n\t///\t\tfrom a `msg.sender` to service fee recepient\r\n\t/// @param _symbol target currency symbol\r\n\t/// @param _from holder address of the `_symbol`\r\n\t/// @param _amount amount to retransfer\r\n\t/// @return result code of an operation\r\n\tfunction retranslateToFeeRecipient(bytes32 _symbol, address _from, uint _amount) external payable returns (uint);\r\n}\r\n\r\n// File: contracts/common/Signatures.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\nlibrary Signatures {\r\n\r\n    bytes constant internal SIGNATURE_PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\r\n    uint constant internal SIGNATURE_LENGTH = 65;\r\n\r\n    function getSignerFromSignature(bytes32 _message, bytes _signature)\r\n    public\r\n    pure\r\n    returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (_signature.length != SIGNATURE_LENGTH) {\r\n            return 0;\r\n        }\r\n\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := and(mload(add(_signature, 65)), 255)\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        return ecrecover(\r\n            keccak256(abi.encodePacked(SIGNATURE_PREFIX, _message)),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n    /// @notice Get signers from signatures byte array.\r\n    /// @param _message message hash\r\n    /// @param _signatures signatures\r\n    /// @return addresses of signers\r\n    function getSignersFromSignatures(bytes32 _message, bytes _signatures)\r\n    public\r\n    pure\r\n    returns (address[] memory _addresses)\r\n    {\r\n        require(validSignaturesLength(_signatures), \"SIGNATURES_SHOULD_HAVE_CORRECT_LENGTH\");\r\n        _addresses = new address[](numSignatures(_signatures));\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            _addresses[i] = getSignerFromSignature(_message, signatureAt(_signatures, i));\r\n        }\r\n    }\r\n\r\n    function numSignatures(bytes _signatures)\r\n    private\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return _signatures.length / SIGNATURE_LENGTH;\r\n    }\r\n\r\n    function validSignaturesLength(bytes _signatures)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (_signatures.length % SIGNATURE_LENGTH) == 0;\r\n    }\r\n\r\n    function signatureAt(bytes _signatures, uint position)\r\n    private\r\n    pure\r\n    returns (bytes)\r\n    {\r\n        return slice(_signatures, position * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\r\n    }\r\n\r\n    function bytesToBytes4(bytes memory source)\r\n    private\r\n    pure\r\n    returns (bytes4 output) {\r\n        if (source.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            output := mload(add(source, 4))\r\n        }\r\n    }\r\n\r\n    function slice(bytes _bytes, uint _start, uint _length)\r\n    private\r\n    pure\r\n    returns (bytes)\r\n    {\r\n        require(_bytes.length >= (_start + _length), \"SIGNATURES_SLICE_SIZE_SHOULD_NOT_OVERTAKE_BYTES_LENGTH\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/common/access/Context.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/common/access/Roles.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/common/access/roles/WhitelistAdminRole.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(_msgSender()), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/common/access/roles/WhitelistedRole.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\r\n * it), and not Whitelisteds themselves.\r\n */\r\ncontract WhitelistedRole is Context, WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(_msgSender()), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(_msgSender());\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/common/Relayed.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\ncontract Relayed is Object, WhitelistedRole {\r\n\r\n    uint private whitelistedCount;\r\n\r\n    event RelayTransferred(address indexed previousRelay, address indexed newRelay);\r\n\r\n    /// @dev Throws if called by any account other than the relay.\r\n    modifier onlyRelay() {\r\n        require(!isActivatedRelay() || isWhitelisted(msg.sender), \"RELAY_ONLY\");\r\n        _;\r\n    }\r\n\r\n    function isActivatedRelay() public view returns (bool) {\r\n        return whitelistedCount != 0;\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        super._addWhitelisted(account);\r\n        whitelistedCount = whitelistedCount + 1;\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        super._removeWhitelisted(account);\r\n        whitelistedCount = whitelistedCount - 1;\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/EscrowBase.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract EscrowBase {\r\n\r\n    mapping(bytes32 => bool) internal _saltWithEscrow2flagMapping;\r\n\r\n    /// @notice Gets balance locked on escrow.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @return currency symbol\r\n    /// @return currence balance on escrow\r\n    function getBalanceOf(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    )\r\n    external\r\n    view\r\n    returns (bytes32, uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        return (_getEscrowSymbol(_escrowHash), _getEscrowValue(_escrowHash));\r\n    }\r\n\r\n    /// @notice  Hashes the values and returns the escrow hash.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n    /// @return returns escrow hash\r\n    function _getEscrowHash(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    )\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_tradeRecordId, _seller, _buyer));\r\n    }\r\n\r\n    function _getEncodedSaltWithEscrowHash(uint _salt, bytes32 _escrowHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_salt, _escrowHash));\r\n    }\r\n\r\n    function _getEscrowExists(bytes32 _escrowHash) internal view returns (bool);\r\n\r\n    function _getEscrowDisputed(bytes32 _escrowHash) internal view returns (bool);\r\n\r\n    function _getEscrowSymbol(bytes32 _escrowHash) internal view returns (bytes32);\r\n\r\n    function _getEscrowValue(bytes32 _escrowHash) internal view returns (uint);\r\n\r\n    function _getEscrowArbiter(bytes32 _escrowHash) internal view returns (address);\r\n}\r\n\r\n// File: contracts/escrow/DisputedEmitter.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract DisputedEmitter {\r\n    event DisputeRequested(bytes32 indexed tradeHash, address arbiter);\r\n    event DisputeCanceled(bytes32 indexed tradeHash);\r\n    event ArbiterTransferred(bytes32 indexed tradeHash, address arbiter);\r\n\r\n    function _emitDisputeRequested(bytes32 _tradeHash, address _arbiter) internal {\r\n        emit DisputeRequested(_tradeHash, _arbiter);\r\n    }\r\n\r\n    function _emitDisputeCanceled(bytes32 _tradeHash) internal {\r\n        emit DisputeCanceled(_tradeHash);\r\n    }\r\n\r\n    function _emitArbiterTransferred(bytes32 _tradeHash, address _arbiter) internal {\r\n        emit ArbiterTransferred(_tradeHash, _arbiter);\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/Disputed.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\ncontract Disputed is\r\n    Relayed,\r\n    EscrowBase,\r\n    DisputedEmitter\r\n{\r\n    mapping(bytes32 => address) internal _disputeInitiators;\r\n\r\n    /// @notice Starts a dispute process between seller `_seller` and buyer `_buyer`.\r\n\t/// \tCould start only if an arbiter was specified.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n    function initiateDispute(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_getEscrowExists(_escrowHash), \"DISPUTED_ESCROW_SHOULD_EXIST\");\r\n        require(!_getEscrowDisputed(_escrowHash), \"DISPUTED_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n        address _arbiter = _getEscrowArbiter(_escrowHash);\r\n        require(_arbiter != address(0), \"DISPUTED_ARBITER_SHOULD_NOT_BE_EMPTY\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"DISPUTED_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _signature);\r\n        require(_signer == _seller || _signer == _buyer, \"DISPUTED_SIGNER_SHOULD_BE_BUYER_OR_SELLER\");\r\n        require(block.number < _expireAtBlock, \"DISPUTED_TX_SHOULD_NOT_BE_EXPIRED\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _disputeInitiators[_escrowHash] = _signer;\r\n        _setEscrowDisputed(_escrowHash, true);\r\n        _emitDisputeRequested(_escrowHash, _arbiter);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Cancels an initiated dispute process\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n    function cancelDispute(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_getEscrowExists(_escrowHash), \"DISPUTED_ESCROW_SHOULD_EXIST\");\r\n        require(_getEscrowDisputed(_escrowHash), \"DISPUTED_ESCROW_SHOULD_BE_DISPUTED\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"DISPUTED_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _signature);\r\n        require(_signer == _disputeInitiators[_escrowHash], \"DISPUTED_SIGNER_SHOULD_BE_DISPUTE_INITIATOR\");\r\n        require(block.number < _expireAtBlock, \"DISPUTED_TX_SHOULD_NOT_BE_EXPIRED\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _setEscrowDisputed(_escrowHash, false);\r\n        delete _disputeInitiators[_escrowHash];\r\n        _emitDisputeCanceled(_escrowHash);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Transfers disputed value from escrow to the seller `_seller` and the buyer `_buyer` according\r\n\t/// \tto provided buyer value `_buyerValue`. The value of escrow - _buyerValue will be transferred to the seller.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Arbiter should sign hash of (message, escrow address, msg.sig, _buyerValue, _expireAtBlock) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _buyerValue value that will be transferred to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _arbiterSignature signature of an arbiter\r\n\t/// @return result code of an operation\r\n    function releaseDisputedPayment(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _buyerValue,\r\n        uint _expireAtBlock,\r\n        bytes _arbiterSignature\r\n        ) external returns (uint);\r\n\r\n    function getArbiter(bytes32 _tradeRecordId, address _seller, address _buyer) external view returns (address) {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        return _getEscrowArbiter(_escrowHash);\r\n    }\r\n\r\n    /// @notice Sets a new arbiter `_arbiter`. His address should be approved by both parties.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _arbiter, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _bothSignatures signatures of seller and buyer\r\n    function setArbiter(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        address _arbiter,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _bothSignatures\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_getEscrowExists(_escrowHash), \"DISPUTED_ESCROW_SHOULD_EXIST\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"DISPUTED_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _arbiter,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address[] memory _signers = Signatures.getSignersFromSignatures(keccak256(_message), _bothSignatures);\r\n        require(\r\n            _signers.length == 2 &&\r\n            (\r\n                (_signers[0] == _seller && _signers[1] == _buyer) ||\r\n                (_signers[0] == _buyer && _signers[1] == _seller)\r\n            ),\r\n            \"DISPUTED_SIGNERS_SHOULD_BE_BUYER_AND_SELLER\");\r\n        require(block.number < _expireAtBlock, \"DISPUTED_TX_SHOULD_NOT_BE_EXPIRED\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _setEscrowArbiter(_escrowHash, _arbiter);\r\n        _emitArbiterTransferred(_escrowHash, _arbiter);\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _setEscrowDisputed(bytes32 _escrowHash, bool _disputeStatus) internal;\r\n\r\n    function _setEscrowArbiter(bytes32 _escrowHash, address _arbiter) internal;\r\n}\r\n\r\n// File: contracts/escrow/FeeApplicable.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract FeeApplicable is Object {\r\n\r\n    uint constant MAX_FEE = 100; // 100 = 1%\r\n    uint constant FEE_PRECISION = 10000; // Fee calculation: value * (fee / FEE_PRECISION)\r\n\r\n    address private _serviceFeeAddress;\r\n    uint16 private _serviceFee;\r\n\r\n    modifier onlyFeeAdmin {\r\n        require(_isFeeAdmin(msg.sender), \"AF_IC\"); // AF_IC == applicable fee invalid caller\r\n        _;\r\n    }\r\n\r\n    function getServiceFeeInfo() public view returns (address, uint16, uint) {\r\n        return (_serviceFeeAddress, _serviceFee, FEE_PRECISION);\r\n    }\r\n\r\n    function setServiceFee(uint16 _feeValue) external onlyFeeAdmin returns (uint) {\r\n        require(_feeValue <= MAX_FEE, \"AF_IV\"); // AF_IV == applicable fee invalid fee value\r\n        _serviceFee = _feeValue;\r\n    }\r\n\r\n    function setServiceFeeAddress(address _feeReceiver) external onlyFeeAdmin returns (uint) {\r\n        _serviceFeeAddress = _feeReceiver;\r\n    }\r\n\r\n    function _isFeeAdmin(address _account) internal view returns (bool);\r\n}\r\n\r\n// File: contracts/escrow/EscrowEmitter.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract EscrowEmitter {\r\n    event Created(bytes32 indexed tradeHash, bytes32 symbol, uint value);\r\n    event Deposited(bytes32 indexed tradeHash, bytes32 symbol, uint value);\r\n    event ReleasedPayment(bytes32 indexed tradeHash, bytes32 symbol, uint value);\r\n    event Payback(bytes32 indexed tradeHash, bytes32 symbol, uint value);\r\n\r\n    function _emitCreated(bytes32 _tradeHash, bytes32 _symbol, uint _value) internal {\r\n        emit Created(_tradeHash, _symbol, _value);\r\n    }\r\n\r\n    function _emitDeposited(bytes32 _tradeHash, bytes32 _symbol, uint _value) internal {\r\n        emit Deposited(_tradeHash, _symbol, _value);\r\n    }\r\n\r\n    function _emitReleasedPayment(bytes32 _tradeHash, bytes32 _symbol, uint _value) internal {\r\n        emit ReleasedPayment(_tradeHash, _symbol, _value);\r\n    }\r\n\r\n    function _emitPayback(bytes32 _tradeHash, bytes32 _symbol, uint _value) internal {\r\n        emit Payback(_tradeHash, _symbol, _value);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/Bits.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\nlibrary Bits {\r\n\r\n    uint constant internal ONE = uint(1);\r\n    uint constant internal ONES = uint(~0);\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '1'.\r\n    // Returns the modified value.\r\n    function setBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self | ONE << index;\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '0'.\r\n    // Returns the modified value.\r\n    function clearBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self & ~(ONE << index);\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to:\r\n    //  '1' - if the bit is '0'\r\n    //  '0' - if the bit is '1'\r\n    // Returns the modified value.\r\n    function toggleBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self ^ ONE << index;\r\n    }\r\n\r\n    // Get the value of the bit at the given 'index' in 'self'.\r\n    function bit(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(self >> index & 1);\r\n    }\r\n\r\n    // Check if the bit at the given 'index' in 'self' is set.\r\n    // Returns:\r\n    //  'true' - if the value of the bit is '1'\r\n    //  'false' - if the value of the bit is '0'\r\n    function bitSet(uint self, uint8 index) internal pure returns (bool) {\r\n        return self >> index & 1 == 1;\r\n    }\r\n\r\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\r\n    // bit in 'other'.\r\n    // Returns:\r\n    //  'true' - if both bits are '0' or both bits are '1'\r\n    //  'false' - otherwise\r\n    function bitEqual(uint self, uint other, uint8 index) internal pure returns (bool) {\r\n        return (self ^ other) >> index & 1 == 0;\r\n    }\r\n\r\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\r\n    function bitNot(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(1 - (self >> index & 1));\r\n    }\r\n\r\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitAnd(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self & other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitOr(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self | other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitXor(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self ^ other) >> index & 1);\r\n    }\r\n\r\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\r\n    // Returns the bits as a 'uint'.\r\n    // Requires that:\r\n    //  - '0 < numBits <= 256'\r\n    //  - 'startIndex < 256'\r\n    //  - 'numBits + startIndex <= 256'\r\n    function bits(uint self, uint8 startIndex, uint16 numBits) internal pure returns (uint) {\r\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\r\n        return self >> startIndex & ONES >> 256 - numBits;\r\n    }\r\n\r\n    // Computes the index of the highest bit set in 'self'.\r\n    // Returns the highest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function highestBitSet(uint self) internal pure returns (uint8 highest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 << i != 0) {\r\n                highest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Computes the index of the lowest bit set in 'self'.\r\n    // Returns the lowest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function lowestBitSet(uint self) internal pure returns (uint8 lowest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 == 0) {\r\n                lowest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/common/FeeConstants.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\ncontract FeeConstants {\r\n\r\n    using Bits for uint8;\r\n\r\n    uint8 constant SELLER_FLAG_BIT_IDX = 0;\r\n    uint8 constant BUYER_FLAG_BIT_IDX = 1;\r\n\r\n    /// @dev This bit means that someone should be a deposit initiator so it becomes possible to know\r\n    ///     the source of deposit (for example it is important for working with ERC-20 tokens).\r\n    ///\r\n    /// If this bit is '0' then is signs that a 'seller' is responsible for deposit. Otherwise if\r\n    ///     this bit is equal to '1' then a 'buyer' is depositing.\r\n    uint8 constant BUYER_DEPOSIT_INITIATOR_IDX = 2;\r\n\r\n    function _getSellerFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(_feeStatus.setBit(SELLER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getBuyerFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(_feeStatus.setBit(BUYER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getAllFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(uint8(_feeStatus\r\n            .setBit(SELLER_FLAG_BIT_IDX))\r\n            .setBit(BUYER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getBuyerDepositInitiatorFlag() internal pure returns (uint8 _status) {\r\n        return uint8(_status.setBit(BUYER_DEPOSIT_INITIATOR_IDX));\r\n    }\r\n\r\n    function _getNoFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return 0;\r\n    }\r\n\r\n    function _isFeeFlagAppliedFor(uint8 _feeStatus, uint8 _userBit) internal pure returns (bool) {\r\n        return _feeStatus.bitSet(_userBit);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/SafeMath.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b, \"SAFE_MATH_MUL\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SAFE_MATH_SUB\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SAFE_MATH_ADD\");\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/PercentCalculator.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\nlibrary PercentCalculator {\r\n\r\n    using SafeMath for uint;\r\n\r\n    function getPercent(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.mul(_percent).div(_precision);\r\n    }\r\n\r\n    function getValueWithPercent(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.add(getPercent(_value, _percent, _precision));\r\n    }\r\n\r\n    function getFullValueFromPercentedValue(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.mul(_precision).div(_percent);\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/EscrowERC20.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ERC20_Draft_v_0_1 is a cut version of full ERC-20 standard that\r\n///     includes only transfer methods and return no result after their completion\r\n///     (no return value, so we need to handle this).\r\n/// @dev USDT (Tether) implementation uses such technique (without return value) so this is\r\n///     a workaround that supports token from Tether.\r\ncontract ERC20_Draft_v_0_1 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n    string public symbol;\r\n\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256 supply);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address owner, address spender) public view returns (uint);\r\n    function transferFrom(address from, address to, uint value) public;\r\n    function transfer(address to, uint value) public;\r\n}\r\n\r\n\r\ncontract EscrowERC20 is\r\n    EscrowBaseInterface,\r\n    Disputed,\r\n    FeeApplicable,\r\n    EscrowEmitter,\r\n    FeeConstants,\r\n    ERC223ReceivingInterface\r\n{\r\n    using SafeMath for uint;\r\n\r\n    ERC20Manager public erc20Manager;\r\n\r\n    mapping(bytes32 => Escrow) private escrows;\r\n    mapping(address => uint) private token2accumulatedFeeMapping;\r\n\r\n    struct Escrow {\r\n        bool exists;\r\n        bool disputed;\r\n        bytes32 symbol;\r\n        uint value;\r\n        address arbiter;\r\n    }\r\n\r\n    constructor(address _erc20Manager) public {\r\n        erc20Manager = ERC20Manager(_erc20Manager);\r\n    }\r\n\r\n    function() external payable {\r\n        revert(\"ESCROW_ERC20_DOES_NOT_SUPPORT_ETH\");\r\n    }\r\n\r\n    /// @dev Standard ERC223 function that will handle incoming token transfers.\r\n    function tokenFallback(address /* _from */, uint /* _value */, bytes /* _data */) external {\r\n        require(erc20Manager.isTokenExists(msg.sender), \"ESCROW_ERC20_CURRENCY_SHOULD_BE_SUPPORTED\");\r\n    }\r\n\r\n    function getFeeBalance(address[] _tokens) public view returns (uint[] _balances) {\r\n        _balances = new uint[](_tokens.length);\r\n\r\n        for (uint _tokenIdx = 0; _tokenIdx < _tokens.length; _tokenIdx++) {\r\n            _balances[_tokenIdx] = token2accumulatedFeeMapping[_tokens[_tokenIdx]];\r\n        }\r\n    }\r\n\r\n    /// @notice Creates an escrow record for provided symbol \"`_symbol`\"\r\n    /// @dev Escrow is reusable so the same tradeRecordId could be reused after an escrow\r\n    ///\t\twith the same identifier is resolved.\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _symbol symbol of payment currency\r\n    /// @param _value amount to initially deposit to escrow; could be 0\r\n    /// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n    /// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n    /// @return result code of an operation\r\n    function createEscrow(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        bytes32 _symbol,\r\n        uint _value,\r\n        uint _transferImmediatelyToBuyerAmount,\r\n        uint8 _feeStatus\r\n    ) external payable onlyRelay returns (uint) {\r\n        require(msg.value == 0, \"ESCROW_ERC20_DOES_NOT_SUPPORT_ETH\");\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        require(!_escrow.exists, \"ESCROW_ERC20_ESCROW_SHOULD_NOT_EXIST\");\r\n        require(hasCurrencySupport(_symbol), \"ESCROW_ERC20_CURRENCY_SHOULD_BE_SUPPORTED\");\r\n\r\n        uint _valueWithoutFee = _value;\r\n        if (_value > 0) {\r\n            ERC20_Draft_v_0_1 _token = ERC20_Draft_v_0_1(erc20Manager.getTokenAddressBySymbol(_symbol));\r\n            require(_token.allowance(_seller, address(this)) >= _value && _value >= _transferImmediatelyToBuyerAmount, \"ESCROW_ERC20_VALUE_SHOULD_BE_CORRECT\");\r\n            _token.transferFrom(_seller, address(this), _value);\r\n\r\n            _valueWithoutFee = _takeDepositFee(_token, _value, _feeStatus);\r\n            if (_transferImmediatelyToBuyerAmount > 0) {\r\n                //send upfront to buyer\r\n                _valueWithoutFee = _valueWithoutFee.sub(_transferImmediatelyToBuyerAmount);\r\n                uint _transferImmediatelyToBuyerAmountWithoutFee = _takeWithdrawalFee(_token, _transferImmediatelyToBuyerAmount, _feeStatus);\r\n                _token.transfer(_buyer, _transferImmediatelyToBuyerAmountWithoutFee);\r\n            }\r\n        }\r\n        escrows[_escrowHash] = Escrow(true, false, _symbol, _valueWithoutFee, address(0));\r\n        _emitCreated(_escrowHash, _symbol, _valueWithoutFee);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Deposits to an escrow provided amount `_value`\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _value amount to deposit\r\n    /// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n    /// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n    /// @return result code of an operation\r\n    function deposit(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _value,\r\n        uint _transferImmediatelyToBuyerAmount, // transfers _transferImmediatelyToBuyerAmount directly to _buyer.\r\n        uint8 _feeStatus\r\n    ) external payable onlyRelay returns (uint) {\r\n        require(msg.value == 0, \"ESCROW_ERC20_DOES_NOT_SUPPORT_ETH\");\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        require(_escrow.exists, \"ESCROW_ERC20_ESCROW_SHOULD_EXIST\");\r\n        require(!_escrow.disputed, \"ESCROW_ERC20_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n\r\n        ERC20_Draft_v_0_1 _token = ERC20_Draft_v_0_1(erc20Manager.getTokenAddressBySymbol(_escrow.symbol));\r\n        address _investor = _getDepositInitiator(_seller, _buyer, _feeStatus);\r\n        require(_value > 0 && _token.allowance(_investor, address(this)) >= _value &&\r\n            _value >= _transferImmediatelyToBuyerAmount, \"ESCROW_ERC20_VALUE_SHOULD_BE_CORRECT\");\r\n        _token.transferFrom(_investor, address(this), _value);\r\n\r\n        uint _valueWithoutFee = _takeDepositFee(_token, _value, _feeStatus);\r\n        if (_transferImmediatelyToBuyerAmount > 0) {\r\n            //send upfront to buyer\r\n            _valueWithoutFee = _valueWithoutFee.sub(_transferImmediatelyToBuyerAmount);\r\n            uint _transferImmediatelyToBuyerAmountWithoutFee = _takeWithdrawalFee(_token, _transferImmediatelyToBuyerAmount, _feeStatus);\r\n            _token.transfer(_buyer, _transferImmediatelyToBuyerAmountWithoutFee);\r\n        }\r\n        _escrow.value = _escrow.value.add(_valueWithoutFee);\r\n        _emitDeposited(_escrowHash, _escrow.symbol, _valueWithoutFee);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Transfers `_value` from escrow to buyer `_buyer`\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @dev Seller shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _value amount to withdraw from escrow\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _sellerSignature signature produced by seller\r\n    /// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n    /// @return result code of an operation\r\n    function releaseBuyerPayment(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _sellerSignature,\r\n        uint8 _feeStatus\r\n    ) external onlyRelay returns (uint) {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_escrow.exists, \"ESCROW_ERC20_ESCROW_SHOULD_EXIST\");\r\n        require(!_escrow.disputed, \"ESCROW_ERC20_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"ESCROW_ERC20_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        _assertSeller(_escrowHash, _seller, _value, _expireAtBlock, _salt, _sellerSignature);\r\n        require(block.number < _expireAtBlock, \"ESCROW_ERC20_TX_SHOULD_NOT_BE_EXPIRED\");\r\n        require(_escrow.value >= _value && _value > 0, \"ESCROW_ERC20_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _escrow.value = _escrow.value.sub(_value);\r\n        ERC20_Draft_v_0_1 _token = ERC20_Draft_v_0_1(erc20Manager.getTokenAddressBySymbol(_escrow.symbol));\r\n        uint _valueWithoutFee = _takeWithdrawalFee(_token, _value, _feeStatus);\r\n        _token.transfer(_buyer, _valueWithoutFee);\r\n        _emitReleasedPayment(_escrowHash, _escrow.symbol, _valueWithoutFee);\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _assertSeller(\r\n        bytes32 _escrowHash,\r\n        address _seller,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _sellerSignature\r\n    )\r\n    private\r\n    view\r\n    {\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _value,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _sellerSignature);\r\n        require(_signer == _seller, \"ESCROW_ERC20_SIGNER_SHOULD_BE_SELLER\");\r\n    }\r\n\r\n    /// @notice Transfers `_value` from escrow to seller `_seller`\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @dev Buyer shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _value amount to withdraw from escrow\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _buyerSignature signature produced by buyer\r\n    /// @return result code of an operation\r\n    function sendSellerPayback(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _buyerSignature\r\n    ) external onlyRelay returns (uint) {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_escrow.exists, \"ESCROW_ERC20_ESCROW_SHOULD_EXIST\");\r\n        require(!_escrow.disputed, \"ESCROW_ERC20_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"ESCROW_ERC20_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _value,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _buyerSignature);\r\n        require(_signer == _buyer, \"ESCROW_ERC20_SIGNER_SHOULD_BE_BUYER\");\r\n        require(block.number < _expireAtBlock, \"ESCROW_ERC20_TX_SHOULD_NOT_BE_EXPIRED\");\r\n        require(_escrow.value >= _value && _value > 0, \"ESCROW_ERC20_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _escrow.value = _escrow.value.sub(_value);\r\n        ERC20_Draft_v_0_1 _token = ERC20_Draft_v_0_1(erc20Manager.getTokenAddressBySymbol(_escrow.symbol));\r\n        _token.transfer(_seller, _value);\r\n        _emitPayback(_escrowHash, _escrow.symbol, _value);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Transfers `_value` from escrow to seller `_seller` and buyer `_buyer`\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _sellerValue, _buyerValue, _expireAtBlock, _salt) data\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _sellerValue amount to withdraw from escrow to the seller\r\n    /// @param _buyerValue amount to withdraw from escrow to the buyer\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _signatures concatenated signatures produced by seller and buyer\r\n    /// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n    /// @return result code of an operation\r\n    function releaseNegotiatedPayment(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _sellerValue,\r\n        uint _buyerValue,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signatures,\r\n        uint8 _feeStatus\r\n    ) external onlyRelay returns (uint) {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        require(_escrow.exists, \"ESCROW_ERC20_ESCROW_SHOULD_EXIST\");\r\n        require(!_escrow.disputed, \"ESCROW_ERC20_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n        require(!_saltWithEscrow2flagMapping[_getEncodedSaltWithEscrowHash(_salt, _escrowHash)], \"ESCROW_ERC20_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        _assertSellerAndBuyer(_escrowHash, _seller, _buyer, _sellerValue, _buyerValue, _expireAtBlock, _salt, _signatures);\r\n        require(block.number < _expireAtBlock, \"ESCROW_ERC20_TX_SHOULD_NOT_BE_EXPIRED\");\r\n        require(_escrow.value >= _sellerValue.add(_buyerValue) && _sellerValue.add(_buyerValue) > 0, \"ESCROW_ERC20_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        _saltWithEscrow2flagMapping[_getEncodedSaltWithEscrowHash(_salt, _escrowHash)] = true;\r\n        _escrow.value = _escrow.value.sub(_sellerValue.add(_buyerValue));\r\n        ERC20_Draft_v_0_1 _token = ERC20_Draft_v_0_1(erc20Manager.getTokenAddressBySymbol(_escrow.symbol));\r\n        _token.transfer(_seller, _sellerValue);\r\n        uint _buyerValueWithoutFee = _takeWithdrawalFee(_token, _buyerValue, _feeStatus);\r\n        _token.transfer(_buyer, _buyerValueWithoutFee);\r\n        _emitPayback(_escrowHash, _escrow.symbol, _sellerValue);\r\n        _emitReleasedPayment(_escrowHash, _escrow.symbol, _buyerValueWithoutFee);\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _assertSellerAndBuyer(\r\n        bytes32 _escrowHash,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _sellerValue,\r\n        uint _buyerValue,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signatures\r\n    )\r\n    private\r\n    view\r\n    {\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _sellerValue,\r\n            _buyerValue,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address[] memory _signers = Signatures.getSignersFromSignatures(keccak256(_message), _signatures);\r\n        require(_signers.length == 2 && ((_signers[0] == _seller && _signers[1] == _buyer) ||\r\n            (_signers[0] == _buyer && _signers[1] == _seller)), \"ESCROW_ERC20_SIGNERS_SHOULD_BE_BUYER_AND_SELLER\");\r\n    }\r\n\r\n    /// @notice Transfers disputed value from escrow to the seller `_seller` and the buyer `_buyer` according\r\n    /// \tto provided buyer value `_buyerValue`. The value of escrow - _buyerValue will be transferred to the seller.\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @dev Arbiter should sign hash of (message, escrow address, msg.sig, _buyerValue, _expireAtBlock) data\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _buyerValue value that will be transferred to the buyer\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _arbiterSignature signature of an arbiter\r\n    /// @return result code of an operation\r\n    function releaseDisputedPayment(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _buyerValue,\r\n        uint _expireAtBlock,\r\n        bytes _arbiterSignature\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        require(_escrow.exists, \"ESCROW_ERC20_ESCROW_SHOULD_EXIST\");\r\n        require(_escrow.disputed, \"ESCROW_ERC20_ESCROW_SHOULD_BE_DISPUTED\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _buyerValue,\r\n            _expireAtBlock\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _arbiterSignature);\r\n        require(_signer == _escrow.arbiter, \"ESCROW_ERC20_SIGNER_SHOULD_BE_ARBITER\");\r\n        require(block.number < _expireAtBlock, \"ESCROW_ERC20_TX_SHOULD_NOT_BE_EXPIRED\");\r\n        require(_buyerValue <= _escrow.value, \"ESCROW_ERC20_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        ERC20_Draft_v_0_1 _token = ERC20_Draft_v_0_1(erc20Manager.getTokenAddressBySymbol(_escrow.symbol));\r\n        if (_buyerValue < _escrow.value) {\r\n            uint _sellerValue = _escrow.value.sub(_buyerValue);\r\n            _token.transfer(_seller, _sellerValue);\r\n            _emitPayback(_escrowHash, _escrow.symbol, _sellerValue);\r\n        }\r\n        uint _buyerValueWithoutFee = _takeWithdrawalFee(_token, _buyerValue);\r\n        _token.transfer(_buyer, _buyerValueWithoutFee);\r\n\r\n        _deleteEscrow(_escrowHash);\r\n        delete _disputeInitiators[_escrowHash];\r\n        _emitReleasedPayment(_escrowHash, _escrow.symbol, _buyerValueWithoutFee);\r\n        _emitDisputeCanceled(_escrowHash);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Deletes escrow record when it is no more needed.\r\n    ///     Escrow should be empty to be deleted.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    function deleteEscrow(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external returns (uint) {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        if (_escrow.exists && _escrow.value == 0) {\r\n            _deleteEscrow(_escrowHash);\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _deleteEscrow(bytes32 _escrowHash) private {\r\n        delete escrows[_escrowHash];\r\n    }\r\n\r\n    /// @notice Charges a service fee for deposits to escrow contract.\r\n    /// @param _value value from which the commission is taken\r\n    /// @param _feeStatus activate state fee: 1 - active, 0 - not active. 1st bit - seller, 2nd bit - buyer\r\n    /// @return result value without service fee\r\n    function _takeDepositFee(address _token, uint _value, uint8 _feeStatus) private returns (uint _valueToDeposit) {\r\n        _valueToDeposit = _value;\r\n        bool _isActivatedRelay = isActivatedRelay();\r\n        (, uint16 _serviceFeeValue, uint _feePrecision) = getServiceFeeInfo();\r\n        if (_serviceFeeValue > 0 && (!_isActivatedRelay || (_isActivatedRelay && _isFeeFlagAppliedFor(_feeStatus, SELLER_FLAG_BIT_IDX)))) {\r\n            _valueToDeposit = PercentCalculator.getFullValueFromPercentedValue(_value, _feePrecision.add(_serviceFeeValue), _feePrecision);\r\n            uint _feeValue = _value.sub(_valueToDeposit);\r\n            token2accumulatedFeeMapping[_token] = token2accumulatedFeeMapping[_token].add(_feeValue);\r\n        }\r\n    }\r\n\r\n    /// @notice Charges a service fee for withdrawal payments from escrow contract.\r\n    /// @param _token erc20 token address\r\n    /// @param _value value from which the commission is taken\r\n    /// @param _feeStatus activate state fee: 1 - active, 0 - not active. 1st bit - seller, 2nd bit - buyer\r\n    /// @return result value without service fee\r\n    function _takeWithdrawalFee(address _token, uint _value, uint8 _feeStatus) private returns (uint) {\r\n        bool _isActivatedRelay = isActivatedRelay();\r\n        if (!_isActivatedRelay || (_isActivatedRelay && _isFeeFlagAppliedFor(_feeStatus, BUYER_FLAG_BIT_IDX))) {\r\n            return _takeWithdrawalFee(_token, _value);\r\n        }\r\n        return _value;\r\n    }\r\n\r\n    function _takeWithdrawalFee(address _token, uint _value) private returns (uint) {\r\n        (, uint16 _serviceFeeValue, uint _feePrecision) = getServiceFeeInfo();\r\n        if (_serviceFeeValue > 0) {\r\n            uint _feeValue = PercentCalculator.getPercent(_value, _serviceFeeValue, _feePrecision);\r\n            _value = _value.sub(_feeValue);\r\n            token2accumulatedFeeMapping[_token] = token2accumulatedFeeMapping[_token].add(_feeValue);\r\n        }\r\n        return _value;\r\n    }\r\n\r\n    function withdrawFeeForTokens(address[] _tokens) public onlyContractOwner {\r\n        (address _feeDestinationAddress,,) = getServiceFeeInfo();\r\n        require(_feeDestinationAddress != address(0), \"ESCROW_ERC20_INVALID_SERVICE_FEE_ADDRESS\");\r\n\r\n        for (uint _tokenIdx = 0; _tokenIdx < _tokens.length; _tokenIdx++) {\r\n            address _token = _tokens[_tokenIdx];\r\n            uint _accumulatedFee = token2accumulatedFeeMapping[_token];\r\n            token2accumulatedFeeMapping[_token] = 0;\r\n            if (_accumulatedFee > 0) {\r\n                ERC20_Draft_v_0_1(_token).transfer(_feeDestinationAddress, _accumulatedFee);\r\n            }\r\n        }\r\n    }\r\n\r\n\tfunction retranslateToFeeRecipient(bytes32 _symbol, address _from, uint _amount) external payable returns (uint) {\r\n        require(hasCurrencySupport(_symbol), \"ESCROW_ERC20_CURRENCY_SHOULD_BE_SUPPORTED\");\r\n        ERC20_Draft_v_0_1 _token = ERC20_Draft_v_0_1(erc20Manager.getTokenAddressBySymbol(_symbol));\r\n        require(_amount > 0 && _token.allowance(_from, address(this)) >= _amount, \"ESCROW_ERC20_VALUE_SHOULD_BE_CORRECT\");\r\n        _token.transferFrom(_from, address(this), _amount);\r\n\r\n        token2accumulatedFeeMapping[_token] = token2accumulatedFeeMapping[_token].add(_amount);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Transfer accumulated service fee to the serviceFeeAddress\r\n    function withdrawFee(address _token) public onlyContractOwner {\r\n        address[] memory _tokens = new address[](1);\r\n        _tokens[0] = _token;\r\n        withdrawFeeForTokens(_tokens);\r\n    }\r\n\r\n    function hasCurrencySupport(bytes32 _symbol) public view returns (bool) {\r\n        return erc20Manager.isTokenSymbolExists(_symbol);\r\n    }\r\n\r\n    function _isFeeAdmin(address _account) internal view returns (bool) {\r\n        return contractOwner == _account;\r\n    }\r\n\r\n    function _getEscrowExists(bytes32 _escrowHash) internal view returns (bool) {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        return _escrow.exists;\r\n    }\r\n\r\n    function _getEscrowDisputed(bytes32 _escrowHash) internal view returns (bool) {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        return _escrow.disputed;\r\n    }\r\n\r\n    function _getEscrowSymbol(bytes32 _escrowHash) internal view returns (bytes32) {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        return _escrow.symbol;\r\n    }\r\n\r\n    function _getEscrowValue(bytes32 _escrowHash) internal view returns (uint) {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        return _escrow.value;\r\n    }\r\n\r\n    function _getEscrowArbiter(bytes32 _escrowHash) internal view returns (address) {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        return _escrow.arbiter;\r\n    }\r\n\r\n    function _setEscrowDisputed(bytes32 _escrowHash, bool _disputeStatus) internal {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        _escrow.disputed = _disputeStatus;\r\n    }\r\n\r\n    function _setEscrowArbiter(bytes32 _escrowHash, address _arbiter) internal {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        _escrow.arbiter = _arbiter;\r\n    }\r\n\r\n    function _getDepositInitiator(address _seller, address _buyer, uint8 _status) private pure returns (address) {\r\n        if (_isFeeFlagAppliedFor(_status, BUYER_DEPOSIT_INITIATOR_IDX)) {\r\n            return _buyer;\r\n        }\r\n\r\n        return _seller;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_transferImmediatelyToBuyerAmount\",\"type\":\"uint256\"},{\"name\":\"_feeStatus\",\"type\":\"uint8\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getFeeBalance\",\"outputs\":[{\"name\":\"_balances\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_sellerValue\",\"type\":\"uint256\"},{\"name\":\"_buyerValue\",\"type\":\"uint256\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_signatures\",\"type\":\"bytes\"},{\"name\":\"_feeStatus\",\"type\":\"uint8\"}],\"name\":\"releaseNegotiatedPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setServiceFeeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_sellerSignature\",\"type\":\"bytes\"},{\"name\":\"_feeStatus\",\"type\":\"uint8\"}],\"name\":\"releaseBuyerPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"initiateDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_buyerSignature\",\"type\":\"bytes\"}],\"name\":\"sendSellerPayback\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawFeeForTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"bytes32\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"retranslateToFeeRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"bytes32\"}],\"name\":\"hasCurrencySupport\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_buyerValue\",\"type\":\"uint256\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_arbiterSignature\",\"type\":\"bytes\"}],\"name\":\"releaseDisputedPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20Manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_symbol\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_transferImmediatelyToBuyerAmount\",\"type\":\"uint256\"},{\"name\":\"_feeStatus\",\"type\":\"uint8\"}],\"name\":\"createEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeValue\",\"type\":\"uint16\"}],\"name\":\"setServiceFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"deleteEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getServiceFeeInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"cancelDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getArbiter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_arbiter\",\"type\":\"address\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_bothSignatures\",\"type\":\"bytes\"}],\"name\":\"setArbiter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActivatedRelay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_erc20Manager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReleasedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Payback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"DisputeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"}],\"name\":\"DisputeCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"ArbiterTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousRelay\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newRelay\",\"type\":\"address\"}],\"name\":\"RelayTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EscrowERC20","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000026b579aec4cf7fdbb1885d987968e6f5515ab82b","Library":"Signatures:65b81c19ab7b084f31adf0915b6baaa6130c6d26","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://22a1c3492c37eb12d9a005bae595246afef3a1ff20f810f9c4ce1090d7a9f219"}]}