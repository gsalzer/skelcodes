{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\n\r\ninterface ILiquidityPool {\r\n    \r\n    \r\n    function take(address _token, uint256 _amount) external;\r\n\r\n    \r\n    \r\n    function deposit(address _token, uint256 _amount) external returns (uint256);\r\n\r\n    \r\n    \r\n    function withdraw(address _token, uint256 _amount) external;\r\n\r\n    \r\n    \r\n    \r\n    function isEther(address _ether) external pure returns (bool);\r\n}\r\n\r\ninterface IRebalancer {\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function giveUnbalancedPosition(address _negToken, uint256 _negAmount, address _posToken, uint256 _posAmount) external payable;\r\n}\r\n\r\ncontract Context {\r\n    \r\n    \r\n    constructor () internal { }\r\n    \r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    \r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    \r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    \r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    \r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    \r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n        \r\n        \r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        \r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        \r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    \r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    \r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    \r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     \r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    \r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        \r\n        \r\n        \r\n\r\n        \r\n        \r\n        \r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        \r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    \r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        \r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        \r\n        \r\n        \r\n        \r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    \r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        \r\n        \r\n\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        \r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { \r\n            \r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract CanReclaimTokens is Ownable {\r\n    using SafeERC20 for ERC20;\r\n\r\n    mapping(address => bool) private recoverableTokensBlacklist;\r\n\r\n    function blacklistRecoverableToken(address _token) public onlyOwner {\r\n        recoverableTokensBlacklist[_token] = true;\r\n    }\r\n\r\n    \r\n    \r\n    function recoverTokens(address _token) external onlyOwner {\r\n        require(!recoverableTokensBlacklist[_token], \"CanReclaimTokens: token is not recoverable\");\r\n\r\n        if (_token == address(0x0)) {\r\n            msg.sender.transfer(address(this).balance);\r\n        } else {\r\n            ERC20(_token).safeTransfer(msg.sender, ERC20(_token).balanceOf(address(this)));\r\n        }\r\n    }\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    \r\n    function isComptroller() external view returns (bool);\r\n\r\n    \r\n\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cToken) external returns (uint);\r\n\r\n    \r\n\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);\r\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;\r\n\r\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);\r\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\r\n\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\r\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) external;\r\n\r\n    function repayBorrowAllowed(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function repayBorrowVerify(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint borrowerIndex) external;\r\n\r\n    function liquidateBorrowAllowed(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function liquidateBorrowVerify(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint seizeTokens) external;\r\n\r\n    function seizeAllowed(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external returns (uint);\r\n    function seizeVerify(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external;\r\n\r\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);\r\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) external;\r\n\r\n    \r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        uint repayAmount) external view returns (uint, uint);\r\n}\r\n\r\ncontract ComptrollerErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        COMPTROLLER_MISMATCH,\r\n        INSUFFICIENT_SHORTFALL,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INVALID_CLOSE_FACTOR,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        INVALID_LIQUIDATION_INCENTIVE,\r\n        MARKET_NOT_ENTERED, \r\n        MARKET_NOT_LISTED,\r\n        MARKET_ALREADY_LISTED,\r\n        MATH_ERROR,\r\n        NONZERO_BORROW_BALANCE,\r\n        PRICE_ERROR,\r\n        REJECTION,\r\n        SNAPSHOT_ERROR,\r\n        TOO_MANY_ASSETS,\r\n        TOO_MUCH_REPAY\r\n    }\r\n\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        EXIT_MARKET_BALANCE_OWED,\r\n        EXIT_MARKET_REJECTION,\r\n        SET_CLOSE_FACTOR_OWNER_CHECK,\r\n        SET_CLOSE_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\r\n        SET_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_PRICE_ORACLE_OWNER_CHECK,\r\n        SUPPORT_MARKET_EXISTS,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\r\n    }\r\n\r\n    \r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    \r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    \r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\ncontract TokenErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        BAD_INPUT,\r\n        COMPTROLLER_REJECTION,\r\n        COMPTROLLER_CALCULATION_ERROR,\r\n        INTEREST_RATE_MODEL_ERROR,\r\n        INVALID_ACCOUNT_PAIR,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        MATH_ERROR,\r\n        MARKET_NOT_FRESH,\r\n        MARKET_NOT_LISTED,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_IN_FAILED,\r\n        TOKEN_TRANSFER_OUT_FAILED\r\n    }\r\n\r\n    \r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_ACCRUE_INTEREST_FAILED,\r\n        BORROW_CASH_NOT_AVAILABLE,\r\n        BORROW_FRESHNESS_CHECK,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        BORROW_MARKET_NOT_LISTED,\r\n        BORROW_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\r\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\r\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\r\n        LIQUIDATE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\r\n        LIQUIDATE_FRESHNESS_CHECK,\r\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_SEIZE_TOO_MUCH,\r\n        MINT_ACCRUE_INTEREST_FAILED,\r\n        MINT_COMPTROLLER_REJECTION,\r\n        MINT_EXCHANGE_CALCULATION_FAILED,\r\n        MINT_EXCHANGE_RATE_READ_FAILED,\r\n        MINT_FRESHNESS_CHECK,\r\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        MINT_TRANSFER_IN_FAILED,\r\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\r\n        REDEEM_ACCRUE_INTEREST_FAILED,\r\n        REDEEM_COMPTROLLER_REJECTION,\r\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\r\n        REDEEM_FRESHNESS_CHECK,\r\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\r\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\r\n        REDUCE_RESERVES_ADMIN_CHECK,\r\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\r\n        REDUCE_RESERVES_FRESH_CHECK,\r\n        REDUCE_RESERVES_VALIDATION,\r\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_COMPTROLLER_REJECTION,\r\n        REPAY_BORROW_FRESHNESS_CHECK,\r\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COMPTROLLER_OWNER_CHECK,\r\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\r\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\r\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_ORACLE_MARKET_NOT_LISTED,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\r\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\r\n        SET_RESERVE_FACTOR_FRESH_CHECK,\r\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\r\n        TRANSFER_COMPTROLLER_REJECTION,\r\n        TRANSFER_NOT_ALLOWED,\r\n        TRANSFER_NOT_ENOUGH,\r\n        TRANSFER_TOO_MUCH\r\n    }\r\n\r\n    \r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    \r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    \r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\ncontract CarefulMath {\r\n\r\n    \r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    \r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    \r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    \r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b <= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    \r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    \r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}\r\n\r\ncontract Exponential is CarefulMath {\r\n    uint constant expScale = 1e18;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    \r\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    \r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    \r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    \r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    \r\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    \r\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return addUInt(truncate(product), addend);\r\n    }\r\n\r\n    \r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    \r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\r\n        \r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    \r\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(fraction));\r\n    }\r\n\r\n    \r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        \r\n        \r\n        \r\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n        \r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    \r\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n    \r\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\r\n        (MathError err, Exp memory ab) = mulExp(a, b);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, ab);\r\n        }\r\n        return mulExp(ab, c);\r\n    }\r\n\r\n    \r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    \r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        \r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    \r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    \r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    \r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    \r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n}\r\n\r\ninterface EIP20Interface {\r\n\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    \r\n    function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n    \r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\ninterface EIP20NonStandardInterface {\r\n\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n    function transfer(address dst, uint256 amount) external;\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n    function transferFrom(address src, address dst, uint256 amount) external;\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    \r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        \r\n        \r\n        _guardCounter = 1;\r\n    }\r\n\r\n    \r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"re-entered\");\r\n    }\r\n}\r\n\r\ninterface InterestRateModel {\r\n    \r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\r\n\r\n    \r\n    function isInterestRateModel() external view returns (bool);\r\n}\r\n\r\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\r\n    \r\n    bool public constant isCToken = true;\r\n\r\n    \r\n    string public name;\r\n\r\n    \r\n    string public symbol;\r\n\r\n    \r\n    uint8 public decimals;\r\n\r\n    \r\n\r\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\r\n\r\n    \r\n    uint internal constant reserveFactorMaxMantissa = 1e18;\r\n\r\n    \r\n    address payable public admin;\r\n\r\n    \r\n    address payable public pendingAdmin;\r\n\r\n    \r\n    ComptrollerInterface public comptroller;\r\n\r\n    \r\n    InterestRateModel public interestRateModel;\r\n\r\n    \r\n    uint public initialExchangeRateMantissa;\r\n\r\n    \r\n    uint public reserveFactorMantissa;\r\n\r\n    \r\n    uint public accrualBlockNumber;\r\n\r\n    \r\n    uint public borrowIndex;\r\n\r\n    \r\n    uint public totalBorrows;\r\n\r\n    \r\n    uint public totalReserves;\r\n\r\n    \r\n    uint256 public totalSupply;\r\n\r\n    \r\n    mapping (address => uint256) internal accountTokens;\r\n\r\n    \r\n    mapping (address => mapping (address => uint256)) internal transferAllowances;\r\n\r\n    \r\n    struct BorrowSnapshot {\r\n        uint principal;\r\n        uint interestIndex;\r\n    }\r\n\r\n    \r\n    mapping(address => BorrowSnapshot) internal accountBorrows;\r\n\r\n\r\n    \r\n\r\n    \r\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\r\n    \r\n    event Mint(address minter, uint mintAmount, uint mintTokens);\r\n\r\n    \r\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\r\n\r\n    \r\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    \r\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    \r\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\r\n\r\n\r\n    \r\n\r\n    \r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    \r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    \r\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\r\n\r\n    \r\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\r\n\r\n    \r\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\r\n\r\n    \r\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\r\n\r\n\r\n    \r\n    constructor(ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_) internal {\r\n        \r\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\r\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\r\n\r\n        \r\n        admin = msg.sender;\r\n        \r\n        uint err = _setComptroller(comptroller_);\r\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\r\n\r\n        \r\n        accrualBlockNumber = getBlockNumber();\r\n        borrowIndex = mantissaOne;\r\n\r\n        \r\n        err = _setInterestRateModelFresh(interestRateModel_);\r\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\r\n\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n\r\n        \r\n        admin = admin_;\r\n    }\r\n\r\n    \r\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (src == dst) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        \r\n        uint startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = uint(-1);\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n\r\n        \r\n        MathError mathErr;\r\n        uint allowanceNew;\r\n        uint srcTokensNew;\r\n        uint dstTokensNew;\r\n\r\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\r\n        }\r\n\r\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\r\n        }\r\n\r\n        \r\n        \r\n        \r\n\r\n        accountTokens[src] = srcTokensNew;\r\n        accountTokens[dst] = dstTokensNew;\r\n\r\n        \r\n        if (startingAllowance != uint(-1)) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        \r\n        emit Transfer(src, dst, tokens);\r\n\r\n        comptroller.transferVerify(address(this), src, dst, tokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    \r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        return accountTokens[owner];\r\n    }\r\n\r\n    \r\n    function balanceOfUnderlying(address owner) external returns (uint) {\r\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\r\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\r\n        require(mErr == MathError.NO_ERROR);\r\n        return balance;\r\n    }\r\n\r\n    \r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\r\n        uint cTokenBalance = accountTokens[account];\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n\r\n        MathError mErr;\r\n\r\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\r\n    }\r\n\r\n    \r\n    function getBlockNumber() internal view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    \r\n    function borrowRatePerBlock() external view returns (uint) {\r\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\r\n        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); \r\n        return borrowRateMantissa;\r\n    }\r\n\r\n    \r\n    function supplyRatePerBlock() external view returns (uint) {\r\n        \r\n        uint exchangeRateMantissa = exchangeRateStored();\r\n\r\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\r\n        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); \r\n\r\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\r\n        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\r\n\r\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\r\n        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\r\n\r\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\r\n        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\r\n\r\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\r\n        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\r\n\r\n        return supplyRate.mantissa;\r\n    }\r\n\r\n    \r\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return totalBorrows;\r\n    }\r\n\r\n    \r\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return borrowBalanceStored(account);\r\n    }\r\n\r\n    \r\n    function borrowBalanceStored(address account) public view returns (uint) {\r\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\r\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    \r\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\r\n        \r\n        MathError mathErr;\r\n        uint principalTimesIndex;\r\n        uint result;\r\n\r\n        \r\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\r\n\r\n        \r\n        if (borrowSnapshot.principal == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        \r\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, result);\r\n    }\r\n\r\n    \r\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return exchangeRateStored();\r\n    }\r\n\r\n    \r\n    function exchangeRateStored() public view returns (uint) {\r\n        (MathError err, uint result) = exchangeRateStoredInternal();\r\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    \r\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\r\n        if (totalSupply == 0) {\r\n            \r\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\r\n        } else {\r\n            \r\n            uint totalCash = getCashPrior();\r\n            uint cashPlusBorrowsMinusReserves;\r\n            Exp memory exchangeRate;\r\n            MathError mathErr;\r\n\r\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\r\n        }\r\n    }\r\n\r\n    \r\n    function getCash() external view returns (uint) {\r\n        return getCashPrior();\r\n    }\r\n\r\n    struct AccrueInterestLocalVars {\r\n        MathError mathErr;\r\n        uint opaqueErr;\r\n        uint borrowRateMantissa;\r\n        uint currentBlockNumber;\r\n        uint blockDelta;\r\n\r\n        Exp simpleInterestFactor;\r\n\r\n        uint interestAccumulated;\r\n        uint totalBorrowsNew;\r\n        uint totalReservesNew;\r\n        uint borrowIndexNew;\r\n    }\r\n\r\n    \r\n    function accrueInterest() public returns (uint) {\r\n        AccrueInterestLocalVars memory vars;\r\n\r\n        \r\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\r\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\r\n        if (vars.opaqueErr != 0) {\r\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\r\n        }\r\n\r\n        \r\n        vars.currentBlockNumber = getBlockNumber();\r\n\r\n        \r\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\r\n        assert(vars.mathErr == MathError.NO_ERROR); \r\n\r\n        \r\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        \r\n        \r\n\r\n        \r\n        accrualBlockNumber = vars.currentBlockNumber;\r\n        borrowIndex = vars.borrowIndexNew;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n        totalReserves = vars.totalReservesNew;\r\n\r\n        \r\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        \r\n        return mintFresh(msg.sender, mintAmount);\r\n    }\r\n\r\n    struct MintLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint mintTokens;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n    }\r\n\r\n    \r\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\r\n        }\r\n\r\n        MintLocalVars memory vars;\r\n\r\n        \r\n        vars.err = checkTransferIn(minter, mintAmount);\r\n        if (vars.err != Error.NO_ERROR) {\r\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\r\n        }\r\n\r\n        \r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        \r\n        \r\n\r\n        \r\n        vars.err = doTransferIn(minter, mintAmount);\r\n        if (vars.err != Error.NO_ERROR) {\r\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\r\n        }\r\n\r\n        \r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[minter] = vars.accountTokensNew;\r\n\r\n        \r\n        emit Mint(minter, mintAmount, vars.mintTokens);\r\n        emit Transfer(address(this), minter, vars.mintTokens);\r\n\r\n        \r\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        \r\n        return redeemFresh(msg.sender, redeemTokens, 0);\r\n    }\r\n\r\n    \r\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        \r\n        return redeemFresh(msg.sender, 0, redeemAmount);\r\n    }\r\n\r\n    struct RedeemLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint redeemTokens;\r\n        uint redeemAmount;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n    }\r\n\r\n    \r\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\r\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\r\n\r\n        RedeemLocalVars memory vars;\r\n\r\n        \r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        if (redeemTokensIn > 0) {\r\n            \r\n            vars.redeemTokens = redeemTokensIn;\r\n\r\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n        } else {\r\n            \r\n\r\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n\r\n            vars.redeemAmount = redeemAmountIn;\r\n        }\r\n\r\n        \r\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\r\n        }\r\n\r\n        \r\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        if (getCashPrior() < vars.redeemAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\r\n        }\r\n\r\n        \r\n        \r\n        \r\n\r\n        \r\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\r\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\r\n\r\n        \r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[redeemer] = vars.accountTokensNew;\r\n\r\n        \r\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\r\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n        \r\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        \r\n        return borrowFresh(msg.sender, borrowAmount);\r\n    }\r\n\r\n    struct BorrowLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n    }\r\n\r\n    \r\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\r\n        }\r\n\r\n        \r\n        if (getCashPrior() < borrowAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        BorrowLocalVars memory vars;\r\n\r\n        \r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        \r\n        \r\n\r\n        \r\n        vars.err = doTransferOut(borrower, borrowAmount);\r\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\r\n\r\n        \r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        \r\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        \r\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        \r\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\r\n    }\r\n\r\n    \r\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        \r\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\r\n    }\r\n\r\n    struct RepayBorrowLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint repayAmount;\r\n        uint borrowerIndex;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n    }\r\n\r\n    \r\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\r\n        }\r\n\r\n        RepayBorrowLocalVars memory vars;\r\n\r\n        \r\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\r\n\r\n        \r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        if (repayAmount == uint(-1)) {\r\n            vars.repayAmount = vars.accountBorrows;\r\n        } else {\r\n            vars.repayAmount = repayAmount;\r\n        }\r\n\r\n        \r\n        vars.err = checkTransferIn(payer, vars.repayAmount);\r\n        if (vars.err != Error.NO_ERROR) {\r\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\r\n        }\r\n\r\n        \r\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        \r\n        \r\n        \r\n\r\n        \r\n        vars.err = doTransferIn(payer, vars.repayAmount);\r\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\r\n\r\n        \r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        \r\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        \r\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\r\n        }\r\n\r\n        error = cTokenCollateral.accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\r\n        }\r\n\r\n        \r\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\r\n    }\r\n\r\n    \r\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {\r\n        \r\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\r\n        }\r\n\r\n        \r\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\r\n        }\r\n\r\n        \r\n        if (borrower == liquidator) {\r\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\r\n        }\r\n\r\n        \r\n        if (repayAmount == 0) {\r\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\r\n        }\r\n\r\n        \r\n        if (repayAmount == uint(-1)) {\r\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\r\n        }\r\n\r\n        \r\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);\r\n        if (amountSeizeError != 0) {\r\n            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);\r\n        }\r\n\r\n        \r\n        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\r\n        }\r\n\r\n        \r\n        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\r\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\r\n            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);\r\n        }\r\n\r\n        \r\n        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\r\n        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\r\n\r\n        \r\n        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);\r\n\r\n        \r\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\r\n        \r\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        \r\n        if (borrower == liquidator) {\r\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\r\n        }\r\n\r\n        MathError mathErr;\r\n        uint borrowerTokensNew;\r\n        uint liquidatorTokensNew;\r\n\r\n        \r\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n        \r\n        \r\n        \r\n\r\n        \r\n        accountTokens[borrower] = borrowerTokensNew;\r\n        accountTokens[liquidator] = liquidatorTokensNew;\r\n\r\n        \r\n        emit Transfer(borrower, liquidator, seizeTokens);\r\n\r\n        \r\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    \r\n\r\n    \r\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\r\n        \r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        \r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        \r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        \r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _acceptAdmin() external returns (uint) {\r\n        \r\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        \r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        \r\n        admin = pendingAdmin;\r\n\r\n        \r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\r\n        \r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        ComptrollerInterface oldComptroller = comptroller;\r\n        \r\n        require(newComptroller.isComptroller(), \"marker method returned false\");\r\n\r\n        \r\n        comptroller = newComptroller;\r\n\r\n        \r\n        emit NewComptroller(oldComptroller, newComptroller);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        \r\n        return _setReserveFactorFresh(newReserveFactorMantissa);\r\n    }\r\n\r\n    \r\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\r\n        \r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\r\n        }\r\n\r\n        \r\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\r\n        }\r\n\r\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\r\n        reserveFactorMantissa = newReserveFactorMantissa;\r\n\r\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        \r\n        return _reduceReservesFresh(reduceAmount);\r\n    }\r\n\r\n    \r\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\r\n        Error err;\r\n        \r\n        uint totalReservesNew;\r\n\r\n        \r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\r\n        }\r\n\r\n        \r\n        if (getCashPrior() < reduceAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        \r\n        if (reduceAmount > totalReserves) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\r\n        }\r\n\r\n        \r\n        \r\n        \r\n\r\n        totalReservesNew = totalReserves - reduceAmount;\r\n        \r\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\r\n\r\n        \r\n        totalReserves = totalReservesNew;\r\n\r\n        \r\n        err = doTransferOut(admin, reduceAmount);\r\n        \r\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\r\n\r\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            \r\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        \r\n        return _setInterestRateModelFresh(newInterestRateModel);\r\n    }\r\n\r\n    \r\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\r\n\r\n        \r\n        InterestRateModel oldInterestRateModel;\r\n\r\n        \r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\r\n        }\r\n\r\n        \r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\r\n        }\r\n\r\n        \r\n        oldInterestRateModel = interestRateModel;\r\n\r\n        \r\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\r\n\r\n        \r\n        interestRateModel = newInterestRateModel;\r\n\r\n        \r\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    \r\n\r\n    \r\n    function getCashPrior() internal view returns (uint);\r\n\r\n    \r\n    function checkTransferIn(address from, uint amount) internal view returns (Error);\r\n\r\n    \r\n    function doTransferIn(address from, uint amount) internal returns (Error);\r\n\r\n    \r\n    function doTransferOut(address payable to, uint amount) internal returns (Error);\r\n}\r\n\r\ncontract CErc20 is CToken {\r\n\r\n    \r\n    address public underlying;\r\n\r\n    \r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_) public\r\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_) {\r\n        \r\n        underlying = underlying_;\r\n        EIP20Interface(underlying).totalSupply(); \r\n    }\r\n\r\n    \r\n\r\n    \r\n    function mint(uint mintAmount) external returns (uint) {\r\n        return mintInternal(mintAmount);\r\n    }\r\n\r\n    \r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        return redeemInternal(redeemTokens);\r\n    }\r\n\r\n    \r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        return redeemUnderlyingInternal(redeemAmount);\r\n    }\r\n\r\n    \r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        return borrowInternal(borrowAmount);\r\n    }\r\n\r\n    \r\n    function repayBorrow(uint repayAmount) external returns (uint) {\r\n        return repayBorrowInternal(repayAmount);\r\n    }\r\n\r\n    \r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\r\n        return repayBorrowBehalfInternal(borrower, repayAmount);\r\n    }\r\n\r\n    \r\n    function liquidateBorrow(address borrower, uint repayAmount, CToken cTokenCollateral) external returns (uint) {\r\n        return liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\r\n    }\r\n\r\n    \r\n\r\n    \r\n    function getCashPrior() internal view returns (uint) {\r\n        EIP20Interface token = EIP20Interface(underlying);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    \r\n    function checkTransferIn(address from, uint amount) internal view returns (Error) {\r\n        EIP20Interface token = EIP20Interface(underlying);\r\n\r\n        if (token.allowance(from, address(this)) < amount) {\r\n            return Error.TOKEN_INSUFFICIENT_ALLOWANCE;\r\n        }\r\n\r\n        if (token.balanceOf(from) < amount) {\r\n            return Error.TOKEN_INSUFFICIENT_BALANCE;\r\n        }\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    \r\n    function doTransferIn(address from, uint amount) internal returns (Error) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        bool result;\r\n\r\n        token.transferFrom(from, address(this), amount);\r\n\r\n        \r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      \r\n                    result := not(0)          \r\n                }\r\n                case 32 {                     \r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)        \r\n                }\r\n                default {                     \r\n                    revert(0, 0)\r\n                }\r\n        }\r\n\r\n        if (!result) {\r\n            return Error.TOKEN_TRANSFER_IN_FAILED;\r\n        }\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    \r\n    function doTransferOut(address payable to, uint amount) internal returns (Error) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        bool result;\r\n\r\n        token.transfer(to, amount);\r\n\r\n        \r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      \r\n                    result := not(0)          \r\n                }\r\n                case 32 {                     \r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)        \r\n                }\r\n                default {                     \r\n                    revert(0, 0)\r\n                }\r\n        }\r\n\r\n        if (!result) {\r\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\r\n        }\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n}\r\n\r\ncontract CEther is CToken {\r\n    \r\n    constructor(ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_) public\r\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, admin_) {}\r\n\r\n    \r\n\r\n    \r\n    function mint() external payable {\r\n        requireNoError(mintInternal(msg.value), \"mint failed\");\r\n    }\r\n\r\n    \r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        return redeemInternal(redeemTokens);\r\n    }\r\n\r\n    \r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        return redeemUnderlyingInternal(redeemAmount);\r\n    }\r\n\r\n    \r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        return borrowInternal(borrowAmount);\r\n    }\r\n\r\n    \r\n    function repayBorrow() external payable {\r\n        requireNoError(repayBorrowInternal(msg.value), \"repayBorrow failed\");\r\n    }\r\n\r\n    \r\n    function repayBorrowBehalf(address borrower) external payable {\r\n        requireNoError(repayBorrowBehalfInternal(borrower, msg.value), \"repayBorrowBehalf failed\");\r\n    }\r\n\r\n    \r\n    function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {\r\n        requireNoError(liquidateBorrowInternal(borrower, msg.value, cTokenCollateral), \"liquidateBorrow failed\");\r\n    }\r\n\r\n    \r\n    function () external payable {\r\n        requireNoError(mintInternal(msg.value), \"mint failed\");\r\n    }\r\n\r\n    \r\n\r\n    \r\n    function getCashPrior() internal view returns (uint) {\r\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\r\n        require(err == MathError.NO_ERROR);\r\n        return startingBalance;\r\n    }\r\n\r\n    \r\n    function checkTransferIn(address from, uint amount) internal view returns (Error) {\r\n        \r\n        require(msg.sender == from, \"sender mismatch\");\r\n        require(msg.value == amount, \"value mismatch\");\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    \r\n    function doTransferIn(address from, uint amount) internal returns (Error) {\r\n        \r\n        require(msg.sender == from, \"sender mismatch\");\r\n        require(msg.value == amount, \"value mismatch\");\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    function doTransferOut(address payable to, uint amount) internal returns (Error) {\r\n        \r\n        to.transfer(amount);\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    function requireNoError(uint errCode, string memory message) internal pure {\r\n        if (errCode == uint(Error.NO_ERROR)) {\r\n            return;\r\n        }\r\n\r\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\r\n        uint i;\r\n\r\n        for (i = 0; i < bytes(message).length; i++) {\r\n            fullMessage[i] = bytes(message)[i];\r\n        }\r\n\r\n        fullMessage[i+0] = byte(uint8(32));\r\n        fullMessage[i+1] = byte(uint8(40));\r\n        fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));\r\n        fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));\r\n        fullMessage[i+4] = byte(uint8(41));\r\n\r\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\r\n    }\r\n}\r\n\r\nlibrary ECDSA {\r\n    \r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        \r\n        if (signature.length != 65) {\r\n            revert(\"signature's length is invalid\");\r\n        }\r\n\r\n        \r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        \r\n        \r\n        \r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            revert(\"signature's s is in the wrong range\");\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            revert(\"signature's v is in the wrong range\");\r\n        }\r\n\r\n        \r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    \r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        \r\n        \r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\ncontract CompoundAdapter is CanReclaimTokens {\r\n    using SafeERC20 for ERC20;\r\n    ILiquidityPool liquidityPool;\r\n    IRebalancer rebalancer;\r\n\r\n    CEther cEther;\r\n    mapping (address=>CErc20) cTokens;\r\n\r\n    uint256 loansNonce;\r\n    mapping (bytes32=>bool) loans;\r\n\r\n    function () external payable {\r\n    }\r\n\r\n    constructor(ILiquidityPool _liquidityPool, IRebalancer _rebalancer) public {\r\n        liquidityPool = _liquidityPool;\r\n        rebalancer = _rebalancer;\r\n    }\r\n\r\n    function updateLiquidityPool(ILiquidityPool _newLiquidityPool) external onlyOwner {\r\n        liquidityPool = _newLiquidityPool;\r\n    }\r\n\r\n    function updateRebalancer(IRebalancer _newRebalancer) external onlyOwner {\r\n        rebalancer = _newRebalancer;\r\n    }\r\n\r\n    function register(address _underlying, address _cToken) external onlyOwner {\r\n        require(_underlying != address(0x0), \"Underlying asset cannot be 0x0\");\r\n        if (liquidityPool.isEther(_underlying)) {\r\n            cEther = CEther(uint256(_cToken));\r\n        } else {\r\n            cTokens[_underlying] = CErc20(_cToken);\r\n        }\r\n    }\r\n\r\n    function liquidate(address _borrower, CToken _collateralToken, address _debtToken, uint256 _debtAmount) external {\r\n        _liquidate(_borrower, _collateralToken, _debtToken, _debtAmount);\r\n        loans[keccak256(abi.encodePacked(_borrower, address(_collateralToken), _debtToken, _debtAmount, loansNonce))] = true;\r\n        loansNonce++;\r\n    }\r\n\r\n    function rebalance(address _borrower, CToken _collateralToken, address _debtToken, uint256 _debtAmount, uint256 _loansNonce) internal {\r\n        bytes32 loanId = keccak256(abi.encodePacked(_borrower, address(_collateralToken), _debtToken, _debtAmount, _loansNonce));\r\n        require(loans[loanId], \"Loan does not exist\");\r\n        delete(loans[loanId]);\r\n        uint256 cAmount = _collateralToken.balanceOf(address(this));\r\n        _collateralToken.approve(address(rebalancer), cAmount);\r\n        rebalancer.giveUnbalancedPosition(_debtToken, _debtAmount, address(_collateralToken), cAmount);\r\n    }\r\n\r\n    function _liquidate(address _borrower, CToken cToken, address _debtToken, uint256 _debtAmount) internal {\r\n        liquidityPool.take(_debtToken, _debtAmount);\r\n        if (liquidityPool.isEther(_debtToken)) {\r\n           cEther.liquidateBorrow.value(_debtAmount)(_borrower, cToken);\r\n        } else {\r\n            CErc20 cerc20 = cTokens[_debtToken];\r\n            ERC20(_debtToken).safeTransferFrom(address(liquidityPool), address(this), _debtAmount);\r\n            ERC20(_debtToken).safeApprove(address(cerc20), _debtAmount);\r\n            require(cerc20.liquidateBorrow(_borrower, _debtAmount, cToken) == 0, \"liquidation failed\");\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_underlying\",\"type\":\"address\"},{\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_borrower\",\"type\":\"address\"},{\"name\":\"_collateralToken\",\"type\":\"address\"},{\"name\":\"_debtToken\",\"type\":\"address\"},{\"name\":\"_debtAmount\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRebalancer\",\"type\":\"address\"}],\"name\":\"updateRebalancer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLiquidityPool\",\"type\":\"address\"}],\"name\":\"updateLiquidityPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"blacklistRecoverableToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_liquidityPool\",\"type\":\"address\"},{\"name\":\"_rebalancer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CompoundAdapter","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005e3c8b0f7229f1f1873267b6811465fef73d53ca0000000000000000000000005e976b687d902f13f6af33a5cb097440ddcb149e","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://dd7d77ba27e01c5ccece93b91260cde8fc773cf3019be78b353d827547a0e70d"}]}