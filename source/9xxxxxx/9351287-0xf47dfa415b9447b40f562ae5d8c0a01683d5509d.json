{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\n/// @title An economic simulation and game\r\n/// @author TheTokenPhysicist\r\n/// @dev NatSpec comments provide broader information. Detailed comments available in source code\r\ncontract SHILLcoin\r\n//start contract\r\n{\r\n//NOTE: in general modifiers have been defined/placed just before the functions that use them\r\n\r\n//STATE VARIABLES\r\n//INTERNAL CONSTANTS\r\n//internal constant used for math\r\nuint256 constant internal MAGNITUDE = 2**64;\r\nint256 constant internal IMAGNITUDE = 2**64;\r\n\r\n//NOTE that 1ETHER = 1e18 wei\r\nuint256 constant internal FEE_CYCLE_SIZE = 25e16 wei;\r\n//(6553/65536 = 10.00%)\r\nuint16 constant internal MAX_VARIANCE = 6553;\r\n//(1638/65536 = 2.50%)\r\nuint constant internal BASE_RATE = 1638;\r\n//max rate = base_rate + max_variance (8191/65536 = 12.50%)\r\n//limits for setup phase\r\nuint256 constant internal SETUP_LIMIT = 6e18;\r\nuint256 constant internal CONTRIBUTOR_PURCHASE_MAX = 25e17;\r\n//parameters for token bonding curve\r\n//set to 0.000001=10^-6 (ETH/token), i.e. 10^6 tokens/ETH (ignoring rise due to price increment)\r\nuint256 constant internal TOKEN_PRICE_INITIAL = 0.000001 ether;\r\n//set to 0.000000001=10^-9 (ETH/token), representing an increase of 10^-9 ETH in the price of each token per outstanding token\r\nuint256 constant internal TOKEN_PRICE_INCREMENT = 0.000000001 ether;\r\n\r\n//PUBLIC CONSTANTS\r\n//ERC 20 standard for the number of decimals the token uses\r\nuint8 constant public decimals = 18;\r\n\r\n//PUBLIC VARIABLES\r\nstring public name = \"SHILLcoin\";\r\nstring public symbol = \"SHILL\";\r\n//tracks total ether stored in unwithdrawn dividends\r\nuint256 public _slushFundBalance = 0;\r\n//initializes fee rate at BASE_RATE\r\nuint16 public _feeRate = uint16(BASE_RATE);\r\n//tracks total accumulated rewards per token\r\nuint256 public _rewardsPerTokenAllTime = 0;\r\n//tracks total existing number of tokens. named to match ERC-20 standard (see https://eips.ethereum.org/EIPS/eip-20)\r\nuint256 public totalSupply = 0;\r\n//partner contract address will be set IRREVERSIBLY by administrator in setup phase\r\n//partner address initially set to administrator address to avoid divide by zero error on first token purchase\r\naddress payable public partnerAddress_ = msg.sender;\r\nbool public partnerSet = false;\r\n// when setupPhase is set to true, only contributors can purchase tokens - used during contract setup\r\n//this is automatically switched off (irreversibly) after setupLimit is met, or can be switched off manually by admin with endSetupPhase()\r\nbool public setupPhase = true;\r\n\r\n\r\n//MAPPINGS\r\n// track token balances\r\nmapping(address => uint256) public tokenBalanceLedger_;\r\n// track payouts\r\nmapping(address => int256) public payoutsToLedger_;\r\n//track approved addresses to allow transferFrom functionality - stored as allowance[from][spender] = allowance that [spender] is approved to send from [from]\r\n//named to match ERC-20 standard\r\nmapping(address => mapping(address => uint256)) allowance;\r\n//track ether spending in setup phase\r\nmapping(address => uint256) internal accumulatedContributorSpends_;\r\n//tracks administrator(s) & contributors\r\nmapping(address => bool) public administrator_;\r\nmapping(address => bool) public contributors_;\r\n\r\n\r\n//EVENTS\r\n//when a transfer is completed\r\n//also emitted for token mint/burn events, in which cases, respectively, from/to is set to the 0 address (matches ERC20 standard)\r\nevent Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 tokensTransferred\r\n);\r\n// ERC20 compliance\r\n//when the tokenOwner address adjusts the allowance that the approvedAddress is allowed to transfer from the holdings of tokenOwner\r\n//relevant to transferFrom functionality\r\nevent Approval(\r\n    address indexed tokenOwner,\r\n    address indexed approvedAddress,\r\n    uint256 newAllowance\r\n);\r\n//when a player spends their rewards to purchase more tokens\r\nevent DoubleDown(\r\n    address indexed playerAddress,\r\n    uint256 etherValue, //etherValue of the spent rewards\r\n    uint256 tokensMinted\r\n);\r\n//when a player withdraws their rewards as ether\r\nevent CashOut(\r\n    address indexed playerAddress,\r\n    uint256 etherValue\r\n);\r\n//event announced when the fee rate is recalculated (occurs whenever slush fund balance changes)\r\n//NOTE: fee rate is represented as 16-bit int; calculations of the fee itself use value*feeRate/65536 (65536 = 2^16)\r\nevent AnnounceFeeRate(\r\n    uint16 newFeeRate\r\n);\r\n\r\n\r\n//CONSTRUCTOR/INITIALIZATION\r\nconstructor()\r\n    public\r\n{\r\n    //sets up admin(s) and contributors\r\n    administrator_[msg.sender] = true; //TheTokenPhysicist -- Mastermind\r\n    contributors_[msg.sender] = true;\r\n    contributors_[0xF7388B6a9c65BCEECfaaB0beD560dc229A899848] = true; //MaddEconomist -- Advisor\r\n    contributors_[0x8DA88ecAc7C71EDc34C742232C8D1fdc61C5f8bE] = true; //swimmingly -- Tester & design review\r\n    contributors_[0x6Fa716966c81e8f907629f90352452d8F2dD0dF4] = true; //cryptoGENIUS17 -- Design consulting & editing\r\n}\r\n\r\n\r\n//FALLBACK\r\n/// @notice fallback function. ensures that you still receive tokens if you just send money directly to the contract\r\n/// @dev fallback function. buys tokens with all sent ether *unless* ether is sent from partner address; if it is, then distributes ether as rewards to token holders\r\nfunction()\r\n    external\r\n    payable\r\n{\r\n    if ( msg.sender == partnerAddress_ ) {\r\n        //convert money sent from partner contract into rewards for all token holders\r\n        makeItRain();\r\n    } else {\r\n       purchaseTokens( msg.sender, msg.value ); \r\n    }\r\n}\r\n\r\n\r\n//EXTERNAL FUNCTIONS\r\n/// @notice buys tokens with all sent funds. tokens are automatically credited to sender address\r\n/// @dev emits event Transfer(address(0), playerAddress, newTokens) since function mint is called internally\r\nfunction buyTokens()\r\n    external\r\n    payable\r\n{\r\n    purchaseTokens( msg.sender, msg.value );\r\n}\r\n\r\n/// @notice uses all of message sender's accumulated rewards to buy more tokens for the sender\r\n/// @dev emits event DoubleDown(msg.sender, rewards , newTokens) and event Transfer(address(0), playerAddress, newTokens) since function mint is called internally\r\nfunction doubleDown()\r\n    external\r\n{\r\n    //pull current ether value of sender's rewards\r\n    uint256 etherValue = rewardsOf( msg.sender );\r\n    //update rewards tracker to reflect payout. performed before rewards are sent to prevent re-entrancy\r\n    updateSpentRewards( msg.sender , etherValue);\r\n    //update slush fund and fee rate\r\n    _slushFundBalance -= etherValue;\r\n    require( calcFeeRate(), \"error in calling calcFeeRate\" );\r\n    // use rewards to buy new tokens\r\n    uint256 newTokens = purchaseTokens(msg.sender , etherValue);\r\n    //NOTE: purchaseTokens already emits an event, but this is useful for tracking specifically DoubleDown events\r\n    emit DoubleDown(msg.sender, etherValue , newTokens);\r\n}\r\n\r\n/// @notice converts all of message senders's accumulated rewards into cold, hard ether\r\n/// @dev emits event CashOut( msg.sender, etherValue )\r\n/// @return etherValue sent to account holder\r\nfunction cashOut()\r\n    external\r\n    returns (uint256 etherValue)\r\n{\r\n    //pull current ether value of sender's rewards\r\n    etherValue = rewardsOf( msg.sender );\r\n    //update rewards tracker to reflect payout. performed before rewards are sent to prevent re-entrancy\r\n    updateSpentRewards( msg.sender , etherValue);\r\n    //update slush fund and fee rate\r\n    _slushFundBalance -= etherValue;\r\n    require( calcFeeRate(), \"error in calling calcFeeRate\" );\r\n    //transfer rewards to sender\r\n    msg.sender.transfer( etherValue );\r\n    //NOTE: purchaseTokens already emits an event, but this is useful for tracking specifically CashOut events\r\n    emit CashOut( msg.sender, etherValue );\r\n}\r\n\r\n/// @notice sells all of sender's tokens\r\n/// @dev emits event Transfer(playerAddress, address(0), amountTokens) since function burn is called internally\r\nfunction sellAll()\r\n    external\r\n    returns (bool)\r\n{\r\n    uint256 tokens = tokenBalanceLedger_[msg.sender];\r\n    if ( tokens > 0 ) {\r\n        sell(tokens);\r\n    }\r\n    return true;\r\n}\r\n\r\n/// @notice sells desired number of message sender's tokens\r\n/// @dev emits event Transfer(playerAddress, address(0), amountTokens) since function burn is called internally\r\n/// @param amountTokens The number of tokens the sender wants to sell\r\nfunction sellTokens( uint256 amountTokens )\r\n    external\r\n    returns (bool)\r\n{\r\n    require( amountTokens <= tokenBalanceLedger_[msg.sender], \"insufficient funds available\" );\r\n    sell(amountTokens);\r\n    return true;\r\n}\r\n\r\n/// @notice transfers tokens from sender to another address. Pays fee at same rate as buy/sell\r\n/// @dev emits event Transfer( msg.sender, toAddress, tokensAfterFee )\r\n/// @param toAddress Destination for transferred tokens\r\n/// @param amountTokens The number of tokens the sender wants to transfer\r\nfunction transfer( address toAddress, uint256 amountTokens )\r\n    external\r\n    returns( bool )\r\n{\r\n    //make sure message sender has the requested tokens (transfers also disabled during SetupPhase)\r\n    require( ( amountTokens <= tokenBalanceLedger_[ msg.sender ] && !setupPhase ), \"transfer not allowed\" );\r\n    //make the transfer internally\r\n    require( transferInternal( msg.sender, toAddress, amountTokens ), \"error in internal token transfer\" );\r\n    //ERC20 compliance\r\n    return true;\r\n}\r\n\r\n/// @notice sets approved amount of tokens that an external address can transfer on behalf of the user\r\n/// @dev emits event Approval(msg.sender, approvedAddress, amountTokens)\r\n/// @param approvedAddress External address to give approval to (i.e. to give control to transfer sender's tokens)\r\n/// @param amountTokens The number of tokens the sender wants to approve the external address to transfer for them\r\nfunction approve( address approvedAddress, uint256 amountTokens)\r\n    external\r\n    returns (bool)\r\n{\r\n    allowance[msg.sender][approvedAddress] = amountTokens;\r\n    emit Approval(msg.sender, approvedAddress, amountTokens);\r\n    return true;\r\n}\r\n\r\n/// @notice increases approved amount of tokens that an external address can transfer on behalf of the user\r\n/// @dev emits event Approval(msg.sender, approvedAddress, newAllowance)\r\n/// @param approvedAddress External address to give approval to (i.e. to give control to transfer sender's tokens)\r\n/// @param amountTokens The number of tokens by which the sender wants to increase the external address' allowance\r\nfunction increaseAllowance( address approvedAddress, uint256 amountTokens)\r\n    external\r\n    returns (bool)\r\n{\r\n    uint256 pastAllowance = allowance[msg.sender][approvedAddress];\r\n    uint256 newAllowance = SafeMath.add( pastAllowance , amountTokens );\r\n    allowance[msg.sender][approvedAddress] = newAllowance;\r\n    emit Approval(msg.sender, approvedAddress, newAllowance);\r\n    return true;\r\n}\r\n\r\n/// @notice decreases approved amount of tokens that an external address can transfer on behalf of the user\r\n/// @dev emits event Approval(msg.sender, approvedAddress, newAllowance)\r\n/// @param approvedAddress External address to give approval to (i.e. to give control to transfer sender's tokens)\r\n/// @param amountTokens The number of tokens by which the sender wants to decrease the external address' allowance\r\nfunction decreaseAllowance( address approvedAddress, uint256 amountTokens)\r\n    external\r\n    returns (bool)\r\n{\r\n    uint256 pastAllowance = allowance[msg.sender][approvedAddress];\r\n    uint256 newAllowance = SafeMath.sub( pastAllowance , amountTokens );\r\n    allowance[msg.sender][approvedAddress] = newAllowance;\r\n    emit Approval(msg.sender, approvedAddress, newAllowance);\r\n    return true;\r\n}\r\n\r\nmodifier checkTransferApproved(address fromAddress, uint256 amountTokens){\r\n    require( allowance[fromAddress][msg.sender] <= amountTokens, \"transfer not authorized (allowance insufficient)\" );\r\n    _;\r\n} \r\n/// @notice transfers tokens from one address to another. Pays fee at same rate as buy/sell\r\n/// @dev emits event Transfer( fromAddress, toAddress, tokensAfterFee )\r\n/// @param fromAddress Account that sender wishes to transfer tokens from\r\n/// @param toAddress Destination for transferred tokens\r\n/// @param amountTokens The number of tokens the sender wants to transfer\r\nfunction transferFrom(address payable fromAddress, address payable toAddress, uint256 amountTokens)\r\n    checkTransferApproved(fromAddress , amountTokens)\r\n    external\r\n    returns (bool)\r\n{\r\n    // make sure sending address has requested tokens (transfers also disabled during SetupPhase)\r\n    require( ( amountTokens <= tokenBalanceLedger_[ fromAddress ] && !setupPhase ), \"transfer not allowed - insufficient funds available\" );\r\n    //update allowance (reduce it by tokens to be sent)\r\n    uint256 pastAllowance = allowance[fromAddress][msg.sender];\r\n    uint256 newAllowance = SafeMath.sub( pastAllowance , amountTokens );\r\n    allowance[fromAddress][msg.sender] = newAllowance;\r\n    //make the transfer internally\r\n    require( transferInternal( fromAddress, toAddress, amountTokens ), \"error in internal token transfer\" ); \r\n    // ERC20 compliance\r\n    return true;\r\n}\r\n\r\n/// @notice called by users to exchange between token types. Pays fee at half the rate of buy/sell\r\n/// @param amountTokens the number of tokens the user wishes to exchange\r\nfunction exchangeTokens( uint256 amountTokens )\r\n    external\r\n    returns(bool)\r\n{\r\n    // make sure sending address has requested tokens (transfers also disabled during SetupPhase)\r\n    require( ( amountTokens <= tokenBalanceLedger_[ msg.sender ] && !setupPhase ), \"transfer not allowed - insufficient funds available\" );\r\n    //mirrors valueAfterFee function, but with fee halved (half fee is also charged by the other contract)\r\n    uint256 amountEther = tokensToEther( amountTokens );\r\n    uint256 fee = SafeMath.div( ( amountEther * _feeRate / 2 ) , 65536 ); //fee\r\n    uint256 valueAfterFee = SafeMath.sub( amountEther , fee ); //value after fee\r\n    //destroys sold tokens (removes sold tokens from total token supply) and subtracts them from player balance\r\n    //also updates reward tracker (payoutsToLedger_) for player address\r\n    burn(msg.sender, amountTokens);\r\n    //mirrors makeItRain function (distributes fee to token holders)\r\n    uint256 addedRewards = SafeMath.mul( fee , MAGNITUDE );\r\n    uint256 additionalRewardsPerToken = SafeMath.div( addedRewards , totalSupply );\r\n    _rewardsPerTokenAllTime = SafeMath.add( _rewardsPerTokenAllTime , additionalRewardsPerToken );\r\n    //updates balance in slush fund and calculates new fee rate\r\n    require( updateSlushFund( fee ), \"error in calling updateSlushFund\" );\r\n    //sends remainder to partner contract, to be used to buy tokens from that contract\r\n    address payable buddy = partnerAddress_;\r\n    ( bool success, bytes memory returnData ) = buddy.call.value( valueAfterFee )(abi.encodeWithSignature(\"incomingExchangeRequest(address)\", msg.sender));\r\n    //no need to check return data since partner is a trusted entity\r\n    require( success, \"failed to send funds to partner contract (not enough gas provided?)\" );\r\n    return true;    \r\n}\r\n\r\n/// @notice handles exchange. only callable by partner contract.\r\n/// @param playerAddress passed on from call to exchangeTokens function. used to track player address\r\nfunction incomingExchangeRequest( address playerAddress )\r\n    external\r\n    payable\r\n    returns(bool)\r\n{\r\n    require( (msg.sender == partnerAddress_), \"this function can only be called by the partner contract\" );\r\n    //mirrors valueAfterFee function, but with fee halved (half fee is also charged by the other contract)\r\n    uint256 amountEther = msg.value;\r\n    uint256 fee = SafeMath.div( ( amountEther * _feeRate / 2 ) , 65536 ); //fee\r\n    uint256 valueAfterFee = SafeMath.sub( amountEther , fee ); //value after fee\r\n    //mirrors makeItRain function (distributes fee to token holders)\r\n    uint256 addedRewards = SafeMath.mul( fee , MAGNITUDE );\r\n    uint256 additionalRewardsPerToken = SafeMath.div( addedRewards , totalSupply );\r\n    _rewardsPerTokenAllTime = SafeMath.add( _rewardsPerTokenAllTime , additionalRewardsPerToken );\r\n    //updates balance in slush fund and calculates new fee rate\r\n    require( updateSlushFund( fee ), \"error in calling updateSlushFund\" );\r\n    //mirrors purchaseTokens function\r\n    uint256 amountTokens = etherToTokens( valueAfterFee );\r\n    //adds new tokens to total token supply and gives them to the player\r\n    //also updates reward tracker (payoutsToLedger_) for player address\r\n    mint( playerAddress, amountTokens );\r\n    return true;\r\n}\r\n\r\n\r\n//ADMIN ONLY FUNCTIONS (ALL EXTERNAL AS WELL)\r\n//defines modifier for functions that only contract admin(s) can use\r\nmodifier onlyAdministrator() {  \r\n    require( administrator_[ msg.sender ] == true, \"function can only be called by contract admin\" );\r\n    _;\r\n}\r\n/// @notice admin only function. irreversibly sets address of partner contract\r\n/// @param partner Address of partner contract\r\nfunction setPartner( address payable partner)\r\n    onlyAdministrator()\r\n    public\r\n{\r\n    if ( partnerSet == false ) {\r\n        partnerAddress_ = partner;\r\n        partnerSet = true;\r\n    }\r\n}\r\n\r\n/// @notice admin only function. irreversibly ends SetupPhase\r\n/// @dev SetupPhase also ends automatically if contract holds more than (SETUP_LIMIT) in ether. see modifier purchaseAllowed(uint256 amountEther)\r\nfunction endSetupPhase()\r\n    onlyAdministrator()\r\n    public\r\n{\r\n    setupPhase = false;\r\n}\r\n\r\n/// @notice admin only function. simple name change\r\n/// @param newName Desired new name for contract\r\nfunction setName( string memory newName )\r\n    onlyAdministrator()\r\n    public\r\n{\r\n    name = newName;\r\n}\r\n\r\n/// @notice admin only function. simple symbol change\r\n/// @param newSymbol Desired new symbol for contract\r\nfunction setSymbol( string memory newSymbol )\r\n    onlyAdministrator()\r\n    public\r\n{\r\n    symbol = newSymbol;\r\n}\r\n\r\n\r\n//HELPER FUNCTIONS (ALL EXTERNAL AS WELL) -- used to pull information\r\n/// @notice returns current sell price for one token\r\nfunction sellPrice() \r\n    external\r\n    view\r\n    returns(uint256)\r\n{\r\n    // avoid dividing by zero\r\n    require(totalSupply != 0, \"function called too early (supply is zero)\");\r\n    //represents selling one \"full token\" since the token has 18 decimals\r\n    uint256 etherValue = tokensToEther( 1e18 );\r\n    uint[2] memory feeAndValue = valueAfterFee( etherValue );\r\n    return feeAndValue[1];\r\n}\r\n\r\n/// @notice calculates current buy price for one token\r\nfunction currentBuyPrice() \r\n    external\r\n    view\r\n    returns(uint256)\r\n{\r\n    // avoid dividing by zero\r\n    require(totalSupply != 0, \"function called too early (supply is zero)\");\r\n    //represents buying one \"full token\" since the token has 18 decimals\r\n    uint256 etherValue = tokensToEther( 1e18 );\r\n    uint[2] memory feeAndValue = valueAfterFee( etherValue );\r\n    //NOTE: this is not strictly correct, but gets very close to real purchase value\r\n    uint256 totalCost = etherValue + feeAndValue[0];\r\n    return totalCost;\r\n}\r\n\r\n/// @notice calculates number of tokens that can be bought at current price and fee rate for input amount of ether\r\n/// @param etherValue Desired amount of ether from which to calculate equivalent number of tokens\r\n/// @return amountTokens Expected return of tokens for spending etherValue\r\nfunction calculateExpectedTokens(uint256 etherValue) \r\n    external\r\n    view\r\n    returns(uint256)\r\n{\r\n    uint256 etherAfterFee = valueAfterFee( etherValue )[1];\r\n    uint256 amountTokens = etherToTokens( etherAfterFee );\r\n    return amountTokens;\r\n}\r\n\r\n/// @notice calculates amount of ether (as wei) received if input number of tokens is sold at current price and fee rate\r\n/// @param tokensToSell Desired number of tokens (as an integer) from which to calculate equivalent value of ether\r\n/// @return etherAfterFee Amount of ether that would be received for selling tokens\r\nfunction calculateExpectedWei(uint256 tokensToSell) \r\n    external\r\n    view\r\n    returns(uint256)\r\n{\r\n    require( tokensToSell <= totalSupply, \"unable to calculate for amount of tokens greater than current supply\" );\r\n    //finds ether value of tokens before fee\r\n    uint256 etherValue = tokensToEther( tokensToSell );\r\n    //calculates ether after fee\r\n    uint256 etherAfterFee = valueAfterFee( etherValue )[1];\r\n    return etherAfterFee;\r\n}\r\n\r\n/// @notice returns total ether balance of contract\r\nfunction totalEtherBalance()\r\n    external\r\n    view\r\n    returns(uint)\r\n{\r\n    return address(this).balance;\r\n}\r\n\r\n/// @notice returns number of tokens owned by message sender\r\nfunction myTokens()\r\n    external\r\n    view\r\n    returns(uint256)\r\n{\r\n    return tokenBalanceLedger_[msg.sender];\r\n}\r\n\r\n/// @notice returns reward balance of message sender\r\nfunction myRewards() \r\n    external \r\n    view \r\n    returns(uint256)\r\n{\r\n    return rewardsOf( msg.sender );\r\n}\r\n\r\n/// @notice returns token balance of desired address\r\n/// @dev conforms to ERC-20 standard\r\n/// @param playerAddress Address which sender wants to know the balance of\r\n/// @return balance Current raw token balance of playerAddress\r\nfunction balanceOf( address playerAddress )\r\n    external\r\n    view\r\n    returns(uint256 balance)\r\n{\r\n    return (tokenBalanceLedger_[playerAddress]);\r\n}\r\n\r\n\r\n//PUBLIC FUNCTIONS\r\n/// @notice function for donating to slush fund. adjusts current fee rate as fast as possible but does not give the message sender any tokens\r\n/// @dev invoked internally when partner contract sends funds to this contract (see fallback function)\r\nfunction makeItRain()\r\n    public\r\n    payable\r\n    returns(bool)\r\n{\r\n    //avoid dividing by zero\r\n    require(totalSupply != 0, \"makeItRain function called too early (supply is zero)\");\r\n    uint256 amountEther = msg.value;\r\n    uint256 addedRewards = SafeMath.mul( amountEther , MAGNITUDE );\r\n    uint256 additionalRewardsPerToken = SafeMath.div( addedRewards , totalSupply );\r\n    _rewardsPerTokenAllTime = SafeMath.add( _rewardsPerTokenAllTime , additionalRewardsPerToken );\r\n    //updates balance in slush fund and calculates new fee rate\r\n    require( updateSlushFund( amountEther ), \"error in calling updateSlushFund\" );\r\n    return true;\r\n}\r\n\r\n/// @notice returns reward balance of desired address\r\n/// @dev invoked internally in cashOut and doubleDown functions\r\n/// @param playerAddress Address which sender wants to know the rewards balance of\r\n/// @return playerRewards Current ether value of unspent rewards of playerAddress\r\nfunction rewardsOf( address playerAddress )\r\n    public\r\n    view\r\n    returns(uint256 playerRewards)\r\n{\r\n    playerRewards = (uint256) ( ( (int256)( _rewardsPerTokenAllTime * tokenBalanceLedger_[ playerAddress ] ) - payoutsToLedger_[ playerAddress ] ) / IMAGNITUDE );\r\n    return playerRewards;\r\n}\r\n\r\n\r\n//INTERNAL FUNCTIONS\r\n//recalculates fee rate given current contract state\r\nfunction calcFeeRate()\r\n    internal\r\n    returns(bool)\r\n{\r\n    uint excessSlush = ( (_slushFundBalance % FEE_CYCLE_SIZE) * MAX_VARIANCE );\r\n    uint16 cycleLocation = uint16( excessSlush / FEE_CYCLE_SIZE );\r\n    uint16 newFeeRate = uint16( BASE_RATE + cycleLocation );\r\n    //copy local variable to state variable\r\n    _feeRate = newFeeRate;\r\n    //anounce new rate\r\n    emit AnnounceFeeRate( newFeeRate );\r\n    return(true);\r\n}\r\n\r\n//updates balance in slush fund and calculates new fee rate\r\nfunction updateSlushFund( uint256 amountEther )\r\n    internal\r\n    returns(bool)\r\n{\r\n    _slushFundBalance += amountEther;\r\n    require( calcFeeRate(), \"error in calling calcFeeRate\" );\r\n    return true;\r\n}\r\n\r\n//update rewards tracker when a user withdraws their rewards\r\nfunction updateSpentRewards( address playerAddress, uint256 etherValue )\r\n    internal\r\n    returns(bool)\r\n{\r\n    int256 updatedPayouts = payoutsToLedger_[playerAddress] + int256 ( SafeMath.mul( etherValue, MAGNITUDE ) );\r\n    require( (updatedPayouts >= payoutsToLedger_[playerAddress]), \"ERROR: integer overflow in updateSpentRewards function\" );\r\n    payoutsToLedger_[playerAddress] = updatedPayouts;\r\n    return true;\r\n}\r\n\r\n//updates rewards tracker. makes sure that player does not receive any rewards accumulated before they purchased/received these tokens\r\nfunction updateRewardsOnPurchase( address playerAddress, uint256 amountTokens )\r\n    internal\r\n    returns(bool)\r\n{\r\n    int256 updatedPayouts = payoutsToLedger_[playerAddress] + int256 ( SafeMath.mul( _rewardsPerTokenAllTime, amountTokens ) );\r\n    require( (updatedPayouts >= payoutsToLedger_[playerAddress]), \"ERROR: integer overflow in updateRewardsOnPurchase function\" );\r\n    payoutsToLedger_[playerAddress] = updatedPayouts;    \r\n    return true;\r\n}\r\n\r\n//adds new tokens to total token supply and gives them to the player\r\nfunction mint(address playerAddress, uint256 amountTokens)\r\n    internal\r\n{\r\n    require( playerAddress != address(0), \"cannot mint tokens for zero address\" );\r\n    totalSupply = SafeMath.add( totalSupply, amountTokens );\r\n    //updates rewards tracker. makes sure that player does not receive any rewards accumulated before they purchased these tokens\r\n    updateRewardsOnPurchase( playerAddress, amountTokens );\r\n    //give tokens to player. performed last to prevent re-entrancy attacks\r\n    tokenBalanceLedger_[playerAddress] = SafeMath.add( tokenBalanceLedger_[playerAddress] , amountTokens );\r\n    //event conforms to ERC-20 standard\r\n    emit Transfer(address(0), playerAddress, amountTokens);\r\n}\r\n\r\n//Modifier that limits buying while contract setup occurs\r\nmodifier purchaseAllowed(uint256 amountEther){\r\n    //check if still in setup phase\r\n    if ( setupPhase ) {\r\n        //check that sender is in contributor list\r\n        require( contributors_[ msg.sender ] == true, \"purchases currently limited only to contributors\" );\r\n        //check that sender hasn't deposited more ether than allowed\r\n        uint256 contributorSpent = SafeMath.add( accumulatedContributorSpends_[ msg.sender ] , amountEther );\r\n        require( contributorSpent <= CONTRIBUTOR_PURCHASE_MAX, \"attempted purchase would exceed limit placed upon contributors\" );\r\n        //before SETUP_LIMIT is met, track contributor spends\r\n        if ( ( address(this).balance + amountEther ) <= SETUP_LIMIT ) {\r\n            //update the amount spent by address\r\n            accumulatedContributorSpends_[ msg.sender ] = contributorSpent;\r\n        } else {\r\n        //if conditions have been met to end setup phase, then exit it automatically. admin also has ability to end setup phase manually\r\n        setupPhase = false;\r\n        }\r\n    }\r\n    _;\r\n}\r\n//gives appropriate number of tokens to purchasing address\r\nfunction purchaseTokens(address payable playerAddress, uint256 etherValue)\r\n    //checks if purchase allowed -- only relevant for limiting actions during setup phase\r\n    purchaseAllowed( etherValue )    \r\n    internal\r\n    returns( uint256 )\r\n{\r\n    //calculates fee/rewards\r\n    uint[2] memory feeAndValue = valueAfterFee( etherValue );\r\n    //calculates tokens from postFee value of input ether\r\n    uint256 amountTokens = etherToTokens( feeAndValue[1] );\r\n    //avoid overflow errors\r\n    require ( ( (amountTokens + totalSupply) > totalSupply), \"purchase would cause integer overflow\" );\r\n    // send rewards to partner contract, to be distributed to its holders\r\n    address payable buddy = partnerAddress_;\r\n    ( bool success, bytes memory returnData ) = buddy.call.value( feeAndValue[0] )(\"\");\r\n    require( success, \"failed to send funds to partner contract (not enough gas provided?)\" );\r\n    //adds new tokens to total token supply and gives them to the player\r\n    //also updates reward tracker (payoutsToLedger_) for player address\r\n    mint( playerAddress, amountTokens );\r\n    return( amountTokens );\r\n}\r\n\r\n//update rewards tracker. makes sure that player can still withdraw rewards that accumulated while they were holding their sold/transferred tokens\r\nfunction updateRewardsOnSale( address playerAddress, uint256 amountTokens )\r\n    internal\r\n    returns(bool)\r\n{\r\n    int256 updatedPayouts = payoutsToLedger_[playerAddress] - int256 ( SafeMath.mul( _rewardsPerTokenAllTime, amountTokens ) );\r\n    require( (updatedPayouts <= payoutsToLedger_[playerAddress]), \"ERROR: integer underflow in updateRewardsOnSale function\" );\r\n    payoutsToLedger_[playerAddress] = updatedPayouts;\r\n    return true;\r\n}\r\n\r\n//destroys sold tokens (removes sold tokens from total token supply) and subtracts them from player balance\r\nfunction burn(address playerAddress, uint256 amountTokens)\r\n    internal\r\n{\r\n    require( playerAddress != address(0), \"cannot burn tokens for zero address\" );\r\n    require( amountTokens <= tokenBalanceLedger_[ playerAddress ], \"insufficient funds available\" );\r\n    //subtract tokens from player balance. performed first to prevent possibility of re-entrancy attacks\r\n    tokenBalanceLedger_[playerAddress] = SafeMath.sub( tokenBalanceLedger_[playerAddress], amountTokens );\r\n    //remove tokens from total supply\r\n    totalSupply = SafeMath.sub( totalSupply, amountTokens );\r\n    //update rewards tracker. makes sure that player can still withdraw rewards that accumulated while they were holding their sold tokens\r\n    updateRewardsOnSale( playerAddress, amountTokens );\r\n    //event conforms to ERC-20 standard\r\n    emit Transfer(playerAddress, address(0), amountTokens);\r\n  }\r\n\r\n//sells desired amount of tokens for ether\r\nfunction sell(uint256 amountTokens)\r\n    internal\r\n    returns (bool)\r\n{\r\n    require( amountTokens <= tokenBalanceLedger_[ msg.sender ], \"insufficient funds available\" );\r\n    //calculates fee and net value to send to seller\r\n    uint256 etherValue = tokensToEther( amountTokens );\r\n    uint[2] memory feeAndValue = valueAfterFee( etherValue );\r\n    //destroys sold tokens (removes sold tokens from total token supply) and subtracts them from player balance\r\n    //also updates reward tracker (payoutsToLedger_) for player address\r\n    burn(msg.sender, amountTokens);\r\n    // sends rewards to partner contract, to be distributed to its holders\r\n    address payable buddy = partnerAddress_;\r\n    ( bool success, bytes memory returnData ) = buddy.call.value( feeAndValue[0] )(\"\");\r\n    require( success, \"failed to send funds to partner contract (not enough gas provided?)\" );\r\n    //sends ether to seller\r\n    //NOTE: occurs last to avoid re-entrancy attacks\r\n    msg.sender.transfer( feeAndValue[1] );\r\n    return true;\r\n}\r\n\r\n//takes in amount and returns fee to pay on it and the value after the fee\r\n//classified as view since needs to access state (to pull current fee rate) but not write to it\r\nfunction valueAfterFee( uint amount )\r\n    internal\r\n    view\r\n    returns (uint[2] memory outArray_ )\r\n{\r\n    outArray_[0] = SafeMath.div( SafeMath.mul(amount, _feeRate), 65536 ); //fee\r\n    outArray_[1] = SafeMath.sub( amount , outArray_[0] ); //value after fee\r\n    return outArray_;\r\n}\r\n\r\n//returns purchased number of tokens based on linear bonding curve with fee\r\n//it's the quadratic formula stupid!\r\nfunction etherToTokens(uint256 etherValue)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n{\r\n    uint256 tokenPriceInitial = TOKEN_PRICE_INITIAL * 1e18;\r\n    uint256 _tokensReceived = \r\n     (\r\n        (\r\n            // avoids underflow\r\n            SafeMath.sub(\r\n                ( sqrt( \r\n                        ( tokenPriceInitial**2 ) +\r\n                        ( 2 * ( TOKEN_PRICE_INCREMENT * 1e18 ) * ( etherValue * 1e18 ) ) +\r\n                        ( ( ( TOKEN_PRICE_INCREMENT ) ** 2 ) * ( totalSupply ** 2 ) ) +\r\n                        ( 2 * ( TOKEN_PRICE_INCREMENT ) * tokenPriceInitial * totalSupply )\r\n                    )\r\n                ), tokenPriceInitial )\r\n        ) / ( TOKEN_PRICE_INCREMENT )\r\n    ) - ( totalSupply );\r\n  \r\n    return _tokensReceived;\r\n}\r\n\r\n//returns sell value of tokens based on linear bonding curve with fee\r\n//~inverse of etherToTokens, but with rounding down to ensure contract is always more than solvent\r\nfunction tokensToEther(uint256 inputTokens)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n{\r\n    uint256 tokens = ( inputTokens + 1e18 );\r\n    uint256 functionTotalSupply = ( totalSupply + 1e18 );\r\n    uint256 etherReceived = (\r\n        // avoids underflow\r\n        SafeMath.sub(\r\n            ( (\r\n                ( TOKEN_PRICE_INITIAL + ( TOKEN_PRICE_INCREMENT * ( functionTotalSupply / 1e18 ) ) )\r\n               - TOKEN_PRICE_INCREMENT )\r\n            * ( tokens - 1e18 ) ),\r\n            ( TOKEN_PRICE_INCREMENT * ( ( tokens ** 2 - tokens ) / 1e18 ) ) / 2 )\r\n        / 1e18 );\r\n    return etherReceived;\r\n}\r\n\r\n//manages transfers of tokens in both transfer and transferFrom functions\r\nfunction transferInternal( address fromAddress, address toAddress, uint256 amountTokens )\r\n    internal\r\n    returns( bool )\r\n{\r\n    uint[2] memory feeAndValue = valueAfterFee( amountTokens ); //(token fee) and (amount of tokens after fee)\r\n    uint256 etherRewards = tokensToEther( feeAndValue[0] );\r\n    //destroy the tokens paid as fee\r\n    totalSupply = SafeMath.sub(totalSupply , feeAndValue[0]);\r\n    //emit event to reflect destruction of tokens (conforms to ERC-20 standard)\r\n    emit Transfer(fromAddress, address(0), feeAndValue[0]);\r\n    //remove tokens from sending address\r\n    tokenBalanceLedger_[ fromAddress ] = SafeMath.sub( tokenBalanceLedger_[ fromAddress ], amountTokens );\r\n    //makes sure that receiving address does not receive any rewards accumulated before they received these tokens\r\n    updateRewardsOnPurchase( toAddress, feeAndValue[1] );\r\n    //give tokens to receiving address\r\n    tokenBalanceLedger_[ toAddress ] = SafeMath.add( tokenBalanceLedger_[ toAddress ], feeAndValue[1] );\r\n    //makes sure that sender can still withdraw rewards that accumulated while they were holding their transferred tokens\r\n    //NOTE: uses amountTokens as input since this is what the sending address sends, while receiving address gets (feeAndValue[1]) tokens\r\n    updateRewardsOnSale( fromAddress, amountTokens );\r\n    //send rewards to partner contract, to be distributed to its holders\r\n    address payable buddy = partnerAddress_;\r\n    ( bool success, bytes memory returnData ) = buddy.call.value( etherRewards )(\"\");\r\n    require( success, \"failed to send funds to partner contract (not enough gas provided?)\" );\r\n    // emit event\r\n    emit Transfer( fromAddress, toAddress, feeAndValue[1] );\r\n    return true;\r\n}\r\n\r\n//utility for calculating (approximate) square roots. simple implementation of Babylonian method\r\n//see: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\nfunction sqrt(uint x)\r\n    internal\r\n    pure\r\n    returns (uint y)\r\n{\r\n    uint z = (x + 1) / 2;\r\n    y = x;\r\n    while (z < y)\r\n    {\r\n        y = z;\r\n        z = (x / z + z) / 2;\r\n    }\r\n}\r\n\r\n//end contract\r\n}\r\n\r\n\r\n//MATH OPERATIONS -- designed to avoid possibility of errors with built-in math functions\r\nlibrary SafeMath\r\n{\r\n\r\n//@dev Multiplies two numbers, throws on overflow.\r\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n}\r\n\r\n//@dev Integer division of two numbers, truncating the quotient.\r\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n}\r\n\r\n//@dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n}\r\n\r\n//@dev Adds two numbers, throws on overflow.\r\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n}\r\n\r\n//end library\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newFeeRate\",\"type\":\"uint16\"}],\"name\":\"AnnounceFeeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approvedAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAllowance\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"etherValue\",\"type\":\"uint256\"}],\"name\":\"CashOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"etherValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"DoubleDown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensTransferred\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"_feeRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_rewardsPerTokenAllTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_slushFundBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"administrator_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"approvedAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"etherValue\",\"type\":\"uint256\"}],\"name\":\"calculateExpectedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateExpectedWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cashOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"etherValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributors_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBuyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"approvedAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doubleDown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSetupPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"exchangeTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"incomingExchangeRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"approvedAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"makeItRain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerAddress_\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"payoutsToLedger_\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"rewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"playerRewards\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"sellTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"setPartner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"setupPhase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalanceLedger_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SHILLcoin","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://05a4502a65bb0e2a1a551683a17b6451794fc459ac3de41d759414e829c63ad5"}]}