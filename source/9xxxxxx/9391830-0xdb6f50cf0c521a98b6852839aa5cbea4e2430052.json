{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/ACE/validators/dividend/DividendABIEncoder.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * @title DividendABIEncoder\r\n * @author AZTEC\r\n * @dev Library to ABI encode the output of a dividend proof verification operation\r\n * Don't include this as an internal library. This contract uses a static memory table to cache\r\n * elliptic curve primitives and hashes.\r\n * Calling this internally from another function will lead to memory mutation and undefined behaviour.\r\n * The intended use case is to call this externally via `staticcall`.\r\n * External calls to OptimizedAZTEC can be treated as pure functions as this contract contains no\r\n * storage and makes no external calls (other than to precompiles)\r\n * \r\n * Copyright 2020 Spilsbury Holdings Ltd \r\n *\r\n * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n**/\r\n\r\nlibrary DividendABIEncoder {\r\n    /**\r\n    * New calldata map\r\n    * 0x04:0x24      = calldata location of proofData byte array  // proof data byte array\r\n    * 0x24:0x44      = message sender // address\r\n    * 0x44:0x64      = h_x     // crs\r\n    * 0x64:0x84      = h_y     // crs\r\n    * 0x84:0xa4      = t2_x0   // crs\r\n    * 0xa4:0xc4      = t2_x1   // crs\r\n    * 0xc4:0xe4      = t2_y0   // crs\r\n    * 0xe4:0x104     = t2_y1   // crs\r\n    * 0x104:0x124    = length of proofData byte array\r\n    * 0x124:0x144    = challenge\r\n    * 0x144:0x164    = za\r\n    * 0x164:0x184    = zb\r\n    * 0x184:0x1a4    = offset in byte array to notes\r\n    * 0x1a4:0x1c4    = offset in byte array to inputOwners\r\n    * 0x1c4:0x1e4    = offset in byte array to outputOwners\r\n    * 0x1e4:0x204    = offset in byte array to metadata\r\n    */\r\n    function encodeAndExit() internal pure {\r\n        assembly {\r\n            // set up initial variables\r\n            let notes := add(0x104, calldataload(0x184))\r\n            let n := calldataload(notes)\r\n            let m := 1\r\n            let inputOwners := add(0x124, calldataload(0x1a4)) // one word after outputOwners = 1st\r\n            let outputOwners := add(0x124, calldataload(0x1c4)) // one word after outputOwners = 1st\r\n            let metadata := add(0x144, calldataload(0x1e4)) // two words after metadata = 1st\r\n\r\n            // `returndata` starts at 0x160\r\n            // `proofOutputs` starts at 0x180\r\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\r\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\r\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\r\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\r\n\r\n            // `proofOutput` - t, starts at 0x1e0\r\n            // 0x1e0 - 0x200 = length of `proofOutput`\r\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\r\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\r\n            // 0x240 - 0x260 = `publicOwner`\r\n            // 0x260 - 0x280 = `publicValue`\r\n\r\n            // `inputNotes` starts at 0x280\r\n            // structure of `inputNotes` and `outputNotes`\r\n            // 0x00 - 0x20 = byte length of notes array\r\n            // 0x20 - 0x40 = number of notes `i`\r\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\r\n            // start of notes array and the location of the `note`\r\n\r\n            // structure of a `note`\r\n            // 0x00 - 0x20 = size of `note`\r\n            // 0x20 - 0x40 = `noteType`\r\n            // 0x40 - 0x60 = `owner`\r\n            // 0x60 - 0x80 = `noteHash`\r\n            // 0x80 - 0xa0 = size of note `data`\r\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\r\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\r\n            // 0xe0 - ???? = remaining note metadata\r\n\r\n            // `proofOutputs` must form a monolithic block of memory that we can return.\r\n            // `s` points to the memory location of the start of the current note\r\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\r\n\r\n            // length of proofOutputs is at s\r\n            mstore(0x1a0, 0x01)                            // number of proofs\r\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\r\n            // length of proofOutput is at s + 0x60\r\n            mstore(0x200, 0xc0)                            // location of inputNotes\r\n            // location of outputNotes is at s + 0xc0\r\n            mstore(0x240, 0x00)             // publicOwner\r\n            // store kPublic. If kPublic is negative, store correct signed representation,\r\n            // relative to 2^256, not to the order of the bn128 group\r\n            let kPublic := 0\r\n            mstore(0x260, kPublic)\r\n\r\n            // 0x280 = challenge\r\n            mstore(0x280, calldataload(0x124))\r\n\r\n            let inputPtr := 0x2a0                                 // point to inputNotes\r\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\r\n            // set note pointer, offsetting lookup indices for each input note\r\n            let s := add(0x2e0, mul(m, 0x20))\r\n\r\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\r\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\r\n                // copy note data to 0x00 - 0x80\r\n                mstore(0x00, 0x01) // store note type at 0x00\r\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\r\n\r\n\r\n                // store note length in `s`\r\n                mstore(s, 0xc0)\r\n                // store note type (UXTO = 1) in `s+0x20`\r\n                mstore(add(s, 0x20), 0x01)\r\n                // store note owner in `s + 0x20`\r\n                mstore(add(s, 0x40), calldataload(inputOwners))\r\n\r\n                // store note hash in `s + 0x60`\r\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\r\n\r\n                // store note metadata length in `s + 0x80` (just the coordinates)\r\n                mstore(add(s, 0x80), 0x40)\r\n                // store compressed note coordinate gamma in `s + 0x80`\r\n                mstore(\r\n                    add(s, 0xa0),\r\n                    or(\r\n                        calldataload(add(noteIndex, 0x40)),\r\n                        mul(\r\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\r\n                            0x8000000000000000000000000000000000000000000000000000000000000000\r\n                        )\r\n                    )\r\n                )\r\n                // store compressed note coordinate sigma in `s + 0xa0`\r\n                mstore(\r\n                    add(s, 0xc0),\r\n                    or(\r\n                        calldataload(add(noteIndex, 0x80)),\r\n                        mul(\r\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\r\n                            0x8000000000000000000000000000000000000000000000000000000000000000\r\n                        )\r\n                    )\r\n                )\r\n                // compute the relative offset to index this note in our returndata\r\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\r\n\r\n                // increase s by note length\r\n                s := add(s, 0xe0)\r\n            }\r\n\r\n            // transition between input and output notes\r\n            // store total length of inputNotes at first index of inputNotes\r\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\r\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\r\n            inputPtr := s\r\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\r\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\r\n\r\n            // output notes\r\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\r\n                // get note index\r\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\r\n                // get pointer to metadata\r\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\r\n                // get size of metadata\r\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\r\n\r\n                mstore(0x00, 0x01) // store note type at 0x00\r\n                // copy note data to 0x20 - 0xa0\r\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\r\n\r\n                // store note length in `s`\r\n                mstore(s, add(0xc0, metadataLength))\r\n                // store note type (UXTO = 1) in `s+0x20`\r\n                mstore(add(s, 0x20), 0x01)\r\n                // store the owner of the note in `s + 0x20`\r\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\r\n                // store note hash\r\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\r\n                // store note metadata length if `s + 0x60`\r\n                mstore(add(s, 0x80), add(0x40, metadataLength))\r\n                // store compressed note coordinate gamma in `s + 0x80`\r\n                mstore(\r\n                    add(s, 0xa0),\r\n                    or(\r\n                        mload(0x20),\r\n                        mul(\r\n                            and(mload(0x40), 0x01),\r\n                            0x8000000000000000000000000000000000000000000000000000000000000000\r\n                        )\r\n                    )\r\n                )\r\n                // store compressed note coordinate sigma in `s + 0xa0`\r\n                mstore(\r\n                add(s, 0xc0),\r\n                or(\r\n                    mload(0x60),\r\n                    mul(\r\n                        and(mload(0x80), 0x01),\r\n                        0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                )\r\n                )\r\n                // copy metadata into `s + 0xc0`\r\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\r\n                // compute the relative offset to index this note in our returndata\r\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\r\n\r\n                // increase s by note length\r\n                s := add(s, add(mload(s), 0x20))\r\n            }\r\n\r\n            // cleanup. the length of the outputNotes = s - inputPtr\r\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\r\n            let notesLength := sub(s, 0x2a0)\r\n            // store length of proofOutput at 0x160. 0xa0 comes from:\r\n            // (offset to input notes, offset to output notes, publicOwner, publicValue, challenge)\r\n            mstore(0x1e0, add(0xa0, notesLength))\r\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\r\n\r\n            mstore(0x160, 0x20)\r\n            return(0x160, add(0x140, notesLength)) // return the final byte array\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/DividendInterface.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * @title DividendInterface\r\n * @author AZTEC\r\n * @dev An interface for the dividend validator contract\r\n *\r\n * Copyright 2020 Spilsbury Holdings Ltd \r\n *\r\n * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n**/\r\nlibrary DividendInterface {\r\n    function validateDividend(\r\n        bytes calldata,\r\n        address,\r\n        uint[6] calldata\r\n    )\r\n        external\r\n        pure\r\n        returns (bytes memory)\r\n    {}\r\n}\r\n\r\n// File: contracts/ACE/validators/dividend/Dividend.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Dividend\r\n * @author AZTEC\r\n * @dev Library to validate AZTEC dividend proofs. \r\n * Don't include this as an internal library. This contract uses a static memory table\r\n * to cache elliptic curve primitives and hashes.\r\n * Calling this internally from another function will lead to memory mutation and undefined behaviour.\r\n * The intended use case is to call this externally via `staticcall`. External calls to OptimizedAZTEC\r\n * can be treated as pure functions as this contract contains no storage and makes no external calls\r\n * (other than to precompiles).\r\n *\r\n * Copyright 2020 Spilsbury Holdings Ltd \r\n *\r\n * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n**/\r\ncontract Dividend {\r\n    /**\r\n     * @dev This will take any dividend calculation proof data and attempt to verify it in zero-knowledge\r\n     * If the proof is not valid, the transaction throws.\r\n     * @notice See DividendInterface for how method calls should be constructed.\r\n     * Dividend is written in YUL to enable manual memory management and for other efficiency savings.\r\n     **/\r\n    // solhint-disable payable-fallback\r\n    function() external {\r\n        assembly {\r\n\r\n            // We don't check for function signatures, there's only one function\r\n            // that ever gets called: validateDividend()\r\n            // We still assume calldata is offset by 4 bytes so that we can\r\n            // represent this contract through a compatible ABI\r\n            validateDividend()\r\n\r\n            // if we get to here, the proof is valid. We now 'fall through' the assembly block\r\n            // and into DividendABIEncoder.encodeAndExit()\r\n            // reset the free memory pointer because we're touching Solidity code again\r\n            mstore(0x40, 0x60)\r\n\r\n            /**\r\n             * New calldata map\r\n             * 0x04:0x24      = calldata location of proofData byte array  // proof data byte array\r\n             * 0x24:0x44      = message sender // address\r\n             * 0x44:0x64      = h_x     // crs\r\n             * 0x64:0x84      = h_y     // crs\r\n             * 0x84:0xa4      = t2_x0   // crs\r\n             * 0xa4:0xc4      = t2_x1   // crs\r\n             * 0xc4:0xe4      = t2_y0   // crs\r\n             * 0xe4:0x104     = t2_y1   // crs\r\n             * 0x104:0x124    = length of proofData byte array\r\n             * 0x124:0x144    = challenge\r\n             * 0x144:0x164    = za\r\n             * 0x164:0x184    = zb\r\n             * 0x184:0x1a4    = offset in byte array to notes\r\n             * 0x1a4:0x1c4    = offset in byte array to inputOwners\r\n             * 0x1c4:0x1e4    = offset in byte array to outputOwners\r\n             * 0x1e4:0x204    = offset in byte array to metadata\r\n             */\r\n\r\n            function validateDividend() {\r\n\r\n                /*\r\n                ///////////////////////////////////////////  SETUP  //////////////////////////////////////////////\r\n                */\r\n                mstore(0x80, calldataload(0x44))\r\n                mstore(0xa0, calldataload(0x64))\r\n                let notes := add(0x104, calldataload(0x184))\r\n                let n := calldataload(notes)\r\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\r\n                let challenge := mod(calldataload(0x124), gen_order)\r\n\r\n                let za := mod(calldataload(0x144), gen_order)\r\n                let zb := mod(calldataload(0x164), gen_order)\r\n\r\n\r\n                // Check that za <= kMax\r\n                if gt(za, 10000000) {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n\r\n                // Check that zb <= kMax\r\n                if gt(zb, 10000000) {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n\r\n                /*\r\n                m is the deliminator between input and output notes.\r\n                We only have one input note, and then the next two are output notes.\r\n\r\n                m = 0 and n = 3\r\n\r\n                Variables not defined and instead hard-coded, to save on stack depth\r\n                */\r\n\r\n                // add caller, za and zb to final hash table\r\n                mstore(0x2a0, calldataload(0x24))\r\n                mstore(0x2c0, za)\r\n                mstore(0x2e0, zb)\r\n\r\n                hashCommitments(notes, n)\r\n                let b := add(0x300, mul(n, 0x80))\r\n\r\n                /*\r\n                ///////////////////////////  CALCULATE BLINDING FACTORS  /////////////////////////////////////\r\n                */\r\n\r\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\r\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1.\r\n                // This adds some minor alterations\r\n                let x := 1\r\n                for { let i := 0 } lt(i, 3) { i := add(i, 0x01) } {\r\n\r\n                    // Get the calldata index of this note - call data location of start of note\r\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\r\n\r\n                    // Define variables k, a and c.\r\n                    // If i <= m then - input notes\r\n                    //   k = kBar_i\r\n                    //   a = aBar_i\r\n                    //   c = challenge\r\n                    // If i > m then we add a modification for the pairing optimization\r\n                    //   k = kBar_i * x_i\r\n                    //   a = aBar_i * x_i\r\n                    //   c = challenge * x_i\r\n                    // Set j = i - (m + 1). - index to count the output commitment\r\n                    // x_0 = 1\r\n                    // x_1 = keccak256(input string)\r\n                    // all other x_{j} = keccak256(x_{j-1})\r\n                    // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\r\n                    // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\r\n                    // We instead validate:\r\n                    // e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\r\n                    // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\r\n                    // a sum of commitment points to be evaluated in one pairing comparison\r\n\r\n                    let k\r\n                    let a := calldataload(add(noteIndex, 0x20))\r\n                    let c := challenge\r\n                    x := mulmod(x, mload(0x00), gen_order)\r\n\r\n                    switch gt(i, 1)\r\n                    case 1 { // output note\r\n                        /*\r\n                        Enforce the condition k_3 = (k_1)(z_b) - (k_2)(z_a)\r\n                        */\r\n                        k := addmod(\r\n                                    mulmod(\r\n                                        calldataload(sub(noteIndex, add(0xc0, 0xc0))),\r\n                                        zb,\r\n                                        gen_order), // k_1 * z_b\r\n                                    mulmod(\r\n                                        sub(gen_order, calldataload(sub(noteIndex, 0xc0))),\r\n                                        za,\r\n                                        gen_order), //-(k_2 * z_a)\r\n                                    gen_order)\r\n                    }\r\n\r\n                    case 0 { // input note\r\n                        /*\r\n                        Input commitments just have the k factors as according to the note data\r\n                        */\r\n                        k := calldataload(noteIndex)\r\n                    }\r\n\r\n                    // Check this commitment is well formed\r\n                    validateCommitment(noteIndex, k, a)\r\n\r\n                    // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\r\n                    k := mulmod(k, x, gen_order) // kx\r\n                    a := mulmod(a, x, gen_order) // ax\r\n                    c := mulmod(challenge, x, gen_order) // cx\r\n                    // calculate x_{j+1}\r\n\r\n\r\n\r\n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i - already has all x stuff\r\n                    // Memory map:\r\n                    // 0x20: \\gamma_iX\r\n                    // 0x40: \\gamma_iY\r\n                    // 0x60: k_i\r\n                    // 0x80: hX\r\n                    // 0xa0: hY\r\n                    // 0xc0: a_i\r\n                    // 0xe0: \\sigma_iX\r\n                    // 0x100: \\sigma_iY\r\n                    // 0x120: -c\r\n\r\n                    // loading key variables into memory to be operated on later\r\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\r\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\r\n                    mstore(0x120, sub(gen_order, c))\r\n                    mstore(0x60, k)\r\n                    mstore(0xc0, a)\r\n\r\n                    // Call bn128 scalar multiplication precompiles\r\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\r\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\r\n                    // Store \\gamma_i^{k} at 0x120:0x160\r\n                    // Store h^{a} at 0x160:0x1a0\r\n\r\n                    // result is a boolean. It keeps track of whether the call to the pre-compile was\r\n                    // successful. True if it was, False if it wasn't\r\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40) // sigma_i^{-c}\r\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40)) // gamma_i^{k}\r\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40)) // h^{a}\r\n\r\n                    // Call bn128 group addition precompiles\r\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\r\n                    // Store result of addition at 0x160:0x1a0\r\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\r\n\r\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\r\n                    // Store resulting point B at memory index b\r\n                    // index b points to the end of the block of memory containing commitments\r\n                    // we're appending blinding factors to the end of the commitment block\r\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\r\n\r\n                    // We have \\sigma^{-c} at 0x1a0:0x200\r\n                    // And \\sigma_{acc} at 0x1e0:0x200\r\n                    // If i = m + 1 (i.e. first output note)\r\n                    // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\r\n                    // the accumulator is the variable that is used to condense the various pairing\r\n                    // comparisons into a single one\r\n                    if eq(i, 0) { // m = 0\r\n                        mstore(0x260, mload(0x20))\r\n                        mstore(0x280, mload(0x40))\r\n                        mstore(0x1e0, mload(0xe0))\r\n                        mstore(\r\n                            0x200,\r\n                            sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100))\r\n                            )\r\n                    }\r\n\r\n                    // If i > m + 1 (i.e. subsequent output notes)\r\n                    // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\r\n                    // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\r\n                    if gt(i, 0) { // m = 0\r\n                        mstore(0x60, c)\r\n                        result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\r\n\r\n                       // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\r\n                        result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\r\n\r\n                       // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\r\n                        result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\r\n                    }\r\n\r\n                    // throw transaction if any calls to precompiled contracts failed\r\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\r\n                    b := add(b, 0x40) // increase B pointer by 2 words\r\n                }\r\n\r\n\r\n                    validatePairing(0x84)\r\n\r\n                // We now have the message sender, z_a, z_b, note commitments and the\r\n                // calculated blinding factors in a block of memory starting at 0x2a0, of size (b - 0x2a0).\r\n                // Hash this block to reconstruct the initial challenge and validate that they match\r\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\r\n\r\n\r\n                if iszero(eq(expected, challenge)) {\r\n\r\n                    // Proof failed\r\n                    mstore(0x00, 404)\r\n                    revert(0x00, 0x20)\r\n                }\r\n            }\r\n\r\n            /**\r\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\r\n             * @notice we don't hard-code t2 so that contracts that call this library can use different trusted setups.\r\n             **/\r\n            function validatePairing(t2) {\r\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\r\n                let t2_x_1 := calldataload(t2)\r\n                let t2_x_2 := calldataload(add(t2, 0x20))\r\n                let t2_y_1 := calldataload(add(t2, 0x40))\r\n                let t2_y_2 := calldataload(add(t2, 0x60))\r\n\r\n                // check provided setup pubkey is not zero or g2\r\n                if or(or(or(or(or(or(or(\r\n                    iszero(t2_x_1),\r\n                    iszero(t2_x_2)),\r\n                    iszero(t2_y_1)),\r\n                    iszero(t2_y_2)),\r\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\r\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\r\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\r\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\r\n                {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n\r\n                // store coords in memory\r\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\r\n                // to what precompile expects. We can overwrite the memory we used previously as this function\r\n                // is called at the end of the validation routine.\r\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\r\n                mstore(0x40, mload(0x200)) // sigma accumulator y\r\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\r\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\r\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\r\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\r\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\r\n                mstore(0x100, mload(0x280)) // gamma accumulator y\r\n                mstore(0x140, t2_x_1)\r\n                mstore(0x120, t2_x_2)\r\n                mstore(0x180, t2_y_1)\r\n                mstore(0x160, t2_y_2)\r\n\r\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\r\n\r\n                if or(iszero(success), iszero(mload(0x20))) {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n            }\r\n\r\n            /**\r\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\r\n             * and that signatures 'k' and 'a' are modulo the order of the curve.\r\n             * Transaction throws if this is not the case.\r\n             * @param note the calldata loation of the note\r\n             **/\r\n            function validateCommitment(note, k, a) {\r\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\r\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\r\n                let gammaX := calldataload(add(note, 0x40))\r\n                let gammaY := calldataload(add(note, 0x60))\r\n                let sigmaX := calldataload(add(note, 0x80))\r\n                let sigmaY := calldataload(add(note, 0xa0))\r\n                if iszero(\r\n                    and(\r\n                        and(\r\n                            and(\r\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\r\n                                gt(a, 1)                  // can't be 0 or 1 either!\r\n                            ),\r\n                            and(\r\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\r\n                                gt(k, 1)                  // and not 0 or 1\r\n                            )\r\n                        ),\r\n                        and(\r\n                            eq( // y^2 ?= x^3 + 3\r\n                                addmod(\r\n                                    mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order),\r\n                                    3,\r\n                                    field_order),\r\n                                mulmod(sigmaY, sigmaY, field_order)\r\n                            ),\r\n                            eq( // y^2 ?= x^3 + 3\r\n                                addmod(\r\n                                    mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order),\r\n                                    3,\r\n                                    field_order),\r\n                                mulmod(gammaY, gammaY, field_order)\r\n                            )\r\n                        )\r\n                    )\r\n                ) {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n            }\r\n\r\n            /**\r\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\r\n             * This is used both as an input to validate the challenge `c` and also\r\n             * to generate pseudorandom relationships between commitments for different outputNotes, so\r\n             * that we can combine them into a single multi-exponentiation for the purposes of\r\n             * validating the bilinear pairing relationships.\r\n             * @param notes calldata location of notes\r\n             * @param n number of notes\r\n             *\r\n             * @notice\r\n             */\r\n\r\n            function hashCommitments(notes, n) {\r\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\r\n                    let index := add(add(notes, mul(i, 0xc0)), 0x60)\r\n                    calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\r\n                }\r\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\r\n            }\r\n        }\r\n\r\n        DividendABIEncoder.encodeAndExit();\r\n    }\r\n}","ABI":"[{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}]","ContractName":"Dividend","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://f250ff60382d2774be38c4f01759d6d371e6ed16e2a98d7eade66ae9cb56f08d"}]}