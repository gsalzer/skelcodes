{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.7.0;\r\n\r\n// * poker2win - Fair and freedom games that pay Ether, No banker\r\n//\r\n// * @author poker2win <poker2win.club@gmail.com>\r\n//\r\n// * @license Apache2.0\r\n\r\ncontract Battle {\r\n    // Bet ether limitation\r\n    uint constant betUnitMinEther = 0.15 ether;\r\n    uint constant betUnitMaxEther = 135 ether;\r\n\r\n    // Pokers total count\r\n    uint constant pokerCountTotal = 2;\r\n\r\n    // Game status\r\n    bool private gameIsRunning = false;\r\n    uint private startTime;\r\n\r\n    // Bet ether statics and transfer\r\n    uint private currentRoundBet = 0; // wei\r\n    address private betPoolAddress = address(this);\r\n\r\n    // Take part players, for loop addresses\r\n    address[] private players;\r\n    mapping (address => uint) private playersMapIndex;\r\n\r\n    uint[] private pokerIndexes;\r\n    mapping (uint => bool) private pokerIndexesExistence;\r\n\r\n    uint private highestPokerValue;\r\n    address[] private highestPlayersAddress;\r\n\r\n    uint[] private prePokerValues;\r\n\r\n    // Service charge address\r\n    address payable private serviceChargeAddress = 0x04481B739cfEb9E55cd6aA062f3db4930bE0D610;\r\n\r\n    address public owner;\r\n\r\n    // When deploy contract\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function getBetUnitMinEther () external pure returns (uint) {\r\n        return betUnitMinEther;\r\n    }\r\n\r\n    function getBetUnitMaxEther () external pure returns (uint) {\r\n        return betUnitMaxEther;\r\n    }\r\n\r\n    function getGameIsRunning() external view returns (bool) {\r\n        return gameIsRunning;\r\n    }\r\n\r\n    function getStartTime() external view returns (uint) {\r\n        return startTime;\r\n    }\r\n\r\n    // If gt 0 ether, later player can only bet currentRoundBetWei\r\n    function getCurrentRoundBetWei() external view returns (uint) {\r\n        return currentRoundBet;\r\n    }\r\n\r\n    function getMyPokerIndex() external view returns (uint) {\r\n        return playersMapIndex[msg.sender];\r\n    }\r\n\r\n    function getAllPokerIndex() external view returns (uint[] memory) {\r\n        return pokerIndexes;\r\n    }\r\n\r\n    function getPrePokerValues() external view returns (uint[] memory) {\r\n        return prePokerValues;\r\n    }\r\n\r\n    function getPokersCountLeft() public view returns (uint) {\r\n        return pokerCountTotal - players.length;\r\n    }\r\n\r\n    function betOn(uint _pokerIndex) external payable onlyBalanceValid onlyHasPokerLeft {\r\n\r\n        require(playersMapIndex[msg.sender] == 0, 'You have already bet on yet');\r\n        require(pokerIndexesExistence[_pokerIndex] == false, 'This poker was bet on by others yet');\r\n        if (gameIsRunning) {\r\n            require(msg.value == currentRoundBet, 'Your bet ether is not equals to the first player');\r\n        }\r\n\r\n        if (! gameIsRunning) {\r\n            // new round should clear pre data\r\n            delete prePokerValues;\r\n\r\n            gameIsRunning = true;\r\n            currentRoundBet = msg.value;\r\n        }\r\n        startTime = block.timestamp;\r\n\r\n        // Give poker to the player\r\n        uint v = random(_pokerIndex);\r\n\r\n        players.push(msg.sender);\r\n        playersMapIndex[msg.sender] = _pokerIndex;\r\n        pokerIndexesExistence[_pokerIndex] = true;\r\n        pokerIndexes.push(_pokerIndex);\r\n\r\n        prePokerValues.push(v);\r\n\r\n        if (players.length == 1) {\r\n            highestPokerValue = v;\r\n        } else {\r\n            if (v > highestPokerValue) {\r\n                highestPokerValue = v;\r\n                highestPlayersAddress.push(msg.sender);\r\n            } else if (v == highestPokerValue) {\r\n                highestPlayersAddress.push(players[0]);\r\n                highestPlayersAddress.push(msg.sender);\r\n            } else {\r\n                highestPlayersAddress.push(players[0]);\r\n            }\r\n            allocateFunds();\r\n        }\r\n    }\r\n\r\n    modifier onlyBalanceValid() {\r\n        require(msg.value >= betUnitMinEther, 'Your bet ETH is lower than the minimum');\r\n        require(msg.value <= betUnitMaxEther, 'Your bet ETH is largger than the maximum');\r\n        _;\r\n    }\r\n\r\n    modifier onlyHasPokerLeft() {\r\n        require(getPokersCountLeft() > 0, 'No poker left, please wait next round start');\r\n        _;\r\n    }\r\n\r\n    modifier onlyMultiPlayersHasJoined() {\r\n        require(gameIsRunning == true, 'Current round is not running');\r\n        require(players.length >= 2, 'Joined player count less than 2');\r\n        _;\r\n    }\r\n\r\n    function random(uint i) internal view returns (uint8) {\r\n        return uint8(uint256(keccak256(abi.encodePacked(\r\n            block.difficulty, block.coinbase, block.timestamp, block.number, i\r\n        ))) % 10);\r\n    }\r\n\r\n    // We need a backend to pay this action. Even more backend can count down.\r\n    function allocateFunds() internal {\r\n        require(players.length >= 2, 'No player joined');\r\n\r\n        // 2% service charge\r\n        uint serviceCharge = betPoolAddress.balance / 50;\r\n        serviceChargeAddress.transfer(serviceCharge);\r\n\r\n        // Amount assign\r\n        uint winnerNumber = highestPlayersAddress.length;\r\n        uint winnerAverageAmount = betPoolAddress.balance / winnerNumber;\r\n        for (uint i = 0; i < winnerNumber; i++) {\r\n            address payable addr = address(uint160(highestPlayersAddress[i]));\r\n            addr.transfer(winnerAverageAmount);\r\n        }\r\n\r\n        // If others\r\n        uint otherAmount = betPoolAddress.balance;\r\n        if (otherAmount > 0) {\r\n            serviceChargeAddress.transfer(otherAmount);\r\n        }\r\n\r\n        refresh();\r\n    }\r\n\r\n    function refresh() internal {\r\n        gameIsRunning = false;\r\n        currentRoundBet = 0;\r\n        delete startTime;\r\n\r\n        uint playerLength = players.length;\r\n        for (uint i = 0; i < playerLength; i++) {\r\n            delete playersMapIndex[players[i]];\r\n            delete pokerIndexesExistence[pokerIndexes[i]];\r\n        }\r\n\r\n        delete players;\r\n        delete pokerIndexes;\r\n\r\n        delete highestPokerValue;\r\n        delete highestPlayersAddress;\r\n    }\r\n\r\n    function setServiceChargeAddress(address payable _addr) external onlyOwner {\r\n        serviceChargeAddress = _addr;\r\n    }\r\n\r\n    // Maybe for exception situations, platform promise\r\n    function withdrawIfOccurUnknowProblem() external onlyOwner {\r\n        uint amount = betPoolAddress.balance;\r\n        serviceChargeAddress.transfer(amount);\r\n\r\n        refresh();\r\n    }\r\n\r\n    function destroyContract() external onlyOwner {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, 'You are not owner');\r\n        _;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pokerIndex\",\"type\":\"uint256\"}],\"name\":\"betOn\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllPokerIndex\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBetUnitMaxEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBetUnitMinEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundBetWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameIsRunning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyPokerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPokersCountLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrePokerValues\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setServiceChargeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawIfOccurUnknowProblem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Battle","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://7793fb83ad303300e7e656f047e4233cfd4a834812f65aaccd2fb3dfeeab59d9"}]}