{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity 0.4.25;\r\n\r\n    library DappDatasets {\r\n\r\n        struct Player {\r\n\r\n            uint withdrawalAmount;\r\n\r\n            uint wallet;\r\n\r\n            uint fomoTotalRevenue;\r\n\r\n            uint lotteryTotalRevenue;\r\n\r\n            uint dynamicIncome;\r\n\r\n            uint rechargeAmount;\r\n\r\n            uint staticIncome;\r\n\r\n            uint shareholderLevel;\r\n\r\n            uint underUmbrellaLevel;\r\n\r\n            uint subbordinateTotalPerformance;\r\n\r\n            bool isExist;\r\n\r\n            bool superior;\r\n\r\n            address superiorAddr;\r\n\r\n            address[] subordinates;\r\n        }\r\n\r\n\r\n        struct Fomo {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint endTime;\r\n\r\n            uint fomoPrizePool;\r\n\r\n            address[] participant;\r\n        }\r\n\r\n        struct Lottery {\r\n\r\n            bool whetherToEnd;\r\n\r\n            uint lotteryPool;\r\n\r\n            uint unopenedBonus;\r\n\r\n            uint number;\r\n\r\n            uint todayAmountTotal;\r\n\r\n            uint totayLotteryAmountTotal;\r\n\r\n            uint[] grandPrizeNum;\r\n\r\n            uint[] firstPrizeNum;\r\n\r\n            uint[] secondPrizeNum;\r\n\r\n            uint[] thirdPrizeNum;\r\n\r\n            mapping(address => uint[]) lotteryMap;\r\n\r\n            mapping(uint => address) numToAddr;\r\n\r\n            mapping(address => uint) personalAmount;\r\n\r\n            mapping(uint => uint) awardAmount;\r\n        }\r\n\r\n\r\n        function getNowTime() internal view returns(uint) {\r\n            return now;\r\n        }\r\n\r\n\r\n        function rand(uint256 _length, uint num) internal view returns(uint256) {\r\n            uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, now - num)));\r\n            return random%_length;\r\n        }\r\n\r\n        function returnArray(uint len, uint range, uint number) internal view returns(uint[]) {\r\n            uint[] memory numberArray = new uint[](len);\r\n            uint i = 0;\r\n            while(true) {\r\n                number = number + 9;\r\n                uint temp = rand(range, number);\r\n                if(temp == 0) {\r\n                    continue;\r\n                }\r\n                numberArray[i] = temp;\r\n                i++;\r\n                if(i == len) {\r\n                    break;\r\n                }\r\n            }\r\n            return numberArray;\r\n        }\r\n    }\r\n\r\npragma solidity 0.4.25;\r\n\r\n    contract AWMain {\r\n\r\n\r\n        address owner;\r\n\r\n\r\n        address specifyAddr;\r\n\r\n\r\n        address technologyAddr;\r\n\r\n        address gameAddr;\r\n\r\n        address[] temp = new address[](0);\r\n\r\n        uint staticDividendUsdt;\r\n\r\n        uint public staticPrizePool;\r\n\r\n        uint public staticTotalRecharge;\r\n\r\n        address[] allPlayer;\r\n\r\n        address[] shareholdersV1;\r\n\r\n        address[] shareholdersV2;\r\n\r\n        address[] shareholdersV3;\r\n\r\n        address[] shareholdersV4;\r\n\r\n        uint public usdtPool;\r\n\r\n        TetherToken tether;\r\n        AWToken awToken;\r\n\r\n        AWGame game;\r\n\r\n        mapping(address => DappDatasets.Player) public playerMap;\r\n\r\n        constructor(\r\n            address _owner,\r\n            address _tetherAddr,\r\n            address _awAddr,\r\n            address _gameAddr,\r\n            address _technologyAddr,\r\n            address _specifyAddr\r\n        )  public {\r\n            owner = _owner;\r\n            DappDatasets.Player memory player = DappDatasets.Player(\r\n                {\r\n                    withdrawalAmount : 0,\r\n                    wallet : 0,\r\n                    fomoTotalRevenue : 0,\r\n                    lotteryTotalRevenue : 0,\r\n                    dynamicIncome : 0,\r\n                    rechargeAmount : 0,\r\n                    staticIncome : 0,\r\n                    shareholderLevel : 0,\r\n                    underUmbrellaLevel : 0,\r\n                    subbordinateTotalPerformance : 0,\r\n                    isExist : true,\r\n                    superior : false,\r\n                    superiorAddr : address(0x0),\r\n                    subordinates : temp\r\n                }\r\n            );\r\n            specifyAddr = _specifyAddr;\r\n            playerMap[owner] = player;\r\n            tether = TetherToken(_tetherAddr);\r\n            awToken = AWToken(_awAddr);\r\n            game = AWGame(_gameAddr);\r\n            gameAddr = _gameAddr;\r\n            technologyAddr = _technologyAddr;\r\n            allPlayer.push(owner);\r\n            if(owner != technologyAddr) {\r\n                playerMap[technologyAddr] = player;\r\n                allPlayer.push(technologyAddr);\r\n            }\r\n        }\r\n\r\n        function() public payable {\r\n            withdrawImpl(msg.sender);\r\n        }\r\n\r\n        function resetNodePool() external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            usdtPool = 0;\r\n        }\r\n\r\n        function addWalletAndDynamicIncome(address addr, uint num) internal {\r\n            playerMap[addr].wallet = SafeMath.add(playerMap[addr].wallet, num);\r\n            playerMap[addr].dynamicIncome = SafeMath.add(playerMap[addr].dynamicIncome, num);\r\n        }\r\n\r\n        function usdtNode(uint start, uint count) external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            if(shareholdersV4.length < 1) {\r\n                staticPrizePool = SafeMath.add(staticPrizePool, usdtPool);\r\n                return;\r\n            }\r\n            uint award = SafeMath.div(usdtPool, shareholdersV4.length);\r\n            uint index = 0;\r\n            for(uint i = start; i < shareholdersV4.length; i++) {\r\n                fosterInteraction(shareholdersV4[i], award);\r\n                index++;\r\n                if(index == count) {\r\n                    break;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        function getShareholder() external view returns(uint, uint, uint, uint, uint) {\r\n            return (\r\n                shareholdersV1.length,\r\n                shareholdersV2.length,\r\n                shareholdersV3.length,\r\n                shareholdersV4.length,\r\n                allPlayer.length\r\n            );\r\n        }\r\n\r\n        function getStatistics() external view returns(\r\n            uint level,\r\n            uint destroyedQuantity,\r\n            uint fomoTotalRevenue,\r\n            uint lotteryTotalRevenue,\r\n            uint difference\r\n        ) {\r\n            return (\r\n                playerMap[msg.sender].shareholderLevel,\r\n                awToken.balanceOf(address(0x0)),\r\n                playerMap[msg.sender].fomoTotalRevenue,\r\n                playerMap[msg.sender].lotteryTotalRevenue,\r\n                SafeMath.sub(\r\n                    SafeMath.mul(playerMap[msg.sender].rechargeAmount, 3),\r\n                    playerMap[msg.sender].staticIncome\r\n                )\r\n            );\r\n        }\r\n\r\n        function getSubordinatesAndPerformanceByAddr(address addr) external view returns(address[], uint[], uint[]) {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            uint[] memory performance = new uint[](player.subordinates.length);\r\n            uint[] memory numberArray = new uint[](player.subordinates.length);\r\n            for(uint i = 0; i < player.subordinates.length; i++) {\r\n                performance[i] = SafeMath.add(\r\n                    playerMap[player.subordinates[i]].subbordinateTotalPerformance,\r\n                    playerMap[player.subordinates[i]].rechargeAmount\r\n                );\r\n                numberArray[i] = playerMap[player.subordinates[i]].subordinates.length;\r\n            }\r\n            return (player.subordinates, performance, numberArray);\r\n        }\r\n\r\n        function getPlayerInfo() external view returns(address superiorAddr, address ownerAddr, uint numberOfInvitations, bool exist) {\r\n            return (playerMap[msg.sender].superiorAddr,  msg.sender, playerMap[msg.sender].subordinates.length, playerMap[msg.sender].isExist);\r\n        }\r\n\r\n        function getRevenueAndPerformance() external view returns(\r\n            uint withdrawalAmount,\r\n            uint subbordinateTotalPerformance,\r\n            uint dynamicIncome,\r\n            uint staticIncome,\r\n            uint withdrawn,\r\n            uint outboundDifference\r\n        ) {\r\n            uint number = 0;\r\n            uint motionAndStaticAmount = SafeMath.add(playerMap[msg.sender].staticIncome, playerMap[msg.sender].dynamicIncome);\r\n            uint withdrawableBalance = SafeMath.mul(playerMap[msg.sender].rechargeAmount, 3);\r\n            if(motionAndStaticAmount > withdrawableBalance) {\r\n                number = SafeMath.sub(motionAndStaticAmount, withdrawableBalance);\r\n            }\r\n            uint value = SafeMath.add(playerMap[msg.sender].dynamicIncome, playerMap[msg.sender].staticIncome);\r\n            uint difference = 0;\r\n            if(value > SafeMath.mul(playerMap[msg.sender].rechargeAmount, 3)) {\r\n                difference = 0;\r\n            }else {\r\n                difference = SafeMath.sub(SafeMath.mul(playerMap[msg.sender].rechargeAmount, 3), value);\r\n            }\r\n            return (\r\n                SafeMath.sub(playerMap[msg.sender].wallet, number),\r\n                playerMap[msg.sender].subbordinateTotalPerformance,\r\n                playerMap[msg.sender].dynamicIncome,\r\n                playerMap[msg.sender].staticIncome,\r\n                playerMap[msg.sender].withdrawalAmount,\r\n                difference\r\n            );\r\n        }\r\n\r\n        function withdrawImpl(address addr) internal {\r\n            require(playerMap[addr].wallet > 0, \"Insufficient wallet balance\");\r\n\r\n            uint number = 0;\r\n            uint motionAndStaticAmount = SafeMath.add(playerMap[addr].staticIncome, playerMap[addr].dynamicIncome);\r\n            uint withdrawableBalance = SafeMath.mul(playerMap[addr].rechargeAmount, 3);\r\n\r\n            if(motionAndStaticAmount > withdrawableBalance) {\r\n                number = SafeMath.sub(motionAndStaticAmount, withdrawableBalance);\r\n            }\r\n            uint amount = SafeMath.sub(playerMap[addr].wallet, number);\r\n            uint value = amount;\r\n            if(amount > 1000 * 10 ** 6) {\r\n                value = 1000 * 10 ** 6;\r\n            }\r\n            playerMap[addr].wallet = SafeMath.sub(playerMap[addr].wallet, value);\r\n            playerMap[addr].withdrawalAmount = SafeMath.add(playerMap[addr].withdrawalAmount, value);\r\n\r\n            uint handlingFee = SafeMath.div(value, 10);\r\n            game.buyLotto(handlingFee, addr);\r\n            staticPrizePool = SafeMath.add(staticPrizePool, handlingFee);\r\n            tether.transfer(addr, SafeMath.sub(value, handlingFee));\r\n        }\r\n\r\n        function withdrawService() external {\r\n            withdrawImpl(msg.sender);\r\n        }\r\n\r\n        function afterStaticPayment() external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            staticPrizePool = SafeMath.sub(staticPrizePool, staticDividendUsdt);\r\n            staticDividendUsdt = 0;\r\n        }\r\n\r\n        function staticDividend(uint index) external {\r\n            require(owner == msg.sender, \"Insufficient permissions\");\r\n            uint count = 0;\r\n            for(uint i = index; i < allPlayer.length; i++) {\r\n                if(\r\n                    playerMap[allPlayer[i]].rechargeAmount == 0 ||\r\n                    SafeMath.add(playerMap[allPlayer[i]].staticIncome, playerMap[allPlayer[i]].dynamicIncome) >=\r\n                    SafeMath.mul(playerMap[allPlayer[i]].rechargeAmount, 3)\r\n                ) {\r\n                    continue;\r\n                }\r\n\r\n                uint proportionOfInvestment = SafeMath.div(\r\n                    SafeMath.mul(playerMap[allPlayer[i]].rechargeAmount, 10 ** 6),\r\n                    staticTotalRecharge\r\n                );\r\n\r\n                uint personalAmount = SafeMath.div(\r\n                    SafeMath.div(SafeMath.mul(staticPrizePool, proportionOfInvestment), 120),\r\n                    10 ** 6\r\n                );\r\n                playerMap[allPlayer[i]].wallet = SafeMath.add(\r\n                    playerMap[allPlayer[i]].wallet,\r\n                    personalAmount\r\n                );\r\n                playerMap[allPlayer[i]].staticIncome = SafeMath.add(\r\n                    playerMap[allPlayer[i]].staticIncome,\r\n                    personalAmount\r\n                );\r\n                staticDividendUsdt += personalAmount;\r\n                count++;\r\n                if(count == 100) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function participateFomo(uint usdtVal, address superiorAddr) external {\r\n            require(usdtVal >= 10 * 10 ** 6, \"Less than the minimum amount\");\r\n            register(msg.sender, superiorAddr);\r\n\r\n            DappDatasets.Player storage player = playerMap[msg.sender];\r\n            player.rechargeAmount = SafeMath.add(player.rechargeAmount, usdtVal);\r\n            staticTotalRecharge = SafeMath.add(staticTotalRecharge, usdtVal);\r\n\r\n            uint amount = SafeMath.div(SafeMath.mul(usdtVal, 3), 100);\r\n            playerMap[technologyAddr].wallet = SafeMath.add(playerMap[technologyAddr].wallet, amount);\r\n            usdtPool = SafeMath.add(usdtPool, amount);\r\n\r\n            increasePerformance(usdtVal);\r\n\r\n            uint remaining = game.deposit(usdtVal, msg.sender);\r\n            staticPrizePool = SafeMath.add(staticPrizePool, remaining);\r\n\r\n            tether.transferFrom(msg.sender, this, usdtVal);\r\n        }\r\n\r\n        function increasePerformance(uint usdtVal) internal {\r\n            DappDatasets.Player storage player = playerMap[msg.sender];\r\n            uint length = 0;\r\n            while(player.superior) {\r\n                address tempAddr = player.superiorAddr;\r\n                player = playerMap[player.superiorAddr];\r\n                player.subbordinateTotalPerformance = SafeMath.add(player.subbordinateTotalPerformance, usdtVal);\r\n                promotionMechanisms(tempAddr);\r\n                length++;\r\n                if(length == 50) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function promotionMechanisms(address addr) internal {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            if(player.subbordinateTotalPerformance >= 10 * 10 ** 10) {\r\n                uint length = player.subordinates.length;\r\n                if(player.subordinates.length > 30) {\r\n                    length = 30;\r\n                }\r\n                for(uint i = 0; i < 4; i++) {\r\n                    if(player.shareholderLevel == i) {\r\n                        uint levelCount = 0;\r\n                        for(uint j = 0; j < length; j++) {\r\n                            if(i == 0 && player.rechargeAmount >= 1000 * 10 ** 6) {\r\n                                uint areaTotal = SafeMath.add(\r\n                                            playerMap[player.subordinates[j]].subbordinateTotalPerformance,\r\n                                            playerMap[player.subordinates[j]].rechargeAmount\r\n                                );\r\n                                if(areaTotal >= 3 * 10 ** 10) {\r\n                                    levelCount++;\r\n                                }\r\n                            }else if(i == 1 && player.rechargeAmount >= 3000 * 10 ** 6) {\r\n                                if(playerMap[player.subordinates[j]].shareholderLevel >= 1 || playerMap[player.subordinates[j]].underUmbrellaLevel >= 1) {\r\n                                    levelCount++;\r\n                                }\r\n                            }else if(i == 2 && player.rechargeAmount >= 5000 * 10 ** 6) {\r\n                                if(playerMap[player.subordinates[j]].shareholderLevel >= 2 || playerMap[player.subordinates[j]].underUmbrellaLevel >= 2) {\r\n                                    levelCount++;\r\n                                }\r\n                            }else if(i == 3 && player.rechargeAmount >= 10000 * 10 ** 6) {\r\n                                if(playerMap[player.subordinates[j]].shareholderLevel >= 3 || playerMap[player.subordinates[j]].underUmbrellaLevel >= 3) {\r\n                                    levelCount++;\r\n                                }\r\n                            }\r\n\r\n                            if(levelCount >= 2) {\r\n                                player.shareholderLevel = i + 1;\r\n                                if(i == 0 ) {\r\n                                    shareholdersV1.push(addr);\r\n                                }else if(i == 1) {\r\n                                    shareholdersV2.push(addr);\r\n                                }else if(i == 2) {\r\n                                    shareholdersV3.push(addr);\r\n                                }else if(i == 3) {\r\n                                    shareholdersV4.push(addr);\r\n                                }\r\n                                \r\n                                DappDatasets.Player storage tempPlayer = player;\r\n                                uint count = 0;\r\n                                while(tempPlayer.superior) {\r\n                                    tempPlayer = playerMap[tempPlayer.superiorAddr];\r\n                                    if(tempPlayer.underUmbrellaLevel < i + 1) {\r\n                                        tempPlayer.underUmbrellaLevel = i + 1;\r\n                                    }else {\r\n                                        break;\r\n                                    }\r\n                                    count++;\r\n                                    if(count == 49) {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        function rewardDistribution(address addr, uint amount) external returns(uint) {\r\n            require(gameAddr == msg.sender, \"Insufficient permissions\");\r\n            return fosterInteraction(addr, amount);\r\n        }\r\n\r\n\r\n        function fosterInteraction(address addr, uint amount) internal returns(uint) {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            addWalletAndDynamicIncome(addr, amount);\r\n            uint number = amount;\r\n            uint reward = SafeMath.div(amount, 10);\r\n            if(player.superior) {\r\n                addWalletAndDynamicIncome(player.superiorAddr, reward);\r\n                number = SafeMath.add(number, reward);\r\n            }\r\n            if(player.subordinates.length > 0) {\r\n                uint length = player.subordinates.length;\r\n                if(player.subordinates.length > 30) {\r\n                    length = 30;\r\n                }\r\n                uint splitEqually = SafeMath.div(reward, length);\r\n                for(uint i = 0; i < length; i++) {\r\n                    addWalletAndDynamicIncome(player.subordinates[i], splitEqually);\r\n                }\r\n                number = SafeMath.add(number, reward);\r\n            }\r\n            return number;\r\n        }\r\n\r\n        function releaseStaticPoolAndV4(uint usdtVal) external {\r\n            require(gameAddr == msg.sender, \"Insufficient permissions\");\r\n            uint staticPool60 = SafeMath.div(SafeMath.mul(usdtVal, 6), 10);\r\n            staticPrizePool = SafeMath.add(staticPrizePool, staticPool60);\r\n\r\n            uint amount = SafeMath.sub(usdtVal, staticPool60);\r\n            if(shareholdersV4.length > 0) {\r\n                uint length = 0;\r\n                if(shareholdersV4.length > 100) {\r\n                    length = 100;\r\n                }else {\r\n                    length = shareholdersV4.length;\r\n                }\r\n                uint splitEqually = SafeMath.div(amount, length);\r\n                for(uint i = 0; i < length; i++) {\r\n                    addWalletAndDynamicIncome(shareholdersV4[i], splitEqually);\r\n                }\r\n            }else {\r\n                staticPrizePool = SafeMath.add(staticPrizePool, amount);\r\n            }\r\n\r\n        }\r\n\r\n        function updateRevenue(address addr, uint amount, bool flag) external {\r\n            require(gameAddr == msg.sender, \"Insufficient permissions\");\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            if(flag) {\r\n                player.wallet = SafeMath.add(player.wallet, amount);\r\n                player.fomoTotalRevenue = SafeMath.add(player.fomoTotalRevenue, amount);\r\n            }else {\r\n                player.wallet = SafeMath.add(player.wallet, amount);\r\n                player.lotteryTotalRevenue = SafeMath.add(player.lotteryTotalRevenue, amount);\r\n            }\r\n        }\r\n\r\n        function participateLottery(uint usdtVal, address superiorAddr) external {\r\n            require(usdtVal <= 300 * 10 ** 6 && usdtVal >= 10 ** 6, \"Purchase value between 1-300\");\r\n            register(msg.sender, superiorAddr);\r\n            game.buyLotto(usdtVal, msg.sender);\r\n            staticPrizePool = SafeMath.add(staticPrizePool, usdtVal);\r\n            tether.transferFrom(msg.sender, this, usdtVal);\r\n        }\r\n\r\n        function getPlayer(address addr) external view returns(uint, address, address[]) {\r\n            DappDatasets.Player storage player = playerMap[addr];\r\n            return (playerMap[player.superiorAddr].shareholderLevel, player.superiorAddr, player.subordinates);\r\n        }\r\n\r\n        function exchange(uint usdtVal, address superiorAddr) external {\r\n            require(usdtVal >= 10 ** 6, \"Redeem at least 1USDT\");\r\n            register(msg.sender, superiorAddr);\r\n\r\n            uint usdtPrice = awToken.usdtPrice();\r\n\r\n            game.redeemAW(usdtVal, usdtPrice, msg.sender);\r\n            uint staticAmount = SafeMath.div(SafeMath.mul(usdtVal, 4), 10);\r\n            staticPrizePool = SafeMath.add(staticPrizePool, staticAmount);\r\n\r\n            tether.transferFrom(msg.sender, this, staticAmount);\r\n\r\n            tether.transferFrom(msg.sender, specifyAddr, SafeMath.sub(usdtVal, staticAmount));\r\n        }\r\n\r\n        function register(address addr, address superiorAddr) internal{\r\n            if(playerMap[addr].isExist == true) {\r\n                return;\r\n            }\r\n            DappDatasets.Player memory player;\r\n            if(superiorAddr == address(0x0) || playerMap[superiorAddr].isExist == false) {\r\n                player = DappDatasets.Player(\r\n                    {\r\n                        withdrawalAmount : 0,\r\n                        wallet : 0,\r\n                        fomoTotalRevenue : 0,\r\n                        lotteryTotalRevenue : 0,\r\n                        dynamicIncome : 0,\r\n                        rechargeAmount : 0,\r\n                        staticIncome : 0,\r\n                        shareholderLevel : 0,\r\n                        underUmbrellaLevel : 0,\r\n                        subbordinateTotalPerformance : 0,\r\n                        isExist : true,\r\n                        superior : false,\r\n                        superiorAddr : address(0x0),\r\n                        subordinates : temp\r\n                    }\r\n                );\r\n                playerMap[addr] = player;\r\n            }else {\r\n                player = DappDatasets.Player(\r\n                    {\r\n                        withdrawalAmount : 0,\r\n                        wallet : 0,\r\n                        fomoTotalRevenue : 0,\r\n                        lotteryTotalRevenue : 0,\r\n                        dynamicIncome : 0,\r\n                        rechargeAmount : 0,\r\n                        staticIncome : 0,\r\n                        shareholderLevel : 0,\r\n                        underUmbrellaLevel : 0,\r\n                        subbordinateTotalPerformance : 0,\r\n                        isExist : true,\r\n                        superior : true,\r\n                        superiorAddr : superiorAddr,\r\n                        subordinates : temp\r\n                    }\r\n                );\r\n                DappDatasets.Player storage superiorPlayer = playerMap[superiorAddr];\r\n                superiorPlayer.subordinates.push(addr);\r\n                playerMap[addr] = player;\r\n            }\r\n            allPlayer.push(addr);\r\n        }\r\n\r\n    }\r\n\r\n    contract TetherToken {\r\n       function transfer(address to, uint value) public;\r\n       function transferFrom(address from, address to, uint value) public;\r\n    }\r\n\r\n    contract AWToken {\r\n       function burn(address addr, uint value) public;\r\n       function balanceOf(address who) external view returns (uint);\r\n       function calculationNeedAW(uint usdtVal) external view returns(uint);\r\n       function usdtPrice() external view returns(uint);\r\n    }\r\n\r\n    contract AWGame {\r\n        function deposit(uint usdtVal, address addr) external returns(uint);\r\n        function updateLotteryPoolAndTodayAmountTotal(uint usdtVal, uint lotteryPool) external;\r\n        function redeemAW(uint usdtVal, uint usdtPrice, address addr) external;\r\n        function buyLotto(uint usdtVal, address addr) external;\r\n    }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"usdtPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"exchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"afterStaticPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staticPrizePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"updateRevenue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStatistics\",\"outputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"destroyedQuantity\",\"type\":\"uint256\"},{\"name\":\"fomoTotalRevenue\",\"type\":\"uint256\"},{\"name\":\"lotteryTotalRevenue\",\"type\":\"uint256\"},{\"name\":\"difference\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"usdtNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"staticDividend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"participateFomo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getSubordinatesAndPerformanceByAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"}],\"name\":\"releaseStaticPoolAndV4\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdtVal\",\"type\":\"uint256\"},{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"participateLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRevenueAndPerformance\",\"outputs\":[{\"name\":\"withdrawalAmount\",\"type\":\"uint256\"},{\"name\":\"subbordinateTotalPerformance\",\"type\":\"uint256\"},{\"name\":\"dynamicIncome\",\"type\":\"uint256\"},{\"name\":\"staticIncome\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"name\":\"outboundDifference\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staticTotalRecharge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetNodePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getShareholder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"superiorAddr\",\"type\":\"address\"},{\"name\":\"ownerAddr\",\"type\":\"address\"},{\"name\":\"numberOfInvitations\",\"type\":\"uint256\"},{\"name\":\"exist\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerMap\",\"outputs\":[{\"name\":\"withdrawalAmount\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"uint256\"},{\"name\":\"fomoTotalRevenue\",\"type\":\"uint256\"},{\"name\":\"lotteryTotalRevenue\",\"type\":\"uint256\"},{\"name\":\"dynamicIncome\",\"type\":\"uint256\"},{\"name\":\"rechargeAmount\",\"type\":\"uint256\"},{\"name\":\"staticIncome\",\"type\":\"uint256\"},{\"name\":\"shareholderLevel\",\"type\":\"uint256\"},{\"name\":\"underUmbrellaLevel\",\"type\":\"uint256\"},{\"name\":\"subbordinateTotalPerformance\",\"type\":\"uint256\"},{\"name\":\"isExist\",\"type\":\"bool\"},{\"name\":\"superior\",\"type\":\"bool\"},{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rewardDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tetherAddr\",\"type\":\"address\"},{\"name\":\"_awAddr\",\"type\":\"address\"},{\"name\":\"_gameAddr\",\"type\":\"address\"},{\"name\":\"_technologyAddr\",\"type\":\"address\"},{\"name\":\"_specifyAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"AWMain","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e712a2f678426edf433df1d3ad8555daf8abe68900000000000000000000000068dfa5327696c92bbb847953deea4b68e491f4b40000000000000000000000004fff42650a1f0001214eb2f9a01a53d85bc18f600000000000000000000000002e2652277239990dd91939b8ca924e706aeae574000000000000000000000000eee3e6692b20ec6c83d5ce96191d7f2d8c647b5f000000000000000000000000fa79bd751b1acee27954aff8f16b2a5d4ab2ee61","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://4c7302fa4dc640952d26ea25e03ab0b03fc859692f0d24afc52d42c6505b31f3"}]}