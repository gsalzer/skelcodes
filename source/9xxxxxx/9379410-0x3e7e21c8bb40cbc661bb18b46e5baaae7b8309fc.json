{"status":"1","message":"OK","result":[{"SourceCode":"/*\nSNET SAVE\n\n fully decentralized AGI earning platform \n\nHow does it work\n\nUser buys in with AGI and receives SNET \nSNET enables the user to collect dividends in AGI instant on every transaction that is happening on the platform\n\n10% of every buyIn are distributed amongst all existing SNET holders.\n10%  are beeing distributed on every sell amongst all remaining SNET holders.\n\nThis makes our Platform sustainable and will therefore run forever.\n\nREMINDER: Developers have at no time access to userfunds thatswhy you need to make sure you keep your private keys safe.\n\nDevelopers will also NEVER ask you for your privatekeys or any personal Information.\n\nDevelopers  dont have any access to contract balance or any AGI or SNET inside the contract other than their own personal funds.\n\nSNET save is on the ETHEREUM Blockchain and it will run and do forever what it was programmed to do. TRUST THE CODE.\n\nSNETSAVE is 100% decentralized and 100% safe to use\n\nAll payments are beeing paid out instant in AGI (SingularityNET ERC20 token)\n\nIf you have any Questions please visit our telgram and discord channels\n\n\n*/\n\npragma solidity ^0.4.26;\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n}\n\ncontract TOKEN {\n   function totalSupply() external view returns (uint256);\n   function balanceOf(address account) external view returns (uint256);\n   function transfer(address recipient, uint256 amount) external returns (bool);\n   function allowance(address owner, address spender) external view returns (uint256);\n   function approve(address spender, uint256 amount) external returns (bool);\n   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract Ownable {\n\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor() public {\n    owner = address(0x17D25a33212343213DED3B0c7fc75219F96045f4);\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\ncontract Snet is Ownable {\n\n    mapping(address => bool) internal ambassadors_;\n    uint256 constant internal ambassadorMaxPurchase_ = 100000e8;\n    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n    bool public onlyAmbassadors = true;\n    uint256 ACTIVATION_TIME = 1580684400;\n\n    modifier antiEarlyWhale(uint256 _amountOfAGI, address _customerAddress){\n      if (now >= ACTIVATION_TIME) {\n        onlyAmbassadors = false;\n      }\n\n      if (onlyAmbassadors) {\n         require((ambassadors_[_customerAddress] == true && (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfAGI) <= ambassadorMaxPurchase_));\n         ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfAGI);\n         _;\n      } else {\n        if(now < (ACTIVATION_TIME + 60 seconds)) {\n          require(tx.gasprice <= 0.1 szabo);\n        }\n\n         onlyAmbassadors = false;\n         _;\n      }\n    }\n\n    modifier onlyTokenHolders {\n        require(myTokens() > 0);\n        _;\n    }\n\n    modifier onlyDivis {\n        require(myDividends(true) > 0);\n        _;\n    }\n\n    event onDistribute(\n        address indexed customerAddress,\n        uint256 price\n    );\n\n    event onTokenPurchase(\n        address indexed customerAddress,\n        uint256 incomingAGI,\n        uint256 tokensMinted,\n        address indexed referredBy,\n        uint timestamp\n    );\n\n    event onTokenSell(\n        address indexed customerAddress,\n        uint256 tokensBurned,\n        uint256 agiEarned,\n        uint timestamp\n    );\n\n    event onReinvestment(\n        address indexed customerAddress,\n        uint256 agiReinvested,\n        uint256 tokensMinted\n    );\n\n    event onWithdraw(\n        address indexed customerAddress,\n        uint256 agiWithdrawn\n    );\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 tokens\n    );\n\n    string public name = \"SnetSave\";\n    string public symbol = \"SNET\";\n    uint8 constant public decimals = 8;\n    uint256 internal entryFee_ = 10;\n    uint256 internal transferFee_ = 1;\n    uint256 internal exitFee_ = 10;\n    uint256 internal referralFee_ = 20; // 20% of the 10% buy or sell fees makes it 2%\n    uint256 internal maintenanceFee_ = 20; // 20% of the 10% buy or sell fees makes it 2%\n    address internal maintenanceAddress1;\n    address internal maintenanceAddress2;\n    uint256 constant internal magnitude = 2 ** 64;\n    mapping(address => uint256) internal tokenBalanceLedger_;\n    mapping(address => uint256) internal referralBalance_;\n    mapping(address => int256) internal payoutsTo_;\n    mapping(address => uint256) internal invested_;\n    uint256 internal tokenSupply_;\n    uint256 internal profitPerShare_;\n    uint256 public stakingRequirement = 100e8;\n    uint256 public totalHolder = 0;\n    uint256 public totalDonation = 0;\n    TOKEN erc20;\n\n    constructor() public {\n        maintenanceAddress1 = address(0x27FC1bF641206886A856e3835620Fe03e638A6E2); // Marketing Fund ALL users have voting right on how to spend marketing fund\n        maintenanceAddress2 = address(0xBeBF283B05C63D6100d0DbD5F2Cd968730217C99); // Developer Fund \n\n        ambassadors_[0x17D25a33212343213DED3B0c7fc75219F96045f4] = true; // Main Dev\n        ambassadors_[0xfB7230192E54Ea3ADb719096ae04A58564E282e3] = true; // ambassador\n  \n\n        erc20 = TOKEN(address(0x8eB24319393716668D768dCEC29356ae9CfFe285));\n    }\n\n    function updateMaintenanceAddress1(address maintenance) public {\n        require(maintenance != address(0) && msg.sender == maintenanceAddress1);\n        maintenanceAddress1 = maintenance;\n    }\n\n    function updateMaintenanceAddress2(address maintenance) public {\n        require(maintenance != address(0) && msg.sender == maintenanceAddress2);\n        maintenanceAddress2 = maintenance;\n    }\n\n    function checkAndTransferAGI(uint256 _amount) private {\n        require(erc20.transferFrom(msg.sender, address(this), _amount) == true, \"transfer must succeed\");\n    }\n\n    function distribute(uint256 _amount) public returns (uint256) {\n        require(_amount > 0, \"must be a positive value\");\n        checkAndTransferAGI(_amount);\n        totalDonation += _amount;\n        profitPerShare_ = SafeMath.add(profitPerShare_, (_amount * magnitude) / tokenSupply_);\n        emit onDistribute(msg.sender, _amount);\n    }\n\n    function buy(uint256 _amount, address _referredBy) public returns (uint256) {\n        checkAndTransferAGI(_amount);\n        return purchaseTokens(_referredBy, msg.sender, _amount);\n    }\n\n    function buyFor(uint256 _amount, address _customerAddress, address _referredBy) public returns (uint256) {\n        checkAndTransferAGI(_amount);\n        return purchaseTokens(_referredBy, _customerAddress, _amount);\n    }\n\n    function() payable public {\n        revert();\n    }\n\n    function reinvest() onlyDivis public {\n        address _customerAddress = msg.sender;\n        uint256 _dividends = myDividends(false);\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\n        _dividends += referralBalance_[_customerAddress];\n        referralBalance_[_customerAddress] = 0;\n        uint256 _tokens = purchaseTokens(0x0, _customerAddress, _dividends);\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\n    }\n\n    function exit() external {\n        address _customerAddress = msg.sender;\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n        if (_tokens > 0) sell(_tokens);\n        withdraw();\n    }\n\n    function withdraw() onlyDivis public {\n        address _customerAddress = msg.sender;\n        uint256 _dividends = myDividends(false);\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n        _dividends += referralBalance_[_customerAddress];\n        referralBalance_[_customerAddress] = 0;\n        erc20.transfer(_customerAddress, _dividends);\n        emit onWithdraw(_customerAddress, _dividends);\n    }\n\n    function sell(uint256 _amountOfTokens) onlyTokenHolders public {\n        address _customerAddress = msg.sender;\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_amountOfTokens, exitFee_), 100);\n        uint256 _taxedAGI = SafeMath.sub(_amountOfTokens, _dividends);\n\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfTokens);\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens + (_taxedAGI * magnitude));\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\n\n        if (tokenSupply_ > 0) {\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n        }\n\n        emit Transfer(_customerAddress, address(0), _amountOfTokens);\n        emit onTokenSell(_customerAddress, _amountOfTokens, _taxedAGI, now);\n    }\n\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlyTokenHolders external returns (bool){\n        address _customerAddress = msg.sender;\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n\n        if (myDividends(true) > 0) {\n            withdraw();\n        }\n\n        uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\n        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n        uint256 _dividends = _tokenFee;\n\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\n\n        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n\n        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\n\n        return true;\n    }\n\n    function setName(string _name) onlyOwner public\n    {\n       name = _name;\n    }\n\n    function setSymbol(string _symbol) onlyOwner public\n    {\n       symbol = _symbol;\n    }\n\n    function totalAgiBalance() public view returns (uint256) {\n        return erc20.balanceOf(address(this));\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return tokenSupply_;\n    }\n\n    function myTokens() public view returns (uint256) {\n        address _customerAddress = msg.sender;\n        return balanceOf(_customerAddress);\n    }\n\n    function myDividends(bool _includeReferralBonus) public view returns (uint256) {\n        address _customerAddress = msg.sender;\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n    }\n\n    function balanceOf(address _customerAddress) public view returns (uint256) {\n        return tokenBalanceLedger_[_customerAddress];\n    }\n\n    function dividendsOf(address _customerAddress) public view returns (uint256) {\n        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n    }\n\n    function sellPrice() public view returns (uint256) {\n        uint256 _agi = 1e8;\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_agi, exitFee_), 100);\n        uint256 _taxedAGI = SafeMath.sub(_agi, _dividends);\n\n        return _taxedAGI;\n    }\n\n    function buyPrice() public view returns (uint256) {\n        uint256 _agi = 1e8;\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_agi, entryFee_), 100);\n        uint256 _taxedAGI = SafeMath.add(_agi, _dividends);\n\n        return _taxedAGI;\n    }\n\n    function calculateTokensReceived(uint256 _agiToSpend) public view returns (uint256) {\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_agiToSpend, entryFee_), 100);\n        uint256 _amountOfTokens = SafeMath.sub(_agiToSpend, _dividends);\n\n        return _amountOfTokens;\n    }\n\n    function calculateAgiReceived(uint256 _tokensToSell) public view returns (uint256) {\n        require(_tokensToSell <= tokenSupply_);\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_tokensToSell, exitFee_), 100);\n        uint256 _taxedAGI = SafeMath.sub(_tokensToSell, _dividends);\n\n        return _taxedAGI;\n    }\n\n    function getInvested() public view returns (uint256) {\n        return invested_[msg.sender];\n    }\n\n    function purchaseTokens(address _referredBy, address _customerAddress, uint256 _incomingAGI) internal antiEarlyWhale(_incomingAGI, _customerAddress) returns (uint256) {\n        if (getInvested() == 0) {\n          totalHolder++;\n        }\n\n        invested_[msg.sender] += _incomingAGI;\n\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingAGI, entryFee_), 100);\n\n        uint256 _maintenance = SafeMath.div(SafeMath.mul(_undividedDividends, maintenanceFee_), 100);\n        uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, referralFee_), 100);\n\n        uint256 _dividends = SafeMath.sub(_undividedDividends, SafeMath.add(_referralBonus,_maintenance));\n        uint256 _amountOfTokens = SafeMath.sub(_incomingAGI, _undividedDividends);\n        uint256 _fee = _dividends * magnitude;\n\n        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\n\n        referralBalance_[maintenanceAddress1] = SafeMath.add(referralBalance_[maintenanceAddress1], (_maintenance/2));\n        referralBalance_[maintenanceAddress2] = SafeMath.add(referralBalance_[maintenanceAddress2], (_maintenance/2));\n\n        if (_referredBy != address(0) && _referredBy != _customerAddress && tokenBalanceLedger_[_referredBy] >= stakingRequirement) {\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n        } else {\n            _dividends = SafeMath.add(_dividends, _referralBonus);\n            _fee = _dividends * magnitude;\n        }\n\n        if (tokenSupply_ > 0) {\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n            profitPerShare_ += (_dividends * magnitude / tokenSupply_);\n            _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / tokenSupply_)));\n        } else {\n            tokenSupply_ = _amountOfTokens;\n        }\n\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens - _fee);\n        payoutsTo_[_customerAddress] += _updatedPayouts;\n\n        emit Transfer(address(0), msg.sender, _amountOfTokens);\n        emit onTokenPurchase(_customerAddress, _incomingAGI, _amountOfTokens, _referredBy, now);\n\n        return _amountOfTokens;\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_agiToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateAgiReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyAmbassadors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buyFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAgiBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maintenance\",\"type\":\"address\"}],\"name\":\"updateMaintenanceAddress2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maintenance\",\"type\":\"address\"}],\"name\":\"updateMaintenanceAddress1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDonation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"onDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingAGI\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"agiEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"agiReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"agiWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Snet","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://589ecae3740f6007678f602bda156a7fb996f33a8ccef2904b44cbdab79df22e"}]}