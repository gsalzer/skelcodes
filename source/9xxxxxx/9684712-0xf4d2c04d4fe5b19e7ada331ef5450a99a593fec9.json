{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n* Commit sha: d04b668834b9f05058f4f4e8f9b799a5e26463a1\r\n* GitHub repository: https://github.com/aragon/aragon-court\r\n* Tool used for the deploy: https://github.com/aragon/aragon-network-deploy\r\n**/\r\n\r\n// File: contracts/lib/os/ERC20.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/token/ERC20.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/lib/os/SafeERC20.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/SafeERC20.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\r\n    // https://github.com/ethereum/solidity/issues/3544\r\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferCallData = abi.encodeWithSelector(\r\n            TRANSFER_SELECTOR,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), transferCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferFromCallData = abi.encodeWithSelector(\r\n            _token.transferFrom.selector,\r\n            _from,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\r\n        bytes memory approveCallData = abi.encodeWithSelector(\r\n            _token.approve.selector,\r\n            _spender,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), approveCallData);\r\n    }\r\n\r\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata) private returns (bool) {\r\n        bool ret;\r\n        assembly {\r\n            let ptr := mload(0x40)    // free memory pointer\r\n\r\n            let success := call(\r\n                gas,                  // forward all gas\r\n                _addr,                // address\r\n                0,                    // no value\r\n                add(_calldata, 0x20), // calldata start\r\n                mload(_calldata),     // calldata length\r\n                ptr,                  // write output over free memory\r\n                0x20                  // uint256 return\r\n            )\r\n\r\n            if gt(success, 0) {\r\n            // Check number of bytes returned from last function call\r\n                switch returndatasize\r\n\r\n                // No bytes returned: assume success\r\n                case 0 {\r\n                    ret := 1\r\n                }\r\n\r\n                // 32 bytes returned: check if non-zero\r\n                case 0x20 {\r\n                // Only return success if returned data was true\r\n                // Already have output in ptr\r\n                    ret := eq(mload(ptr), 1)\r\n                }\r\n\r\n                // Not sure what was returned: don't mark as success\r\n                default { }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/SafeMath.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/SafeMath64.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath64.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title SafeMath64\r\n * @dev Math operations for uint64 with safety checks that revert on error\r\n */\r\nlibrary SafeMath64 {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH64_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH64_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH64_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH64_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        uint256 c = uint256(_a) * uint256(_b);\r\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\r\n\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint64 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint64 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        uint64 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/Uint256Helpers.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Uint256Helpers.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\nlibrary Uint256Helpers {\r\n    uint256 private constant MAX_UINT8 = uint8(-1);\r\n    uint256 private constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_UINT8_NUMBER_TOO_BIG = \"UINT8_NUMBER_TOO_BIG\";\r\n    string private constant ERROR_UINT64_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\r\n\r\n    function toUint8(uint256 a) internal pure returns (uint8) {\r\n        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\r\n        return uint8(a);\r\n    }\r\n\r\n    function toUint64(uint256 a) internal pure returns (uint64) {\r\n        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\r\n        return uint64(a);\r\n    }\r\n}\r\n\r\n// File: contracts/arbitration/IArbitrator.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface IArbitrator {\r\n    /**\r\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\r\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\r\n\r\n    /**\r\n    * @dev Close the evidence period of a dispute\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Execute the Arbitrable associated to a dispute based on its final ruling\r\n    * @param _disputeId Identification number of the dispute to be executed\r\n    */\r\n    function executeRuling(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Tell the dispute fees information to create a dispute\r\n    * @return recipient Address where the corresponding dispute fees must be transferred to\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\r\n    */\r\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\r\n\r\n    /**\r\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\r\n    * @param _subscriber Address of the account paying the subscription fees for\r\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\r\n    * @return feeToken ERC20 token used for the subscription fees\r\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\r\n    */\r\n    function getSubscriptionFees(address _subscriber) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\r\n}\r\n\r\n// File: contracts/standards/ERC165.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ninterface ERC165 {\r\n    /**\r\n    * @dev Query if a contract implements a certain interface\r\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\r\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\r\n    */\r\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool);\r\n}\r\n\r\n// File: contracts/arbitration/IArbitrable.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\ncontract IArbitrable is ERC165 {\r\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\r\n    bytes4 internal constant ARBITRABLE_INTERFACE_ID = bytes4(0x88f3ee69);\r\n\r\n    /**\r\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\r\n    * @param arbitrator IArbitrator instance ruling the dispute\r\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\r\n    * @param ruling Ruling given by the arbitrator\r\n    */\r\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\r\n\r\n    /**\r\n    * @dev Emitted when new evidence is submitted for the IArbitrable instance's dispute\r\n    * @param disputeId Identification number of the dispute receiving new evidence\r\n    * @param submitter Address of the account submitting the evidence\r\n    * @param evidence Data submitted for the evidence of the dispute\r\n    * @param finished Whether or not the submitter has finished submitting evidence\r\n    */\r\n    event EvidenceSubmitted(uint256 indexed disputeId, address indexed submitter, bytes evidence, bool finished);\r\n\r\n    /**\r\n    * @dev Submit evidence for a dispute\r\n    * @param _disputeId Id of the dispute in the Court\r\n    * @param _evidence Data submitted for the evidence related to the dispute\r\n    * @param _finished Whether or not the submitter has finished submitting evidence\r\n    */\r\n    function submitEvidence(uint256 _disputeId, bytes calldata _evidence, bool _finished) external;\r\n\r\n    /**\r\n    * @dev Give a ruling for a certain dispute, the account calling it must have rights to rule on the contract\r\n    * @param _disputeId Identification number of the dispute to be ruled\r\n    * @param _ruling Ruling given by the arbitrator, where 0 is reserved for \"refused to make a decision\"\r\n    */\r\n    function rule(uint256 _disputeId, uint256 _ruling) external;\r\n\r\n    /**\r\n    * @dev ERC165 - Query if a contract implements a certain interface\r\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\r\n    * @return True if this contract supports the given interface, false otherwise\r\n    */\r\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\r\n        return _interfaceId == ARBITRABLE_INTERFACE_ID || _interfaceId == ERC165_INTERFACE_ID;\r\n    }\r\n}\r\n\r\n// File: contracts/disputes/IDisputeManager.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\ninterface IDisputeManager {\r\n    enum DisputeState {\r\n        PreDraft,\r\n        Adjudicating,\r\n        Ruled\r\n    }\r\n\r\n    enum AdjudicationState {\r\n        Invalid,\r\n        Committing,\r\n        Revealing,\r\n        Appealing,\r\n        ConfirmingAppeal,\r\n        Ended\r\n    }\r\n\r\n    /**\r\n    * @dev Create a dispute to be drafted in a future term\r\n    * @param _subject Arbitrable instance creating the dispute\r\n    * @param _possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(IArbitrable _subject, uint8 _possibleRulings, bytes calldata _metadata) external returns (uint256);\r\n\r\n    /**\r\n    * @dev Close the evidence period of a dispute\r\n    * @param _subject IArbitrable instance requesting to close the evidence submission period\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(IArbitrable _subject, uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Draft jurors for the next round of a dispute\r\n    * @param _disputeId Identification number of the dispute to be drafted\r\n    */\r\n    function draft(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Appeal round of a dispute in favor of a certain ruling\r\n    * @param _disputeId Identification number of the dispute being appealed\r\n    * @param _roundId Identification number of the dispute round being appealed\r\n    * @param _ruling Ruling appealing a dispute round in favor of\r\n    */\r\n    function createAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\r\n\r\n    /**\r\n    * @dev Confirm appeal for a round of a dispute in favor of a ruling\r\n    * @param _disputeId Identification number of the dispute confirming an appeal of\r\n    * @param _roundId Identification number of the dispute round confirming an appeal of\r\n    * @param _ruling Ruling being confirmed against a dispute round appeal\r\n    */\r\n    function confirmAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\r\n\r\n    /**\r\n    * @dev Compute the final ruling for a dispute\r\n    * @param _disputeId Identification number of the dispute to compute its final ruling\r\n    * @return subject Arbitrable instance associated to the dispute\r\n    * @return finalRuling Final ruling decided for the given dispute\r\n    */\r\n    function computeRuling(uint256 _disputeId) external returns (IArbitrable subject, uint8 finalRuling);\r\n\r\n    /**\r\n    * @dev Settle penalties for a round of a dispute\r\n    * @param _disputeId Identification number of the dispute to settle penalties for\r\n    * @param _roundId Identification number of the dispute round to settle penalties for\r\n    * @param _jurorsToSettle Maximum number of jurors to be slashed in this call\r\n    */\r\n    function settlePenalties(uint256 _disputeId, uint256 _roundId, uint256 _jurorsToSettle) external;\r\n\r\n    /**\r\n    * @dev Claim rewards for a round of a dispute for juror\r\n    * @dev For regular rounds, it will only reward winning jurors\r\n    * @param _disputeId Identification number of the dispute to settle rewards for\r\n    * @param _roundId Identification number of the dispute round to settle rewards for\r\n    * @param _juror Address of the juror to settle their rewards\r\n    */\r\n    function settleReward(uint256 _disputeId, uint256 _roundId, address _juror) external;\r\n\r\n    /**\r\n    * @dev Settle appeal deposits for a round of a dispute\r\n    * @param _disputeId Identification number of the dispute to settle appeal deposits for\r\n    * @param _roundId Identification number of the dispute round to settle appeal deposits for\r\n    */\r\n    function settleAppealDeposit(uint256 _disputeId, uint256 _roundId) external;\r\n\r\n    /**\r\n    * @dev Tell the amount of token fees required to create a dispute\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return feeAmount Total amount of fees to be paid for a dispute at the given term\r\n    */\r\n    function getDisputeFees() external view returns (ERC20 feeToken, uint256 feeAmount);\r\n\r\n    /**\r\n    * @dev Tell information of a certain dispute\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @return subject Arbitrable subject being disputed\r\n    * @return possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\r\n    * @return state Current state of the dispute being queried: pre-draft, adjudicating, or ruled\r\n    * @return finalRuling The winning ruling in case the dispute is finished\r\n    * @return lastRoundId Identification number of the last round created for the dispute\r\n    * @return createTermId Identification number of the term when the dispute was created\r\n    */\r\n    function getDispute(uint256 _disputeId) external view\r\n        returns (IArbitrable subject, uint8 possibleRulings, DisputeState state, uint8 finalRuling, uint256 lastRoundId, uint64 createTermId);\r\n\r\n    /**\r\n    * @dev Tell information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @return draftTerm Term from which the requested round can be drafted\r\n    * @return delayedTerms Number of terms the given round was delayed based on its requested draft term id\r\n    * @return jurorsNumber Number of jurors requested for the round\r\n    * @return selectedJurors Number of jurors already selected for the requested round\r\n    * @return settledPenalties Whether or not penalties have been settled for the requested round\r\n    * @return collectedTokens Amount of juror tokens that were collected from slashed jurors for the requested round\r\n    * @return coherentJurors Number of jurors that voted in favor of the final ruling in the requested round\r\n    * @return state Adjudication state of the requested round\r\n    */\r\n    function getRound(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (\r\n            uint64 draftTerm,\r\n            uint64 delayedTerms,\r\n            uint64 jurorsNumber,\r\n            uint64 selectedJurors,\r\n            uint256 jurorFees,\r\n            bool settledPenalties,\r\n            uint256 collectedTokens,\r\n            uint64 coherentJurors,\r\n            AdjudicationState state\r\n        );\r\n\r\n    /**\r\n    * @dev Tell appeal-related information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @return maker Address of the account appealing the given round\r\n    * @return appealedRuling Ruling confirmed by the appealer of the given round\r\n    * @return taker Address of the account confirming the appeal of the given round\r\n    * @return opposedRuling Ruling confirmed by the appeal taker of the given round\r\n    */\r\n    function getAppeal(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (address maker, uint64 appealedRuling, address taker, uint64 opposedRuling);\r\n\r\n    /**\r\n    * @dev Tell information related to the next round due to an appeal of a certain round given.\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round requesting the appeal details of\r\n    * @return nextRoundStartTerm Term ID from which the next round will start\r\n    * @return nextRoundJurorsNumber Jurors number for the next round\r\n    * @return newDisputeState New state for the dispute associated to the given round after the appeal\r\n    * @return feeToken ERC20 token used for the next round fees\r\n    * @return jurorFees Total amount of fees to be distributed between the winning jurors of the next round\r\n    * @return totalFees Total amount of fees for a regular round at the given term\r\n    * @return appealDeposit Amount to be deposit of fees for a regular round at the given term\r\n    * @return confirmAppealDeposit Total amount of fees for a regular round at the given term\r\n    */\r\n    function getNextRoundDetails(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (\r\n            uint64 nextRoundStartTerm,\r\n            uint64 nextRoundJurorsNumber,\r\n            DisputeState newDisputeState,\r\n            ERC20 feeToken,\r\n            uint256 totalFees,\r\n            uint256 jurorFees,\r\n            uint256 appealDeposit,\r\n            uint256 confirmAppealDeposit\r\n        );\r\n\r\n    /**\r\n    * @dev Tell juror-related information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @param _juror Address of the juror being queried\r\n    * @return weight Juror weight drafted for the requested round\r\n    * @return rewarded Whether or not the given juror was rewarded based on the requested round\r\n    */\r\n    function getJuror(uint256 _disputeId, uint256 _roundId, address _juror) external view returns (uint64 weight, bool rewarded);\r\n}\r\n\r\n// File: contracts/lib/PctHelpers.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\nlibrary PctHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant PCT_BASE = 10000; // ‱ (1 / 10,000)\r\n\r\n    function isValid(uint16 _pct) internal pure returns (bool) {\r\n        return _pct <= PCT_BASE;\r\n    }\r\n\r\n    function pct(uint256 self, uint16 _pct) internal pure returns (uint256) {\r\n        return self.mul(uint256(_pct)) / PCT_BASE;\r\n    }\r\n\r\n    function pct256(uint256 self, uint256 _pct) internal pure returns (uint256) {\r\n        return self.mul(_pct) / PCT_BASE;\r\n    }\r\n\r\n    function pctIncrease(uint256 self, uint16 _pct) internal pure returns (uint256) {\r\n        // No need for SafeMath: for addition note that `PCT_BASE` is lower than (2^256 - 2^16)\r\n        return self.mul(PCT_BASE + uint256(_pct)) / PCT_BASE;\r\n    }\r\n}\r\n\r\n// File: contracts/voting/ICRVotingOwner.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ninterface ICRVotingOwner {\r\n    /**\r\n    * @dev Ensure votes can be committed for a vote instance, revert otherwise\r\n    * @param _voteId ID of the vote instance to request the weight of a voter for\r\n    */\r\n    function ensureCanCommit(uint256 _voteId) external;\r\n\r\n    /**\r\n    * @dev Ensure a certain voter can commit votes for a vote instance, revert otherwise\r\n    * @param _voteId ID of the vote instance to request the weight of a voter for\r\n    * @param _voter Address of the voter querying the weight of\r\n    */\r\n    function ensureCanCommit(uint256 _voteId, address _voter) external;\r\n\r\n    /**\r\n    * @dev Ensure a certain voter can reveal votes for vote instance, revert otherwise\r\n    * @param _voteId ID of the vote instance to request the weight of a voter for\r\n    * @param _voter Address of the voter querying the weight of\r\n    * @return Weight of the requested juror for the requested vote instance\r\n    */\r\n    function ensureCanReveal(uint256 _voteId, address _voter) external returns (uint64);\r\n}\r\n\r\n// File: contracts/voting/ICRVoting.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface ICRVoting {\r\n    /**\r\n    * @dev Create a new vote instance\r\n    * @dev This function can only be called by the CRVoting owner\r\n    * @param _voteId ID of the new vote instance to be created\r\n    * @param _possibleOutcomes Number of possible outcomes for the new vote instance to be created\r\n    */\r\n    function create(uint256 _voteId, uint8 _possibleOutcomes) external;\r\n\r\n    /**\r\n    * @dev Get the winning outcome of a vote instance\r\n    * @param _voteId ID of the vote instance querying the winning outcome of\r\n    * @return Winning outcome of the given vote instance or refused in case it's missing\r\n    */\r\n    function getWinningOutcome(uint256 _voteId) external view returns (uint8);\r\n\r\n    /**\r\n    * @dev Get the tally of an outcome for a certain vote instance\r\n    * @param _voteId ID of the vote instance querying the tally of\r\n    * @param _outcome Outcome querying the tally of\r\n    * @return Tally of the outcome being queried for the given vote instance\r\n    */\r\n    function getOutcomeTally(uint256 _voteId, uint8 _outcome) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell whether an outcome is valid for a given vote instance or not\r\n    * @param _voteId ID of the vote instance to check the outcome of\r\n    * @param _outcome Outcome to check if valid or not\r\n    * @return True if the given outcome is valid for the requested vote instance, false otherwise\r\n    */\r\n    function isValidOutcome(uint256 _voteId, uint8 _outcome) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Get the outcome voted by a voter for a certain vote instance\r\n    * @param _voteId ID of the vote instance querying the outcome of\r\n    * @param _voter Address of the voter querying the outcome of\r\n    * @return Outcome of the voter for the given vote instance\r\n    */\r\n    function getVoterOutcome(uint256 _voteId, address _voter) external view returns (uint8);\r\n\r\n    /**\r\n    * @dev Tell whether a voter voted in favor of a certain outcome in a vote instance or not\r\n    * @param _voteId ID of the vote instance to query if a voter voted in favor of a certain outcome\r\n    * @param _outcome Outcome to query if the given voter voted in favor of\r\n    * @param _voter Address of the voter to query if voted in favor of the given outcome\r\n    * @return True if the given voter voted in favor of the given outcome, false otherwise\r\n    */\r\n    function hasVotedInFavorOf(uint256 _voteId, uint8 _outcome, address _voter) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Filter a list of voters based on whether they voted in favor of a certain outcome in a vote instance or not\r\n    * @param _voteId ID of the vote instance to be checked\r\n    * @param _outcome Outcome to filter the list of voters of\r\n    * @param _voters List of addresses of the voters to be filtered\r\n    * @return List of results to tell whether a voter voted in favor of the given outcome or not\r\n    */\r\n    function getVotersInFavorOf(uint256 _voteId, uint8 _outcome, address[] calldata _voters) external view returns (bool[] memory);\r\n}\r\n\r\n// File: contracts/treasury/ITreasury.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface ITreasury {\r\n    /**\r\n    * @dev Assign a certain amount of tokens to an account\r\n    * @param _token ERC20 token to be assigned\r\n    * @param _to Address of the recipient that will be assigned the tokens to\r\n    * @param _amount Amount of tokens to be assigned to the recipient\r\n    */\r\n    function assign(ERC20 _token, address _to, uint256 _amount) external;\r\n\r\n    /**\r\n    * @dev Withdraw a certain amount of tokens\r\n    * @param _token ERC20 token to be withdrawn\r\n    * @param _to Address of the recipient that will receive the tokens\r\n    * @param _amount Amount of tokens to be withdrawn from the sender\r\n    */\r\n    function withdraw(ERC20 _token, address _to, uint256 _amount) external;\r\n}\r\n\r\n// File: contracts/registry/IJurorsRegistry.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface IJurorsRegistry {\r\n\r\n    /**\r\n    * @dev Assign a requested amount of juror tokens to a juror\r\n    * @param _juror Juror to add an amount of tokens to\r\n    * @param _amount Amount of tokens to be added to the available balance of a juror\r\n    */\r\n    function assignTokens(address _juror, uint256 _amount) external;\r\n\r\n    /**\r\n    * @dev Burn a requested amount of juror tokens\r\n    * @param _amount Amount of tokens to be burned\r\n    */\r\n    function burnTokens(uint256 _amount) external;\r\n\r\n    /**\r\n    * @dev Draft a set of jurors based on given requirements for a term id\r\n    * @param _params Array containing draft requirements:\r\n    *        0. bytes32 Term randomness\r\n    *        1. uint256 Dispute id\r\n    *        2. uint64  Current term id\r\n    *        3. uint256 Number of seats already filled\r\n    *        4. uint256 Number of seats left to be filled\r\n    *        5. uint64  Number of jurors required for the draft\r\n    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\r\n    *\r\n    * @return jurors List of jurors selected for the draft\r\n    * @return length Size of the list of the draft result\r\n    */\r\n    function draft(uint256[7] calldata _params) external returns (address[] memory jurors, uint256 length);\r\n\r\n    /**\r\n    * @dev Slash a set of jurors based on their votes compared to the winning ruling\r\n    * @param _termId Current term id\r\n    * @param _jurors List of juror addresses to be slashed\r\n    * @param _lockedAmounts List of amounts locked for each corresponding juror that will be either slashed or returned\r\n    * @param _rewardedJurors List of booleans to tell whether a juror's active balance has to be slashed or not\r\n    * @return Total amount of slashed tokens\r\n    */\r\n    function slashOrUnlock(uint64 _termId, address[] calldata _jurors, uint256[] calldata _lockedAmounts, bool[] calldata _rewardedJurors)\r\n        external\r\n        returns (uint256 collectedTokens);\r\n\r\n    /**\r\n    * @dev Try to collect a certain amount of tokens from a juror for the next term\r\n    * @param _juror Juror to collect the tokens from\r\n    * @param _amount Amount of tokens to be collected from the given juror and for the requested term id\r\n    * @param _termId Current term id\r\n    * @return True if the juror has enough unlocked tokens to be collected for the requested term, false otherwise\r\n    */\r\n    function collectTokens(address _juror, uint256 _amount, uint64 _termId) external returns (bool);\r\n\r\n    /**\r\n    * @dev Lock a juror's withdrawals until a certain term ID\r\n    * @param _juror Address of the juror to be locked\r\n    * @param _termId Term ID until which the juror's withdrawals will be locked\r\n    */\r\n    function lockWithdrawals(address _juror, uint64 _termId) external;\r\n\r\n    /**\r\n    * @dev Tell the active balance of a juror for a given term id\r\n    * @param _juror Address of the juror querying the active balance of\r\n    * @param _termId Term ID querying the active balance for\r\n    * @return Amount of active tokens for juror in the requested past term id\r\n    */\r\n    function activeBalanceOfAt(address _juror, uint64 _termId) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell the total amount of active juror tokens at the given term id\r\n    * @param _termId Term ID querying the total active balance for\r\n    * @return Total amount of active juror tokens at the given term id\r\n    */\r\n    function totalActiveBalanceAt(uint64 _termId) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/subscriptions/ISubscriptions.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface ISubscriptions {\r\n    /**\r\n    * @dev Tell whether a certain subscriber has paid all the fees up to current period or not\r\n    * @param _subscriber Address of subscriber being checked\r\n    * @return True if subscriber has paid all the fees up to current period, false otherwise\r\n    */\r\n    function isUpToDate(address _subscriber) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Tell the minimum amount of fees to pay and resulting last paid period for a given subscriber in order to be up-to-date\r\n    * @param _subscriber Address of the subscriber willing to pay\r\n    * @return feeToken ERC20 token used for the subscription fees\r\n    * @return amountToPay Amount of subscription fee tokens to be paid\r\n    * @return newLastPeriodId Identification number of the resulting last paid period\r\n    */\r\n    function getOwedFeesDetails(address _subscriber) external view returns (ERC20, uint256, uint256);\r\n}\r\n\r\n// File: contracts/lib/os/IsContract.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/IsContract.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ncontract IsContract {\r\n    /*\r\n    * NOTE: this should NEVER be used for authentication\r\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\r\n    *\r\n    * This is only intended to be used as a sanity check that an address is actually a contract,\r\n    * RATHER THAN an address not being a contract.\r\n    */\r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := extcodesize(_target) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/TimeHelpers.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/TimeHelpers.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ncontract TimeHelpers {\r\n    using Uint256Helpers for uint256;\r\n\r\n    /**\r\n    * @dev Returns the current block number.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current block number, converted to uint64.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber64() internal view returns (uint64) {\r\n        return getBlockNumber().toUint64();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp() internal view returns (uint256) {\r\n        return block.timestamp; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp, converted to uint64.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp64() internal view returns (uint64) {\r\n        return getTimestamp().toUint64();\r\n    }\r\n}\r\n\r\n// File: contracts/court/clock/IClock.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ninterface IClock {\r\n    /**\r\n    * @dev Ensure that the current term of the clock is up-to-date\r\n    * @return Identification number of the current term\r\n    */\r\n    function ensureCurrentTerm() external returns (uint64);\r\n\r\n    /**\r\n    * @dev Transition up to a certain number of terms to leave the clock up-to-date\r\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\r\n    * @return Identification number of the term ID after executing the heartbeat transitions\r\n    */\r\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64);\r\n\r\n    /**\r\n    * @dev Ensure that a certain term has its randomness set\r\n    * @return Randomness of the current term\r\n    */\r\n    function ensureCurrentTermRandomness() external returns (bytes32);\r\n\r\n    /**\r\n    * @dev Tell the last ensured term identification number\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function getLastEnsuredTermId() external view returns (uint64);\r\n\r\n    /**\r\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\r\n    * @return Identification number of the current term\r\n    */\r\n    function getCurrentTermId() external view returns (uint64);\r\n\r\n    /**\r\n    * @dev Tell the number of terms the clock should transition to be up-to-date\r\n    * @return Number of terms the clock should transition to be up-to-date\r\n    */\r\n    function getNeededTermTransitions() external view returns (uint64);\r\n\r\n    /**\r\n    * @dev Tell the information related to a term based on its ID\r\n    * @param _termId ID of the term being queried\r\n    * @return startTime Term start time\r\n    * @return randomnessBN Block number used for randomness in the requested term\r\n    * @return randomness Randomness computed for the requested term\r\n    */\r\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness);\r\n\r\n    /**\r\n    * @dev Tell the randomness of a term even if it wasn't computed yet\r\n    * @param _termId Identification number of the term being queried\r\n    * @return Randomness of the requested term\r\n    */\r\n    function getTermRandomness(uint64 _termId) external view returns (bytes32);\r\n}\r\n\r\n// File: contracts/court/clock/CourtClock.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\ncontract CourtClock is IClock, TimeHelpers {\r\n    using SafeMath64 for uint64;\r\n\r\n    string private constant ERROR_TERM_DOES_NOT_EXIST = \"CLK_TERM_DOES_NOT_EXIST\";\r\n    string private constant ERROR_TERM_DURATION_TOO_LONG = \"CLK_TERM_DURATION_TOO_LONG\";\r\n    string private constant ERROR_TERM_RANDOMNESS_NOT_YET = \"CLK_TERM_RANDOMNESS_NOT_YET\";\r\n    string private constant ERROR_TERM_RANDOMNESS_UNAVAILABLE = \"CLK_TERM_RANDOMNESS_UNAVAILABLE\";\r\n    string private constant ERROR_BAD_FIRST_TERM_START_TIME = \"CLK_BAD_FIRST_TERM_START_TIME\";\r\n    string private constant ERROR_TOO_MANY_TRANSITIONS = \"CLK_TOO_MANY_TRANSITIONS\";\r\n    string private constant ERROR_INVALID_TRANSITION_TERMS = \"CLK_INVALID_TRANSITION_TERMS\";\r\n    string private constant ERROR_CANNOT_DELAY_STARTED_COURT = \"CLK_CANNOT_DELAY_STARTED_COURT\";\r\n    string private constant ERROR_CANNOT_DELAY_PAST_START_TIME = \"CLK_CANNOT_DELAY_PAST_START_TIME\";\r\n\r\n    // Maximum number of term transitions a callee may have to assume in order to call certain functions that require the Court being up-to-date\r\n    uint64 internal constant MAX_AUTO_TERM_TRANSITIONS_ALLOWED = 1;\r\n\r\n    // Max duration in seconds that a term can last\r\n    uint64 internal constant MAX_TERM_DURATION = 365 days;\r\n\r\n    // Max time until first term starts since contract is deployed\r\n    uint64 internal constant MAX_FIRST_TERM_DELAY_PERIOD = 2 * MAX_TERM_DURATION;\r\n\r\n    struct Term {\r\n        uint64 startTime;              // Timestamp when the term started\r\n        uint64 randomnessBN;           // Block number for entropy\r\n        bytes32 randomness;            // Entropy from randomnessBN block hash\r\n    }\r\n\r\n    // Duration in seconds for each term of the Court\r\n    uint64 private termDuration;\r\n\r\n    // Last ensured term id\r\n    uint64 private termId;\r\n\r\n    // List of Court terms indexed by id\r\n    mapping (uint64 => Term) private terms;\r\n\r\n    event Heartbeat(uint64 previousTermId, uint64 currentTermId);\r\n    event StartTimeDelayed(uint64 previousStartTime, uint64 currentStartTime);\r\n\r\n    /**\r\n    * @dev Ensure a certain term has already been processed\r\n    * @param _termId Identification number of the term to be checked\r\n    */\r\n    modifier termExists(uint64 _termId) {\r\n        require(_termId <= termId, ERROR_TERM_DOES_NOT_EXIST);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _termParams Array containing:\r\n    *        0. _termDuration Duration in seconds per term\r\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for juror on-boarding)\r\n    */\r\n    constructor(uint64[2] memory _termParams) public {\r\n        uint64 _termDuration = _termParams[0];\r\n        uint64 _firstTermStartTime = _termParams[1];\r\n\r\n        require(_termDuration < MAX_TERM_DURATION, ERROR_TERM_DURATION_TOO_LONG);\r\n        require(_firstTermStartTime >= getTimestamp64() + _termDuration, ERROR_BAD_FIRST_TERM_START_TIME);\r\n        require(_firstTermStartTime <= getTimestamp64() + MAX_FIRST_TERM_DELAY_PERIOD, ERROR_BAD_FIRST_TERM_START_TIME);\r\n\r\n        termDuration = _termDuration;\r\n\r\n        // No need for SafeMath: we already checked values above\r\n        terms[0].startTime = _firstTermStartTime - _termDuration;\r\n    }\r\n\r\n    /**\r\n    * @notice Ensure that the current term of the Court is up-to-date. If the Court is outdated by more than `MAX_AUTO_TERM_TRANSITIONS_ALLOWED`\r\n    *         terms, the heartbeat function must be called manually instead.\r\n    * @return Identification number of the current term\r\n    */\r\n    function ensureCurrentTerm() external returns (uint64) {\r\n        return _ensureCurrentTerm();\r\n    }\r\n\r\n    /**\r\n    * @notice Transition up to `_maxRequestedTransitions` terms\r\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\r\n    * @return Identification number of the term ID after executing the heartbeat transitions\r\n    */\r\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64) {\r\n        return _heartbeat(_maxRequestedTransitions);\r\n    }\r\n\r\n    /**\r\n    * @notice Ensure that a certain term has its randomness set. As we allow to draft disputes requested for previous terms, if there\r\n    *      were mined more than 256 blocks for the current term, the blockhash of its randomness BN is no longer available, given\r\n    *      round will be able to be drafted in the following term.\r\n    * @return Randomness of the current term\r\n    */\r\n    function ensureCurrentTermRandomness() external returns (bytes32) {\r\n        // If the randomness for the given term was already computed, return\r\n        uint64 currentTermId = termId;\r\n        Term storage term = terms[currentTermId];\r\n        bytes32 termRandomness = term.randomness;\r\n        if (termRandomness != bytes32(0)) {\r\n            return termRandomness;\r\n        }\r\n\r\n        // Compute term randomness\r\n        bytes32 newRandomness = _computeTermRandomness(currentTermId);\r\n        require(newRandomness != bytes32(0), ERROR_TERM_RANDOMNESS_UNAVAILABLE);\r\n        term.randomness = newRandomness;\r\n        return newRandomness;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the term duration of the Court\r\n    * @return Duration in seconds of the Court term\r\n    */\r\n    function getTermDuration() external view returns (uint64) {\r\n        return termDuration;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the last ensured term identification number\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function getLastEnsuredTermId() external view returns (uint64) {\r\n        return _lastEnsuredTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\r\n    * @return Identification number of the current term\r\n    */\r\n    function getCurrentTermId() external view returns (uint64) {\r\n        return _currentTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the number of terms the Court should transition to be up-to-date\r\n    * @return Number of terms the Court should transition to be up-to-date\r\n    */\r\n    function getNeededTermTransitions() external view returns (uint64) {\r\n        return _neededTermTransitions();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the information related to a term based on its ID. Note that if the term has not been reached, the\r\n    *      information returned won't be computed yet. This function allows querying future terms that were not computed yet.\r\n    * @param _termId ID of the term being queried\r\n    * @return startTime Term start time\r\n    * @return randomnessBN Block number used for randomness in the requested term\r\n    * @return randomness Randomness computed for the requested term\r\n    */\r\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness) {\r\n        Term storage term = terms[_termId];\r\n        return (term.startTime, term.randomnessBN, term.randomness);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the randomness of a term even if it wasn't computed yet\r\n    * @param _termId Identification number of the term being queried\r\n    * @return Randomness of the requested term\r\n    */\r\n    function getTermRandomness(uint64 _termId) external view termExists(_termId) returns (bytes32) {\r\n        return _computeTermRandomness(_termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to ensure that the current term of the Court is up-to-date. If the Court is outdated by more than\r\n    *      `MAX_AUTO_TERM_TRANSITIONS_ALLOWED` terms, the heartbeat function must be called manually.\r\n    * @return Identification number of the resultant term ID after executing the corresponding transitions\r\n    */\r\n    function _ensureCurrentTerm() internal returns (uint64) {\r\n        // Check the required number of transitions does not exceeds the max allowed number to be processed automatically\r\n        uint64 requiredTransitions = _neededTermTransitions();\r\n        require(requiredTransitions <= MAX_AUTO_TERM_TRANSITIONS_ALLOWED, ERROR_TOO_MANY_TRANSITIONS);\r\n\r\n        // If there are no transitions pending, return the last ensured term id\r\n        if (uint256(requiredTransitions) == 0) {\r\n            return termId;\r\n        }\r\n\r\n        // Process transition if there is at least one pending\r\n        return _heartbeat(requiredTransitions);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to transition the Court terms up to a requested number of terms\r\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\r\n    * @return Identification number of the resultant term ID after executing the requested transitions\r\n    */\r\n    function _heartbeat(uint64 _maxRequestedTransitions) internal returns (uint64) {\r\n        // Transition the minimum number of terms between the amount requested and the amount actually needed\r\n        uint64 neededTransitions = _neededTermTransitions();\r\n        uint256 transitions = uint256(_maxRequestedTransitions < neededTransitions ? _maxRequestedTransitions : neededTransitions);\r\n        require(transitions > 0, ERROR_INVALID_TRANSITION_TERMS);\r\n\r\n        uint64 blockNumber = getBlockNumber64();\r\n        uint64 previousTermId = termId;\r\n        uint64 currentTermId = previousTermId;\r\n        for (uint256 transition = 1; transition <= transitions; transition++) {\r\n            // Term IDs are incremented by one based on the number of time periods since the Court started. Since time is represented in uint64,\r\n            // even if we chose the minimum duration possible for a term (1 second), we can ensure terms will never reach 2^64 since time is\r\n            // already assumed to fit in uint64.\r\n            Term storage previousTerm = terms[currentTermId++];\r\n            Term storage currentTerm = terms[currentTermId];\r\n            _onTermTransitioned(currentTermId);\r\n\r\n            // Set the start time of the new term. Note that we are using a constant term duration value to guarantee\r\n            // equally long terms, regardless of heartbeats.\r\n            currentTerm.startTime = previousTerm.startTime.add(termDuration);\r\n\r\n            // In order to draft a random number of jurors in a term, we use a randomness factor for each term based on a\r\n            // block number that is set once the term has started. Note that this information could not be known beforehand.\r\n            currentTerm.randomnessBN = blockNumber + 1;\r\n        }\r\n\r\n        termId = currentTermId;\r\n        emit Heartbeat(previousTermId, currentTermId);\r\n        return currentTermId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to delay the first term start time only if it wasn't reached yet\r\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\r\n    */\r\n    function _delayStartTime(uint64 _newFirstTermStartTime) internal {\r\n        require(_currentTermId() == 0, ERROR_CANNOT_DELAY_STARTED_COURT);\r\n\r\n        Term storage term = terms[0];\r\n        uint64 currentFirstTermStartTime = term.startTime.add(termDuration);\r\n        require(_newFirstTermStartTime > currentFirstTermStartTime, ERROR_CANNOT_DELAY_PAST_START_TIME);\r\n\r\n        // No need for SafeMath: we already checked above that `_newFirstTermStartTime` > `currentFirstTermStartTime` >= `termDuration`\r\n        term.startTime = _newFirstTermStartTime - termDuration;\r\n        emit StartTimeDelayed(currentFirstTermStartTime, _newFirstTermStartTime);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to notify when a term has been transitioned. This function must be overridden to provide custom behavior.\r\n    * @param _termId Identification number of the new current term that has been transitioned\r\n    */\r\n    function _onTermTransitioned(uint64 _termId) internal;\r\n\r\n    /**\r\n    * @dev Internal function to tell the last ensured term identification number\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function _lastEnsuredTermId() internal view returns (uint64) {\r\n        return termId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the current term identification number. Note that there may be pending term transitions.\r\n    * @return Identification number of the current term\r\n    */\r\n    function _currentTermId() internal view returns (uint64) {\r\n        return termId.add(_neededTermTransitions());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the number of terms the Court should transition to be up-to-date\r\n    * @return Number of terms the Court should transition to be up-to-date\r\n    */\r\n    function _neededTermTransitions() internal view returns (uint64) {\r\n        // Note that the Court is always initialized providing a start time for the first-term in the future. If that's the case,\r\n        // no term transitions are required.\r\n        uint64 currentTermStartTime = terms[termId].startTime;\r\n        if (getTimestamp64() < currentTermStartTime) {\r\n            return uint64(0);\r\n        }\r\n\r\n        // No need for SafeMath: we already know that the start time of the current term is in the past\r\n        return (getTimestamp64() - currentTermStartTime) / termDuration;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to compute the randomness that will be used to draft jurors for the given term. This\r\n    *      function assumes the given term exists. To determine the randomness factor for a term we use the hash of a\r\n    *      block number that is set once the term has started to ensure it cannot be known beforehand. Note that the\r\n    *      hash function being used only works for the 256 most recent block numbers.\r\n    * @param _termId Identification number of the term being queried\r\n    * @return Randomness computed for the given term\r\n    */\r\n    function _computeTermRandomness(uint64 _termId) internal view returns (bytes32) {\r\n        Term storage term = terms[_termId];\r\n        require(getBlockNumber64() > term.randomnessBN, ERROR_TERM_RANDOMNESS_NOT_YET);\r\n        return blockhash(term.randomnessBN);\r\n    }\r\n}\r\n\r\n// File: contracts/court/config/IConfig.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ninterface IConfig {\r\n\r\n    /**\r\n    * @dev Tell the full Court configuration parameters at a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @return minActiveBalance Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getConfig(uint64 _termId) external view\r\n        returns (\r\n            ERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        );\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    */\r\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\r\n\r\n    /**\r\n    * @dev Tell the min active balance config at a certain term\r\n    * @param _termId Term querying the min active balance config of\r\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell whether a certain holder accepts automatic withdrawals of tokens or not\r\n    * @return True if the given holder accepts automatic withdrawals of their tokens, false otherwise\r\n    */\r\n    function areWithdrawalsAllowedFor(address _holder) external view returns (bool);\r\n}\r\n\r\n// File: contracts/court/config/CourtConfigData.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ncontract CourtConfigData {\r\n    struct Config {\r\n        FeesConfig fees;                        // Full fees-related config\r\n        DisputesConfig disputes;                // Full disputes-related config\r\n        uint256 minActiveBalance;               // Minimum amount of tokens jurors have to activate to participate in the Court\r\n    }\r\n\r\n    struct FeesConfig {\r\n        ERC20 token;                            // ERC20 token to be used for the fees of the Court\r\n        uint16 finalRoundReduction;             // Permyriad of fees reduction applied for final appeal round (‱ - 1/10,000)\r\n        uint256 jurorFee;                       // Amount of tokens paid to draft a juror to adjudicate a dispute\r\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting jurors\r\n        uint256 settleFee;                      // Amount of tokens paid per round to cover the costs of slashing jurors\r\n    }\r\n\r\n    struct DisputesConfig {\r\n        uint64 evidenceTerms;                   // Max submitting evidence period duration in terms\r\n        uint64 commitTerms;                     // Committing period duration in terms\r\n        uint64 revealTerms;                     // Revealing period duration in terms\r\n        uint64 appealTerms;                     // Appealing period duration in terms\r\n        uint64 appealConfirmTerms;              // Confirmation appeal period duration in terms\r\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n        uint64 firstRoundJurorsNumber;          // Number of jurors drafted on first round\r\n        uint64 appealStepFactor;                // Factor in which the jurors number is increased on each appeal\r\n        uint64 finalRoundLockTerms;             // Period a coherent juror in the final round will remain locked\r\n        uint256 maxRegularAppealRounds;         // Before the final appeal\r\n        uint256 appealCollateralFactor;         // Permyriad multiple of dispute fees required to appeal a preliminary ruling (‱ - 1/10,000)\r\n        uint256 appealConfirmCollateralFactor;  // Permyriad multiple of dispute fees required to confirm appeal (‱ - 1/10,000)\r\n    }\r\n\r\n    struct DraftConfig {\r\n        ERC20 feeToken;                         // ERC20 token to be used for the fees of the Court\r\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting jurors\r\n    }\r\n}\r\n\r\n// File: contracts/court/config/CourtConfig.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CourtConfig is IConfig, CourtConfigData {\r\n    using SafeMath64 for uint64;\r\n    using PctHelpers for uint256;\r\n\r\n    string private constant ERROR_TOO_OLD_TERM = \"CONF_TOO_OLD_TERM\";\r\n    string private constant ERROR_INVALID_PENALTY_PCT = \"CONF_INVALID_PENALTY_PCT\";\r\n    string private constant ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT = \"CONF_INVALID_FINAL_ROUND_RED_PCT\";\r\n    string private constant ERROR_INVALID_MAX_APPEAL_ROUNDS = \"CONF_INVALID_MAX_APPEAL_ROUNDS\";\r\n    string private constant ERROR_LARGE_ROUND_PHASE_DURATION = \"CONF_LARGE_ROUND_PHASE_DURATION\";\r\n    string private constant ERROR_BAD_INITIAL_JURORS_NUMBER = \"CONF_BAD_INITIAL_JURORS_NUMBER\";\r\n    string private constant ERROR_BAD_APPEAL_STEP_FACTOR = \"CONF_BAD_APPEAL_STEP_FACTOR\";\r\n    string private constant ERROR_ZERO_COLLATERAL_FACTOR = \"CONF_ZERO_COLLATERAL_FACTOR\";\r\n    string private constant ERROR_ZERO_MIN_ACTIVE_BALANCE = \"CONF_ZERO_MIN_ACTIVE_BALANCE\";\r\n\r\n    // Max number of terms that each of the different adjudication states can last (if lasted 1h, this would be a year)\r\n    uint64 internal constant MAX_ADJ_STATE_DURATION = 8670;\r\n\r\n    // Cap the max number of regular appeal rounds\r\n    uint256 internal constant MAX_REGULAR_APPEAL_ROUNDS_LIMIT = 10;\r\n\r\n    // Future term ID in which a config change has been scheduled\r\n    uint64 private configChangeTermId;\r\n\r\n    // List of all the configs used in the Court\r\n    Config[] private configs;\r\n\r\n    // List of configs indexed by id\r\n    mapping (uint64 => uint256) private configIdByTerm;\r\n\r\n    // Holders opt-in config for automatic withdrawals\r\n    mapping (address => bool) private withdrawalsAllowed;\r\n\r\n    event NewConfig(uint64 fromTermId, uint64 courtConfigId);\r\n    event AutomaticWithdrawalsAllowedChanged(address indexed holder, bool allowed);\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    constructor(\r\n        ERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        public\r\n    {\r\n        // Leave config at index 0 empty for non-scheduled config changes\r\n        configs.length = 1;\r\n        _setConfig(\r\n            0,\r\n            0,\r\n            _feeToken,\r\n            _fees,\r\n            _roundStateDurations,\r\n            _pcts,\r\n            _roundParams,\r\n            _appealCollateralParams,\r\n            _minActiveBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Set the automatic withdrawals config for the sender to `_allowed`\r\n    * @param _allowed Whether or not the automatic withdrawals are allowed by the sender\r\n    */\r\n    function setAutomaticWithdrawals(bool _allowed) external {\r\n        withdrawalsAllowed[msg.sender] = _allowed;\r\n        emit AutomaticWithdrawalsAllowedChanged(msg.sender, _allowed);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the full Court configuration parameters at a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @return minActiveBalance Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getConfig(uint64 _termId) external view\r\n        returns (\r\n            ERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        );\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    */\r\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\r\n\r\n    /**\r\n    * @dev Tell the min active balance config at a certain term\r\n    * @param _termId Term querying the min active balance config of\r\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell whether a certain holder accepts automatic withdrawals of tokens or not\r\n    * @param _holder Address of the token holder querying if withdrawals are allowed for\r\n    * @return True if the given holder accepts automatic withdrawals of their tokens, false otherwise\r\n    */\r\n    function areWithdrawalsAllowedFor(address _holder) external view returns (bool) {\r\n        return withdrawalsAllowed[_holder];\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the term identification number of the next scheduled config change\r\n    * @return Term identification number of the next scheduled config change\r\n    */\r\n    function getConfigChangeTermId() external view returns (uint64) {\r\n        return configChangeTermId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal to make sure to set a config for the new term, it will copy the previous term config if none\r\n    * @param _termId Identification number of the new current term that has been transitioned\r\n    */\r\n    function _ensureTermConfig(uint64 _termId) internal {\r\n        // If the term being transitioned had no config change scheduled, keep the previous one\r\n        uint256 currentConfigId = configIdByTerm[_termId];\r\n        if (currentConfigId == 0) {\r\n            uint256 previousConfigId = configIdByTerm[_termId.sub(1)];\r\n            configIdByTerm[_termId] = previousConfigId;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Assumes that sender it's allowed (either it's from governor or it's on init)\r\n    * @param _termId Identification number of the current Court term\r\n    * @param _fromTermId Identification number of the term in which the config will be effective at\r\n    * @param _feeToken Address of the token contract that is used to pay for fees.\r\n    * @param _fees Array containing:\r\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    function _setConfig(\r\n        uint64 _termId,\r\n        uint64 _fromTermId,\r\n        ERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        internal\r\n    {\r\n        // If the current term is not zero, changes must be scheduled at least after the current period.\r\n        // No need to ensure delays for on-going disputes since these already use their creation term for that.\r\n        require(_termId == 0 || _fromTermId > _termId, ERROR_TOO_OLD_TERM);\r\n\r\n        // Make sure appeal collateral factors are greater than zero\r\n        require(_appealCollateralParams[0] > 0 && _appealCollateralParams[1] > 0, ERROR_ZERO_COLLATERAL_FACTOR);\r\n\r\n        // Make sure the given penalty and final round reduction pcts are not greater than 100%\r\n        require(PctHelpers.isValid(_pcts[0]), ERROR_INVALID_PENALTY_PCT);\r\n        require(PctHelpers.isValid(_pcts[1]), ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT);\r\n\r\n        // Disputes must request at least one juror to be drafted initially\r\n        require(_roundParams[0] > 0, ERROR_BAD_INITIAL_JURORS_NUMBER);\r\n\r\n        // Prevent that further rounds have zero jurors\r\n        require(_roundParams[1] > 0, ERROR_BAD_APPEAL_STEP_FACTOR);\r\n\r\n        // Make sure the max number of appeals allowed does not reach the limit\r\n        uint256 _maxRegularAppealRounds = _roundParams[2];\r\n        bool isMaxAppealRoundsValid = _maxRegularAppealRounds > 0 && _maxRegularAppealRounds <= MAX_REGULAR_APPEAL_ROUNDS_LIMIT;\r\n        require(isMaxAppealRoundsValid, ERROR_INVALID_MAX_APPEAL_ROUNDS);\r\n\r\n        // Make sure each adjudication round phase duration is valid\r\n        for (uint i = 0; i < _roundStateDurations.length; i++) {\r\n            require(_roundStateDurations[i] > 0 && _roundStateDurations[i] < MAX_ADJ_STATE_DURATION, ERROR_LARGE_ROUND_PHASE_DURATION);\r\n        }\r\n\r\n        // Make sure min active balance is not zero\r\n        require(_minActiveBalance > 0, ERROR_ZERO_MIN_ACTIVE_BALANCE);\r\n\r\n        // If there was a config change already scheduled, reset it (in that case we will overwrite last array item).\r\n        // Otherwise, schedule a new config.\r\n        if (configChangeTermId > _termId) {\r\n            configIdByTerm[configChangeTermId] = 0;\r\n        } else {\r\n            configs.length++;\r\n        }\r\n\r\n        uint64 courtConfigId = uint64(configs.length - 1);\r\n        Config storage config = configs[courtConfigId];\r\n\r\n        config.fees = FeesConfig({\r\n            token: _feeToken,\r\n            jurorFee: _fees[0],\r\n            draftFee: _fees[1],\r\n            settleFee: _fees[2],\r\n            finalRoundReduction: _pcts[1]\r\n        });\r\n\r\n        config.disputes = DisputesConfig({\r\n            evidenceTerms: _roundStateDurations[0],\r\n            commitTerms: _roundStateDurations[1],\r\n            revealTerms: _roundStateDurations[2],\r\n            appealTerms: _roundStateDurations[3],\r\n            appealConfirmTerms: _roundStateDurations[4],\r\n            penaltyPct: _pcts[0],\r\n            firstRoundJurorsNumber: _roundParams[0],\r\n            appealStepFactor: _roundParams[1],\r\n            maxRegularAppealRounds: _maxRegularAppealRounds,\r\n            finalRoundLockTerms: _roundParams[3],\r\n            appealCollateralFactor: _appealCollateralParams[0],\r\n            appealConfirmCollateralFactor: _appealCollateralParams[1]\r\n        });\r\n\r\n        config.minActiveBalance = _minActiveBalance;\r\n\r\n        configIdByTerm[_fromTermId] = courtConfigId;\r\n        configChangeTermId = _fromTermId;\r\n\r\n        emit NewConfig(_fromTermId, courtConfigId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config for a given term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *         3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @return minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    function _getConfigAt(uint64 _termId, uint64 _lastEnsuredTermId) internal view\r\n        returns (\r\n            ERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        )\r\n    {\r\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\r\n\r\n        FeesConfig storage feesConfig = config.fees;\r\n        feeToken = feesConfig.token;\r\n        fees = [feesConfig.jurorFee, feesConfig.draftFee, feesConfig.settleFee];\r\n\r\n        DisputesConfig storage disputesConfig = config.disputes;\r\n        roundStateDurations = [\r\n            disputesConfig.evidenceTerms,\r\n            disputesConfig.commitTerms,\r\n            disputesConfig.revealTerms,\r\n            disputesConfig.appealTerms,\r\n            disputesConfig.appealConfirmTerms\r\n        ];\r\n        pcts = [disputesConfig.penaltyPct, feesConfig.finalRoundReduction];\r\n        roundParams = [\r\n            disputesConfig.firstRoundJurorsNumber,\r\n            disputesConfig.appealStepFactor,\r\n            uint64(disputesConfig.maxRegularAppealRounds),\r\n            disputesConfig.finalRoundLockTerms\r\n        ];\r\n        appealCollateralParams = [disputesConfig.appealCollateralFactor, disputesConfig.appealConfirmCollateralFactor];\r\n\r\n        minActiveBalance = config.minActiveBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    */\r\n    function _getDraftConfig(uint64 _termId,  uint64 _lastEnsuredTermId) internal view\r\n        returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct)\r\n    {\r\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\r\n        return (config.fees.token, config.fees.draftFee, config.disputes.penaltyPct);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the min active balance config for a given term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return Minimum amount of juror tokens that can be activated at the given term\r\n    */\r\n    function _getMinActiveBalance(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\r\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\r\n        return config.minActiveBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config for a given term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return Court config for the given term\r\n    */\r\n    function _getConfigFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (Config storage) {\r\n        uint256 id = _getConfigIdFor(_termId, _lastEnsuredTermId);\r\n        return configs[id];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config ID for a given term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return Identification number of the config for the given terms\r\n    */\r\n    function _getConfigIdFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\r\n        // If the given term is lower or equal to the last ensured Court term, it is safe to use a past Court config\r\n        if (_termId <= _lastEnsuredTermId) {\r\n            return configIdByTerm[_termId];\r\n        }\r\n\r\n        // If the given term is in the future but there is a config change scheduled before it, use the incoming config\r\n        uint64 scheduledChangeTermId = configChangeTermId;\r\n        if (scheduledChangeTermId <= _termId) {\r\n            return configIdByTerm[scheduledChangeTermId];\r\n        }\r\n\r\n        // If no changes are scheduled, use the Court config of the last ensured term\r\n        return configIdByTerm[_lastEnsuredTermId];\r\n    }\r\n}\r\n\r\n// File: contracts/court/controller/Controller.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\ncontract Controller is IsContract, CourtClock, CourtConfig {\r\n    string private constant ERROR_SENDER_NOT_GOVERNOR = \"CTR_SENDER_NOT_GOVERNOR\";\r\n    string private constant ERROR_INVALID_GOVERNOR_ADDRESS = \"CTR_INVALID_GOVERNOR_ADDRESS\";\r\n    string private constant ERROR_IMPLEMENTATION_NOT_CONTRACT = \"CTR_IMPLEMENTATION_NOT_CONTRACT\";\r\n    string private constant ERROR_INVALID_IMPLS_INPUT_LENGTH = \"CTR_INVALID_IMPLS_INPUT_LENGTH\";\r\n\r\n    address private constant ZERO_ADDRESS = address(0);\r\n\r\n    // DisputeManager module ID - keccak256(abi.encodePacked(\"DISPUTE_MANAGER\"))\r\n    bytes32 internal constant DISPUTE_MANAGER = 0x14a6c70f0f6d449c014c7bbc9e68e31e79e8474fb03b7194df83109a2d888ae6;\r\n\r\n    // Treasury module ID - keccak256(abi.encodePacked(\"TREASURY\"))\r\n    bytes32 internal constant TREASURY = 0x06aa03964db1f7257357ef09714a5f0ca3633723df419e97015e0c7a3e83edb7;\r\n\r\n    // Voting module ID - keccak256(abi.encodePacked(\"VOTING\"))\r\n    bytes32 internal constant VOTING = 0x7cbb12e82a6d63ff16fe43977f43e3e2b247ecd4e62c0e340da8800a48c67346;\r\n\r\n    // JurorsRegistry module ID - keccak256(abi.encodePacked(\"JURORS_REGISTRY\"))\r\n    bytes32 internal constant JURORS_REGISTRY = 0x3b21d36b36308c830e6c4053fb40a3b6d79dde78947fbf6b0accd30720ab5370;\r\n\r\n    // Subscriptions module ID - keccak256(abi.encodePacked(\"SUBSCRIPTIONS\"))\r\n    bytes32 internal constant SUBSCRIPTIONS = 0x2bfa3327fe52344390da94c32a346eeb1b65a8b583e4335a419b9471e88c1365;\r\n\r\n    /**\r\n    * @dev Governor of the whole system. Set of three addresses to recover funds, change configuration settings and setup modules\r\n    */\r\n    struct Governor {\r\n        address funds;      // This address can be unset at any time. It is allowed to recover funds from the ControlledRecoverable modules\r\n        address config;     // This address is meant not to be unset. It is allowed to change the different configurations of the whole system\r\n        address modules;    // This address can be unset at any time. It is allowed to plug/unplug modules from the system\r\n    }\r\n\r\n    // Governor addresses of the system\r\n    Governor private governor;\r\n\r\n    // List of modules registered for the system indexed by ID\r\n    mapping (bytes32 => address) internal modules;\r\n\r\n    event ModuleSet(bytes32 id, address addr);\r\n    event FundsGovernorChanged(address previousGovernor, address currentGovernor);\r\n    event ConfigGovernorChanged(address previousGovernor, address currentGovernor);\r\n    event ModulesGovernorChanged(address previousGovernor, address currentGovernor);\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the funds governor\r\n    */\r\n    modifier onlyFundsGovernor {\r\n        require(msg.sender == governor.funds, ERROR_SENDER_NOT_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the modules governor\r\n    */\r\n    modifier onlyConfigGovernor {\r\n        require(msg.sender == governor.config, ERROR_SENDER_NOT_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the modules governor\r\n    */\r\n    modifier onlyModulesGovernor {\r\n        require(msg.sender == governor.modules, ERROR_SENDER_NOT_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _termParams Array containing:\r\n    *        0. _termDuration Duration in seconds per term\r\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for juror on-boarding)\r\n    * @param _governors Array containing:\r\n    *        0. _fundsGovernor Address of the funds governor\r\n    *        1. _configGovernor Address of the config governor\r\n    *        2. _modulesGovernor Address of the modules governor\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted jurors (‱ - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\r\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    constructor(\r\n        uint64[2] memory _termParams,\r\n        address[3] memory _governors,\r\n        ERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        public\r\n        CourtClock(_termParams)\r\n        CourtConfig(_feeToken, _fees, _roundStateDurations, _pcts, _roundParams, _appealCollateralParams, _minActiveBalance)\r\n    {\r\n        _setFundsGovernor(_governors[0]);\r\n        _setConfigGovernor(_governors[1]);\r\n        _setModulesGovernor(_governors[2]);\r\n    }\r\n\r\n    /**\r\n    * @notice Change Court configuration params\r\n    * @param _fromTermId Identification number of the term in which the config will be effective at\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *        1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted jurors (‱ - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\r\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    */\r\n    function setConfig(\r\n        uint64 _fromTermId,\r\n        ERC20 _feeToken,\r\n        uint256[3] calldata _fees,\r\n        uint64[5] calldata _roundStateDurations,\r\n        uint16[2] calldata _pcts,\r\n        uint64[4] calldata _roundParams,\r\n        uint256[2] calldata _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        external\r\n        onlyConfigGovernor\r\n    {\r\n        uint64 currentTermId = _ensureCurrentTerm();\r\n        _setConfig(\r\n            currentTermId,\r\n            _fromTermId,\r\n            _feeToken,\r\n            _fees,\r\n            _roundStateDurations,\r\n            _pcts,\r\n            _roundParams,\r\n            _appealCollateralParams,\r\n            _minActiveBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Delay the Court start time to `_newFirstTermStartTime`\r\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\r\n    */\r\n    function delayStartTime(uint64 _newFirstTermStartTime) external onlyConfigGovernor {\r\n        _delayStartTime(_newFirstTermStartTime);\r\n    }\r\n\r\n    /**\r\n    * @notice Change funds governor address to `_newFundsGovernor`\r\n    * @param _newFundsGovernor Address of the new funds governor to be set\r\n    */\r\n    function changeFundsGovernor(address _newFundsGovernor) external onlyFundsGovernor {\r\n        require(_newFundsGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\r\n        _setFundsGovernor(_newFundsGovernor);\r\n    }\r\n\r\n    /**\r\n    * @notice Change config governor address to `_newConfigGovernor`\r\n    * @param _newConfigGovernor Address of the new config governor to be set\r\n    */\r\n    function changeConfigGovernor(address _newConfigGovernor) external onlyConfigGovernor {\r\n        require(_newConfigGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\r\n        _setConfigGovernor(_newConfigGovernor);\r\n    }\r\n\r\n    /**\r\n    * @notice Change modules governor address to `_newModulesGovernor`\r\n    * @param _newModulesGovernor Address of the new governor to be set\r\n    */\r\n    function changeModulesGovernor(address _newModulesGovernor) external onlyModulesGovernor {\r\n        require(_newModulesGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\r\n        _setModulesGovernor(_newModulesGovernor);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove the funds governor. Set the funds governor to the zero address.\r\n    * @dev This action cannot be rolled back, once the funds governor has been unset, funds cannot be recovered from recoverable modules anymore\r\n    */\r\n    function ejectFundsGovernor() external onlyFundsGovernor {\r\n        _setFundsGovernor(ZERO_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove the modules governor. Set the modules governor to the zero address.\r\n    * @dev This action cannot be rolled back, once the modules governor has been unset, system modules cannot be changed anymore\r\n    */\r\n    function ejectModulesGovernor() external onlyModulesGovernor {\r\n        _setModulesGovernor(ZERO_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * @notice Set module `_id` to `_addr`\r\n    * @param _id ID of the module to be set\r\n    * @param _addr Address of the module to be set\r\n    */\r\n    function setModule(bytes32 _id, address _addr) external onlyModulesGovernor {\r\n        _setModule(_id, _addr);\r\n    }\r\n\r\n    /**\r\n    * @notice Set many modules at once\r\n    * @param _ids List of ids of each module to be set\r\n    * @param _addresses List of addressed of each the module to be set\r\n    */\r\n    function setModules(bytes32[] calldata _ids, address[] calldata _addresses) external onlyModulesGovernor {\r\n        require(_ids.length == _addresses.length, ERROR_INVALID_IMPLS_INPUT_LENGTH);\r\n\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            _setModule(_ids[i], _addresses[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the full Court configuration parameters at a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. jurorFee Amount of fee tokens that is paid per juror per dispute\r\n    *         1. draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per juror to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (‱ - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundJurorsNumber Number of jurors to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of jurors of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *         3. finalRoundLockTerms Number of terms that a coherent juror in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    */\r\n    function getConfig(uint64 _termId) external view\r\n        returns (\r\n            ERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        )\r\n    {\r\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\r\n        return _getConfigAt(_termId, lastEnsuredTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per juror to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted juror (‱ - 1/10,000)\r\n    */\r\n    function getDraftConfig(uint64 _termId) external view returns (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct) {\r\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\r\n        return _getDraftConfig(_termId, lastEnsuredTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the min active balance config at a certain term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @return Minimum amount of tokens jurors have to activate to participate in the Court\r\n    */\r\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256) {\r\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\r\n        return _getMinActiveBalance(_termId, lastEnsuredTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the funds governor\r\n    * @return Address of the funds governor\r\n    */\r\n    function getFundsGovernor() external view returns (address) {\r\n        return governor.funds;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the config governor\r\n    * @return Address of the config governor\r\n    */\r\n    function getConfigGovernor() external view returns (address) {\r\n        return governor.config;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the modules governor\r\n    * @return Address of the modules governor\r\n    */\r\n    function getModulesGovernor() external view returns (address) {\r\n        return governor.modules;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell address of a module based on a given ID\r\n    * @param _id ID of the module being queried\r\n    * @return Address of the requested module\r\n    */\r\n    function getModule(bytes32 _id) external view returns (address) {\r\n        return _getModule(_id);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the DisputeManager module\r\n    * @return Address of the DisputeManager module\r\n    */\r\n    function getDisputeManager() external view returns (address) {\r\n        return _getDisputeManager();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the Treasury module\r\n    * @return Address of the Treasury module\r\n    */\r\n    function getTreasury() external view returns (address) {\r\n        return _getModule(TREASURY);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the Voting module\r\n    * @return Address of the Voting module\r\n    */\r\n    function getVoting() external view returns (address) {\r\n        return _getModule(VOTING);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the JurorsRegistry module\r\n    * @return Address of the JurorsRegistry module\r\n    */\r\n    function getJurorsRegistry() external view returns (address) {\r\n        return _getModule(JURORS_REGISTRY);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the Subscriptions module\r\n    * @return Address of the Subscriptions module\r\n    */\r\n    function getSubscriptions() external view returns (address) {\r\n        return _getSubscriptions();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set the address of the funds governor\r\n    * @param _newFundsGovernor Address of the new config governor to be set\r\n    */\r\n    function _setFundsGovernor(address _newFundsGovernor) internal {\r\n        emit FundsGovernorChanged(governor.funds, _newFundsGovernor);\r\n        governor.funds = _newFundsGovernor;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set the address of the config governor\r\n    * @param _newConfigGovernor Address of the new config governor to be set\r\n    */\r\n    function _setConfigGovernor(address _newConfigGovernor) internal {\r\n        emit ConfigGovernorChanged(governor.config, _newConfigGovernor);\r\n        governor.config = _newConfigGovernor;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set the address of the modules governor\r\n    * @param _newModulesGovernor Address of the new modules governor to be set\r\n    */\r\n    function _setModulesGovernor(address _newModulesGovernor) internal {\r\n        emit ModulesGovernorChanged(governor.modules, _newModulesGovernor);\r\n        governor.modules = _newModulesGovernor;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set a module\r\n    * @param _id Id of the module to be set\r\n    * @param _addr Address of the module to be set\r\n    */\r\n    function _setModule(bytes32 _id, address _addr) internal {\r\n        require(isContract(_addr), ERROR_IMPLEMENTATION_NOT_CONTRACT);\r\n        modules[_id] = _addr;\r\n        emit ModuleSet(_id, _addr);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to notify when a term has been transitioned\r\n    * @param _termId Identification number of the new current term that has been transitioned\r\n    */\r\n    function _onTermTransitioned(uint64 _termId) internal {\r\n        _ensureTermConfig(_termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the address of the DisputeManager module\r\n    * @return Address of the DisputeManager module\r\n    */\r\n    function _getDisputeManager() internal view returns (address) {\r\n        return _getModule(DISPUTE_MANAGER);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the address of the Subscriptions module\r\n    * @return Address of the Subscriptions module\r\n    */\r\n    function _getSubscriptions() internal view returns (address) {\r\n        return _getModule(SUBSCRIPTIONS);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell address of a module based on a given ID\r\n    * @param _id ID of the module being queried\r\n    * @return Address of the requested module\r\n    */\r\n    function _getModule(bytes32 _id) internal view returns (address) {\r\n        return modules[_id];\r\n    }\r\n}\r\n\r\n// File: contracts/court/config/ConfigConsumer.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\ncontract ConfigConsumer is CourtConfigData {\r\n    /**\r\n    * @dev Internal function to fetch the address of the Config module from the controller\r\n    * @return Address of the Config module\r\n    */\r\n    function _courtConfig() internal view returns (IConfig);\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config for a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return Court config for the given term\r\n    */\r\n    function _getConfigAt(uint64 _termId) internal view returns (Config memory) {\r\n        (ERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance) = _courtConfig().getConfig(_termId);\r\n\r\n        Config memory config;\r\n\r\n        config.fees = FeesConfig({\r\n            token: _feeToken,\r\n            jurorFee: _fees[0],\r\n            draftFee: _fees[1],\r\n            settleFee: _fees[2],\r\n            finalRoundReduction: _pcts[1]\r\n        });\r\n\r\n        config.disputes = DisputesConfig({\r\n            evidenceTerms: _roundStateDurations[0],\r\n            commitTerms: _roundStateDurations[1],\r\n            revealTerms: _roundStateDurations[2],\r\n            appealTerms: _roundStateDurations[3],\r\n            appealConfirmTerms: _roundStateDurations[4],\r\n            penaltyPct: _pcts[0],\r\n            firstRoundJurorsNumber: _roundParams[0],\r\n            appealStepFactor: _roundParams[1],\r\n            maxRegularAppealRounds: _roundParams[2],\r\n            finalRoundLockTerms: _roundParams[3],\r\n            appealCollateralFactor: _appealCollateralParams[0],\r\n            appealConfirmCollateralFactor: _appealCollateralParams[1]\r\n        });\r\n\r\n        config.minActiveBalance = _minActiveBalance;\r\n\r\n        return config;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the draft config for a given term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return Draft config for the given term\r\n    */\r\n    function _getDraftConfig(uint64 _termId) internal view returns (DraftConfig memory) {\r\n        (ERC20 feeToken, uint256 draftFee, uint16 penaltyPct) = _courtConfig().getDraftConfig(_termId);\r\n        return DraftConfig({ feeToken: feeToken, draftFee: draftFee, penaltyPct: penaltyPct });\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the min active balance config for a given term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @return Minimum amount of juror tokens that can be activated\r\n    */\r\n    function _getMinActiveBalance(uint64 _termId) internal view returns (uint256) {\r\n        return _courtConfig().getMinActiveBalance(_termId);\r\n    }\r\n}\r\n\r\n// File: contracts/court/controller/Controlled.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Controlled is IsContract, ConfigConsumer {\r\n    string private constant ERROR_CONTROLLER_NOT_CONTRACT = \"CTD_CONTROLLER_NOT_CONTRACT\";\r\n    string private constant ERROR_SENDER_NOT_CONTROLLER = \"CTD_SENDER_NOT_CONTROLLER\";\r\n    string private constant ERROR_SENDER_NOT_CONFIG_GOVERNOR = \"CTD_SENDER_NOT_CONFIG_GOVERNOR\";\r\n    string private constant ERROR_SENDER_NOT_DISPUTES_MODULE = \"CTD_SENDER_NOT_DISPUTES_MODULE\";\r\n\r\n    // Address of the controller\r\n    Controller internal controller;\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the controller's config governor\r\n    */\r\n    modifier onlyConfigGovernor {\r\n        require(msg.sender == _configGovernor(), ERROR_SENDER_NOT_CONFIG_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the controller\r\n    */\r\n    modifier onlyController() {\r\n        require(msg.sender == address(controller), ERROR_SENDER_NOT_CONTROLLER);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the DisputeManager module\r\n    */\r\n    modifier onlyDisputeManager() {\r\n        require(msg.sender == address(_disputeManager()), ERROR_SENDER_NOT_DISPUTES_MODULE);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _controller Address of the controller\r\n    */\r\n    constructor(Controller _controller) public {\r\n        require(isContract(address(_controller)), ERROR_CONTROLLER_NOT_CONTRACT);\r\n        controller = _controller;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the controller\r\n    * @return Address of the controller\r\n    */\r\n    function getController() external view returns (Controller) {\r\n        return controller;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to ensure the Court term is up-to-date, it will try to update it if not\r\n    * @return Identification number of the current Court term\r\n    */\r\n    function _ensureCurrentTerm() internal returns (uint64) {\r\n        return _clock().ensureCurrentTerm();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the last ensured term ID of the Court\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function _getLastEnsuredTermId() internal view returns (uint64) {\r\n        return _clock().getLastEnsuredTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the current term identification number\r\n    * @return Identification number of the current term\r\n    */\r\n    function _getCurrentTermId() internal view returns (uint64) {\r\n        return _clock().getCurrentTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the controller's config governor\r\n    * @return Address of the controller's governor\r\n    */\r\n    function _configGovernor() internal view returns (address) {\r\n        return controller.getConfigGovernor();\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the DisputeManager module from the controller\r\n    * @return Address of the DisputeManager module\r\n    */\r\n    function _disputeManager() internal view returns (IDisputeManager) {\r\n        return IDisputeManager(controller.getDisputeManager());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Treasury module implementation from the controller\r\n    * @return Address of the Treasury module implementation\r\n    */\r\n    function _treasury() internal view returns (ITreasury) {\r\n        return ITreasury(controller.getTreasury());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Voting module implementation from the controller\r\n    * @return Address of the Voting module implementation\r\n    */\r\n    function _voting() internal view returns (ICRVoting) {\r\n        return ICRVoting(controller.getVoting());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Voting module owner from the controller\r\n    * @return Address of the Voting module owner\r\n    */\r\n    function _votingOwner() internal view returns (ICRVotingOwner) {\r\n        return ICRVotingOwner(address(_disputeManager()));\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the JurorRegistry module implementation from the controller\r\n    * @return Address of the JurorRegistry module implementation\r\n    */\r\n    function _jurorsRegistry() internal view returns (IJurorsRegistry) {\r\n        return IJurorsRegistry(controller.getJurorsRegistry());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Subscriptions module implementation from the controller\r\n    * @return Address of the Subscriptions module implementation\r\n    */\r\n    function _subscriptions() internal view returns (ISubscriptions) {\r\n        return ISubscriptions(controller.getSubscriptions());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Clock module from the controller\r\n    * @return Address of the Clock module\r\n    */\r\n    function _clock() internal view returns (IClock) {\r\n        return IClock(controller);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to fetch the address of the Config module from the controller\r\n    * @return Address of the Config module\r\n    */\r\n    function _courtConfig() internal view returns (IConfig) {\r\n        return IConfig(controller);\r\n    }\r\n}\r\n\r\n// File: contracts/court/controller/ControlledRecoverable.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\ncontract ControlledRecoverable is Controlled {\r\n    using SafeERC20 for ERC20;\r\n\r\n    string private constant ERROR_SENDER_NOT_FUNDS_GOVERNOR = \"CTD_SENDER_NOT_FUNDS_GOVERNOR\";\r\n    string private constant ERROR_INSUFFICIENT_RECOVER_FUNDS = \"CTD_INSUFFICIENT_RECOVER_FUNDS\";\r\n    string private constant ERROR_RECOVER_TOKEN_FUNDS_FAILED = \"CTD_RECOVER_TOKEN_FUNDS_FAILED\";\r\n\r\n    event RecoverFunds(ERC20 token, address recipient, uint256 balance);\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the controller's funds governor\r\n    */\r\n    modifier onlyFundsGovernor {\r\n        require(msg.sender == controller.getFundsGovernor(), ERROR_SENDER_NOT_FUNDS_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _controller Address of the controller\r\n    */\r\n    constructor(Controller _controller) Controlled(_controller) public {\r\n        // solium-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n    * @notice Transfer all `_token` tokens to `_to`\r\n    * @param _token ERC20 token to be recovered\r\n    * @param _to Address of the recipient that will be receive all the funds of the requested token\r\n    */\r\n    function recoverFunds(ERC20 _token, address _to) external onlyFundsGovernor {\r\n        uint256 balance = _token.balanceOf(address(this));\r\n        require(balance > 0, ERROR_INSUFFICIENT_RECOVER_FUNDS);\r\n        require(_token.safeTransfer(_to, balance), ERROR_RECOVER_TOKEN_FUNDS_FAILED);\r\n        emit RecoverFunds(_token, _to, balance);\r\n    }\r\n}\r\n\r\n// File: contracts/disputes/DisputeManager.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DisputeManager is ControlledRecoverable, ICRVotingOwner, IDisputeManager {\r\n    using SafeERC20 for ERC20;\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n    using PctHelpers for uint256;\r\n    using Uint256Helpers for uint256;\r\n\r\n    // Voting-related error messages\r\n    string private constant ERROR_VOTER_WEIGHT_ZERO = \"DM_VOTER_WEIGHT_ZERO\";\r\n    string private constant ERROR_SENDER_NOT_VOTING = \"DM_SENDER_NOT_VOTING\";\r\n\r\n    // Disputes-related error messages\r\n    string private constant ERROR_SENDER_NOT_DISPUTE_SUBJECT = \"DM_SENDER_NOT_DISPUTE_SUBJECT\";\r\n    string private constant ERROR_EVIDENCE_PERIOD_IS_CLOSED = \"DM_EVIDENCE_PERIOD_IS_CLOSED\";\r\n    string private constant ERROR_TERM_OUTDATED = \"DM_TERM_OUTDATED\";\r\n    string private constant ERROR_DISPUTE_DOES_NOT_EXIST = \"DM_DISPUTE_DOES_NOT_EXIST\";\r\n    string private constant ERROR_INVALID_RULING_OPTIONS = \"DM_INVALID_RULING_OPTIONS\";\r\n    string private constant ERROR_SUBSCRIPTION_NOT_PAID = \"DM_SUBSCRIPTION_NOT_PAID\";\r\n    string private constant ERROR_DEPOSIT_FAILED = \"DM_DEPOSIT_FAILED\";\r\n    string private constant ERROR_BAD_MAX_DRAFT_BATCH_SIZE = \"DM_BAD_MAX_DRAFT_BATCH_SIZE\";\r\n\r\n    // Rounds-related error messages\r\n    string private constant ERROR_ROUND_IS_FINAL = \"DM_ROUND_IS_FINAL\";\r\n    string private constant ERROR_ROUND_DOES_NOT_EXIST = \"DM_ROUND_DOES_NOT_EXIST\";\r\n    string private constant ERROR_INVALID_ADJUDICATION_STATE = \"DM_INVALID_ADJUDICATION_STATE\";\r\n    string private constant ERROR_ROUND_ALREADY_DRAFTED = \"DM_ROUND_ALREADY_DRAFTED\";\r\n    string private constant ERROR_DRAFT_TERM_NOT_REACHED = \"DM_DRAFT_TERM_NOT_REACHED\";\r\n    string private constant ERROR_ROUND_NOT_APPEALED = \"DM_ROUND_NOT_APPEALED\";\r\n    string private constant ERROR_INVALID_APPEAL_RULING = \"DM_INVALID_APPEAL_RULING\";\r\n\r\n    // Settlements-related error messages\r\n    string private constant ERROR_PREV_ROUND_NOT_SETTLED = \"DM_PREVIOUS_ROUND_NOT_SETTLED\";\r\n    string private constant ERROR_ROUND_ALREADY_SETTLED = \"DM_ROUND_ALREADY_SETTLED\";\r\n    string private constant ERROR_ROUND_NOT_SETTLED = \"DM_ROUND_PENALTIES_NOT_SETTLED\";\r\n    string private constant ERROR_JUROR_ALREADY_REWARDED = \"DM_JUROR_ALREADY_REWARDED\";\r\n    string private constant ERROR_WONT_REWARD_NON_VOTER_JUROR = \"DM_WONT_REWARD_NON_VOTER_JUROR\";\r\n    string private constant ERROR_WONT_REWARD_INCOHERENT_JUROR = \"DM_WONT_REWARD_INCOHERENT_JUROR\";\r\n    string private constant ERROR_ROUND_APPEAL_ALREADY_SETTLED = \"DM_APPEAL_ALREADY_SETTLED\";\r\n\r\n    // Minimum possible rulings for a dispute\r\n    uint8 internal constant MIN_RULING_OPTIONS = 2;\r\n\r\n    // Maximum possible rulings for a dispute, equal to minimum limit\r\n    uint8 internal constant MAX_RULING_OPTIONS = MIN_RULING_OPTIONS;\r\n\r\n    // Precision factor used to improve rounding when computing weights for the final round\r\n    uint256 internal constant FINAL_ROUND_WEIGHT_PRECISION = 1000;\r\n\r\n    // Mask used to decode vote IDs\r\n    uint256 internal constant VOTE_ID_MASK = 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    struct Dispute {\r\n        IArbitrable subject;           // Arbitrable associated to a dispute\r\n        uint64 createTermId;           // Term ID when the dispute was created\r\n        uint8 possibleRulings;         // Number of possible rulings jurors can vote for each dispute\r\n        uint8 finalRuling;             // Winning ruling of a dispute\r\n        DisputeState state;            // State of a dispute: pre-draft, adjudicating, or ruled\r\n        AdjudicationRound[] rounds;    // List of rounds for each dispute\r\n    }\r\n\r\n    struct AdjudicationRound {\r\n        uint64 draftTermId;            // Term from which the jurors of a round can be drafted\r\n        uint64 jurorsNumber;           // Number of jurors drafted for a round\r\n        bool settledPenalties;         // Whether or not penalties have been settled for a round\r\n        uint256 jurorFees;             // Total amount of fees to be distributed between the winning jurors of a round\r\n        address[] jurors;              // List of jurors drafted for a round\r\n        mapping (address => JurorState) jurorsStates; // List of states for each drafted juror indexed by address\r\n        uint64 delayedTerms;           // Number of terms a round was delayed based on its requested draft term id\r\n        uint64 selectedJurors;         // Number of jurors selected for a round, to allow drafts to be batched\r\n        uint64 coherentJurors;         // Number of drafted jurors that voted in favor of the dispute final ruling\r\n        uint64 settledJurors;          // Number of jurors whose rewards were already settled\r\n        uint256 collectedTokens;       // Total amount of tokens collected from losing jurors\r\n        Appeal appeal;                 // Appeal-related information of a round\r\n    }\r\n\r\n    struct JurorState {\r\n        uint64 weight;                 // Weight computed for a juror on a round\r\n        bool rewarded;                 // Whether or not a drafted juror was rewarded\r\n    }\r\n\r\n    struct Appeal {\r\n        address maker;                 // Address of the appealer\r\n        uint8 appealedRuling;          // Ruling appealing in favor of\r\n        address taker;                 // Address of the one confirming an appeal\r\n        uint8 opposedRuling;           // Ruling opposed to an appeal\r\n        bool settled;                  // Whether or not an appeal has been settled\r\n    }\r\n\r\n    struct DraftParams {\r\n        uint256 disputeId;            // Identification number of the dispute to be drafted\r\n        uint256 roundId;              // Identification number of the round to be drafted\r\n        uint64 termId;                // Identification number of the current term of the Court\r\n        bytes32 draftTermRandomness;  // Randomness of the term in which the dispute was requested to be drafted\r\n        DraftConfig config;           // Draft config of the Court at the draft term\r\n    }\r\n\r\n    struct NextRoundDetails {\r\n        uint64 startTerm;              // Term ID from which the next round will start\r\n        uint64 jurorsNumber;           // Jurors number for the next round\r\n        DisputeState newDisputeState;  // New state for the dispute associated to the given round after the appeal\r\n        ERC20 feeToken;                // ERC20 token used for the next round fees\r\n        uint256 totalFees;             // Total amount of fees to be distributed between the winning jurors of the next round\r\n        uint256 jurorFees;             // Total amount of fees for a regular round at the given term\r\n        uint256 appealDeposit;         // Amount to be deposit of fees for a regular round at the given term\r\n        uint256 confirmAppealDeposit;  // Total amount of fees for a regular round at the given term\r\n    }\r\n\r\n    // Max jurors to be drafted in each batch. To prevent running out of gas. We allow to change it because max gas per tx can vary\r\n    // As a reference, drafting 100 jurors from a small tree of 4 would cost ~2.4M. Drafting 500, ~7.75M.\r\n    uint64 public maxJurorsPerDraftBatch;\r\n\r\n    // List of all the disputes created in the Court\r\n    Dispute[] internal disputes;\r\n\r\n    event DisputeStateChanged(uint256 indexed disputeId, DisputeState indexed state);\r\n    event EvidencePeriodClosed(uint256 indexed disputeId, uint64 indexed termId);\r\n    event NewDispute(uint256 indexed disputeId, IArbitrable indexed subject, uint64 indexed draftTermId, uint64 jurorsNumber, bytes metadata);\r\n    event JurorDrafted(uint256 indexed disputeId, uint256 indexed roundId, address indexed juror);\r\n    event RulingAppealed(uint256 indexed disputeId, uint256 indexed roundId, uint8 ruling);\r\n    event RulingAppealConfirmed(uint256 indexed disputeId, uint256 indexed roundId, uint64 indexed draftTermId, uint256 jurorsNumber);\r\n    event RulingComputed(uint256 indexed disputeId, uint8 indexed ruling);\r\n    event PenaltiesSettled(uint256 indexed disputeId, uint256 indexed roundId, uint256 collectedTokens);\r\n    event RewardSettled(uint256 indexed disputeId, uint256 indexed roundId, address juror, uint256 tokens, uint256 fees);\r\n    event AppealDepositSettled(uint256 indexed disputeId, uint256 indexed roundId);\r\n    event MaxJurorsPerDraftBatchChanged(uint64 previousMaxJurorsPerDraftBatch, uint64 currentMaxJurorsPerDraftBatch);\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the CR Voting module\r\n    */\r\n    modifier onlyVoting() {\r\n        ICRVoting voting = _voting();\r\n        require(msg.sender == address(voting), ERROR_SENDER_NOT_VOTING);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure a dispute exists\r\n    * @param _disputeId Identification number of the dispute to be ensured\r\n    */\r\n    modifier disputeExists(uint256 _disputeId) {\r\n        _checkDisputeExists(_disputeId);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure a dispute round exists\r\n    * @param _disputeId Identification number of the dispute to be ensured\r\n    * @param _roundId Identification number of the dispute round to be ensured\r\n    */\r\n    modifier roundExists(uint256 _disputeId, uint256 _roundId) {\r\n        _checkRoundExists(_disputeId, _roundId);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _controller Address of the controller\r\n    * @param _maxJurorsPerDraftBatch Max number of jurors to be drafted per batch\r\n    * @param _skippedDisputes Number of disputes to be skipped\r\n    */\r\n    constructor(Controller _controller, uint64 _maxJurorsPerDraftBatch, uint256 _skippedDisputes) ControlledRecoverable(_controller) public {\r\n        // No need to explicitly call `Controlled` constructor since `ControlledRecoverable` is already doing it\r\n        _setMaxJurorsPerDraftBatch(_maxJurorsPerDraftBatch);\r\n        _skipDisputes(_skippedDisputes);\r\n    }\r\n\r\n    /**\r\n    * @notice Create a dispute over `_subject` with `_possibleRulings` possible rulings\r\n    * @param _subject Arbitrable instance creating the dispute\r\n    * @param _possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(IArbitrable _subject, uint8 _possibleRulings, bytes calldata _metadata) external onlyController returns (uint256) {\r\n        uint64 termId = _ensureCurrentTerm();\r\n        require(_possibleRulings >= MIN_RULING_OPTIONS && _possibleRulings <= MAX_RULING_OPTIONS, ERROR_INVALID_RULING_OPTIONS);\r\n\r\n        // Create the dispute\r\n        uint256 disputeId = disputes.length++;\r\n        Dispute storage dispute = disputes[disputeId];\r\n        dispute.subject = _subject;\r\n        dispute.possibleRulings = _possibleRulings;\r\n        dispute.createTermId = termId;\r\n\r\n        Config memory config = _getConfigAt(termId);\r\n        uint64 jurorsNumber = config.disputes.firstRoundJurorsNumber;\r\n        uint64 draftTermId = termId.add(config.disputes.evidenceTerms);\r\n        emit NewDispute(disputeId, _subject, draftTermId, jurorsNumber, _metadata);\r\n\r\n        // Create first adjudication round of the dispute\r\n        (ERC20 feeToken, uint256 jurorFees, uint256 totalFees) = _getRegularRoundFees(config.fees, jurorsNumber);\r\n        _createRound(disputeId, DisputeState.PreDraft, draftTermId, jurorsNumber, jurorFees);\r\n\r\n        // Pay round fees and return dispute id\r\n        _depositAmount(address(_subject), feeToken, totalFees);\r\n        return disputeId;\r\n    }\r\n\r\n    /**\r\n    * @notice Close the evidence period of dispute #`_disputeId`\r\n    * @param _subject IArbitrable instance requesting to close the evidence submission period\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(IArbitrable _subject, uint256 _disputeId) external onlyController roundExists(_disputeId, 0) {\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        AdjudicationRound storage round = dispute.rounds[0];\r\n        require(dispute.subject == _subject, ERROR_SENDER_NOT_DISPUTE_SUBJECT);\r\n\r\n        // Check current term is within the evidence submission period\r\n        uint64 termId = _ensureCurrentTerm();\r\n        uint64 newDraftTermId = termId.add(1);\r\n        require(newDraftTermId < round.draftTermId, ERROR_EVIDENCE_PERIOD_IS_CLOSED);\r\n\r\n        // Update the draft term of the first round to the next term\r\n        round.draftTermId = newDraftTermId;\r\n        emit EvidencePeriodClosed(_disputeId, termId);\r\n    }\r\n\r\n    /**\r\n    * @notice Draft jurors for the next round of dispute #`_disputeId`\r\n    * @param _disputeId Identification number of the dispute to be drafted\r\n    */\r\n    function draft(uint256 _disputeId) external disputeExists(_disputeId) {\r\n        // Drafts can only be computed when the Court is up-to-date. Note that forcing a term transition won't work since the term randomness\r\n        // is always based on the next term which means it won't be available anyway.\r\n        IClock clock = _clock();\r\n        uint64 requiredTransitions = _clock().getNeededTermTransitions();\r\n        require(uint256(requiredTransitions) == 0, ERROR_TERM_OUTDATED);\r\n        uint64 currentTermId = _getLastEnsuredTermId();\r\n\r\n        // Ensure dispute has not been drafted yet\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        require(dispute.state == DisputeState.PreDraft, ERROR_ROUND_ALREADY_DRAFTED);\r\n\r\n        // Ensure draft term randomness can be computed for the current block number\r\n        uint256 roundId = dispute.rounds.length - 1;\r\n        AdjudicationRound storage round = dispute.rounds[roundId];\r\n        uint64 draftTermId = round.draftTermId;\r\n        require(draftTermId <= currentTermId, ERROR_DRAFT_TERM_NOT_REACHED);\r\n        bytes32 draftTermRandomness = clock.ensureCurrentTermRandomness();\r\n\r\n        // Draft jurors for the given dispute and reimburse fees\r\n        DraftConfig memory config = _getDraftConfig(draftTermId);\r\n        bool draftEnded = _draft(round, _buildDraftParams(_disputeId, roundId, currentTermId, draftTermRandomness, config));\r\n\r\n        // If the drafting is over, update its state\r\n        if (draftEnded) {\r\n            // No need for SafeMath: we ensured `currentTermId` is greater than or equal to `draftTermId` above\r\n            round.delayedTerms = currentTermId - draftTermId;\r\n            dispute.state = DisputeState.Adjudicating;\r\n            emit DisputeStateChanged(_disputeId, DisputeState.Adjudicating);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Appeal round #`_roundId` of dispute #`_disputeId` in favor of ruling `_ruling`\r\n    * @param _disputeId Identification number of the dispute being appealed\r\n    * @param _roundId Identification number of the dispute round being appealed\r\n    * @param _ruling Ruling appealing a dispute round in favor of\r\n    */\r\n    function createAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external roundExists(_disputeId, _roundId) {\r\n        // Ensure current term and check that the given round can be appealed.\r\n        // Note that if there was a final appeal the adjudication state will be 'Ended'.\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        Config memory config = _getDisputeConfig(dispute);\r\n        _ensureAdjudicationState(dispute, _roundId, AdjudicationState.Appealing, config.disputes);\r\n\r\n        // Ensure that the ruling being appealed in favor of is valid and different from the current winning ruling\r\n        ICRVoting voting = _voting();\r\n        uint256 voteId = _getVoteId(_disputeId, _roundId);\r\n        uint8 roundWinningRuling = voting.getWinningOutcome(voteId);\r\n        require(roundWinningRuling != _ruling && voting.isValidOutcome(voteId, _ruling), ERROR_INVALID_APPEAL_RULING);\r\n\r\n        // Update round appeal state\r\n        AdjudicationRound storage round = dispute.rounds[_roundId];\r\n        Appeal storage appeal = round.appeal;\r\n        appeal.maker = msg.sender;\r\n        appeal.appealedRuling = _ruling;\r\n        emit RulingAppealed(_disputeId, _roundId, _ruling);\r\n\r\n        // Pay appeal deposit\r\n        NextRoundDetails memory nextRound = _getNextRoundDetails(round, _roundId, config);\r\n        _depositAmount(msg.sender, nextRound.feeToken, nextRound.appealDeposit);\r\n    }\r\n\r\n    /**\r\n    * @notice Confirm appeal for round #`_roundId` of dispute #`_disputeId` in favor of ruling `_ruling`\r\n    * @param _disputeId Identification number of the dispute confirming an appeal of\r\n    * @param _roundId Identification number of the dispute round confirming an appeal of\r\n    * @param _ruling Ruling being confirmed against a dispute round appeal\r\n    */\r\n    function confirmAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external roundExists(_disputeId, _roundId) {\r\n        // Ensure current term and check that the given round is appealed and can be confirmed.\r\n        // Note that if there was a final appeal the adjudication state will be 'Ended'.\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        Config memory config = _getDisputeConfig(dispute);\r\n        _ensureAdjudicationState(dispute, _roundId, AdjudicationState.ConfirmingAppeal, config.disputes);\r\n\r\n        // Ensure that the ruling being confirmed in favor of is valid and different from the appealed ruling\r\n        AdjudicationRound storage round = dispute.rounds[_roundId];\r\n        Appeal storage appeal = round.appeal;\r\n        uint256 voteId = _getVoteId(_disputeId, _roundId);\r\n        require(appeal.appealedRuling != _ruling && _voting().isValidOutcome(voteId, _ruling), ERROR_INVALID_APPEAL_RULING);\r\n\r\n        // Create a new adjudication round for the dispute\r\n        NextRoundDetails memory nextRound = _getNextRoundDetails(round, _roundId, config);\r\n        DisputeState newDisputeState = nextRound.newDisputeState;\r\n        uint256 newRoundId = _createRound(_disputeId, newDisputeState, nextRound.startTerm, nextRound.jurorsNumber, nextRound.jurorFees);\r\n\r\n        // Update previous round appeal state\r\n        appeal.taker = msg.sender;\r\n        appeal.opposedRuling = _ruling;\r\n        emit RulingAppealConfirmed(_disputeId, newRoundId, nextRound.startTerm, nextRound.jurorsNumber);\r\n\r\n        // Pay appeal confirm deposit\r\n        _depositAmount(msg.sender, nextRound.feeToken, nextRound.confirmAppealDeposit);\r\n    }\r\n\r\n    /**\r\n    * @notice Compute the final ruling for dispute #`_disputeId`\r\n    * @param _disputeId Identification number of the dispute to compute its final ruling\r\n    * @return subject Arbitrable instance associated to the dispute\r\n    * @return finalRuling Final ruling decided for the given dispute\r\n    */\r\n    function computeRuling(uint256 _disputeId) external disputeExists(_disputeId) returns (IArbitrable subject, uint8 finalRuling) {\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        subject = dispute.subject;\r\n\r\n        Config memory config = _getDisputeConfig(dispute);\r\n        finalRuling = _ensureFinalRuling(dispute, _disputeId, config);\r\n\r\n        if (dispute.state != DisputeState.Ruled) {\r\n            dispute.state = DisputeState.Ruled;\r\n            emit RulingComputed(_disputeId, finalRuling);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Settle penalties for round #`_roundId` of dispute #`_disputeId`\r\n    * @dev In case of a regular round, all the drafted jurors that didn't vote in favor of the final ruling of the given dispute will be slashed.\r\n    *      In case of a final round, jurors are slashed when voting, thus it is considered these rounds settled at once. Rewards have to be\r\n    *      manually claimed through `settleReward` which will return pre-slashed tokens for the winning jurors of a final round as well.\r\n    * @param _disputeId Identification number of the dispute to settle penalties for\r\n    * @param _roundId Identification number of the dispute round to settle penalties for\r\n    * @param _jurorsToSettle Maximum number of jurors to be slashed in this call. It can be set to zero to slash all the losing jurors of the\r\n    *        given round. This argument is only used when settling regular rounds.\r\n    */\r\n    function settlePenalties(uint256 _disputeId, uint256 _roundId, uint256 _jurorsToSettle) external roundExists(_disputeId, _roundId) {\r\n        // Enforce that rounds are settled in order to avoid one round without incentive to settle. Even if there is a settle fee\r\n        // it may not be big enough and all jurors in the round could be slashed.\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        require(_roundId == 0 || dispute.rounds[_roundId - 1].settledPenalties, ERROR_PREV_ROUND_NOT_SETTLED);\r\n\r\n        // Ensure given round has not been fully settled yet\r\n        AdjudicationRound storage round = dispute.rounds[_roundId];\r\n        require(!round.settledPenalties, ERROR_ROUND_ALREADY_SETTLED);\r\n\r\n        // Ensure the final ruling of the given dispute is already computed\r\n        Config memory config = _getDisputeConfig(dispute);\r\n        uint8 finalRuling = _ensureFinalRuling(dispute, _disputeId, config);\r\n\r\n        // Set the number of jurors that voted in favor of the final ruling if we haven't started settling yet\r\n        uint256 voteId = _getVoteId(_disputeId, _roundId);\r\n        if (round.settledJurors == 0) {\r\n            // Note that we are safe to cast the tally of a ruling to uint64 since the highest value a ruling can have is equal to the jurors\r\n            // number for regular rounds or to the total active balance of the registry for final rounds, and both are ensured to fit in uint64.\r\n            ICRVoting voting = _voting();\r\n            round.coherentJurors = uint64(voting.getOutcomeTally(voteId, finalRuling));\r\n        }\r\n\r\n        ITreasury treasury = _treasury();\r\n        ERC20 feeToken = config.fees.token;\r\n        if (_isRegularRound(_roundId, config)) {\r\n            // For regular appeal rounds we compute the amount of locked tokens that needs to get burned in batches.\r\n            // The callers of this function will get rewarded in this case.\r\n            uint256 jurorsSettled = _settleRegularRoundPenalties(round, voteId, finalRuling, config.disputes.penaltyPct, _jurorsToSettle, config.minActiveBalance);\r\n            treasury.assign(feeToken, msg.sender, config.fees.settleFee.mul(jurorsSettled));\r\n        } else {\r\n            // For the final appeal round, there is no need to settle in batches since, to guarantee scalability,\r\n            // all the tokens are collected from jurors when they vote, and those jurors who\r\n            // voted in favor of the winning ruling can claim their collected tokens back along with their reward.\r\n            // Note that the caller of this function is not being reimbursed.\r\n            round.settledPenalties = true;\r\n        }\r\n\r\n        if (round.settledPenalties) {\r\n            uint256 collectedTokens = round.collectedTokens;\r\n            emit PenaltiesSettled(_disputeId, _roundId, collectedTokens);\r\n            _burnCollectedTokensIfNecessary(dispute, round, _roundId, treasury, feeToken, collectedTokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Claim reward for round #`_roundId` of dispute #`_disputeId` for juror `_juror`\r\n    * @dev For regular rounds, it will only reward winning jurors\r\n    * @param _disputeId Identification number of the dispute to settle rewards for\r\n    * @param _roundId Identification number of the dispute round to settle rewards for\r\n    * @param _juror Address of the juror to settle their rewards\r\n    */\r\n    function settleReward(uint256 _disputeId, uint256 _roundId, address _juror) external roundExists(_disputeId, _roundId) {\r\n        // Ensure dispute round penalties are settled first\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        AdjudicationRound storage round = dispute.rounds[_roundId];\r\n        require(round.settledPenalties, ERROR_ROUND_NOT_SETTLED);\r\n\r\n        // Ensure given juror was not rewarded yet and was drafted for the given round\r\n        JurorState storage jurorState = round.jurorsStates[_juror];\r\n        require(!jurorState.rewarded, ERROR_JUROR_ALREADY_REWARDED);\r\n        require(uint256(jurorState.weight) > 0, ERROR_WONT_REWARD_NON_VOTER_JUROR);\r\n        jurorState.rewarded = true;\r\n\r\n        // Check if the given juror has voted in favor of the final ruling of the dispute in this round\r\n        ICRVoting voting = _voting();\r\n        uint256 voteId = _getVoteId(_disputeId, _roundId);\r\n        require(voting.hasVotedInFavorOf(voteId, dispute.finalRuling, _juror), ERROR_WONT_REWARD_INCOHERENT_JUROR);\r\n\r\n        uint256 collectedTokens = round.collectedTokens;\r\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\r\n\r\n        // Distribute the collected tokens of the jurors that were slashed weighted by the winning jurors. Note that we are penalizing jurors\r\n        // that refused intentionally their vote for the final round.\r\n        uint256 rewardTokens;\r\n        if (collectedTokens > 0) {\r\n            // Note that the number of coherent jurors has to be greater than zero since we already ensured the juror has voted in favor of the\r\n            // final ruling, therefore there will be at least one coherent juror and divisions below are safe.\r\n            rewardTokens = _getRoundWeightedAmount(round, jurorState, collectedTokens);\r\n            jurorsRegistry.assignTokens(_juror, rewardTokens);\r\n        }\r\n\r\n        // Reward the winning juror with fees\r\n        Config memory config = _getDisputeConfig(dispute);\r\n        // Note that the number of coherent jurors has to be greater than zero since we already ensured the juror has voted in favor of the\r\n        // final ruling, therefore there will be at least one coherent juror and divisions below are safe.\r\n        uint256 rewardFees = _getRoundWeightedAmount(round, jurorState, round.jurorFees);\r\n        _treasury().assign(config.fees.token, _juror, rewardFees);\r\n\r\n        // Set the lock for final round\r\n        if (!_isRegularRound(_roundId, config)) {\r\n            // Round end term ID (as it's final there's no draft delay nor appeal) plus the lock period\r\n            DisputesConfig memory disputesConfig = config.disputes;\r\n            jurorsRegistry.lockWithdrawals(\r\n                _juror,\r\n                round.draftTermId + disputesConfig.commitTerms + disputesConfig.revealTerms + disputesConfig.finalRoundLockTerms\r\n            );\r\n        }\r\n\r\n        emit RewardSettled(_disputeId, _roundId, _juror, rewardTokens, rewardFees);\r\n    }\r\n\r\n    /**\r\n    * @notice Settle appeal deposits for round #`_roundId` of dispute #`_disputeId`\r\n    * @param _disputeId Identification number of the dispute to settle appeal deposits for\r\n    * @param _roundId Identification number of the dispute round to settle appeal deposits for\r\n    */\r\n    function settleAppealDeposit(uint256 _disputeId, uint256 _roundId) external roundExists(_disputeId, _roundId) {\r\n        // Ensure dispute round penalties are settled first\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        AdjudicationRound storage round = dispute.rounds[_roundId];\r\n        require(round.settledPenalties, ERROR_ROUND_NOT_SETTLED);\r\n\r\n        // Ensure given round was appealed and has not been settled yet\r\n        Appeal storage appeal = round.appeal;\r\n        require(_existsAppeal(appeal), ERROR_ROUND_NOT_APPEALED);\r\n        require(!appeal.settled, ERROR_ROUND_APPEAL_ALREADY_SETTLED);\r\n        appeal.settled = true;\r\n        emit AppealDepositSettled(_disputeId, _roundId);\r\n\r\n        // Load next round details\r\n        Config memory config = _getDisputeConfig(dispute);\r\n        NextRoundDetails memory nextRound = _getNextRoundDetails(round, _roundId, config);\r\n        ERC20 feeToken = nextRound.feeToken;\r\n        uint256 totalFees = nextRound.totalFees;\r\n        uint256 appealDeposit = nextRound.appealDeposit;\r\n        uint256 confirmAppealDeposit = nextRound.confirmAppealDeposit;\r\n\r\n        // If the appeal wasn't confirmed, return the entire deposit to appeal maker\r\n        ITreasury treasury = _treasury();\r\n        if (!_isAppealConfirmed(appeal)) {\r\n            treasury.assign(feeToken, appeal.maker, appealDeposit);\r\n            return;\r\n        }\r\n\r\n        // If the appeal was confirmed and there is a winner, we transfer the total deposit to that party. Otherwise, if the final ruling wasn't\r\n        // selected by any of the appealing parties or no juror voted in the in favor of the possible outcomes, we split it between both parties.\r\n        // Note that we are safe to access the dispute final ruling, since we already ensured that round penalties were settled.\r\n        uint8 finalRuling = dispute.finalRuling;\r\n        uint256 totalDeposit = appealDeposit.add(confirmAppealDeposit);\r\n        if (appeal.appealedRuling == finalRuling) {\r\n            treasury.assign(feeToken, appeal.maker, totalDeposit.sub(totalFees));\r\n        } else if (appeal.opposedRuling == finalRuling) {\r\n            treasury.assign(feeToken, appeal.taker, totalDeposit.sub(totalFees));\r\n        } else {\r\n            uint256 feesRefund = totalFees / 2;\r\n            treasury.assign(feeToken, appeal.maker, appealDeposit.sub(feesRefund));\r\n            treasury.assign(feeToken, appeal.taker, confirmAppealDeposit.sub(feesRefund));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Ensure votes can be committed for vote #`_voteId`, revert otherwise\r\n    * @dev This function will ensure the current term of the Court and revert in case votes cannot still be committed\r\n    * @param _voteId ID of the vote instance to request the weight of a voter for\r\n    */\r\n    function ensureCanCommit(uint256 _voteId) external {\r\n        (Dispute storage dispute, uint256 roundId) = _decodeVoteId(_voteId);\r\n        Config memory config = _getDisputeConfig(dispute);\r\n\r\n        // Ensure current term and check that votes can still be committed for the given round\r\n        _ensureAdjudicationState(dispute, roundId, AdjudicationState.Committing, config.disputes);\r\n    }\r\n\r\n    /**\r\n    * @notice Ensure `voter` can commit votes for vote #`_voteId`, revert otherwise\r\n    * @dev This function will ensure the current term of the Court and revert in case the given voter is not allowed to commit votes\r\n    * @param _voteId ID of the vote instance to request the weight of a voter for\r\n    * @param _voter Address of the voter querying the weight of\r\n    */\r\n    function ensureCanCommit(uint256 _voteId, address _voter) external onlyVoting {\r\n        (Dispute storage dispute, uint256 roundId) = _decodeVoteId(_voteId);\r\n        Config memory config = _getDisputeConfig(dispute);\r\n\r\n        // Ensure current term and check that votes can still be committed for the given round\r\n        _ensureAdjudicationState(dispute, roundId, AdjudicationState.Committing, config.disputes);\r\n        uint64 weight = _computeJurorWeight(dispute, roundId, _voter, config);\r\n        require(weight > 0, ERROR_VOTER_WEIGHT_ZERO);\r\n    }\r\n\r\n    /**\r\n    * @notice Ensure `voter` can reveal votes for vote #`_voteId`, revert otherwise\r\n    * @dev This function will ensure the current term of the Court and revert in case votes cannot still be revealed\r\n    * @param _voteId ID of the vote instance to request the weight of a voter for\r\n    * @param _voter Address of the voter querying the weight of\r\n    * @return Weight of the requested juror for the requested dispute's round\r\n    */\r\n    function ensureCanReveal(uint256 _voteId, address _voter) external returns (uint64) {\r\n        (Dispute storage dispute, uint256 roundId) = _decodeVoteId(_voteId);\r\n        Config memory config = _getDisputeConfig(dispute);\r\n\r\n        // Ensure current term and check that votes can still be revealed for the given round\r\n        _ensureAdjudicationState(dispute, roundId, AdjudicationState.Revealing, config.disputes);\r\n        AdjudicationRound storage round = dispute.rounds[roundId];\r\n        return _getJurorWeight(round, _voter);\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the global configuration for the max number of jurors to be drafted per batch to `_maxJurorsPerDraftBatch`\r\n    * @param _maxJurorsPerDraftBatch Max number of jurors to be drafted per batch\r\n    */\r\n    function setMaxJurorsPerDraftBatch(uint64 _maxJurorsPerDraftBatch) external onlyConfigGovernor {\r\n        _setMaxJurorsPerDraftBatch(_maxJurorsPerDraftBatch);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the amount of token fees required to create a dispute\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return totalFees Total amount of fees for a regular round at the given term\r\n    */\r\n    function getDisputeFees() external view returns (ERC20 feeToken, uint256 totalFees) {\r\n        uint64 currentTermId = _getCurrentTermId();\r\n        Config memory config = _getConfigAt(currentTermId);\r\n        (feeToken,, totalFees) = _getRegularRoundFees(config.fees, config.disputes.firstRoundJurorsNumber);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell information of a certain dispute\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @return subject Arbitrable subject being disputed\r\n    * @return possibleRulings Number of possible rulings allowed for the drafted jurors to vote on the dispute\r\n    * @return state Current state of the dispute being queried: pre-draft, adjudicating, or ruled\r\n    * @return finalRuling The winning ruling in case the dispute is finished\r\n    * @return lastRoundId Identification number of the last round created for the dispute\r\n    * @return createTermId Identification number of the term when the dispute was created\r\n    */\r\n    function getDispute(uint256 _disputeId) external view disputeExists(_disputeId)\r\n        returns (IArbitrable subject, uint8 possibleRulings, DisputeState state, uint8 finalRuling, uint256 lastRoundId, uint64 createTermId)\r\n    {\r\n        Dispute storage dispute = disputes[_disputeId];\r\n\r\n        subject = dispute.subject;\r\n        possibleRulings = dispute.possibleRulings;\r\n        state = dispute.state;\r\n        finalRuling = dispute.finalRuling;\r\n        createTermId = dispute.createTermId;\r\n        // If a dispute exists, it has at least one round\r\n        lastRoundId = dispute.rounds.length - 1;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @return draftTerm Term from which the requested round can be drafted\r\n    * @return delayedTerms Number of terms the given round was delayed based on its requested draft term id\r\n    * @return jurorsNumber Number of jurors requested for the round\r\n    * @return selectedJurors Number of jurors already selected for the requested round\r\n    * @return settledPenalties Whether or not penalties have been settled for the requested round\r\n    * @return collectedTokens Amount of juror tokens that were collected from slashed jurors for the requested round\r\n    * @return coherentJurors Number of jurors that voted in favor of the final ruling in the requested round\r\n    * @return state Adjudication state of the requested round\r\n    */\r\n    function getRound(uint256 _disputeId, uint256 _roundId) external view roundExists(_disputeId, _roundId)\r\n        returns (\r\n            uint64 draftTerm,\r\n            uint64 delayedTerms,\r\n            uint64 jurorsNumber,\r\n            uint64 selectedJurors,\r\n            uint256 jurorFees,\r\n            bool settledPenalties,\r\n            uint256 collectedTokens,\r\n            uint64 coherentJurors,\r\n            AdjudicationState state\r\n        )\r\n    {\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        state = _adjudicationStateAt(dispute, _roundId, _getCurrentTermId(), _getDisputeConfig(dispute).disputes);\r\n\r\n        AdjudicationRound storage round = dispute.rounds[_roundId];\r\n        draftTerm = round.draftTermId;\r\n        delayedTerms = round.delayedTerms;\r\n        jurorsNumber = round.jurorsNumber;\r\n        selectedJurors = round.selectedJurors;\r\n        jurorFees = round.jurorFees;\r\n        settledPenalties = round.settledPenalties;\r\n        coherentJurors = round.coherentJurors;\r\n        collectedTokens = round.collectedTokens;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell appeal-related information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @return maker Address of the account appealing the given round\r\n    * @return appealedRuling Ruling confirmed by the appealer of the given round\r\n    * @return taker Address of the account confirming the appeal of the given round\r\n    * @return opposedRuling Ruling confirmed by the appeal taker of the given round\r\n    */\r\n    function getAppeal(uint256 _disputeId, uint256 _roundId) external view roundExists(_disputeId, _roundId)\r\n        returns (address maker, uint64 appealedRuling, address taker, uint64 opposedRuling)\r\n    {\r\n        Appeal storage appeal = disputes[_disputeId].rounds[_roundId].appeal;\r\n\r\n        maker = appeal.maker;\r\n        appealedRuling = appeal.appealedRuling;\r\n        taker = appeal.taker;\r\n        opposedRuling = appeal.opposedRuling;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell information related to the next round due to an appeal of a certain round given.\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round requesting the appeal details of\r\n    * @return nextRoundStartTerm Term ID from which the next round will start\r\n    * @return nextRoundJurorsNumber Jurors number for the next round\r\n    * @return newDisputeState New state for the dispute associated to the given round after the appeal\r\n    * @return feeToken ERC20 token used for the next round fees\r\n    * @return jurorFees Total amount of fees to be distributed between the winning jurors of the next round\r\n    * @return totalFees Total amount of fees for a regular round at the given term\r\n    * @return appealDeposit Amount to be deposit of fees for a regular round at the given term\r\n    * @return confirmAppealDeposit Total amount of fees for a regular round at the given term\r\n    */\r\n    function getNextRoundDetails(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (\r\n            uint64 nextRoundStartTerm,\r\n            uint64 nextRoundJurorsNumber,\r\n            DisputeState newDisputeState,\r\n            ERC20 feeToken,\r\n            uint256 totalFees,\r\n            uint256 jurorFees,\r\n            uint256 appealDeposit,\r\n            uint256 confirmAppealDeposit\r\n        )\r\n    {\r\n        _checkRoundExists(_disputeId, _roundId);\r\n\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        Config memory config = _getDisputeConfig(dispute);\r\n        require(_isRegularRound(_roundId, config), ERROR_ROUND_IS_FINAL);\r\n\r\n        AdjudicationRound storage round = dispute.rounds[_roundId];\r\n        NextRoundDetails memory nextRound = _getNextRoundDetails(round, _roundId, config);\r\n        return (\r\n            nextRound.startTerm,\r\n            nextRound.jurorsNumber,\r\n            nextRound.newDisputeState,\r\n            nextRound.feeToken,\r\n            nextRound.totalFees,\r\n            nextRound.jurorFees,\r\n            nextRound.appealDeposit,\r\n            nextRound.confirmAppealDeposit\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Tell juror-related information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @param _juror Address of the juror being queried\r\n    * @return weight Juror weight drafted for the requested round\r\n    * @return rewarded Whether or not the given juror was rewarded based on the requested round\r\n    */\r\n    function getJuror(uint256 _disputeId, uint256 _roundId, address _juror) external view roundExists(_disputeId, _roundId)\r\n        returns (uint64 weight, bool rewarded)\r\n    {\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        AdjudicationRound storage round = dispute.rounds[_roundId];\r\n        Config memory config = _getDisputeConfig(dispute);\r\n\r\n        if (_isRegularRound(_roundId, config)) {\r\n            weight = _getJurorWeight(round, _juror);\r\n        } else {\r\n            IJurorsRegistry jurorsRegistry = _jurorsRegistry();\r\n            uint256 activeBalance = jurorsRegistry.activeBalanceOfAt(_juror, round.draftTermId);\r\n            weight = _getMinActiveBalanceMultiple(activeBalance, config.minActiveBalance);\r\n        }\r\n\r\n        rewarded = round.jurorsStates[_juror].rewarded;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to create a new round for a given dispute\r\n    * @param _disputeId Identification number of the dispute to create a new round for\r\n    * @param _disputeState New state for the dispute to be changed\r\n    * @param _draftTermId Term ID when the jurors for the new round will be drafted\r\n    * @param _jurorsNumber Number of jurors to be drafted for the new round\r\n    * @param _jurorFees Total amount of fees to be shared between the winning jurors of the new round\r\n    * @return Identification number of the new dispute round\r\n    */\r\n    function _createRound(uint256 _disputeId, DisputeState _disputeState, uint64 _draftTermId, uint64 _jurorsNumber, uint256 _jurorFees) internal\r\n        returns (uint256)\r\n    {\r\n        // Update dispute state\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        dispute.state = _disputeState;\r\n\r\n        // Create new requested round\r\n        uint256 roundId = dispute.rounds.length++;\r\n        AdjudicationRound storage round = dispute.rounds[roundId];\r\n        round.draftTermId = _draftTermId;\r\n        round.jurorsNumber = _jurorsNumber;\r\n        round.jurorFees = _jurorFees;\r\n\r\n        // Create new vote for the new round\r\n        ICRVoting voting = _voting();\r\n        uint256 voteId = _getVoteId(_disputeId, roundId);\r\n        voting.create(voteId, dispute.possibleRulings);\r\n        return roundId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to ensure the adjudication state of a certain dispute round. This function will make sure the court term is updated.\r\n    *      This function assumes the given round exists.\r\n    * @param _dispute Dispute to be checked\r\n    * @param _roundId Identification number of the dispute round to be checked\r\n    * @param _state Expected adjudication state for the given dispute round\r\n    * @param _config Config at the draft term ID of the given dispute\r\n    */\r\n    function _ensureAdjudicationState(Dispute storage _dispute, uint256 _roundId, AdjudicationState _state, DisputesConfig memory _config)\r\n        internal\r\n    {\r\n        uint64 termId = _ensureCurrentTerm();\r\n        AdjudicationState roundState = _adjudicationStateAt(_dispute, _roundId, termId, _config);\r\n        require(roundState == _state, ERROR_INVALID_ADJUDICATION_STATE);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to ensure the final ruling of a dispute. It will compute it only if missing.\r\n    * @param _dispute Dispute to ensure its final ruling\r\n    * @param _disputeId Identification number of the dispute to ensure its final ruling\r\n    * @param _config Config at the draft term ID of the given dispute\r\n    * @return Number of the final ruling ensured for the given dispute\r\n    */\r\n    function _ensureFinalRuling(Dispute storage _dispute, uint256 _disputeId, Config memory _config) internal returns (uint8) {\r\n        // Check if there was a final ruling already cached\r\n        if (uint256(_dispute.finalRuling) > 0) {\r\n            return _dispute.finalRuling;\r\n        }\r\n\r\n        // Ensure current term and check that the last adjudication round has ended.\r\n        // Note that there will always be at least one round.\r\n        uint256 lastRoundId = _dispute.rounds.length - 1;\r\n        _ensureAdjudicationState(_dispute, lastRoundId, AdjudicationState.Ended, _config.disputes);\r\n\r\n        // If the last adjudication round was appealed but no-one confirmed it, the final ruling is the outcome the\r\n        // appealer vouched for. Otherwise, fetch the winning outcome from the voting app of the last round.\r\n        AdjudicationRound storage lastRound = _dispute.rounds[lastRoundId];\r\n        Appeal storage lastAppeal = lastRound.appeal;\r\n        bool isRoundAppealedAndNotConfirmed = _existsAppeal(lastAppeal) && !_isAppealConfirmed(lastAppeal);\r\n        uint8 finalRuling = isRoundAppealedAndNotConfirmed\r\n            ? lastAppeal.appealedRuling\r\n            : _voting().getWinningOutcome(_getVoteId(_disputeId, lastRoundId));\r\n\r\n        // Store the winning ruling as the final decision for the given dispute\r\n        _dispute.finalRuling = finalRuling;\r\n        return finalRuling;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to slash all the jurors drafted for a round that didn't vote in favor of the final ruling of a dispute. Note that\r\n    *      the slashing can be batched handling the maximum number of jurors to be slashed on each call.\r\n    * @param _round Round to slash the non-winning jurors of\r\n    * @param _voteId Identification number of the voting associated to the given round\r\n    * @param _finalRuling Winning ruling of the dispute corresponding to the given round\r\n    * @param _penaltyPct Per ten thousand of the minimum active balance of a juror to be slashed\r\n    * @param _jurorsToSettle Maximum number of jurors to be slashed in this call. It can be set to zero to slash all the losing jurors of the round.\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    * @return Number of jurors slashed for the given round\r\n    */\r\n    function _settleRegularRoundPenalties(\r\n        AdjudicationRound storage _round,\r\n        uint256 _voteId,\r\n        uint8 _finalRuling,\r\n        uint16 _penaltyPct,\r\n        uint256 _jurorsToSettle,\r\n        uint256 _minActiveBalance\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint64 termId = _ensureCurrentTerm();\r\n        // The batch starts where the previous one ended, stored in _round.settledJurors\r\n        uint256 roundSettledJurors = _round.settledJurors;\r\n        // Compute the amount of jurors that are going to be settled in this batch, which is returned by the function for fees calculation\r\n        // Initially we try to reach the end of the jurors array\r\n        uint256 batchSettledJurors = _round.jurors.length.sub(roundSettledJurors);\r\n\r\n        // If the requested amount of jurors is not zero and it is lower that the remaining number of jurors to be settled for the given round,\r\n        // we cap the number of jurors that are going to be settled in this batch to the requested amount. If not, we know we have reached the\r\n        // last batch and we are safe to mark round penalties as settled.\r\n        if (_jurorsToSettle > 0 && batchSettledJurors > _jurorsToSettle) {\r\n            batchSettledJurors = _jurorsToSettle;\r\n        } else {\r\n            _round.settledPenalties = true;\r\n        }\r\n\r\n        // Update the number of round settled jurors.\r\n        _round.settledJurors = uint64(roundSettledJurors.add(batchSettledJurors));\r\n\r\n        // Prepare the list of jurors and penalties to either be slashed or returned based on their votes for the given round\r\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\r\n        address[] memory jurors = new address[](batchSettledJurors);\r\n        uint256[] memory penalties = new uint256[](batchSettledJurors);\r\n        for (uint256 i = 0; i < batchSettledJurors; i++) {\r\n            address juror = _round.jurors[roundSettledJurors + i];\r\n            jurors[i] = juror;\r\n            penalties[i] = _minActiveBalance.pct(_penaltyPct).mul(_round.jurorsStates[juror].weight);\r\n        }\r\n\r\n        // Check which of the jurors voted in favor of the final ruling of the dispute in this round. Ask the registry to slash or unlocked the\r\n        // locked active tokens of each juror depending on their vote, and finally store the total amount of slashed tokens.\r\n        bool[] memory jurorsInFavor = _voting().getVotersInFavorOf(_voteId, _finalRuling, jurors);\r\n        _round.collectedTokens = _round.collectedTokens.add(jurorsRegistry.slashOrUnlock(termId, jurors, penalties, jurorsInFavor));\r\n        return batchSettledJurors;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to compute the juror weight for a dispute's round\r\n    * @param _dispute Dispute to calculate the juror's weight of\r\n    * @param _roundId ID of the dispute's round to calculate the juror's weight of\r\n    * @param _juror Address of the juror to calculate the weight of\r\n    * @param _config Config at the draft term ID of the given dispute\r\n    * @return Computed weight of the requested juror for the final round of the given dispute\r\n    */\r\n    function _computeJurorWeight(Dispute storage _dispute, uint256 _roundId, address _juror, Config memory _config) internal returns (uint64) {\r\n        AdjudicationRound storage round = _dispute.rounds[_roundId];\r\n\r\n        return _isRegularRound(_roundId, _config)\r\n            ? _getJurorWeight(round, _juror)\r\n            : _computeJurorWeightForFinalRound(_config, round, _juror);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to compute the juror weight for the final round. Note that for a final round the weight of\r\n    *      each juror is equal to the number of times the min active balance the juror has. This function will try to\r\n    *      collect said amount from the active balance of a juror, acting as a lock to allow them to vote.\r\n    * @param _config Court config to calculate the juror's weight\r\n    * @param _round Dispute round to calculate the juror's weight for\r\n    * @param _juror Address of the juror to calculate the weight of\r\n    * @return Weight of the requested juror for the final round of the given dispute\r\n    */\r\n    function _computeJurorWeightForFinalRound(Config memory _config, AdjudicationRound storage _round, address _juror) internal\r\n        returns (uint64)\r\n    {\r\n        // Fetch active balance and multiples of the min active balance from the registry\r\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\r\n        uint256 activeBalance = jurorsRegistry.activeBalanceOfAt(_juror, _round.draftTermId);\r\n        uint64 weight = _getMinActiveBalanceMultiple(activeBalance, _config.minActiveBalance);\r\n\r\n        // If the juror weight for the last round is zero, return zero\r\n        if (weight == 0) {\r\n            return uint64(0);\r\n        }\r\n\r\n        // To guarantee scalability of the final round, since all jurors may vote, we try to collect the amount of\r\n        // active tokens that needs to be locked for each juror when they try to commit their vote.\r\n        uint256 weightedPenalty = activeBalance.pct(_config.disputes.penaltyPct);\r\n\r\n        // If it was not possible to collect the amount to be locked, return 0 to prevent juror from voting\r\n        if (!jurorsRegistry.collectTokens(_juror, weightedPenalty, _getLastEnsuredTermId())) {\r\n            return uint64(0);\r\n        }\r\n\r\n        // If it was possible to collect the amount of active tokens to be locked, update the final round state\r\n        _round.jurorsStates[_juror].weight = weight;\r\n        _round.collectedTokens = _round.collectedTokens.add(weightedPenalty);\r\n\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the global configuration for the max number of jurors to be drafted per batch\r\n    * @param _maxJurorsPerDraftBatch Max number of jurors to be drafted per batch\r\n    */\r\n    function _setMaxJurorsPerDraftBatch(uint64 _maxJurorsPerDraftBatch) internal {\r\n        require(_maxJurorsPerDraftBatch > 0, ERROR_BAD_MAX_DRAFT_BATCH_SIZE);\r\n        emit MaxJurorsPerDraftBatchChanged(maxJurorsPerDraftBatch, _maxJurorsPerDraftBatch);\r\n        maxJurorsPerDraftBatch = _maxJurorsPerDraftBatch;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to execute a deposit of tokens from an account to the Court treasury contract\r\n    * @param _from Address transferring the amount of tokens\r\n    * @param _token ERC20 token to execute a transfer from\r\n    * @param _amount Amount of tokens to be transferred from the address transferring the funds to the Court treasury\r\n    */\r\n    function _depositAmount(address _from, ERC20 _token, uint256 _amount) internal {\r\n        if (_amount > 0) {\r\n            ITreasury treasury = _treasury();\r\n            require(_token.safeTransferFrom(_from, address(treasury), _amount), ERROR_DEPOSIT_FAILED);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the stored juror weight for a round. Note that the weight of a juror is:\r\n    *      - For a regular round: the number of times a juror was picked for the round round.\r\n    *      - For a final round: the relative active stake of a juror's state over the total active tokens, only set after the juror has voted.\r\n    * @param _round Dispute round to calculate the juror's weight of\r\n    * @param _juror Address of the juror to calculate the weight of\r\n    * @return Weight of the requested juror for the given round\r\n    */\r\n    function _getJurorWeight(AdjudicationRound storage _round, address _juror) internal view returns (uint64) {\r\n        return _round.jurorsStates[_juror].weight;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell information related to the next round due to an appeal of a certain round given. This function assumes\r\n    *      given round can be appealed and that the given round ID corresponds to the given round pointer.\r\n    * @param _round Round requesting the appeal details of\r\n    * @param _roundId Identification number of the round requesting the appeal details of\r\n    * @param _config Config at the draft term of the given dispute\r\n    * @return Next round details\r\n    */\r\n    function _getNextRoundDetails(AdjudicationRound storage _round, uint256 _roundId, Config memory _config) internal view\r\n        returns (NextRoundDetails memory)\r\n    {\r\n        NextRoundDetails memory nextRound;\r\n        DisputesConfig memory disputesConfig = _config.disputes;\r\n\r\n        // Next round start term is current round end term\r\n        uint64 delayedDraftTerm = _round.draftTermId.add(_round.delayedTerms);\r\n        uint64 currentRoundAppealStartTerm = delayedDraftTerm.add(disputesConfig.commitTerms).add(disputesConfig.revealTerms);\r\n        nextRound.startTerm = currentRoundAppealStartTerm.add(disputesConfig.appealTerms).add(disputesConfig.appealConfirmTerms);\r\n\r\n        // Compute next round settings depending on if it will be the final round or not\r\n        if (_roundId >= disputesConfig.maxRegularAppealRounds.sub(1)) {\r\n            // If the next round is the final round, no draft is needed.\r\n            nextRound.newDisputeState = DisputeState.Adjudicating;\r\n            // The number of jurors will be the number of times the minimum stake is held in the registry,\r\n            // multiplied by a precision factor to help with division rounding.\r\n            // Total active balance is guaranteed to never be greater than `2^64 * minActiveBalance / FINAL_ROUND_WEIGHT_PRECISION`.\r\n            // Thus, the jurors number for a final round will always fit in uint64.\r\n            IJurorsRegistry jurorsRegistry = _jurorsRegistry();\r\n            uint256 totalActiveBalance = jurorsRegistry.totalActiveBalanceAt(nextRound.startTerm);\r\n            uint64 jurorsNumber = _getMinActiveBalanceMultiple(totalActiveBalance, _config.minActiveBalance);\r\n            nextRound.jurorsNumber = jurorsNumber;\r\n            // Calculate fees for the final round using the appeal start term of the current round\r\n            (nextRound.feeToken, nextRound.jurorFees, nextRound.totalFees) = _getFinalRoundFees(_config.fees, jurorsNumber);\r\n        } else {\r\n            // For a new regular rounds we need to draft jurors\r\n            nextRound.newDisputeState = DisputeState.PreDraft;\r\n            // The number of jurors will be the number of jurors of the current round multiplied by an appeal factor\r\n            nextRound.jurorsNumber = _getNextRegularRoundJurorsNumber(_round, disputesConfig);\r\n            // Calculate fees for the next regular round using the appeal start term of the current round\r\n            (nextRound.feeToken, nextRound.jurorFees, nextRound.totalFees) = _getRegularRoundFees(_config.fees, nextRound.jurorsNumber);\r\n        }\r\n\r\n        // Calculate appeal collateral\r\n        nextRound.appealDeposit = nextRound.totalFees.pct256(disputesConfig.appealCollateralFactor);\r\n        nextRound.confirmAppealDeposit = nextRound.totalFees.pct256(disputesConfig.appealConfirmCollateralFactor);\r\n        return nextRound;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to calculate the jurors number for the next regular round of a given round. This function assumes Court term is\r\n    *      up-to-date, that the next round of the one given is regular, and the given config corresponds to the draft term of the given round.\r\n    * @param _round Round querying the jurors number of its next round\r\n    * @param _config Disputes config at the draft term of the first round of the dispute\r\n    * @return Jurors number for the next regular round of the given round\r\n    */\r\n    function _getNextRegularRoundJurorsNumber(AdjudicationRound storage _round, DisputesConfig memory _config) internal view returns (uint64) {\r\n        // Jurors number are increased by a step factor on each appeal\r\n        uint64 jurorsNumber = _round.jurorsNumber.mul(_config.appealStepFactor);\r\n        // Make sure it's odd to enforce avoiding a tie. Note that it can happen if any of the jurors don't vote anyway.\r\n        if (uint256(jurorsNumber) % 2 == 0) {\r\n            jurorsNumber++;\r\n        }\r\n        return jurorsNumber;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell adjudication state of a round at a certain term. This function assumes the given round exists.\r\n    * @param _dispute Dispute querying the adjudication round of\r\n    * @param _roundId Identification number of the dispute round querying the adjudication round of\r\n    * @param _termId Identification number of the term to be used for the different round phases durations\r\n    * @param _config Disputes config at the draft term ID of the given dispute\r\n    * @return Adjudication state of the requested dispute round for the given term\r\n    */\r\n    function _adjudicationStateAt(Dispute storage _dispute, uint256 _roundId, uint64 _termId, DisputesConfig memory _config) internal view\r\n        returns (AdjudicationState)\r\n    {\r\n        AdjudicationRound storage round = _dispute.rounds[_roundId];\r\n\r\n        // If the dispute is ruled or the given round is not the last one, we consider it ended\r\n        uint256 numberOfRounds = _dispute.rounds.length;\r\n        if (_dispute.state == DisputeState.Ruled || _roundId < numberOfRounds.sub(1)) {\r\n            return AdjudicationState.Ended;\r\n        }\r\n\r\n        // If given term is before the actual term when the last round was finally drafted, then the last round adjudication state is invalid\r\n        uint64 draftFinishedTermId = round.draftTermId.add(round.delayedTerms);\r\n        if (_dispute.state == DisputeState.PreDraft || _termId < draftFinishedTermId) {\r\n            return AdjudicationState.Invalid;\r\n        }\r\n\r\n        // If given term is before the reveal start term of the last round, then jurors are still allowed to commit votes for the last round\r\n        uint64 revealStartTerm = draftFinishedTermId.add(_config.commitTerms);\r\n        if (_termId < revealStartTerm) {\r\n            return AdjudicationState.Committing;\r\n        }\r\n\r\n        // If given term is before the appeal start term of the last round, then jurors are still allowed to reveal votes for the last round\r\n        uint64 appealStartTerm = revealStartTerm.add(_config.revealTerms);\r\n        if (_termId < appealStartTerm) {\r\n            return AdjudicationState.Revealing;\r\n        }\r\n\r\n        // If the max number of appeals has been reached, then the last round is the final round and can be considered ended\r\n        bool maxAppealReached = numberOfRounds > _config.maxRegularAppealRounds;\r\n        if (maxAppealReached) {\r\n            return AdjudicationState.Ended;\r\n        }\r\n\r\n        // If the last round was not appealed yet, check if the confirmation period has started or not\r\n        bool isLastRoundAppealed = _existsAppeal(round.appeal);\r\n        uint64 appealConfirmationStartTerm = appealStartTerm.add(_config.appealTerms);\r\n        if (!isLastRoundAppealed) {\r\n            // If given term is before the appeal confirmation start term, then the last round can still be appealed. Otherwise, it is ended.\r\n            if (_termId < appealConfirmationStartTerm) {\r\n                return AdjudicationState.Appealing;\r\n            } else {\r\n                return AdjudicationState.Ended;\r\n            }\r\n        }\r\n\r\n        // If the last round was appealed and the given term is before the appeal confirmation end term, then the last round appeal can still be\r\n        // confirmed. Note that if the round being checked was already appealed and confirmed, it won't be the last round, thus it will be caught\r\n        // above by the first check and considered 'Ended'.\r\n        uint64 appealConfirmationEndTerm = appealConfirmationStartTerm.add(_config.appealConfirmTerms);\r\n        if (_termId < appealConfirmationEndTerm) {\r\n            return AdjudicationState.ConfirmingAppeal;\r\n        }\r\n\r\n        // If non of the above conditions have been met, the last round is considered ended\r\n        return AdjudicationState.Ended;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config used for a dispute\r\n    * @param _dispute Dispute querying the Court config of\r\n    * @return Court config used for the given dispute\r\n    */\r\n    function _getDisputeConfig(Dispute storage _dispute) internal view returns (Config memory) {\r\n        // Note that it is safe to access a Court config directly for a past term\r\n        return _getConfigAt(_dispute.createTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to check if a certain appeal exists\r\n    * @param _appeal Appeal to be checked\r\n    * @return True if the given appeal has a maker address associated to it, false otherwise\r\n    */\r\n    function _existsAppeal(Appeal storage _appeal) internal view returns (bool) {\r\n        return _appeal.maker != address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to check if a certain appeal has been confirmed\r\n    * @param _appeal Appeal to be checked\r\n    * @return True if the given appeal was confirmed, false otherwise\r\n    */\r\n    function _isAppealConfirmed(Appeal storage _appeal) internal view returns (bool) {\r\n        return _appeal.taker != address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to check if a certain dispute exists, it reverts if it doesn't\r\n    * @param _disputeId Identification number of the dispute to be checked\r\n    */\r\n    function _checkDisputeExists(uint256 _disputeId) internal view {\r\n        require(_disputeId < disputes.length, ERROR_DISPUTE_DOES_NOT_EXIST);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to check if a certain dispute round exists, it reverts if it doesn't\r\n    * @param _disputeId Identification number of the dispute to be checked\r\n    * @param _roundId Identification number of the dispute round to be checked\r\n    */\r\n    function _checkRoundExists(uint256 _disputeId, uint256 _roundId) internal view {\r\n        _checkDisputeExists(_disputeId);\r\n        require(_roundId < disputes[_disputeId].rounds.length, ERROR_ROUND_DOES_NOT_EXIST);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the dispute round of a certain vote identification number\r\n    * @param _voteId Identification number of the vote querying the dispute round of\r\n    * @return dispute Dispute for the given vote\r\n    * @return roundId Identification number of the dispute round for the given vote\r\n    */\r\n    function _decodeVoteId(uint256 _voteId) internal view returns (Dispute storage dispute, uint256 roundId) {\r\n        uint256 disputeId = _voteId >> 128;\r\n        roundId = _voteId & VOTE_ID_MASK;\r\n        _checkRoundExists(disputeId, roundId);\r\n        dispute = disputes[disputeId];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the identification number of the vote of a certain dispute round\r\n    * @param _disputeId Identification number of the dispute querying the vote ID of\r\n    * @param _roundId Identification number of the dispute round querying the vote ID of\r\n    * @return Identification number of the vote of the requested dispute round\r\n    */\r\n    function _getVoteId(uint256 _disputeId, uint256 _roundId) internal pure returns (uint256) {\r\n        return (_disputeId << 128) + _roundId;\r\n    }\r\n\r\n    /**\r\n    * @dev Assumes round.coherentJurors is greater than zero\r\n    * @param _round Round which the weighted amount is computed for\r\n    * @param _jurorState Juror with state which the weighted amount is computed for\r\n    * @param _amount Amount to be weighted\r\n    * @return Weighted amount for a juror in a round in relation to total amount of coherent jurors\r\n    */\r\n    function _getRoundWeightedAmount(\r\n        AdjudicationRound storage _round,\r\n        JurorState storage _jurorState,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _amount.mul(_jurorState.weight) / _round.coherentJurors;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get fees information for regular rounds for a certain term. This function assumes Court term is up-to-date.\r\n    * @param _config Court config to use in order to get fees\r\n    * @param _jurorsNumber Number of jurors participating in the round being queried\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return jurorFees Total amount of fees to be distributed between the winning jurors of a round\r\n    * @return totalFees Total amount of fees for a regular round at the given term\r\n    */\r\n    function _getRegularRoundFees(FeesConfig memory _config, uint64 _jurorsNumber) internal pure\r\n        returns (ERC20 feeToken, uint256 jurorFees, uint256 totalFees)\r\n    {\r\n        feeToken = _config.token;\r\n        // For regular rounds the fees for each juror is constant and given by the config of the round\r\n        jurorFees = uint256(_jurorsNumber).mul(_config.jurorFee);\r\n        // The total fees for regular rounds also considers the number of drafts and settles\r\n        uint256 draftAndSettleFees = (_config.draftFee.add(_config.settleFee)).mul(uint256(_jurorsNumber));\r\n        totalFees = jurorFees.add(draftAndSettleFees);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get fees information for final rounds for a certain term. This function assumes Court term is up-to-date.\r\n    * @param _config Court config to use in order to get fees\r\n    * @param _jurorsNumber Number of jurors participating in the round being queried\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return jurorFees Total amount of fees corresponding to the jurors at the given term\r\n    * @return totalFees Total amount of fees for a final round at the given term\r\n    */\r\n    function _getFinalRoundFees(FeesConfig memory _config, uint64 _jurorsNumber) internal pure\r\n        returns (ERC20 feeToken, uint256 jurorFees, uint256 totalFees)\r\n    {\r\n        feeToken = _config.token;\r\n        // For final rounds, the jurors number is computed as the number of times the registry's minimum active balance is held in the registry\r\n        // itself, multiplied by a precision factor. To avoid requesting a huge amount of fees, a final round discount is applied for each juror.\r\n        jurorFees = (uint256(_jurorsNumber).mul(_config.jurorFee) / FINAL_ROUND_WEIGHT_PRECISION).pct(_config.finalRoundReduction);\r\n        // There is no draft and no extra settle fees considered for final rounds\r\n        totalFees = jurorFees;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell whether a round is regular or final. This function assumes the given round exists.\r\n    * @param _roundId Identification number of the round to be checked\r\n    * @param _config Court config to use in order to check if the given round is regular or final\r\n    * @return True if the given round is regular, false in case its a final round\r\n    */\r\n    function _isRegularRound(uint256 _roundId, Config memory _config) internal pure returns (bool) {\r\n        return _roundId < _config.disputes.maxRegularAppealRounds;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the number of times that an amount contains the min active balance (multiplied by precision).\r\n    *      Used to get the juror weight for the final round. Note that for the final round the weight of\r\n    *      each juror is equal to the number of times the min active balance the juror has, multiplied by a precision\r\n    *      factor to deal with division rounding.\r\n    * @param _activeBalance Juror's or total active balance\r\n    * @param _minActiveBalance Minimum amount of juror tokens that can be activated\r\n    * @return Number of times that the active balance contains the min active balance (multiplied by precision)\r\n    */\r\n    function _getMinActiveBalanceMultiple(uint256 _activeBalance, uint256 _minActiveBalance) internal pure returns (uint64) {\r\n        // Note that jurors may not reach the minimum active balance since some might have been slashed. If that occurs,\r\n        // these jurors cannot vote in the final round.\r\n        if (_activeBalance < _minActiveBalance) {\r\n            return 0;\r\n        }\r\n\r\n        // Otherwise, return the times the active balance of the juror fits in the min active balance, multiplying\r\n        // it by a round factor to ensure a better precision rounding.\r\n        return (FINAL_ROUND_WEIGHT_PRECISION.mul(_activeBalance) / _minActiveBalance).toUint64();\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to build params to call for a draft. It assumes the given data is correct.\r\n    * @param _disputeId Identification number of the dispute to be drafted\r\n    * @param _roundId Identification number of the round to be drafted\r\n    * @param _termId Identification number of the current term of the Court\r\n    * @param _draftTermRandomness Randomness of the term in which the dispute was requested to be drafted\r\n    * @param _config Draft config of the Court at the draft term\r\n    * @return Draft params object\r\n    */\r\n    function _buildDraftParams(uint256 _disputeId, uint256 _roundId, uint64 _termId, bytes32 _draftTermRandomness, DraftConfig memory _config)\r\n        private\r\n        pure\r\n        returns (DraftParams memory)\r\n    {\r\n        return DraftParams({\r\n            disputeId: _disputeId,\r\n            roundId: _roundId,\r\n            termId: _termId,\r\n            draftTermRandomness: _draftTermRandomness,\r\n            config: _config\r\n        });\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to draft jurors for a given dispute and round. It assumes the given data is correct.\r\n    * @param _round Round of the dispute to be drafted\r\n    * @param _draftParams Draft params to be used for the draft\r\n    * @return True if all the requested jurors for the given round were drafted, false otherwise\r\n    */\r\n    function _draft(AdjudicationRound storage _round, DraftParams memory _draftParams) private returns (bool) {\r\n        uint64 jurorsNumber = _round.jurorsNumber;\r\n        uint64 selectedJurors = _round.selectedJurors;\r\n        uint64 maxJurorsPerBatch = maxJurorsPerDraftBatch;\r\n        uint64 jurorsToBeDrafted = jurorsNumber.sub(selectedJurors);\r\n        // Draft the min number of jurors between the one requested by the sender and the one requested by the sender\r\n        uint64 requestedJurors = jurorsToBeDrafted < maxJurorsPerBatch ? jurorsToBeDrafted : maxJurorsPerBatch;\r\n\r\n        // Pack draft params\r\n        uint256[7] memory params = [\r\n            uint256(_draftParams.draftTermRandomness),\r\n            _draftParams.disputeId,\r\n            uint256(_draftParams.termId),\r\n            uint256(selectedJurors),\r\n            uint256(requestedJurors),\r\n            uint256(jurorsNumber),\r\n            uint256(_draftParams.config.penaltyPct)\r\n        ];\r\n\r\n        // Draft jurors for the requested round\r\n        IJurorsRegistry jurorsRegistry = _jurorsRegistry();\r\n        (address[] memory jurors, uint256 draftedJurors) = jurorsRegistry.draft(params);\r\n\r\n        // Update round with drafted jurors information\r\n        uint64 newSelectedJurors = selectedJurors.add(uint64(draftedJurors));\r\n        _round.selectedJurors = newSelectedJurors;\r\n        _updateRoundDraftedJurors(_draftParams.disputeId, _draftParams.roundId, _round, jurors, draftedJurors);\r\n        bool draftEnded = newSelectedJurors == jurorsNumber;\r\n\r\n        // Transfer fees corresponding to the actual number of drafted jurors\r\n        uint256 draftFees = _draftParams.config.draftFee.mul(draftedJurors);\r\n        _treasury().assign(_draftParams.config.feeToken, msg.sender, draftFees);\r\n        return draftEnded;\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to update the drafted jurors' weight for the given round\r\n    * @param _disputeId Identification number of the dispute being drafted\r\n    * @param _roundId Identification number of the round being drafted\r\n    * @param _round Adjudication round that was drafted\r\n    * @param _jurors List of jurors addresses that were drafted for the given round\r\n    * @param _draftedJurors Number of jurors that were drafted for the given round. Note that this number may not necessarily be equal to the\r\n    *        given list of jurors since the draft could potentially return less jurors than the requested amount.\r\n    */\r\n    function _updateRoundDraftedJurors(\r\n        uint256 _disputeId,\r\n        uint256 _roundId,\r\n        AdjudicationRound storage _round,\r\n        address[] memory _jurors,\r\n        uint256 _draftedJurors\r\n    )\r\n        private\r\n    {\r\n        for (uint256 i = 0; i < _draftedJurors; i++) {\r\n            address juror = _jurors[i];\r\n            JurorState storage jurorState = _round.jurorsStates[juror];\r\n\r\n            // If the juror was already registered in the list, then don't add it twice\r\n            if (uint256(jurorState.weight) == 0) {\r\n                _round.jurors.push(juror);\r\n            }\r\n\r\n            jurorState.weight = jurorState.weight.add(1);\r\n            emit JurorDrafted(_disputeId, _roundId, juror);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to burn the collected for a certain round in case there were no coherent jurors\r\n    * @param _dispute Dispute to settle penalties for\r\n    * @param _round Dispute round to settle penalties for\r\n    * @param _roundId Identification number of the dispute round to settle penalties for\r\n    * @param _courtTreasury Treasury module to refund the corresponding juror fees\r\n    * @param _feeToken ERC20 token to be used for the fees corresponding to the draft term of the given dispute round\r\n    * @param _collectedTokens Amount of tokens collected during the given dispute round\r\n    */\r\n    function _burnCollectedTokensIfNecessary(\r\n        Dispute storage _dispute,\r\n        AdjudicationRound storage _round,\r\n        uint256 _roundId,\r\n        ITreasury _courtTreasury,\r\n        ERC20 _feeToken,\r\n        uint256 _collectedTokens\r\n    )\r\n        private\r\n    {\r\n        // If there was at least one juror voting in favor of the winning ruling, return\r\n        if (_round.coherentJurors > 0) {\r\n            return;\r\n        }\r\n\r\n        // Burn all the collected tokens of the jurors to be slashed. Note that this will happen only when there were no jurors voting\r\n        // in favor of the final winning outcome. Otherwise, these will be re-distributed between the winning jurors in `settleReward`\r\n        // instead of being burned.\r\n        if (_collectedTokens > 0) {\r\n            IJurorsRegistry jurorsRegistry = _jurorsRegistry();\r\n            jurorsRegistry.burnTokens(_collectedTokens);\r\n        }\r\n\r\n        // Reimburse juror fees to the Arbtirable subject for round 0 or to the previous appeal parties for other rounds.\r\n        // Note that if the given round is not the first round, we can ensure there was an appeal in the previous round.\r\n        if (_roundId == 0) {\r\n            _courtTreasury.assign(_feeToken, address(_dispute.subject), _round.jurorFees);\r\n        } else {\r\n            uint256 refundFees = _round.jurorFees / 2;\r\n            Appeal storage triggeringAppeal = _dispute.rounds[_roundId - 1].appeal;\r\n            _courtTreasury.assign(_feeToken, triggeringAppeal.maker, refundFees);\r\n            _courtTreasury.assign(_feeToken, triggeringAppeal.taker, refundFees);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Private function only used in the constructor to skip a given number of disputes\r\n    * @param _skippedDisputes Number of disputes to be skipped\r\n    */\r\n    function _skipDisputes(uint256 _skippedDisputes) private {\r\n        assert(disputes.length == 0);\r\n        disputes.length = _skippedDisputes;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_maxJurorsPerDraftBatch\",\"type\":\"uint64\"}],\"name\":\"setMaxJurorsPerDraftBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_voteId\",\"type\":\"uint256\"},{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"ensureCanCommit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"},{\"name\":\"_ruling\",\"type\":\"uint8\"}],\"name\":\"createAppeal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_voteId\",\"type\":\"uint256\"}],\"name\":\"ensureCanCommit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_subject\",\"type\":\"address\"},{\"name\":\"_possibleRulings\",\"type\":\"uint8\"},{\"name\":\"_metadata\",\"type\":\"bytes\"}],\"name\":\"createDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"recoverFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxJurorsPerDraftBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getRound\",\"outputs\":[{\"name\":\"draftTerm\",\"type\":\"uint64\"},{\"name\":\"delayedTerms\",\"type\":\"uint64\"},{\"name\":\"jurorsNumber\",\"type\":\"uint64\"},{\"name\":\"selectedJurors\",\"type\":\"uint64\"},{\"name\":\"jurorFees\",\"type\":\"uint256\"},{\"name\":\"settledPenalties\",\"type\":\"bool\"},{\"name\":\"collectedTokens\",\"type\":\"uint256\"},{\"name\":\"coherentJurors\",\"type\":\"uint64\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"},{\"name\":\"_juror\",\"type\":\"address\"}],\"name\":\"getJuror\",\"outputs\":[{\"name\":\"weight\",\"type\":\"uint64\"},{\"name\":\"rewarded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"draft\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getAppeal\",\"outputs\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"appealedRuling\",\"type\":\"uint64\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"opposedRuling\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputeFees\",\"outputs\":[{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"totalFees\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"},{\"name\":\"_juror\",\"type\":\"address\"}],\"name\":\"settleReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"},{\"name\":\"_jurorsToSettle\",\"type\":\"uint256\"}],\"name\":\"settlePenalties\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"},{\"name\":\"_ruling\",\"type\":\"uint8\"}],\"name\":\"confirmAppeal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"computeRuling\",\"outputs\":[{\"name\":\"subject\",\"type\":\"address\"},{\"name\":\"finalRuling\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_voteId\",\"type\":\"uint256\"},{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"ensureCanReveal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_subject\",\"type\":\"address\"},{\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"closeEvidencePeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getNextRoundDetails\",\"outputs\":[{\"name\":\"nextRoundStartTerm\",\"type\":\"uint64\"},{\"name\":\"nextRoundJurorsNumber\",\"type\":\"uint64\"},{\"name\":\"newDisputeState\",\"type\":\"uint8\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"totalFees\",\"type\":\"uint256\"},{\"name\":\"jurorFees\",\"type\":\"uint256\"},{\"name\":\"appealDeposit\",\"type\":\"uint256\"},{\"name\":\"confirmAppealDeposit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"getDispute\",\"outputs\":[{\"name\":\"subject\",\"type\":\"address\"},{\"name\":\"possibleRulings\",\"type\":\"uint8\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"finalRuling\",\"type\":\"uint8\"},{\"name\":\"lastRoundId\",\"type\":\"uint256\"},{\"name\":\"createTermId\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"settleAppealDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"},{\"name\":\"_maxJurorsPerDraftBatch\",\"type\":\"uint64\"},{\"name\":\"_skippedDisputes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"DisputeStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"termId\",\"type\":\"uint64\"}],\"name\":\"EvidencePeriodClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"subject\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"draftTermId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"jurorsNumber\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"NewDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"juror\",\"type\":\"address\"}],\"name\":\"JurorDrafted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ruling\",\"type\":\"uint8\"}],\"name\":\"RulingAppealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"draftTermId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"jurorsNumber\",\"type\":\"uint256\"}],\"name\":\"RulingAppealConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ruling\",\"type\":\"uint8\"}],\"name\":\"RulingComputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collectedTokens\",\"type\":\"uint256\"}],\"name\":\"PenaltiesSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"juror\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"RewardSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"AppealDepositSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousMaxJurorsPerDraftBatch\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"currentMaxJurorsPerDraftBatch\",\"type\":\"uint64\"}],\"name\":\"MaxJurorsPerDraftBatchChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"RecoverFunds\",\"type\":\"event\"}]","ContractName":"DisputeManager","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"3000","ConstructorArguments":"000000000000000000000000ee4650cbe7a2b23701d416f58b41d8b76b61779700000000000000000000000000000000000000000000000000000000000000510000000000000000000000000000000000000000000000000000000000000001","Library":"","LicenseType":"None","SwarmSource":"bzzr://9736511eab2676614d9c8070491a2225c53a409a0088a8ce0d8d76e3016800ad"}]}