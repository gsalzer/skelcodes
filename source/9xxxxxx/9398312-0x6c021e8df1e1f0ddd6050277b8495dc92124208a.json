{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/token/interfaces/IERC20Token.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {this;}\r\n    function symbol() public view returns (string) {this;}\r\n    function decimals() public view returns (uint8) {this;}\r\n    function totalSupply() public view returns (uint256) {this;}\r\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/utility/interfaces/IOwned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n// File: contracts/token/interfaces/ISmartToken.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/utility/interfaces/IWhitelist.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Whitelist interface\r\n*/\r\ncontract IWhitelist {\r\n    function isWhitelisted(address _address) public view returns (bool);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorConverter.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Bancor Converter interface\r\n*/\r\ncontract IBancorConverter {\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256, uint256);\r\n    function convert2(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn, address _affiliateAccount, uint256 _affiliateFee) public returns (uint256);\r\n    function quickConvert2(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _affiliateAccount, uint256 _affiliateFee) public payable returns (uint256);\r\n    function conversionWhitelist() public view returns (IWhitelist) {this;}\r\n    function conversionFee() public view returns (uint32) {this;}\r\n    function reserves(address _address) public view returns (uint256, uint32, bool, bool, bool) {_address; this;}\r\n    function getReserveBalance(IERC20Token _reserveToken) public view returns (uint256);\r\n    function reserveTokens(uint256 _index) public view returns (IERC20Token) {_index; this;}\r\n    // deprecated, backward compatibility\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    function quickConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\r\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool);\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\r\n    function connectorTokens(uint256 _index) public view returns (IERC20Token);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorConverterOld.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Bancor Converter interface\r\n*/\r\ncontract IBancorConverterOld {\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/bot/Owned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    constructor () public { owner = msg.sender; }\r\n\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner && _newOwner != address(0), \"Unauthorized\");\r\n        emit OwnerUpdate(owner, _newOwner);\r\n        owner = _newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"Invalid\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"Unauthorized\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n// File: contracts/bot/ArbBot.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ArbBot is Owned {\r\n    \r\n    IERC20Token public tokenBNT;\r\n    IERC20Token public tokenUSDB;\r\n    IERC20Token public tokenSAI;\r\n    IERC20Token public tokenPEGUSD;\r\n\r\n    ISmartToken public relayUSDB;\r\n    ISmartToken public relaySAI;\r\n    ISmartToken public relayPEGUSD;\r\n\r\n    uint256 public tradeValue = 10 ether;\r\n    uint256 public threshold = 0;\r\n\r\n    constructor (\r\n        IERC20Token _tokenBNT,\r\n        IERC20Token _tokenSAI,\r\n        IERC20Token _tokenUSDB,\r\n        IERC20Token _tokenPEGUSD,\r\n        ISmartToken _relayUSDB,\r\n        ISmartToken _relaySAI,\r\n        ISmartToken _relayPEGUSD\r\n    ) public {\r\n        tokenBNT = _tokenBNT;\r\n        tokenSAI = _tokenSAI;\r\n        tokenUSDB = _tokenUSDB;\r\n        tokenPEGUSD = _tokenPEGUSD;\r\n\r\n        relayUSDB = _relayUSDB;\r\n        relaySAI = _relaySAI;\r\n        relayPEGUSD = _relayPEGUSD;\r\n    }\r\n\r\n    function getReturnSAI (bool _fromUSDB) public view returns(uint256) {\r\n        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;\r\n        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;\r\n        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());\r\n        uint256 returnBNT;\r\n        if(_fromUSDB) {\r\n            IBancorConverter converterUSDB = IBancorConverter(relayUSD.owner());\r\n            (returnBNT, ) = converterUSDB.getReturn(tokenUSD, tokenBNT, tradeValue);\r\n        } else {\r\n            IBancorConverterOld converterPEGUSD = IBancorConverterOld(relayUSD.owner());\r\n            returnBNT = converterPEGUSD.getReturn(tokenUSD, tokenBNT, tradeValue);\r\n        }\r\n        uint256 returnSAI;\r\n        (returnSAI, ) = converterSAI.getReturn(tokenBNT, tokenSAI, returnBNT);\r\n        return returnSAI;\r\n    }\r\n\r\n    function getReturnUSD (bool _fromUSDB) public view returns(uint256) {\r\n        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;\r\n        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;\r\n        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());\r\n        uint256 returnBNT;\r\n        (returnBNT, ) = converterSAI.getReturn(tokenSAI, tokenBNT, tradeValue);\r\n        uint256 returnUSD;\r\n        if(_fromUSDB) {\r\n            IBancorConverter converterUSDB = IBancorConverter(relayUSD.owner());\r\n            (returnUSD, ) = converterUSDB.getReturn(tokenBNT, tokenUSD, returnBNT);\r\n        } else {\r\n            IBancorConverterOld converterPEGUSD = IBancorConverterOld(relayUSD.owner());\r\n            returnUSD = converterPEGUSD.getReturn(tokenBNT, tokenUSD, returnBNT);\r\n        }\r\n        return returnUSD;\r\n    }\r\n\r\n    function isReadyToTrade(bool _fromUSDB) public view returns(bool) {\r\n        uint256 returnUSD = getReturnUSD(_fromUSDB);\r\n        uint256 returnSAI = getReturnSAI(_fromUSDB);\r\n        if(returnSAI > tradeValue) {\r\n            return ((returnSAI - tradeValue) >= threshold);\r\n        } else {\r\n            if(returnUSD > tradeValue)\r\n                return ((returnUSD - tradeValue) >= threshold);\r\n            else\r\n                return false;\r\n        }\r\n    }\r\n\r\n    function trade(bool _fromUSDB) public returns(bool) {\r\n        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;\r\n        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;\r\n        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());\r\n        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());\r\n\r\n        uint256 returnUSD = getReturnUSD(_fromUSDB);\r\n        uint256 returnSAI = getReturnSAI(_fromUSDB);\r\n        IERC20Token[] memory path = new IERC20Token[](5);\r\n        if(returnSAI > tradeValue) {\r\n            require((returnSAI - tradeValue) >= threshold, 'Trade not yet available.');\r\n            require(tokenUSD.balanceOf(address(this)) >= tradeValue, 'Insufficient USD balance.');\r\n            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];\r\n            path[0] = tokenUSD;\r\n            path[1] = IERC20Token(relayUSD);\r\n            path[2] = tokenBNT;\r\n            path[3] = IERC20Token(relaySAI);\r\n            path[4] = tokenSAI;\r\n            converterUSD.quickConvert(path, tradeValue, tradeValue);\r\n        } else {\r\n            require(returnUSD > tradeValue, 'Trade not yet available.');\r\n            require((returnUSD - tradeValue) >= threshold, 'Trade not yet available.');\r\n            require(tokenSAI.balanceOf(address(this)) >= tradeValue, 'Insufficient SAI balance.');\r\n            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];\r\n            path[0] = tokenSAI;\r\n            path[1] = IERC20Token(relaySAI);\r\n            path[2] = tokenBNT;\r\n            path[3] = IERC20Token(relayUSD);\r\n            path[4] = tokenUSD;\r\n            converterSAI.quickConvert(path, tradeValue, tradeValue);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function unlockTokens() public {\r\n        tokenUSDB.approve(address(relayUSDB.owner()), 0);\r\n        tokenUSDB.approve(address(relayUSDB.owner()), 1000000 ether);\r\n\r\n        tokenSAI.approve(address(relaySAI.owner()), 0);\r\n        tokenSAI.approve(address(relaySAI.owner()), 1000000 ether);\r\n\r\n        tokenPEGUSD.approve(address(relayPEGUSD.owner()), 0);\r\n        tokenPEGUSD.approve(address(relayPEGUSD.owner()), 1000000 ether);\r\n    }\r\n\r\n    function updateTradeValue(uint256 _tradeValue) public ownerOnly {\r\n        tradeValue = _tradeValue;\r\n    }\r\n\r\n    function updateThreshold(uint256 _threshold) public ownerOnly {\r\n        threshold = _threshold;\r\n    }\r\n\r\n    function updateTokens(\r\n        IERC20Token _tokenBNT,\r\n        IERC20Token _tokenSAI,\r\n        IERC20Token _tokenUSDB,\r\n        IERC20Token _tokenPEGUSD\r\n    ) public ownerOnly {\r\n        tokenBNT = _tokenBNT;\r\n        tokenSAI = _tokenSAI;\r\n        tokenUSDB = _tokenUSDB;\r\n        tokenPEGUSD = _tokenPEGUSD;\r\n    }\r\n\r\n    function updateRelays(\r\n        ISmartToken _relayUSDB,\r\n        ISmartToken _relaySAI,\r\n        ISmartToken _relayPEGUSD\r\n    ) public ownerOnly {\r\n        relayUSDB = _relayUSDB;\r\n        relaySAI = _relaySAI;\r\n        relayPEGUSD = _relayPEGUSD;\r\n    }\r\n\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n\r\n    function() public payable {}\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_relayUSDB\",\"type\":\"address\"},{\"name\":\"_relaySAI\",\"type\":\"address\"},{\"name\":\"_relayPEGUSD\",\"type\":\"address\"}],\"name\":\"updateRelays\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSAI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromUSDB\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBNT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromUSDB\",\"type\":\"bool\"}],\"name\":\"getReturnUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromUSDB\",\"type\":\"bool\"}],\"name\":\"getReturnSAI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenBNT\",\"type\":\"address\"},{\"name\":\"_tokenSAI\",\"type\":\"address\"},{\"name\":\"_tokenUSDB\",\"type\":\"address\"},{\"name\":\"_tokenPEGUSD\",\"type\":\"address\"}],\"name\":\"updateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeValue\",\"type\":\"uint256\"}],\"name\":\"updateTradeValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayUSDB\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayPEGUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromUSDB\",\"type\":\"bool\"}],\"name\":\"isReadyToTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPEGUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"updateThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relaySAI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenUSDB\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenBNT\",\"type\":\"address\"},{\"name\":\"_tokenSAI\",\"type\":\"address\"},{\"name\":\"_tokenUSDB\",\"type\":\"address\"},{\"name\":\"_tokenPEGUSD\",\"type\":\"address\"},{\"name\":\"_relayUSDB\",\"type\":\"address\"},{\"name\":\"_relaySAI\",\"type\":\"address\"},{\"name\":\"_relayPEGUSD\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"ArbBot","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001f573d6fb3f13d689ff844b4ce37794d79a7ff1c00000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359000000000000000000000000309627af60f0926daa6041b8279484312f2bf060000000000000000000000000a485bd50228440797abb4d4595161d7546811160000000000000000000000000d1146b08e8104eedba44a73b7bda1d102c6cedc9000000000000000000000000ee01b3ab5f6728adc137be101d99c678938e6e72000000000000000000000000607108c46bce4cf6f86698e9b46e3270a734fefe","Library":"","LicenseType":"None","SwarmSource":"bzzr://f431c48d5b43530b733dd31f7c80321a55a9ac66e3c64e27747b0adb07be673d"}]}