{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"msg.sender == owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(address(0) != _newOwner, \"address(0) != _newOwner\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"msg.sender == newOwner\");\r\n        emit OwnershipTransferred(owner, msg.sender);\r\n        owner = msg.sender;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract Adminable is Ownable {\r\n    mapping(address => bool) public admins;\r\n\r\n    modifier onlyAdmin() {\r\n        require(admins[msg.sender] && msg.sender != owner, \"admins[msg.sender] && msg.sender != owner\");\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address _admin, bool _authorization) public onlyOwner {\r\n        admins[_admin] = _authorization;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Token {\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    uint8 public decimals;\r\n}\r\n\r\ncontract Dex is Ownable, Adminable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) public invalidOrder;\r\n\r\n    function invalidateOrdersBefore(address _user) public onlyAdmin {\r\n        require(now > invalidOrder[_user], \"now > invalidOrder[_user]\");\r\n        invalidOrder[_user] = now;\r\n    }\r\n\r\n    mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\r\n\r\n    mapping (address => uint256) public lastActiveTransaction; // time of last interaction with this contract\r\n    mapping (bytes32 => uint256) public orderFills; //balanceOf order filled\r\n\r\n    address public feeAccount;\r\n    uint256 public inactivityReleasePeriod;\r\n\r\n    mapping (bytes32 => bool) public hashed; //hashes of: order already traded && funds already hashed && accounts updated\r\n\r\n    uint256 public maxFeeWithdrawal;\r\n    uint256 public maxFeeTrade;\r\n\r\n    address public dexToken;\r\n    uint256 public dexTokenFeeDiscount;\r\n\r\n    mapping (address => bool) public baseCurrency;\r\n\r\n    bool internal initialized = true;\r\n    function init(address _feeAccount, address _dexToken, uint256 _dexTokenFeeDiscount, address _admin) public {\r\n        require(!initialized, \"!initialized\");\r\n        initialized = true;\r\n\r\n        feeAccount = _feeAccount;\r\n        dexToken = _dexToken;\r\n        dexTokenFeeDiscount = _dexTokenFeeDiscount;\r\n\r\n        inactivityReleasePeriod = 2 weeks;\r\n        maxFeeWithdrawal = 0.05 ether; // max fee rate applied = 5%\r\n        maxFeeTrade = 0.10 ether; // max fee rate applied = 10%\r\n\r\n        owner = msg.sender;\r\n        admins[_admin] = true;\r\n    }\r\n\r\n\r\n    /***************************\r\n     * EDITABLE CONFINGURATION *\r\n     ***************************/\r\n\r\n    function setInactivityReleasePeriod(uint256 _expiry) public onlyAdmin returns (bool success) {\r\n        require(_expiry < 26 weeks, \"_expiry < 26 weeks\");\r\n        inactivityReleasePeriod = _expiry;\r\n        return true;\r\n    }\r\n\r\n    function setFeeAccount(address _newFeeAccount) public onlyOwner returns (bool success) {\r\n        feeAccount = _newFeeAccount;\r\n        success = true;\r\n    }\r\n\r\n    function setDexToken(address _dexToken) public onlyOwner returns (bool success) {\r\n        dexToken = _dexToken;\r\n        success = true;\r\n    }\r\n\r\n    function setDexTokenFeeDiscount(uint256 _dexTokenFeeDiscount) public onlyOwner returns (bool success) {\r\n        dexTokenFeeDiscount = _dexTokenFeeDiscount;\r\n        success = true;\r\n    }\r\n\r\n    function setBaseCurrency (address _baseCurrency, bool _boolean) public onlyOwner returns (bool success) {\r\n        baseCurrency[_baseCurrency] = _boolean;\r\n        success = true;\r\n    }\r\n\r\n    /***************************\r\n     * UPDATE ACCOUNT ACTIVITY *\r\n     ***************************/\r\n    function updateAccountActivity() public {\r\n        lastActiveTransaction[msg.sender] = now;\r\n    }\r\n\r\n    function adminUpdateAccountActivity(address _user, uint256 _expiry, uint8 _v, bytes32 _r, bytes32 _s)\r\n    public onlyAdmin returns(bool success) {\r\n        require(now < _expiry, \"should be: now < _expiry\");\r\n        bytes32 hash = keccak256(abi.encodePacked(this, _user, _expiry));\r\n        require(!hashed[hash], \"!hashed[hash]\");\r\n        hashed[hash] = true;\r\n\r\n        require(ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), _v, _r, _s) == _user,\"invalid update account activity signature\");\r\n\r\n        lastActiveTransaction[_user] = now;\r\n        success = true;\r\n    }\r\n\r\n    /*****************\r\n     * DEPOSIT TOKEN *\r\n     *****************/\r\n    event Deposit(address token, address user, uint256 amount, uint256 balance);\r\n\r\n    function tokenFallback(address _from, uint256 _amount, bytes memory) public returns(bool) {\r\n        depositTokenFunction(msg.sender, _amount, _from);\r\n        return true;\r\n    }\r\n\r\n    function receiveApproval(address _from, uint256 _amount, bytes memory) public returns(bool) {\r\n        transferFromAndDepositTokenFunction(msg.sender, _amount, _from, _from);\r\n        return true;\r\n    }\r\n\r\n    function depositToken(address _token, uint256 _amount) public returns(bool) {\r\n        transferFromAndDepositTokenFunction(_token, _amount, msg.sender, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function depositTokenFor(address _token, uint256 _amount, address _beneficiary) public returns(bool) {\r\n        transferFromAndDepositTokenFunction(_token, _amount, msg.sender, _beneficiary);\r\n        return true;\r\n    }\r\n\r\n    function transferFromAndDepositTokenFunction (address _token, uint256 _amount, address _sender, address _beneficiary) private {\r\n        require(Token(_token).transferFrom(_sender, address(this), _amount), \"Token(_token).transferFrom(_sender, this, _amount)\");\r\n        depositTokenFunction(_token, _amount, _beneficiary);\r\n    }\r\n\r\n    function depositTokenFunction(address _token, uint256 _amount, address _beneficiary) private {\r\n        tokens[_token][_beneficiary] = tokens[_token][_beneficiary].add(_amount);\r\n\r\n        if(tx.origin == _beneficiary) lastActiveTransaction[tx.origin] = now;\r\n\r\n        emit Deposit(_token, _beneficiary, _amount, tokens[_token][_beneficiary]);\r\n    }\r\n\r\n    /*****************\r\n     * DEPOSIT ETHER *\r\n     *****************/\r\n\r\n    function depositEther() public payable {\r\n        depositEtherFor(msg.sender);\r\n    }\r\n\r\n    function depositEtherFor(address _beneficiary) public payable {\r\n        tokens[address(0)][_beneficiary] = tokens[address(0)][_beneficiary].add(msg.value);\r\n\r\n        if(msg.sender == _beneficiary) lastActiveTransaction[msg.sender] = now;\r\n\r\n        emit Deposit(address(0), _beneficiary, msg.value, tokens[address(0)][_beneficiary]);\r\n    }\r\n\r\n    /************\r\n     * WITHDRAW *\r\n     ************/\r\n    event EmergencyWithdraw(address token, address user, uint256 amount, uint256 balance);\r\n\r\n    function emergencyWithdraw(address _token, uint256 _amount) public returns (bool success) {\r\n\r\n        require(now.sub(lastActiveTransaction[msg.sender]) > inactivityReleasePeriod, \"now.sub(lastActiveTransaction[msg.sender]) > inactivityReleasePeriod\");\r\n        require(tokens[_token][msg.sender] >= _amount, \"not enough balance for withdrawal\");\r\n\r\n        tokens[_token][msg.sender] = tokens[_token][msg.sender].sub(_amount);\r\n\r\n        if (_token == address(0)) {\r\n            require(msg.sender.send(_amount), \"msg.sender.send(_amount)\");\r\n        } else {\r\n            require(Token(_token).transfer(msg.sender, _amount), \"Token(_token).transfer(msg.sender, _amount)\");\r\n        }\r\n\r\n        emit EmergencyWithdraw(_token, msg.sender, _amount, tokens[_token][msg.sender]);\r\n        success = true;\r\n    }\r\n\r\n    event Withdraw(address token, address user, uint256 amount, uint256 balance);\r\n\r\n    function adminWithdraw(address _token, uint256 _amount, address payable _user, uint256 _nonce, uint8 _v, bytes32[2] memory _rs, uint256[2] memory _fee) public onlyAdmin returns (bool success) {\r\n\r\n         /*_fee\r\n                [0] _feeWithdrawal\r\n                [1] _payWithDexToken (yes is 1 - no is 0)\r\n            _rs\r\n                [0] _r\r\n                [1] _s\r\n         */\r\n\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(this, _fee[1], _token, _amount, _user, _nonce));\r\n        require(!hashed[hash], \"!hashed[hash]\");\r\n        hashed[hash] = true;\r\n\r\n        require(ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), _v, _rs[0], _rs[1]) == _user, \"invalid withdraw signature\");\r\n\r\n        require(tokens[_token][_user] >= _amount, \"not enough balance for withdrawal\");\r\n\r\n        tokens[_token][_user] = tokens[_token][_user].sub(_amount);\r\n\r\n        uint256 fee;\r\n        if (_fee[1] == 1) fee = toWei(_amount, _token).mul(_fee[0]) / 1 ether;\r\n        if (_fee[1] == 1 && tokens[dexToken][_user] >= fee) {\r\n            tokens[dexToken][feeAccount] = tokens[dexToken][feeAccount].add(fee);\r\n            tokens[dexToken][_user] = tokens[dexToken][_user].sub(fee);\r\n        } else {\r\n            if (_fee[0] > maxFeeWithdrawal) _fee[0] = maxFeeWithdrawal;\r\n\r\n            fee = _fee[0].mul(_amount) / 1 ether;\r\n            tokens[_token][feeAccount] = tokens[_token][feeAccount].add(fee);\r\n            _amount = _amount.sub(fee);\r\n        }\r\n\r\n        if (_token == address(0)) {\r\n            require(_user.send(_amount), \"_user.send(_amount)\");\r\n        } else {\r\n            require(Token(_token).transfer(_user, _amount), \"Token(_token).transfer(_user, _amount)\");\r\n        }\r\n\r\n        lastActiveTransaction[_user] = now;\r\n\r\n        emit Withdraw(_token, _user, _amount, tokens[_token][_user]);\r\n        success = true;\r\n  }\r\n\r\n    function balanceOf(address _token, address _user) public view returns (uint256) {\r\n        return tokens[_token][_user];\r\n    }\r\n\r\n\r\n    /***************\r\n     * ADMIN TRADE *\r\n     ***************/\r\n\r\n    function adminTrade(uint256[] memory _values, address[] memory _addresses, uint8[] memory _v, bytes32[] memory _rs) public onlyAdmin returns (bool success) {\r\n        /* amountSellTaker is in amountBuyMaker terms\r\n         _values\r\n            [0] amountSellTaker\r\n            [1] tradeNonceTaker\r\n            [2] feeTake\r\n            [3] dexTokenPrice\r\n            [4] feePayableDexTokenTaker (yes is 1 - no is 0)\r\n            [5] feeMake\r\n            [i*5+6] amountBuyMaker\r\n            [i*5+7] amountSellMaker\r\n            [i*5+8] expiresMaker\r\n            [i*5+9] nonceMaker\r\n            [i*5+10] feePayableDexTokenMaker (yes is 1 - no is 0)\r\n         _addresses\r\n            [0] tokenBuyAddress\r\n            [1] tokenSellAddress\r\n            [2] takerAddress\r\n            [i+3] makerAddress\r\n         _v\r\n            [0] vTaker\r\n            [i+1] vMaker\r\n         _rs\r\n            [0] rTaker\r\n            [1] sTaker\r\n            [i*2+2] rMaker\r\n            [i*2+3] sMaker\r\n         */\r\n\r\n\r\n        /**********************\r\n         * FEE SECURITY CHECK *\r\n         **********************/\r\n\r\n        //if (feeTake > maxFeeTrade) feeTake = maxFeeTrade;\r\n        if (_values[2] > maxFeeTrade) _values[2] = maxFeeTrade;    // set max fee take\r\n\r\n        // if (feeMake > maxFeeTrade) feeMake = maxFeeTrade;\r\n        if (_values[5] > maxFeeTrade) _values[5] = maxFeeTrade;    // set max fee make\r\n\r\n        /********************************\r\n         * TAKER BEFORE SECURITY CHECK *\r\n         ********************************/\r\n\r\n        //check if there are sufficient funds for TAKER:\r\n        require(tokens[_addresses[0]][_addresses[2]] >= _values[0],\r\n                \"tokens[tokenBuyAddress][takerAddress] >= amountSellTaker\");\r\n\r\n        /**************\r\n         * LOOP LOGIC *\r\n         **************/\r\n\r\n        bytes32[2] memory orderHash;\r\n        uint256[8] memory amount;\r\n        /*\r\n            orderHash\r\n                [0] globalHash\r\n                [1] makerHash\r\n            amount\r\n                [0] totalBuyMakerAmount\r\n                [1] appliedAmountSellTaker\r\n                [2] remainingAmountSellTaker\r\n                 * [3] amountFeeMake\r\n                 * [4] amountFeeTake\r\n                 * [5] priceTrade\r\n                 * [6] feeDexTokenMaker\r\n                 * [7] feeDexTokenTaker\r\n\r\n        */\r\n\r\n        // remainingAmountSellTaker = amountSellTaker\r\n        amount[2] = _values[0];\r\n\r\n        for(uint256 i=0; i < (_values.length - 6) / 5; i++) {\r\n\r\n            /************************\r\n             * MAKER SECURITY CHECK *\r\n             *************************/\r\n\r\n            //required: nonceMaker is greater or egual makerAddress\r\n            require(_values[i*5+9] >= invalidOrder[_addresses[i+3]],\r\n                    \"nonceMaker >= invalidOrder[makerAddress]\" );\r\n\r\n            // orderHash: ExchangeAddress, tokenBuyAddress, amountBuyMaker, tokenSellAddress, amountSellMaker, expiresMaker, nonceMaker, makerAddress, feePayableDexTokenMaker\r\n            orderHash[1] =  keccak256(abi.encodePacked(abi.encodePacked(this, _addresses[0], _values[i*5+6], _addresses[1], _values[i*5+7], _values[i*5+8], _values[i*5+9], _addresses[i+3]), _values[i*5+10]));\r\n\r\n            //globalHash = keccak256(abi.encodePacked(globalHash, makerHash));\r\n            orderHash[0] = keccak256(abi.encodePacked(orderHash[0], orderHash[1]));\r\n\r\n            //required: the signer is the same address of makerAddress\r\n            require(_addresses[i+3] == ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", orderHash[1])), _v[i+1], _rs[i*2+2], _rs[i*2+3]),\r\n                    'makerAddress    == ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", makerHash  )), vMaker, rMaker   , sMaker   )');\r\n\r\n\r\n            /*****************\r\n             * GLOBAL AMOUNT *\r\n             *****************/\r\n\r\n            //appliedAmountSellTaker = amountBuyMaker.sub(orderFilled)\r\n            amount[1] = _values[i*5+6].sub(orderFills[orderHash[1]]);\r\n\r\n            //if remainingAmountSellTaker < appliedAmountSellTaker\r\n            if (amount[2] < amount[1]) {\r\n                //appliedAmountSellTaker = remainingAmountSellTaker\r\n                amount[1] = amount[2];\r\n            }\r\n\r\n            //remainingAmountSellTaker -= appliedAmountSellTaker\r\n            amount[2] = amount[2].sub(amount[1]);\r\n\r\n            //totalBuyMakerAmount += appliedAmountSellTaker\r\n            amount[0] = amount[0].add(amount[1]);\r\n\r\n\r\n            /******************************\r\n             * MAKER SECURITY CHECK FUNDS *\r\n             ******************************/\r\n\r\n            //check if there are sufficient funds for MAKER: tokens[tokenSellAddress][makerAddress] >= amountSellMaker * appliedAmountSellTaker / amountBuyMaker\r\n            require(tokens[_addresses[1]][_addresses[i+3]] >= (_values[i*5+7].mul(amount[1]).div(_values[i*5+6])),\r\n                    \"tokens[tokenSellAddress][makerAddress] >= (amountSellMaker.mul(appliedAmountSellTaker).div(amountBuyMaker))\");\r\n\r\n\r\n            /*******************\r\n             * FEE COMPUTATION *\r\n             *******************/\r\n\r\n            /* amount\r\n                 * [3] amountFeeMake\r\n                 * [4] amountFeeTake\r\n                 * [5] priceTrade\r\n                 * [6] feeDexTokenMaker\r\n                 * [7] feeDexTokenTaker\r\n            */\r\n\r\n            //appliedAmountSellTaker = toWei(appliedAmountSellTaker, tokenBuyAddress);\r\n            amount[1] = toWei(amount[1], _addresses[0]);\r\n\r\n            //amountSellMaker = toWei(amountSellMaker, tokenSellAddress);\r\n            _values[i*5+7] = toWei(_values[i*5+7], _addresses[1]);\r\n\r\n            //amountBuyMaker = toWei(amountBuyMaker, tokenBuyAddress)\r\n            _values[i*5+6] = toWei(_values[i*5+6], _addresses[0]);\r\n\r\n            //amountFeeMake = appliedAmountSellTaker.mul(feeMake).div(1e18)\r\n            amount[3] = amount[1].mul(_values[5]).div(1e18);\r\n            //amountFeeTake = amountSellMaker.mul(feeTake).mul(appliedAmountSellTaker).div(amountBuyMaker) / 1e18;\r\n            amount[4] = _values[i*5+7].mul(_values[2]).mul(amount[1]).div(_values[i*5+6]) / 1e18;\r\n\r\n            //if (tokenBuyAddress == address(0) || (baseCurrency[tokenBuyAddress] && !(tokenSellAddress == address(0))) {\r\n            if (_addresses[0] == address(0) || (baseCurrency[_addresses[0]] && !(_addresses[1] == address(0)))) { // maker sell order\r\n                //amountBuyMaker is ETH or baseCurrency\r\n                //amountSellMaker is TKN\r\n                //amountFeeMake is ETH or baseCurrency\r\n                //amountFeeTake is TKN\r\n\r\n                //if (feePayableDexTokenMaker == 1) feeDexTokenMaker = amountFeeMake.mul(1e18).div(dexTokenPrice).mul(dexTokenFeeDiscount).div(1e18);\r\n                if (_values[i*5+10] == 1) amount[6] = amount[3].mul(1e18).div(_values[3]).mul(dexTokenFeeDiscount).div(1e18);\r\n\r\n                //if (feePayableDexTokenTaker == 1)\r\n                if (_values[4] == 1) {\r\n                    // priceTrade =  amountBuyMaker.mul(1e18).div(amountSellMaker)\r\n                    amount[5] = _values[i*5+6].mul(1e18).div(_values[i*5+7]); // price is ETH / TKN\r\n                    //feeDexTokenTaker = amountFeeTake.mul(priceTrade).div(dexTokenPrice).mul(dexTokenFeeDiscount).div(1e18);\r\n                    amount[7] = amount[4].mul(amount[5]).div(_values[3]).mul(dexTokenFeeDiscount).div(1e18);\r\n                }\r\n\r\n                //amountFeeTake = fromWei(amountFeeTake, tokenSellAddress);\r\n                amount[4] = fromWei(amount[4], _addresses[1]);\r\n\r\n            } else { //maker buy order\r\n                //amountBuyMaker is TKN\r\n                //amountSellMaker is ETH or baseCurrency\r\n                //amountFeeMake is TKN\r\n                //amountFeeTake is ETH or baseCurrency\r\n\r\n                //if (feePayableDexTokenTaker == 1) feeDexTokenTaker = amountFeeTake.mul(1e18).div(dexTokenPrice).mul(dexTokenFeeDiscount).div(1e18);\r\n                if(_values[4] == 1) amount[7] = amount[4].mul(1e18).div(_values[3]).mul(dexTokenFeeDiscount).div(1e18);\r\n\r\n                //if (feePayableDexTokenMaker == 1)\r\n                if (_values[i*5+10] == 1) {\r\n                    // priceTrade =  amountSellMaker.mul(1e18).div(amountBuyMaker)\r\n                    amount[5] = _values[i*5+7].mul(1e18).div(_values[i*5+6]); // price is ETH / TKN\r\n\r\n                    // feeDexTokenMaker = amountFeeMake.mul(priceTrade).div(dexTokenPrice).mul(dexTokenFeeDiscount).div(1e18);\r\n                    amount[6] = amount[3].mul(amount[5]).div(_values[3]).mul(dexTokenFeeDiscount).div(1e18);\r\n                }\r\n\r\n                //amountFeeMake = fromWei(amountFeeMake, tokenBuyAddress);\r\n                amount[3] = fromWei(amount[3], _addresses[0]);\r\n\r\n            }\r\n\r\n            //appliedAmountSellTaker = fromWei(appliedAmountSellTaker, tokenBuyAddress);\r\n            amount[1] = fromWei(amount[1], _addresses[0]);\r\n\r\n            //amountSellMaker = fromWei(amountSellMaker, tokenSellAddress);\r\n            _values[i*5+7] = fromWei(_values[i*5+7], _addresses[1]);\r\n\r\n            //amountBuyMaker = fromWei(amountBuyMaker, tokenBuyAddress)\r\n            _values[i*5+6] = fromWei(_values[i*5+6], _addresses[0]);\r\n\r\n\r\n            /**********************\r\n             * FEE BALANCE UPDATE *\r\n             **********************/\r\n\r\n            //feePayableDexTokenTaker == 1 && tokens[dexToken][takerAddress] >= feeDexTokenTaker\r\n            if (_values[4] == 1 && tokens[dexToken][_addresses[2]] >= amount[7] ) {\r\n\r\n                //tokens[dexToken][takerAddress]  = tokens[dexToken][takerAddress].sub(feeDexTokenTaker);\r\n                tokens[dexToken][_addresses[2]] = tokens[dexToken][_addresses[2]].sub(amount[7]);\r\n\r\n                //tokens[dexToken][feeAccount] = tokens[dexToken][feeAccount].add(feeDexTokenTaker);\r\n                tokens[dexToken][feeAccount] = tokens[dexToken][feeAccount].add(amount[7]);\r\n\r\n                //amountFeeTake = 0;\r\n                amount[4] = 0;\r\n            } else {\r\n                //tokens[tokenSellAddress][feeAccount] = tokens[tokenSellAddress][feeAccount].add(amountFeeTake);\r\n                tokens[_addresses[1]][feeAccount] = tokens[_addresses[1]][feeAccount].add(amount[4]);\r\n            }\r\n\r\n            //feePayableDexTokenMaker == 1 && tokens[dexToken][makerAddress] >= feeDexTokenMaker\r\n            if (_values[i*5+10] == 1 && tokens[dexToken][_addresses[i+3]] >= amount[6]) {\r\n\r\n                //tokens[dexToken][makerAddress] = tokens[dexToken][makerAddress].sub(feeDexTokenMaker);\r\n                tokens[dexToken][_addresses[i+3]] = tokens[dexToken][_addresses[i+3]].sub(amount[6]);\r\n\r\n                //tokens[dexToken][feeAccount] = tokens[dexToken][feeAccount].add(feeDexTokenMaker);\r\n                tokens[dexToken][feeAccount] = tokens[dexToken][feeAccount].add(amount[6]);\r\n\r\n                //amountFeeMake = 0;\r\n                amount[3] = 0;\r\n            } else {\r\n                //tokens[tokenBuyAddress][feeAccount] = tokens[tokenBuyAddress][feeAccount].add(amountFeeMake);\r\n                tokens[_addresses[0]][feeAccount] = tokens[_addresses[0]][feeAccount].add(amount[3]);\r\n            }\r\n\r\n\r\n            /******************\r\n             * BALANCE UPDATE *\r\n             ******************/\r\n\r\n        //tokens[tokenBuyAddress][takerAddress] = tokens[tokenBuyAddress][takerAddress].sub(appliedAmountSellTaker);\r\n        tokens[_addresses[0]][_addresses[2]] = tokens[_addresses[0]][_addresses[2]].sub(amount[1]);\r\n\r\n            //tokens[tokenBuyAddress][makerAddress] = tokens[tokenBuyAddress]][makerAddress].add(appliedAmountSellTaker.sub(amountFeeMake));\r\n            tokens[_addresses[0]][_addresses[i+3]] = tokens[_addresses[0]][_addresses[i+3]].add(amount[1].sub(amount[3]));\r\n\r\n\r\n            //tokens[tokenSellAddress][makerAddress] = tokens[tokenSellAddress][makerAddress].sub(amountSellMaker.mul(appliedAmountSellTaker).div(amountBuyMaker));\r\n            tokens[_addresses[1]][_addresses[i+3]] = tokens[_addresses[1]][_addresses[i+3]].sub(_values[i*5+7].mul(amount[1]).div(_values[i*5+6]));\r\n\r\n        //tokens[tokenSellAddress][takerAddress] = tokens[tokenSellAddress][takerAddress].add(amountSellMaker.mul(appliedAmountSellTaker).div(amountBuyMaker).sub(amountFeeTake));\r\n        tokens[_addresses[1]][_addresses[2]] = tokens[_addresses[1]][_addresses[2]].add(_values[i*5+7].mul(amount[1]).div(_values[i*5+6]).sub(amount[4]));\r\n\r\n\r\n            /***********************\r\n             * UPDATE MAKER STATUS *\r\n             ***********************/\r\n\r\n            //orderFills[orderHash[1]] = orderFills[orderHash[1]].add(appliedAmountSellTaker);\r\n            orderFills[orderHash[1]] = orderFills[orderHash[1]].add(amount[1]);\r\n\r\n            //lastActiveTransaction[makerAddress] = now;\r\n            lastActiveTransaction[_addresses[i+3]] = now;\r\n\r\n        }\r\n\r\n\r\n        /*******************************\r\n         * TAKER AFTER SECURITY CHECK *\r\n         *******************************/\r\n\r\n        // tradeHash:                                   globalHash, amountSellTaker, takerAddress, tradeNonceTaker, feePayableDexTokenTaker\r\n        bytes32 tradeHash = keccak256(abi.encodePacked(orderHash[0], _values[0], _addresses[2], _values[1], _values[4]));\r\n\r\n        //required: the signer is the same address of takerAddress\r\n        require(_addresses[2] == ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", tradeHash)), _v[0], _rs[0], _rs[1]),\r\n                'takerAddress  == ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", tradeHash)), vTaker, rTaker, sTaker)');\r\n\r\n        //required: the same trade is not done\r\n        require(!hashed[tradeHash], \"!hashed[tradeHash] \");\r\n        hashed[tradeHash] = true;\r\n\r\n        //required: totalBuyMakerAmount == amountSellTaker\r\n        require(amount[0] == _values[0], \"totalBuyMakerAmount == amountSellTaker\");\r\n\r\n\r\n        /***********************\r\n         * UPDATE TAKER STATUS *\r\n         ***********************/\r\n\r\n        //lastActiveTransaction[takerAddress] = now;\r\n        lastActiveTransaction[_addresses[2]] = now;\r\n\r\n        success = true;\r\n    }\r\n    function toWei(uint256 _number, address _token) internal view returns (uint256) {\r\n        if (_token == address(0)) return _number;\r\n        return _number.mul(1e18).div(10**uint256(Token(_token).decimals()));\r\n    }\r\n    function fromWei(uint256 _number, address _token) internal view returns (uint256) {\r\n        if (_token == address(0)) return _number;\r\n        return _number.mul(10**uint256(Token(_token).decimals())).div(1e18);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_rs\",\"type\":\"bytes32[]\"}],\"name\":\"adminTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"adminUpdateAccountActivity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[2]\",\"name\":\"_rs\",\"type\":\"bytes32[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_fee\",\"type\":\"uint256[2]\"}],\"name\":\"adminWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"baseCurrency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"depositEtherFor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"depositTokenFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexTokenFeeDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inactivityReleasePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dexToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_dexTokenFeeDiscount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"invalidOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"invalidateOrdersBefore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastActiveTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxFeeTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxFeeWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_authorization\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseCurrency\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_boolean\",\"type\":\"bool\"}],\"name\":\"setBaseCurrency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexToken\",\"type\":\"address\"}],\"name\":\"setDexToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dexTokenFeeDiscount\",\"type\":\"uint256\"}],\"name\":\"setDexTokenFeeDiscount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFeeAccount\",\"type\":\"address\"}],\"name\":\"setFeeAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"setInactivityReleasePeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAccountActivity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Dex","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://8f607fa6e3ad47449b88fe833053471884ecbf733565ea1afabae86af46e4375"}]}