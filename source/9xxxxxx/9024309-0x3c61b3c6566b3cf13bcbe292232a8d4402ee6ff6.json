{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.13;\n\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract Context {\n    \n    \n    constructor () internal { }\n    \n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint256 private _guardCounter;\n\n    constructor () internal {\n        \n        \n        _guardCounter = 1;\n    }\n\n    \n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\ninterface IMiniMeToken {\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function totalSupply() external view returns(uint);\n    function generateTokens(address _owner, uint _amount) external returns (bool);\n    function destroyTokens(address _owner, uint _amount) external returns (bool);\n    function totalSupplyAt(uint _blockNumber) external view returns(uint);\n    function balanceOfAt(address _holder, uint _blockNumber) external view returns (uint);\n    function transferOwnership(address newOwner) external;\n}\n\ncontract TokenController {\n  \n  \n  \n  function proxyPayment(address _owner) public payable returns(bool);\n\n  \n  \n  \n  \n  \n  \n  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n\n  \n  \n  \n  \n  \n  \n  function onApprove(address _owner, address _spender, uint _amount) public\n    returns(bool);\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    \n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        \n        \n        \n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        \n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    \n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        \n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        \n        \n        \n        \n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    \n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        \n        \n\n        \n        \n        \n        \n        \n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        \n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { \n            \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface KyberNetwork {\n  function getExpectedRate(ERC20Detailed src, ERC20Detailed dest, uint srcQty) external view\n      returns (uint expectedRate, uint slippageRate);\n\n  function tradeWithHint(\n    ERC20Detailed src, uint srcAmount, ERC20Detailed dest, address payable destAddress, uint maxDestAmount,\n    uint minConversionRate, address walletId, bytes calldata hint) external payable returns(uint);\n}\n\ncontract Utils {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Detailed;\n\n  \n  modifier isValidToken(address _token) {\n    require(_token != address(0));\n    if (_token != address(ETH_TOKEN_ADDRESS)) {\n      require(isContract(_token));\n    }\n    _;\n  }\n\n  address public DAI_ADDR;\n  address payable public KYBER_ADDR;\n  address payable public DEXAG_ADDR;\n\n  bytes public constant PERM_HINT = \"PERM\";\n\n  ERC20Detailed internal constant ETH_TOKEN_ADDRESS = ERC20Detailed(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n  ERC20Detailed internal dai;\n  KyberNetwork internal kyber;\n\n  uint constant internal PRECISION = (10**18);\n  uint constant internal MAX_QTY   = (10**28); \n  uint constant internal ETH_DECIMALS = 18;\n  uint constant internal MAX_DECIMALS = 18;\n\n  constructor(\n    address _daiAddr,\n    address payable _kyberAddr,\n    address payable _dexagAddr\n  ) public {\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    DEXAG_ADDR = _dexagAddr;\n\n    dai = ERC20Detailed(_daiAddr);\n    kyber = KyberNetwork(_kyberAddr);\n  }\n\n  \n  function getDecimals(ERC20Detailed _token) internal view returns(uint256) {\n    if (address(_token) == address(ETH_TOKEN_ADDRESS)) {\n      return uint256(ETH_DECIMALS);\n    }\n    return uint256(_token.decimals());\n  }\n\n  \n  function getBalance(ERC20Detailed _token, address _addr) internal view returns(uint256) {\n    if (address(_token) == address(ETH_TOKEN_ADDRESS)) {\n      return uint256(_addr.balance);\n    }\n    return uint256(_token.balanceOf(_addr));\n  }\n\n  \n  function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n        internal pure returns(uint)\n  {\n    require(srcAmount <= MAX_QTY);\n    require(destAmount <= MAX_QTY);\n\n    if (dstDecimals >= srcDecimals) {\n      require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n      return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n    } else {\n      require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n      return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n    }\n  }\n\n  \n  function __kyberTrade(ERC20Detailed _srcToken, uint256 _srcAmount, ERC20Detailed _destToken)\n    internal\n    returns(\n      uint256 _destPriceInSrc,\n      uint256 _srcPriceInDest,\n      uint256 _actualDestAmount,\n      uint256 _actualSrcAmount\n    )\n  {\n    require(_srcToken != _destToken);\n\n    uint256 beforeSrcBalance = getBalance(_srcToken, address(this));\n    uint256 msgValue;\n    if (_srcToken != ETH_TOKEN_ADDRESS) {\n      msgValue = 0;\n      _srcToken.safeApprove(KYBER_ADDR, 0);\n      _srcToken.safeApprove(KYBER_ADDR, _srcAmount);\n    } else {\n      msgValue = _srcAmount;\n    }\n    _actualDestAmount = kyber.tradeWithHint.value(msgValue)(\n      _srcToken,\n      _srcAmount,\n      _destToken,\n      toPayableAddr(address(this)),\n      MAX_QTY,\n      1,\n      0x332D87209f7c8296389C307eAe170c2440830A47,\n      PERM_HINT\n    );\n    _actualSrcAmount = beforeSrcBalance.sub(getBalance(_srcToken, address(this)));\n    require(_actualDestAmount > 0 && _actualSrcAmount > 0);\n    _destPriceInSrc = calcRateFromQty(_actualDestAmount, _actualSrcAmount, getDecimals(_destToken), getDecimals(_srcToken));\n    _srcPriceInDest = calcRateFromQty(_actualSrcAmount, _actualDestAmount, getDecimals(_srcToken), getDecimals(_destToken));\n  }\n\n  \n  function __dexagTrade(ERC20Detailed _srcToken, uint256 _srcAmount, ERC20Detailed _destToken, bytes memory _calldata)\n    internal\n    returns(\n      uint256 _destPriceInSrc,\n      uint256 _srcPriceInDest,\n      uint256 _actualDestAmount,\n      uint256 _actualSrcAmount\n    )\n  {\n    require(_srcToken != _destToken);\n\n    uint256 beforeSrcBalance = getBalance(_srcToken, address(this));\n    uint256 beforeDestBalance = getBalance(_destToken, address(this));\n    \n    if (_srcToken != ETH_TOKEN_ADDRESS) {\n      _actualSrcAmount = 0;\n      _srcToken.safeApprove(DEXAG_ADDR, 0);\n      _srcToken.safeApprove(DEXAG_ADDR, _srcAmount);\n    } else {\n      _actualSrcAmount = _srcAmount;\n    }\n\n    \n    (bool success,) = DEXAG_ADDR.call.value(_actualSrcAmount)(_calldata);\n    require(success);\n\n    \n    _actualDestAmount = beforeDestBalance.sub(getBalance(_destToken, address(this)));\n    _actualSrcAmount = beforeSrcBalance.sub(getBalance(_srcToken, address(this)));\n    require(_actualDestAmount > 0 && _actualSrcAmount > 0);\n    _destPriceInSrc = calcRateFromQty(_actualDestAmount, _actualSrcAmount, getDecimals(_destToken), getDecimals(_srcToken));\n    _srcPriceInDest = calcRateFromQty(_actualSrcAmount, _actualDestAmount, getDecimals(_srcToken), getDecimals(_destToken));\n\n    \n    (, uint256 kyberSrcPriceInDest) = kyber.getExpectedRate(_srcToken, _destToken, _srcAmount);\n    require(kyberSrcPriceInDest > 0 && _srcPriceInDest >= kyberSrcPriceInDest);\n  }\n\n  \n  function isContract(address _addr) internal view returns(bool) {\n    uint size;\n    if (_addr == address(0)) return false;\n    assembly {\n        size := extcodesize(_addr)\n    }\n    return size>0;\n  }\n\n  function toPayableAddr(address _addr) internal pure returns (address payable) {\n    return address(uint160(_addr));\n  }\n}\n\ninterface BetokenProxyInterface {\n  function betokenFundAddress() external view returns (address payable);\n  function updateBetokenFundAddress() external;\n}\n\ninterface ScdMcdMigration {\n  \n  \n  \n  function swapSaiToDai(\n    uint wad\n  ) external;\n}\n\ncontract BetokenStorage is Ownable, ReentrancyGuard {\n  using SafeMath for uint256;\n\n  enum CyclePhase { Intermission, Manage }\n  enum VoteDirection { Empty, For, Against }\n  enum Subchunk { Propose, Vote }\n\n  struct Investment {\n    address tokenAddress;\n    uint256 cycleNumber;\n    uint256 stake;\n    uint256 tokenAmount;\n    uint256 buyPrice; \n    uint256 sellPrice; \n    uint256 buyTime;\n    uint256 buyCostInDAI;\n    bool isSold;\n  }\n\n  \n  uint256 public constant COMMISSION_RATE = 20 * (10 ** 16); \n  uint256 public constant ASSET_FEE_RATE = 1 * (10 ** 15); \n  uint256 public constant NEXT_PHASE_REWARD = 1 * (10 ** 18); \n  uint256 public constant MAX_BUY_KRO_PROP = 1 * (10 ** 16); \n  uint256 public constant FALLBACK_MAX_DONATION = 100 * (10 ** 18); \n  uint256 public constant MIN_KRO_PRICE = 25 * (10 ** 17); \n  uint256 public constant COLLATERAL_RATIO_MODIFIER = 75 * (10 ** 16); \n  uint256 public constant MIN_RISK_TIME = 3 days; \n  uint256 public constant INACTIVE_THRESHOLD = 2; \n  uint256 public constant ROI_PUNISH_THRESHOLD = 1 * (10 ** 17); \n  uint256 public constant ROI_BURN_THRESHOLD = 25 * (10 ** 16); \n  uint256 public constant ROI_PUNISH_SLOPE = 6; \n  uint256 public constant ROI_PUNISH_NEG_BIAS = 5 * (10 ** 17); \n  \n  uint256 public constant CHUNK_SIZE = 3 days;\n  uint256 public constant PROPOSE_SUBCHUNK_SIZE = 1 days;\n  uint256 public constant CYCLES_TILL_MATURITY = 3;\n  uint256 public constant QUORUM = 10 * (10 ** 16); \n  uint256 public constant VOTE_SUCCESS_THRESHOLD = 75 * (10 ** 16); \n\n  \n\n  \n  bool public hasInitializedTokenListings;\n\n  \n  bool public isInitialized;\n\n  \n  address public controlTokenAddr;\n\n  \n  address public shareTokenAddr;\n\n  \n  address payable public proxyAddr;\n\n  \n  address public compoundFactoryAddr;\n\n  \n  address public betokenLogic;\n  address public betokenLogic2;\n\n  \n  address payable public devFundingAccount;\n\n  \n  address payable public previousVersion;\n\n  \n  address public saiAddr;\n\n  \n  uint256 public cycleNumber;\n\n  \n  uint256 public totalFundsInDAI;\n\n  \n  uint256 public startTimeOfCyclePhase;\n\n  \n  uint256 public devFundingRate;\n\n  \n  uint256 public totalCommissionLeft;\n\n  \n  uint256[2] public phaseLengths;\n\n  \n  mapping(address => uint256) internal _lastCommissionRedemption;\n\n  \n  mapping(address => mapping(uint256 => bool)) internal _hasRedeemedCommissionForCycle;\n\n  \n  mapping(address => mapping(uint256 => uint256)) internal _riskTakenInCycle;\n\n  \n  mapping(address => uint256) internal _baseRiskStakeFallback;\n\n  \n  mapping(address => Investment[]) public userInvestments;\n\n  \n  mapping(address => address payable[]) public userCompoundOrders;\n\n  \n  mapping(uint256 => uint256) internal _totalCommissionOfCycle;\n\n  \n  mapping(uint256 => uint256) internal _managePhaseEndBlock;\n\n  \n  mapping(address => uint256) internal _lastActiveCycle;\n\n  \n  mapping(address => bool) public isKyberToken;\n\n  \n  mapping(address => bool) public isCompoundToken;\n\n  \n  mapping(address => bool) public isPositionToken;\n\n  \n  CyclePhase public cyclePhase;\n\n  \n  bool public hasFinalizedNextVersion; \n  bool public upgradeVotingActive; \n  address payable public nextVersion; \n  address[5] public proposers; \n  address payable[5] public candidates; \n  uint256[5] public forVotes; \n  uint256[5] public againstVotes; \n  uint256 public proposersVotingWeight; \n  mapping(uint256 => mapping(address => VoteDirection[5])) public managerVotes; \n  mapping(uint256 => uint256) public upgradeSignalStrength; \n  mapping(uint256 => mapping(address => bool)) public upgradeSignal; \n\n  \n  IMiniMeToken internal cToken;\n  IMiniMeToken internal sToken;\n  BetokenProxyInterface internal proxy;\n  ScdMcdMigration internal mcdaiMigration;\n\n  \n\n  event ChangedPhase(uint256 indexed _cycleNumber, uint256 indexed _newPhase, uint256 _timestamp, uint256 _totalFundsInDAI);\n\n  event Deposit(uint256 indexed _cycleNumber, address indexed _sender, address _tokenAddress, uint256 _tokenAmount, uint256 _daiAmount, uint256 _timestamp);\n  event Withdraw(uint256 indexed _cycleNumber, address indexed _sender, address _tokenAddress, uint256 _tokenAmount, uint256 _daiAmount, uint256 _timestamp);\n\n  event CreatedInvestment(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _tokenAddress, uint256 _stakeInWeis, uint256 _buyPrice, uint256 _costDAIAmount, uint256 _tokenAmount);\n  event SoldInvestment(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _tokenAddress, uint256 _receivedKairo, uint256 _sellPrice, uint256 _earnedDAIAmount);\n\n  event CreatedCompoundOrder(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _order, bool _orderType, address _tokenAddress, uint256 _stakeInWeis, uint256 _costDAIAmount);\n  event SoldCompoundOrder(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _order,  bool _orderType, address _tokenAddress, uint256 _receivedKairo, uint256 _earnedDAIAmount);\n  event RepaidCompoundOrder(uint256 indexed _cycleNumber, address indexed _sender, uint256 _id, address _order, uint256 _repaidDAIAmount);\n\n  event CommissionPaid(uint256 indexed _cycleNumber, address indexed _sender, uint256 _commission);\n  event TotalCommissionPaid(uint256 indexed _cycleNumber, uint256 _totalCommissionInDAI);\n\n  event Register(address indexed _manager, uint256 _donationInDAI, uint256 _kairoReceived);\n\n  event SignaledUpgrade(uint256 indexed _cycleNumber, address indexed _sender, bool indexed _inSupport);\n  event DeveloperInitiatedUpgrade(uint256 indexed _cycleNumber, address _candidate);\n  event InitiatedUpgrade(uint256 indexed _cycleNumber);\n  event ProposedCandidate(uint256 indexed _cycleNumber, uint256 indexed _voteID, address indexed _sender, address _candidate);\n  event Voted(uint256 indexed _cycleNumber, uint256 indexed _voteID, address indexed _sender, bool _inSupport, uint256 _weight);\n  event FinalizedNextVersion(uint256 indexed _cycleNumber, address _nextVersion);\n\n  \n\n  \n  function currentChunk() public view returns (uint) {\n    if (cyclePhase != CyclePhase.Manage) {\n      return 0;\n    }\n    return (now - startTimeOfCyclePhase) / CHUNK_SIZE;\n  }\n\n  \n  function currentSubchunk() public view returns (Subchunk _subchunk) {\n    if (cyclePhase != CyclePhase.Manage) {\n      return Subchunk.Vote;\n    }\n    uint256 timeIntoCurrChunk = (now - startTimeOfCyclePhase) % CHUNK_SIZE;\n    return timeIntoCurrChunk < PROPOSE_SUBCHUNK_SIZE ? Subchunk.Propose : Subchunk.Vote;\n  }\n\n  \n  function getVotingWeight(address _of) public view returns (uint256 _weight) {\n    if (cycleNumber <= CYCLES_TILL_MATURITY || _of == address(0)) {\n      return 0;\n    }\n    return cToken.balanceOfAt(_of, managePhaseEndBlock(cycleNumber.sub(CYCLES_TILL_MATURITY)));\n  }\n\n  \n  function getTotalVotingWeight() public view returns (uint256 _weight) {\n    if (cycleNumber <= CYCLES_TILL_MATURITY) {\n      return 0;\n    }\n    return cToken.totalSupplyAt(managePhaseEndBlock(cycleNumber.sub(CYCLES_TILL_MATURITY))).sub(proposersVotingWeight);\n  }\n\n  \n  function kairoPrice() public view returns (uint256 _kairoPrice) {\n    if (cToken.totalSupply() == 0) { return MIN_KRO_PRICE; }\n    uint256 controlPerKairo = totalFundsInDAI.mul(10 ** 18).div(cToken.totalSupply());\n    if (controlPerKairo < MIN_KRO_PRICE) {\n      \n      return MIN_KRO_PRICE;\n    }\n    return controlPerKairo;\n  }\n\n  function lastCommissionRedemption(address _manager) public view returns (uint256) {\n    if (_lastCommissionRedemption[_manager] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).lastCommissionRedemption(_manager);\n    }\n    return _lastCommissionRedemption[_manager];\n  }\n\n  function hasRedeemedCommissionForCycle(address _manager, uint256 _cycle) public view returns (bool) {\n    if (_hasRedeemedCommissionForCycle[_manager][_cycle] == false) {\n      return previousVersion == address(0) ? false : BetokenStorage(previousVersion).hasRedeemedCommissionForCycle(_manager, _cycle);\n    }\n    return _hasRedeemedCommissionForCycle[_manager][_cycle];\n  }\n\n  function riskTakenInCycle(address _manager, uint256 _cycle) public view returns (uint256) {\n    if (_riskTakenInCycle[_manager][_cycle] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).riskTakenInCycle(_manager, _cycle);\n    }\n    return _riskTakenInCycle[_manager][_cycle];\n  }\n\n  function baseRiskStakeFallback(address _manager) public view returns (uint256) {\n    if (_baseRiskStakeFallback[_manager] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).baseRiskStakeFallback(_manager);\n    }\n    return _baseRiskStakeFallback[_manager];\n  }\n\n  function totalCommissionOfCycle(uint256 _cycle) public view returns (uint256) {\n    if (_totalCommissionOfCycle[_cycle] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).totalCommissionOfCycle(_cycle);\n    }\n    return _totalCommissionOfCycle[_cycle];\n  }\n\n  function managePhaseEndBlock(uint256 _cycle) public view returns (uint256) {\n    if (_managePhaseEndBlock[_cycle] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).managePhaseEndBlock(_cycle);\n    }\n    return _managePhaseEndBlock[_cycle];\n  }\n\n  function lastActiveCycle(address _manager) public view returns (uint256) {\n    if (_lastActiveCycle[_manager] == 0) {\n      return previousVersion == address(0) ? 0 : BetokenStorage(previousVersion).lastActiveCycle(_manager);\n    }\n    return _lastActiveCycle[_manager];\n  }\n}\n\ninterface Comptroller {\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n    function markets(address cToken) external view returns (bool isListed, uint256 collateralFactorMantissa);\n}\n\ninterface PriceOracle {\n  function getUnderlyingPrice(address cToken) external view returns (uint);\n}\n\ninterface CERC20 {\n  function mint(uint mintAmount) external returns (uint);\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function repayBorrow(uint repayAmount) external returns (uint);\n  function borrowBalanceCurrent(address account) external returns (uint);\n  function exchangeRateCurrent() external returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n  function decimals() external view returns (uint);\n  function underlying() external view returns (address);\n}\n\ninterface CEther {\n  function mint() external payable;\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function repayBorrow() external payable;\n  function borrowBalanceCurrent(address account) external returns (uint);\n  function exchangeRateCurrent() external returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n  function decimals() external view returns (uint);\n}\n\ncontract CompoundOrder is Utils(address(0), address(0), address(0)), Ownable {\n  \n  uint256 internal constant NEGLIGIBLE_DEBT = 10 ** 14; \n  uint256 internal constant MAX_REPAY_STEPS = 3; \n  uint256 internal constant DEFAULT_LIQUIDITY_SLIPPAGE = 10 ** 12; \n  uint256 internal constant FALLBACK_LIQUIDITY_SLIPPAGE = 10 ** 15; \n  uint256 internal constant MAX_LIQUIDITY_SLIPPAGE = 10 ** 17; \n\n  \n  Comptroller public COMPTROLLER; \n  PriceOracle public ORACLE; \n  CERC20 public CDAI; \n  address public CETH_ADDR;\n\n  \n  uint256 public stake;\n  uint256 public collateralAmountInDAI;\n  uint256 public loanAmountInDAI;\n  uint256 public cycleNumber;\n  uint256 public buyTime; \n  uint256 public outputAmount; \n  address public compoundTokenAddr;\n  bool public isSold;\n  bool public orderType; \n  bool internal initialized;\n\n\n  constructor() public {}\n\n  function init(\n    address _compoundTokenAddr,\n    uint256 _cycleNumber,\n    uint256 _stake,\n    uint256 _collateralAmountInDAI,\n    uint256 _loanAmountInDAI,\n    bool _orderType,\n    address _daiAddr,\n    address payable _kyberAddr,\n    address _comptrollerAddr,\n    address _priceOracleAddr,\n    address _cDAIAddr,\n    address _cETHAddr\n  ) public {\n    require(!initialized);\n    initialized = true;\n    \n    \n    require(_compoundTokenAddr != _cDAIAddr);\n    require(_stake > 0 && _collateralAmountInDAI > 0 && _loanAmountInDAI > 0); \n    stake = _stake;\n    collateralAmountInDAI = _collateralAmountInDAI;\n    loanAmountInDAI = _loanAmountInDAI;\n    cycleNumber = _cycleNumber;\n    compoundTokenAddr = _compoundTokenAddr;\n    orderType = _orderType;\n\n    COMPTROLLER = Comptroller(_comptrollerAddr);\n    ORACLE = PriceOracle(_priceOracleAddr);\n    CDAI = CERC20(_cDAIAddr);\n    CETH_ADDR = _cETHAddr;\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    dai = ERC20Detailed(_daiAddr);\n    kyber = KyberNetwork(_kyberAddr);\n\n    \n    _transferOwnership(msg.sender);\n  }\n\n  \n  function executeOrder(uint256 _minPrice, uint256 _maxPrice) public;\n\n  \n  function sellOrder(uint256 _minPrice, uint256 _maxPrice) public returns (uint256 _inputAmount, uint256 _outputAmount);\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public;\n\n  function getMarketCollateralFactor() public view returns (uint256);\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount);\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount);\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount);\n\n  \n  function getCurrentProfitInDAI() public returns (bool _isNegative, uint256 _amount) {\n    uint256 l;\n    uint256 r;\n    if (isSold) {\n      l = outputAmount;\n      r = collateralAmountInDAI;\n    } else {\n      uint256 cash = getCurrentCashInDAI();\n      uint256 supply = getCurrentCollateralInDAI();\n      uint256 borrow = getCurrentBorrowInDAI();\n      if (cash >= borrow) {\n        l = supply.add(cash);\n        r = borrow.add(collateralAmountInDAI);\n      } else {\n        l = supply;\n        r = borrow.sub(cash).mul(PRECISION).div(getMarketCollateralFactor()).add(collateralAmountInDAI);\n      }\n    }\n    \n    if (l >= r) {\n      return (false, l.sub(r));\n    } else {\n      return (true, r.sub(l));\n    }\n  }\n\n  \n  function getCurrentCollateralRatioInDAI() public returns (uint256 _amount) {\n    uint256 supply = getCurrentCollateralInDAI();\n    uint256 borrow = getCurrentBorrowInDAI();\n    if (borrow == 0) {\n      return uint256(-1);\n    }\n    return supply.mul(PRECISION).div(borrow);\n  }\n\n  \n  function getCurrentLiquidityInDAI() public returns (bool _isNegative, uint256 _amount) {\n    uint256 supply = getCurrentCollateralInDAI();\n    uint256 borrow = getCurrentBorrowInDAI().mul(PRECISION).div(getMarketCollateralFactor());\n    if (supply >= borrow) {\n      return (false, supply.sub(borrow));\n    } else {\n      return (true, borrow.sub(supply));\n    }\n  }\n\n  function __sellDAIForToken(uint256 _daiAmount) internal returns (uint256 _actualDAIAmount, uint256 _actualTokenAmount) {\n    ERC20Detailed t = __underlyingToken(compoundTokenAddr);\n    (,, _actualTokenAmount, _actualDAIAmount) = __kyberTrade(dai, _daiAmount, t); \n    require(_actualDAIAmount > 0 && _actualTokenAmount > 0); \n  }\n\n  function __sellTokenForDAI(uint256 _tokenAmount) internal returns (uint256 _actualDAIAmount, uint256 _actualTokenAmount) {\n    ERC20Detailed t = __underlyingToken(compoundTokenAddr);\n    (,, _actualDAIAmount, _actualTokenAmount) = __kyberTrade(t, _tokenAmount, dai); \n    require(_actualDAIAmount > 0 && _actualTokenAmount > 0); \n  }\n\n  \n  function __daiToToken(address _cToken, uint256 _daiAmount) internal view returns (uint256) {\n    if (_cToken == CETH_ADDR) {\n      \n      return _daiAmount.mul(ORACLE.getUnderlyingPrice(address(CDAI))).div(PRECISION);\n    }\n    ERC20Detailed t = __underlyingToken(_cToken);\n    return _daiAmount.mul(ORACLE.getUnderlyingPrice(address(CDAI))).mul(10 ** getDecimals(t)).div(ORACLE.getUnderlyingPrice(_cToken).mul(PRECISION));\n  }\n\n  \n  function __tokenToDAI(address _cToken, uint256 _tokenAmount) internal view returns (uint256) {\n    if (_cToken == CETH_ADDR) {\n      \n      return _tokenAmount.mul(PRECISION).div(ORACLE.getUnderlyingPrice(address(CDAI)));\n    }\n    ERC20Detailed t = __underlyingToken(_cToken);\n    return _tokenAmount.mul(ORACLE.getUnderlyingPrice(_cToken)).mul(PRECISION).div(ORACLE.getUnderlyingPrice(address(CDAI)).mul(10 ** uint256(t.decimals())));\n  }\n\n  function __underlyingToken(address _cToken) internal view returns (ERC20Detailed) {\n    if (_cToken == CETH_ADDR) {\n      \n      return ETH_TOKEN_ADDRESS;\n    }\n    CERC20 ct = CERC20(_cToken);\n    address underlyingToken = ct.underlying();\n    ERC20Detailed t = ERC20Detailed(underlyingToken);\n    return t;\n  }\n\n  function() external payable {}\n}\n\ncontract LongCERC20Order is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = ORACLE.getUnderlyingPrice(compoundTokenAddr); \n    require(tokenPrice > 0); \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(collateralAmountInDAI);\n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    token.safeApprove(compoundTokenAddr, 0); \n    token.safeApprove(compoundTokenAddr, actualTokenAmount); \n    require(market.mint(actualTokenAmount) == 0); \n    token.safeApprove(compoundTokenAddr, 0); \n    require(CDAI.borrow(loanAmountInDAI) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    __sellDAIForToken(loanAmountInDAI);\n\n    \n    if (dai.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = dai.balanceOf(address(this));\n      dai.safeApprove(address(CDAI), 0);\n      dai.safeApprove(address(CDAI), repayAmount);\n      require(CDAI.repayBorrow(repayAmount) == 0);\n      dai.safeApprove(address(CDAI), 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n    \n    \n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        liquidity = __daiToToken(compoundTokenAddr, liquidity);\n        uint256 errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            market.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    __sellTokenForDAI(token.balanceOf(address(this)));\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n    token.safeTransfer(owner(), token.balanceOf(address(this))); \n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    uint256 repayAmountInToken = __daiToToken(compoundTokenAddr, _repayAmountInDAI);\n    (uint256 actualDAIAmount,) = __sellTokenForDAI(repayAmountInToken);\n    \n    \n    uint256 currentDebt = CDAI.borrowBalanceCurrent(address(this));\n    if (actualDAIAmount > currentDebt) {\n      actualDAIAmount = currentDebt;\n    }\n    \n    \n    dai.safeApprove(address(CDAI), 0);\n    dai.safeApprove(address(CDAI), actualDAIAmount);\n    require(CDAI.repayBorrow(actualDAIAmount) == 0);\n    dai.safeApprove(address(CDAI), 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(compoundTokenAddr));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 supply = __tokenToDAI(compoundTokenAddr, market.balanceOf(address(this)).mul(market.exchangeRateCurrent()).div(PRECISION));\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    uint256 borrow = CDAI.borrowBalanceCurrent(address(this));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    uint256 cash = __tokenToDAI(compoundTokenAddr, getBalance(token, address(this)));\n    return cash;\n  }\n}\n\ncontract LongCEtherOrder is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = PRECISION; \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n    \n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(collateralAmountInDAI);\n\n    \n    CEther market = CEther(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n    \n    \n    market.mint.value(actualTokenAmount)(); \n    require(CDAI.borrow(loanAmountInDAI) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    __sellDAIForToken(loanAmountInDAI);\n\n    \n    if (dai.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = dai.balanceOf(address(this));\n      dai.safeApprove(address(CDAI), 0);\n      dai.safeApprove(address(CDAI), repayAmount);\n      require(CDAI.repayBorrow(repayAmount) == 0);\n      dai.safeApprove(address(CDAI), 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    CEther market = CEther(compoundTokenAddr);\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        liquidity = __daiToToken(compoundTokenAddr, liquidity);\n        uint256 errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            market.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    __sellTokenForDAI(address(this).balance);\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n    toPayableAddr(owner()).transfer(address(this).balance); \n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    uint256 repayAmountInToken = __daiToToken(compoundTokenAddr, _repayAmountInDAI);\n    (uint256 actualDAIAmount,) = __sellTokenForDAI(repayAmountInToken);\n    \n    \n    uint256 currentDebt = CDAI.borrowBalanceCurrent(address(this));\n    if (actualDAIAmount > currentDebt) {\n      actualDAIAmount = currentDebt;\n    }\n\n    \n    dai.safeApprove(address(CDAI), 0);\n    dai.safeApprove(address(CDAI), actualDAIAmount);\n    require(CDAI.repayBorrow(actualDAIAmount) == 0);\n    dai.safeApprove(address(CDAI), 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(compoundTokenAddr));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    CEther market = CEther(compoundTokenAddr);\n    uint256 supply = __tokenToDAI(compoundTokenAddr, market.balanceOf(address(this)).mul(market.exchangeRateCurrent()).div(PRECISION));\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    uint256 borrow = CDAI.borrowBalanceCurrent(address(this));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    uint256 cash = __tokenToDAI(compoundTokenAddr, getBalance(token, address(this)));\n    return cash;\n  }\n}\n\ncontract ShortCERC20Order is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = ORACLE.getUnderlyingPrice(compoundTokenAddr); \n    require(tokenPrice > 0); \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n    \n    \n    uint256 loanAmountInToken = __daiToToken(compoundTokenAddr, loanAmountInDAI);\n    dai.safeApprove(address(CDAI), 0); \n    dai.safeApprove(address(CDAI), collateralAmountInDAI); \n    require(CDAI.mint(collateralAmountInDAI) == 0); \n    dai.safeApprove(address(CDAI), 0);\n    require(market.borrow(loanAmountInToken) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    (uint256 actualDAIAmount,) = __sellTokenForDAI(loanAmountInToken);\n    loanAmountInDAI = actualDAIAmount; \n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    if (token.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = token.balanceOf(address(this));\n      token.safeApprove(compoundTokenAddr, 0);\n      token.safeApprove(compoundTokenAddr, repayAmount);\n      require(market.repayBorrow(repayAmount) == 0);\n      token.safeApprove(compoundTokenAddr, 0);\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        uint256 errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(_repayAmountInDAI);\n\n    \n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 currentDebt = market.borrowBalanceCurrent(address(this));\n    if (actualTokenAmount > currentDebt) {\n      actualTokenAmount = currentDebt;\n    }\n\n    \n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    token.safeApprove(compoundTokenAddr, 0);\n    token.safeApprove(compoundTokenAddr, actualTokenAmount);\n    require(market.repayBorrow(actualTokenAmount) == 0);\n    token.safeApprove(compoundTokenAddr, 0);\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(CDAI));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    uint256 supply = CDAI.balanceOf(address(this)).mul(CDAI.exchangeRateCurrent()).div(PRECISION);\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 borrow = __tokenToDAI(compoundTokenAddr, market.borrowBalanceCurrent(address(this)));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    uint256 cash = getBalance(dai, address(this));\n    return cash;\n  }\n}\n\ncontract ShortCEtherOrder is CompoundOrder {\n  modifier isValidPrice(uint256 _minPrice, uint256 _maxPrice) {\n    \n    uint256 tokenPrice = PRECISION; \n    tokenPrice = __tokenToDAI(CETH_ADDR, tokenPrice); \n    require(tokenPrice >= _minPrice && tokenPrice <= _maxPrice); \n    _;\n  }\n\n  function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    \n    dai.safeTransferFrom(owner(), address(this), collateralAmountInDAI); \n    \n    \n    CEther market = CEther(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CDAI);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n\n    \n    uint256 loanAmountInToken = __daiToToken(compoundTokenAddr, loanAmountInDAI);\n    dai.safeApprove(address(CDAI), 0); \n    dai.safeApprove(address(CDAI), collateralAmountInDAI); \n    require(CDAI.mint(collateralAmountInDAI) == 0); \n    dai.safeApprove(address(CDAI), 0);\n    require(market.borrow(loanAmountInToken) == 0);\n    (bool negLiquidity, ) = getCurrentLiquidityInDAI();\n    require(!negLiquidity); \n\n    \n    (uint256 actualDAIAmount,) = __sellTokenForDAI(loanAmountInToken);\n    loanAmountInDAI = actualDAIAmount; \n\n    \n    if (address(this).balance > 0) {\n      uint256 repayAmount = address(this).balance;\n      market.repayBorrow.value(repayAmount)();\n    }\n  }\n\n  function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); \n    require(isSold == false);\n    isSold = true;\n\n    \n    \n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i.add(1)) {\n      uint256 currentDebt = getCurrentBorrowInDAI();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        \n        uint256 currentBalance = getCurrentCashInDAI();\n        uint256 repayAmount = 0; \n        if (currentDebt <= currentBalance) {\n          \n          repayAmount = currentDebt;\n        } else {\n          \n          repayAmount = currentBalance;\n        }\n\n        \n        repayLoan(repayAmount);\n      }\n\n      \n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInDAI();\n      if (!isNeg) {\n        uint256 errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          \n          \n          errorCode = CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            \n            \n            CDAI.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    \n    _inputAmount = collateralAmountInDAI;\n    _outputAmount = dai.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    dai.safeTransfer(owner(), dai.balanceOf(address(this)));\n  }\n\n  \n  function repayLoan(uint256 _repayAmountInDAI) public onlyOwner {\n    require(buyTime > 0); \n\n    \n    (,uint256 actualTokenAmount) = __sellDAIForToken(_repayAmountInDAI);\n\n    \n    CEther market = CEther(compoundTokenAddr);\n    uint256 currentDebt = market.borrowBalanceCurrent(address(this));\n    if (actualTokenAmount > currentDebt) {\n      actualTokenAmount = currentDebt;\n    }\n\n    \n    market.repayBorrow.value(actualTokenAmount)();\n  }\n\n  function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(CDAI));\n    return ratio;\n  }\n\n  function getCurrentCollateralInDAI() public returns (uint256 _amount) {\n    uint256 supply = CDAI.balanceOf(address(this)).mul(CDAI.exchangeRateCurrent()).div(PRECISION);\n    return supply;\n  }\n\n  function getCurrentBorrowInDAI() public returns (uint256 _amount) {\n    CEther market = CEther(compoundTokenAddr);\n    uint256 borrow = __tokenToDAI(compoundTokenAddr, market.borrowBalanceCurrent(address(this)));\n    return borrow;\n  }\n\n  function getCurrentCashInDAI() public view returns (uint256 _amount) {\n    uint256 cash = getBalance(dai, address(this));\n    return cash;\n  }\n}\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), targetBytes)\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}\n\ncontract CompoundOrderFactory is CloneFactory {\n  address public SHORT_CERC20_LOGIC_CONTRACT;\n  address public SHORT_CEther_LOGIC_CONTRACT;\n  address public LONG_CERC20_LOGIC_CONTRACT;\n  address public LONG_CEther_LOGIC_CONTRACT;\n\n  address public DAI_ADDR;\n  address payable public KYBER_ADDR;\n  address public COMPTROLLER_ADDR;\n  address public ORACLE_ADDR;\n  address public CDAI_ADDR;\n  address public CETH_ADDR;\n\n  constructor(\n    address _shortCERC20LogicContract,\n    address _shortCEtherLogicContract,\n    address _longCERC20LogicContract,\n    address _longCEtherLogicContract,\n    address _daiAddr,\n    address payable _kyberAddr,\n    address _comptrollerAddr,\n    address _priceOracleAddr,\n    address _cDAIAddr,\n    address _cETHAddr\n  ) public {\n    SHORT_CERC20_LOGIC_CONTRACT = _shortCERC20LogicContract;\n    SHORT_CEther_LOGIC_CONTRACT = _shortCEtherLogicContract;\n    LONG_CERC20_LOGIC_CONTRACT = _longCERC20LogicContract;\n    LONG_CEther_LOGIC_CONTRACT = _longCEtherLogicContract;\n\n    DAI_ADDR = _daiAddr;\n    KYBER_ADDR = _kyberAddr;\n    COMPTROLLER_ADDR = _comptrollerAddr;\n    ORACLE_ADDR = _priceOracleAddr;\n    CDAI_ADDR = _cDAIAddr;\n    CETH_ADDR = _cETHAddr;\n  }\n\n  function createOrder(\n    address _compoundTokenAddr,\n    uint256 _cycleNumber,\n    uint256 _stake,\n    uint256 _collateralAmountInDAI,\n    uint256 _loanAmountInDAI,\n    bool _orderType\n  ) external returns (CompoundOrder) {\n    require(_compoundTokenAddr != address(0));\n\n    CompoundOrder order;\n\n    address payable clone;\n    if (_compoundTokenAddr != CETH_ADDR) {\n      if (_orderType) {\n        \n        clone = toPayableAddr(createClone(SHORT_CERC20_LOGIC_CONTRACT));\n      } else {\n        \n        clone = toPayableAddr(createClone(LONG_CERC20_LOGIC_CONTRACT));\n      }\n    } else {\n      if (_orderType) {\n        \n        clone = toPayableAddr(createClone(SHORT_CEther_LOGIC_CONTRACT));\n      } else {\n        \n        clone = toPayableAddr(createClone(LONG_CEther_LOGIC_CONTRACT));\n      }\n    }\n    order = CompoundOrder(clone);\n    order.init(_compoundTokenAddr, _cycleNumber, _stake, _collateralAmountInDAI, _loanAmountInDAI, _orderType,\n      DAI_ADDR, KYBER_ADDR, COMPTROLLER_ADDR, ORACLE_ADDR, CDAI_ADDR, CETH_ADDR);\n    order.transferOwnership(msg.sender);\n    return order;\n  }\n\n  function getMarketCollateralFactor(address _compoundTokenAddr) external view returns (uint256) {\n    Comptroller troll = Comptroller(COMPTROLLER_ADDR);\n    (, uint256 factor) = troll.markets(_compoundTokenAddr);\n    return factor;\n  }\n\n  function tokenIsListed(address _compoundTokenAddr) external view returns (bool) {\n    Comptroller troll = Comptroller(COMPTROLLER_ADDR);\n    (bool isListed,) = troll.markets(_compoundTokenAddr);\n    return isListed;\n  }\n\n  function toPayableAddr(address _addr) internal pure returns (address payable) {\n    return address(uint160(_addr));\n  }\n}\n\ncontract BetokenFund is BetokenStorage, Utils, TokenController {\n  \n  modifier readyForUpgradeMigration {\n    require(hasFinalizedNextVersion == true);\n    require(now > startTimeOfCyclePhase.add(phaseLengths[uint(CyclePhase.Intermission)]));\n    _;\n  }\n\n\n  \n\n  constructor(\n    address payable _kroAddr,\n    address payable _sTokenAddr,\n    address payable _devFundingAccount,\n    uint256[2] memory _phaseLengths,\n    uint256 _devFundingRate,\n    address payable _previousVersion,\n    address _daiAddr,\n    address payable _kyberAddr,\n    address _compoundFactoryAddr,\n    address _betokenLogic,\n    address _betokenLogic2,\n    uint256 _startCycleNumber,\n    address payable _dexagAddr,\n    address _saiAddr,\n    address _mcdaiMigrationAddr\n  )\n    public\n    Utils(_daiAddr, _kyberAddr, _dexagAddr)\n  {\n    controlTokenAddr = _kroAddr;\n    shareTokenAddr = _sTokenAddr;\n    devFundingAccount = _devFundingAccount;\n    phaseLengths = _phaseLengths;\n    devFundingRate = _devFundingRate;\n    cyclePhase = CyclePhase.Intermission;\n    compoundFactoryAddr = _compoundFactoryAddr;\n    betokenLogic = _betokenLogic;\n    betokenLogic2 = _betokenLogic2;\n    previousVersion = _previousVersion;\n    cycleNumber = _startCycleNumber;\n    saiAddr = _saiAddr;\n\n    cToken = IMiniMeToken(_kroAddr);\n    sToken = IMiniMeToken(_sTokenAddr);\n    mcdaiMigration = ScdMcdMigration(_mcdaiMigrationAddr);\n  }\n\n  function initTokenListings(\n    address[] memory _kyberTokens,\n    address[] memory _compoundTokens,\n    address[] memory _positionTokens\n  )\n    public\n    onlyOwner\n  {\n    \n    require(!hasInitializedTokenListings);\n    hasInitializedTokenListings = true;\n\n    uint256 i;\n    for (i = 0; i < _kyberTokens.length; i = i.add(1)) {\n      isKyberToken[_kyberTokens[i]] = true;\n    }\n\n    for (i = 0; i < _compoundTokens.length; i = i.add(1)) {\n      isCompoundToken[_compoundTokens[i]] = true;\n    }\n\n    for (i = 0; i < _positionTokens.length; i = i.add(1)) {\n      isPositionToken[_positionTokens[i]] = true;\n    }\n  }\n\n  \n  function setProxy(address payable _proxyAddr) public onlyOwner {\n    require(_proxyAddr != address(0));\n    require(proxyAddr == address(0));\n    proxyAddr = _proxyAddr;\n    proxy = BetokenProxyInterface(_proxyAddr);\n  }\n\n  \n\n  \n  function developerInitiateUpgrade(address payable _candidate) public returns (bool _success) {\n    (bool success, bytes memory result) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.developerInitiateUpgrade.selector, _candidate));\n    if (!success) { return false; }\n    return abi.decode(result, (bool));\n  }\n\n  \n  function signalUpgrade(bool _inSupport) public returns (bool _success) {\n    (bool success, bytes memory result) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.signalUpgrade.selector, _inSupport));\n    if (!success) { return false; }\n    return abi.decode(result, (bool));\n  }\n\n  \n  function proposeCandidate(uint256 _chunkNumber, address payable _candidate) public returns (bool _success) {\n    (bool success, bytes memory result) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.proposeCandidate.selector, _chunkNumber, _candidate));\n    if (!success) { return false; }\n    return abi.decode(result, (bool));\n  }\n\n  \n  function voteOnCandidate(uint256 _chunkNumber, bool _inSupport) public returns (bool _success) {\n    (bool success, bytes memory result) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.voteOnCandidate.selector, _chunkNumber, _inSupport));\n    if (!success) { return false; }\n    return abi.decode(result, (bool));\n  }\n\n  \n  function finalizeSuccessfulVote(uint256 _chunkNumber) public returns (bool _success) {\n    (bool success, bytes memory result) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.finalizeSuccessfulVote.selector, _chunkNumber));\n    if (!success) { return false; }\n    return abi.decode(result, (bool));\n  }\n\n  \n  function migrateOwnedContractsToNextVersion() public nonReentrant readyForUpgradeMigration {\n    cToken.transferOwnership(nextVersion);\n    sToken.transferOwnership(nextVersion);\n    proxy.updateBetokenFundAddress();\n  }\n\n  \n  function transferAssetToNextVersion(address _assetAddress) public nonReentrant readyForUpgradeMigration isValidToken(_assetAddress) {\n    if (_assetAddress == address(ETH_TOKEN_ADDRESS)) {\n      nextVersion.transfer(address(this).balance);\n    } else {\n      ERC20Detailed token = ERC20Detailed(_assetAddress);\n      token.safeTransfer(nextVersion, token.balanceOf(address(this)));\n    }\n  }\n\n  \n\n  \n  function investmentsCount(address _userAddr) public view returns(uint256 _count) {\n    return userInvestments[_userAddr].length;\n  }\n\n  \n  function compoundOrdersCount(address _userAddr) public view returns(uint256 _count) {\n    return userCompoundOrders[_userAddr].length;\n  }\n\n  \n  function getPhaseLengths() public view returns(uint256[2] memory _phaseLengths) {\n    return phaseLengths;\n  }\n\n  \n  function commissionBalanceOf(address _manager) public returns (uint256 _commission, uint256 _penalty) {\n    (bool success, bytes memory result) = betokenLogic.delegatecall(abi.encodeWithSelector(this.commissionBalanceOf.selector, _manager));\n    if (!success) { return (0, 0); }\n    return abi.decode(result, (uint256, uint256));\n  }\n\n  \n  function commissionOfAt(address _manager, uint256 _cycle) public returns (uint256 _commission, uint256 _penalty) {\n    (bool success, bytes memory result) = betokenLogic.delegatecall(abi.encodeWithSelector(this.commissionOfAt.selector, _manager, _cycle));\n    if (!success) { return (0, 0); }\n    return abi.decode(result, (uint256, uint256));\n  }\n\n  \n\n  \n  function changeDeveloperFeeAccount(address payable _newAddr) public onlyOwner {\n    require(_newAddr != address(0) && _newAddr != address(this));\n    devFundingAccount = _newAddr;\n  }\n\n  \n  function changeDeveloperFeeRate(uint256 _newProp) public onlyOwner {\n    require(_newProp < PRECISION);\n    require(_newProp < devFundingRate);\n    devFundingRate = _newProp;\n  }\n\n  \n  function listKyberToken(address _token) public onlyOwner {\n    isKyberToken[_token] = true;\n  }\n\n  \n  function listCompoundToken(address _token) public onlyOwner {\n    CompoundOrderFactory factory = CompoundOrderFactory(compoundFactoryAddr);\n    require(factory.tokenIsListed(_token));\n    isCompoundToken[_token] = true;\n  }\n\n  \n  function nextPhase()\n    public\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.nextPhase.selector));\n    if (!success) { revert(); }\n  }\n\n\n  \n\n  \n  function registerWithDAI(uint256 _donationInDAI) public {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.registerWithDAI.selector, _donationInDAI));\n    if (!success) { revert(); }\n  }\n\n  \n  function registerWithETH() public payable {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.registerWithETH.selector));\n    if (!success) { revert(); }\n  }\n\n  \n  function registerWithToken(address _token, uint256 _donationInTokens) public {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.registerWithToken.selector, _token, _donationInTokens));\n    if (!success) { revert(); }\n  }\n\n\n  \n\n  \n  function depositEther()\n    public\n    payable\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.depositEther.selector));\n    if (!success) { revert(); }\n  }\n\n  \n  function depositDAI(uint256 _daiAmount)\n    public\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.depositDAI.selector, _daiAmount));\n    if (!success) { revert(); }\n  }\n\n  \n  function depositToken(address _tokenAddr, uint256 _tokenAmount)\n    public\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.depositToken.selector, _tokenAddr, _tokenAmount));\n    if (!success) { revert(); }\n  }\n\n  \n  function withdrawEther(uint256 _amountInDAI)\n    public\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.withdrawEther.selector, _amountInDAI));\n    if (!success) { revert(); }\n  }\n\n  \n  function withdrawDAI(uint256 _amountInDAI)\n    public\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.withdrawDAI.selector, _amountInDAI));\n    if (!success) { revert(); }\n  }\n\n  \n  function withdrawToken(address _tokenAddr, uint256 _amountInDAI)\n    public\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.withdrawToken.selector, _tokenAddr, _amountInDAI));\n    if (!success) { revert(); }\n  }\n\n  \n  function redeemCommission(bool _inShares)\n    public\n  {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.redeemCommission.selector, _inShares));\n    if (!success) { revert(); }\n  }\n\n  \n  function redeemCommissionForCycle(bool _inShares, uint256 _cycle)\n    public\n  {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.redeemCommissionForCycle.selector, _inShares, _cycle));\n    if (!success) { revert(); }\n  }\n\n  \n  function sellLeftoverToken(address _tokenAddr)\n    public\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.sellLeftoverToken.selector, _tokenAddr));\n    if (!success) { revert(); }\n  }\n\n  function sellLeftoverFulcrumToken(address _tokenAddr)\n    public\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.sellLeftoverFulcrumToken.selector, _tokenAddr));\n    if (!success) { revert(); }\n  }\n\n  \n  function sellLeftoverCompoundOrder(address payable _orderAddress)\n    public\n  {\n    (bool success,) = betokenLogic2.delegatecall(abi.encodeWithSelector(this.sellLeftoverCompoundOrder.selector, _orderAddress));\n    if (!success) { revert(); }\n  }\n\n  \n  function burnDeadman(address _deadman)\n    public\n  {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.burnDeadman.selector, _deadman));\n    if (!success) { revert(); }\n  }\n\n  \n\n  \n  function createInvestment(\n    address _tokenAddress,\n    uint256 _stake,\n    uint256 _minPrice,\n    uint256 _maxPrice\n  )\n    public\n  {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.createInvestment.selector, _tokenAddress, _stake, _minPrice, _maxPrice));\n    if (!success) { revert(); }\n  }\n\n  \n  function createInvestmentV2(\n    address _tokenAddress,\n    uint256 _stake,\n    uint256 _minPrice,\n    uint256 _maxPrice,\n    bytes memory _calldata,\n    bool _useKyber\n  )\n    public\n  {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.createInvestmentV2.selector, _tokenAddress, _stake, _minPrice, _maxPrice, _calldata, _useKyber));\n    if (!success) { revert(); }\n  }\n\n  \n  function sellInvestmentAsset(\n    uint256 _investmentId,\n    uint256 _tokenAmount,\n    uint256 _minPrice,\n    uint256 _maxPrice\n  )\n    public\n  {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.sellInvestmentAsset.selector, _investmentId, _tokenAmount, _minPrice, _maxPrice));\n    if (!success) { revert(); }\n  }\n\n  \n  function sellInvestmentAssetV2(\n    uint256 _investmentId,\n    uint256 _tokenAmount,\n    uint256 _minPrice,\n    uint256 _maxPrice,\n    bytes memory _calldata,\n    bool _useKyber\n  )\n    public\n  {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.sellInvestmentAssetV2.selector, _investmentId, _tokenAmount, _minPrice, _maxPrice, _calldata, _useKyber));\n    if (!success) { revert(); }\n  }\n\n  \n  function createCompoundOrder(\n    bool _orderType,\n    address _tokenAddress,\n    uint256 _stake,\n    uint256 _minPrice,\n    uint256 _maxPrice\n  )\n    public\n  {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.createCompoundOrder.selector, _orderType, _tokenAddress, _stake, _minPrice, _maxPrice));\n    if (!success) { revert(); }\n  }\n\n  \n  function sellCompoundOrder(\n    uint256 _orderId,\n    uint256 _minPrice,\n    uint256 _maxPrice\n  )\n    public\n  {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.sellCompoundOrder.selector, _orderId, _minPrice, _maxPrice));\n    if (!success) { revert(); }\n  }\n\n  \n  function repayCompoundOrder(uint256 _orderId, uint256 _repayAmountInDAI) public {\n    (bool success,) = betokenLogic.delegatecall(abi.encodeWithSelector(this.repayCompoundOrder.selector, _orderId, _repayAmountInDAI));\n    if (!success) { revert(); }\n  }\n\n  \n\n  \n  \n  function proxyPayment(address _owner) public payable returns(bool) {\n    return false;\n  }\n\n  \n  function onTransfer(address _from, address _to, uint _amount) public returns(bool) {\n    return true;\n  }\n\n  \n  function onApprove(address _owner, address _spender, uint _amount) public\n      returns(bool) {\n    return true;\n  }\n\n  function() external payable {}\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_kroAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_sTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_devFundingAccount\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"_phaseLengths\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"_devFundingRate\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_previousVersion\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_daiAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_kyberAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_compoundFactoryAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_betokenLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_betokenLogic2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startCycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_dexagAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_saiAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mcdaiMigrationAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_newPhase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalFundsInDAI\",\"type\":\"uint256\"}],\"name\":\"ChangedPhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"}],\"name\":\"CommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_order\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_orderType\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeInWeis\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_costDAIAmount\",\"type\":\"uint256\"}],\"name\":\"CreatedCompoundOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeInWeis\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_buyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_costDAIAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"CreatedInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"DeveloperInitiatedUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nextVersion\",\"type\":\"address\"}],\"name\":\"FinalizedNextVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"}],\"name\":\"InitiatedUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_voteID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"ProposedCandidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_donationInDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_kairoReceived\",\"type\":\"uint256\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_order\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_repaidDAIAmount\",\"type\":\"uint256\"}],\"name\":\"RepaidCompoundOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"}],\"name\":\"SignaledUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_order\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_orderType\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_receivedKairo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_earnedDAIAmount\",\"type\":\"uint256\"}],\"name\":\"SoldCompoundOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_receivedKairo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sellPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_earnedDAIAmount\",\"type\":\"uint256\"}],\"name\":\"SoldInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalCommissionInDAI\",\"type\":\"uint256\"}],\"name\":\"TotalCommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_voteID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASSET_FEE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHUNK_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLLATERAL_RATIO_MODIFIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSION_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CYCLES_TILL_MATURITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEXAG_ADDR\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FALLBACK_MAX_DONATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INACTIVE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYBER_ADDR\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BUY_KRO_PROP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_KRO_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_RISK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEXT_PHASE_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERM_HINT\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROPOSE_SUBCHUNK_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUORUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_BURN_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_PUNISH_NEG_BIAS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_PUNISH_SLOPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROI_PUNISH_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOTE_SUCCESS_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"againstVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"baseRiskStakeFallback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betokenLogic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betokenLogic2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deadman\",\"type\":\"address\"}],\"name\":\"burnDeadman\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"candidates\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"changeDeveloperFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newProp\",\"type\":\"uint256\"}],\"name\":\"changeDeveloperFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"commissionBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_penalty\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"commissionOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_penalty\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compoundFactoryAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"compoundOrdersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controlTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_orderType\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"createCompoundOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"createInvestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_useKyber\",\"type\":\"bool\"}],\"name\":\"createInvestmentV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentChunk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSubchunk\",\"outputs\":[{\"internalType\":\"enum BetokenStorage.Subchunk\",\"name\":\"_subchunk\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycleNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cyclePhase\",\"outputs\":[{\"internalType\":\"enum BetokenStorage.CyclePhase\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_daiAmount\",\"type\":\"uint256\"}],\"name\":\"depositDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFundingAccount\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFundingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"developerInitiateUpgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chunkNumber\",\"type\":\"uint256\"}],\"name\":\"finalizeSuccessfulVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPhaseLengths\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"_phaseLengths\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalVotingWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getVotingWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasFinalizedNextVersion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasInitializedTokenListings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"hasRedeemedCommissionForCycle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_kyberTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_compoundTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_positionTokens\",\"type\":\"address[]\"}],\"name\":\"initTokenListings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"investmentsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCompoundToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKyberToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPositionToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kairoPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_kairoPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"lastActiveCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"lastCommissionRedemption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"listCompoundToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"listKyberToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"managePhaseEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"managerVotes\",\"outputs\":[{\"internalType\":\"enum BetokenStorage.VoteDirection\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateOwnedContractsToNextVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"nextPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextVersion\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phaseLengths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousVersion\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chunkNumber\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"proposeCandidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposersVotingWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyAddr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"proxyPayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_inShares\",\"type\":\"bool\"}],\"name\":\"redeemCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_inShares\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"redeemCommissionForCycle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_donationInDAI\",\"type\":\"uint256\"}],\"name\":\"registerWithDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"registerWithETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_donationInTokens\",\"type\":\"uint256\"}],\"name\":\"registerWithToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_repayAmountInDAI\",\"type\":\"uint256\"}],\"name\":\"repayCompoundOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"riskTakenInCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saiAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"sellCompoundOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"sellInvestmentAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_useKyber\",\"type\":\"bool\"}],\"name\":\"sellInvestmentAssetV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_orderAddress\",\"type\":\"address\"}],\"name\":\"sellLeftoverCompoundOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"sellLeftoverFulcrumToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"sellLeftoverToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxyAddr\",\"type\":\"address\"}],\"name\":\"setProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"}],\"name\":\"signalUpgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimeOfCyclePhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCommissionLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"totalCommissionOfCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFundsInDAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"transferAssetToNextVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"upgradeSignal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"upgradeSignalStrength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeVotingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userCompoundOrders\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInvestments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyCostInDAI\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSold\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chunkNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_inSupport\",\"type\":\"bool\"}],\"name\":\"voteOnCandidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountInDAI\",\"type\":\"uint256\"}],\"name\":\"withdrawDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountInDAI\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountInDAI\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BetokenFund","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000952bbd5344ca0a898a1b8b2ffcfe3acb1351ebd50000000000000000000000001689dcfef3e695ac4cc1e5b7e77f9135f1d58a50000000000000000000000000332d87209f7c8296389c307eae170c2440830a47000000000000000000000000000000000000000000000000000000000003f480000000000000000000000000000000000000000000000000000000000023988000000000000000000000000000000000000000000000000000038d7ea4c68000000000000000000000000000881a0bdf9514c116f4576f4fba263bf5397fca830000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b7550000000000000000000000000d72c9884e4ba0762f192cc7701f01f6bd48e3ba0000000000000000000000005b435cd2ebc7b91990f9a7fccab0dcbfebddae35000000000000000000000000edd00c14bbe57553768a85e380179018537416230000000000000000000000000000000000000000000000000000000000000007000000000000000000000000b1ba342edb8626b611bbc1754d8c8639521d3f5800000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359000000000000000000000000c73e0383f3aff3215e6f04b0331d58cecf0ab849","Library":"","LicenseType":"","SwarmSource":"bzzr://01a0b0b13a8fd82a10184cb016b49e8ca288a1188073d8d57eaf55880b18a4a7"}]}