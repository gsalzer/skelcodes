{"status":"1","message":"OK","result":[{"SourceCode":"{\"PotLuck.sol\":{\"content\":\"pragma solidity ^0.5.12;\\n\\nimport \\\"./SortitionSumTreeFactory.sol\\\";\\n\\ncontract PotLuck  {\\n    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;\\n    \\n    event PotEventCreated(uint256 eventId, uint256 expirationDateTime);\\n    event TicketBought(address _from, uint256 _ticketPrice, uint _ticketCount);\\n    event EventWinner(address _winnerAddr, uint256 _totalAmountWin);\\n    \\n    struct Pot {\\n        SortitionSumTreeFactory.SortitionSumTrees sortitionSumTrees;\\n        uint256 currentPotEventId;\\n    }\\n\\n    struct PotEntry {\\n        uint256 potEventId;\\n        uint256 ticketPrice;\\n        uint256 maxTicketThreshold;\\n        uint256 expirationDateTime;\\n        uint256 totalAmount;\\n        uint256 totalTicketCount;\\n\\n        // mapping(address =\\u003e UserEntry) userEntries;\\n        // address payable [] userAddr;\\n    }\\n    \\n    struct PotDraw {\\n        address winner;\\n        uint256 netPrize;\\n        uint256 fee;\\n        bool drawn;\\n    }\\n    \\n    Pot pot;\\n    \\n    mapping(uint256 =\\u003e PotEntry) public potEntries;\\n    \\n    mapping(uint256 =\\u003e PotDraw) public potDraws;\\n    \\n    constructor() public {\\n        // minimumBet = 5000000000000000; // 0.005\\n        // fixBet = 5000000000000000; // 0,005\\n        // fixFee = 10000000000000; // 0.00001\\n    }\\n    \\n    function createPotEntry(\\n        bytes32 potEventId,\\n        uint256 _ticketPrice, \\n        uint256 _maxTicketThreshold, \\n        uint256 _duration) payable public {\\n        uint256 _potEventId = uint256(potEventId);\\n        \\n        require(msg.value \\u003e= _ticketPrice, \\\"BET MUST BE GREATER THAN THE MINIMUM BET.\\\");\\n        \\n        uint256 expirationDateTime = now + _duration;\\n        uint256 ticketEntry = msg.value / _ticketPrice;\\n        potEntries[_potEventId] = PotEntry(_potEventId, _ticketPrice, _maxTicketThreshold, expirationDateTime, msg.value, ticketEntry);\\n        pot.sortitionSumTrees.createTree(bytes32(potEventId), _maxTicketThreshold);\\n        \\n        pot.sortitionSumTrees.set(bytes32(potEventId), msg.value, bytes32(uint256(msg.sender)));\\n        emit PotEventCreated(_potEventId, expirationDateTime);\\n    }\\n\\n    \\n    // User buy tickets.\\n    function buyEntry(bytes32 potEventId) payable public {\\n        uint256 _potEventId = uint256(potEventId);\\n        require(!checkEventIfExpired(_potEventId), \\\"Event Expired\\\");\\n        require(!_hasDrawn(_potEventId), \\\"Event already ended\\\");\\n        \\n        bytes32 userId = bytes32(uint256(msg.sender));\\n    \\n        require(msg.value \\u003e= potEntries[_potEventId].ticketPrice, \\\"BET MUST BE GREATER THAN THE MINIMUM BET.\\\");\\n        \\n        PotEntry storage pots = potEntries[_potEventId];\\n        \\n        // update the current draw\\n        uint256 currentAmount = pot.sortitionSumTrees.stakeOf(bytes32(_potEventId), userId);\\n        currentAmount = currentAmount+=msg.value;\\n        \\n        uint256 ticketEntry = msg.value / pots.ticketPrice;\\n        \\n        pot.sortitionSumTrees.set(bytes32(_potEventId), currentAmount, userId);\\n        \\n        pots.totalAmount+=msg.value;\\n        pots.totalTicketCount+=ticketEntry;\\n        \\n        if(_hasReachThreshold(_potEventId)){\\n            address payable winnerAddr = selectWinner(_potEventId);\\n\\n            // https://ethereum.stackexchange.com/questions/41616/assign-decimal-to-a-variable-in-solidity\\n            address payable ownerAddrCompany = 0x99148fEb343A7D000B26396c134236E65bed70f0; // Can be changed.\\n            \\n            //Total prize minus fee.\\n            uint256 totalPrize = pots.totalAmount;\\n            uint256 fee = pots.totalAmount * 1 / 10000;\\n            \\n            PotDraw storage potDraw = potDraws[_potEventId];\\n            //Winner address.\\n            potDraw.winner = winnerAddr;\\n            \\n            //Total prize minus fee.\\n            potDraw.netPrize = totalPrize - fee;\\n            \\n            //Total fee to be trasnfer to impero account.\\n            potDraw.fee = fee;\\n            \\n            potDraw.drawn = true;\\n            \\n            winnerAddr.transfer(potDraw.netPrize);\\n            ownerAddrCompany.transfer(fee);\\n            // delete eventEntries[_eventId];\\n        \\n            emit EventWinner(winnerAddr, totalPrize);\\n        }\\n    }\\n\\n    // function eventExpired(uint _potEventId) public {\\n    //     require(now \\u003e= potEntries[_potEventId].expirationDateTime, \\\"Event not yet expired.\\\");\\n    //     potEntries[_potEventId].expired = true;\\n    //     // selfdestruct(sender);\\n    // }\\n    \\n    function checkEventIfExpired(uint256 potEventId) public view returns(bool) {\\n        uint256 _potEventId = uint256(potEventId);\\n        if(now \\u003e= potEntries[_potEventId].expirationDateTime) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    function getUserEntry(bytes32 potEventId, address addr) public view returns(uint256, uint256) {\\n        uint256 _potEventId = uint256(potEventId);\\n        PotEntry storage pots = potEntries[_potEventId];\\n        bytes32 userId = bytes32(uint256(addr));\\n        uint256 currentAmount = pot.sortitionSumTrees.stakeOf(bytes32(_potEventId), userId);\\n        \\n        return (currentAmount, currentAmount / pots.ticketPrice);\\n    }\\n\\n    function getContractBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    function refundTicket(uint256 potEventId, address payable addr) payable public {\\n        bytes32 userId = bytes32(uint256(addr));\\n        require(pot.sortitionSumTrees.stakeOf(bytes32(potEventId), userId) \\u003e 0, \\\"Zero Balance\\\");\\n        uint256 refundAmount = pot.sortitionSumTrees.stakeOf(bytes32(potEventId), userId);\\n        addr.transfer(refundAmount);\\n        pot.sortitionSumTrees.set(bytes32(potEventId), 0, userId);\\n    }\\n     \\n    function selectWinner(uint256 potEventId) public view returns(address payable) {\\n        uint256 _potEventId = uint256(potEventId);\\n        uint256 randomToken = random() % potEntries[_potEventId].totalAmount;\\n        return address(uint256(pot.sortitionSumTrees.draw(bytes32(_potEventId), randomToken)));\\n    }\\n    \\n\\n    function random() public view returns(uint) {\\n        return uint256(keccak256(abi.encodePacked(block.difficulty, now)));\\n    } \\n    \\n    function _hasReachThreshold(uint256 potEventId) internal view returns (bool) {\\n        uint256 _potEventId = uint256(potEventId);\\n        return potEntries[_potEventId].totalTicketCount == potEntries[_potEventId].maxTicketThreshold;\\n    }\\n    \\n    function _hasEvent(uint256 potEventId) internal view returns (bool) {\\n        uint256 _potEventId = uint256(potEventId);\\n        return potEntries[_potEventId].potEventId == _potEventId;\\n    }\\n    \\n    function _hasDrawn(uint256 potEventId) internal view returns (bool) {\\n        uint256 _potEventId = uint256(potEventId);\\n        return potDraws[_potEventId].drawn;\\n    }\\n}\"},\"SortitionSumTreeFactory.sol\":{\"content\":\"/**\\n *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]\\n *  @auditors: []\\n *  @bounties: [\\u003c14 days 10 ETH max payout\\u003e]\\n *  @deployments: []\\n */\\n\\npragma solidity ^0.5.12;\\n\\n/**\\n *  @title SortitionSumTreeFactory\\n *  @author Enrique Piqueras - \\u003cepiquerass@gmail.com\\u003e\\n *  @dev A factory of trees that keep track of staked values for sortition.\\n */\\nlibrary SortitionSumTreeFactory {\\n    /* Structs */\\n\\n    struct SortitionSumTree {\\n        uint K; // The maximum number of childs per node.\\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\\n        uint[] stack;\\n        uint[] nodes;\\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\\n        mapping(bytes32 =\\u003e uint) IDsToNodeIndexes;\\n        mapping(uint =\\u003e bytes32) nodeIndexesToIDs;\\n    }\\n\\n    /* Storage */\\n\\n    struct SortitionSumTrees {\\n        mapping(bytes32 =\\u003e SortitionSumTree) sortitionSumTrees;\\n    }\\n\\n    /* Public */\\n\\n    /**\\n     *  @dev Create a sortition sum tree at the specified key.\\n     *  @param _key The key of the new tree.\\n     *  @param _K The number of children each node in the tree should have.\\n     */\\n    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) public {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        require(tree.K == 0, \\\"Tree already exists.\\\");\\n        require(_K \\u003e 1, \\\"K must be greater than one.\\\");\\n        tree.K = _K;\\n        tree.stack.length = 0;\\n        tree.nodes.length = 0;\\n        tree.nodes.push(0);\\n    }\\n\\n    /**\\n     *  @dev Set a value of a tree.\\n     *  @param _key The key of the tree.\\n     *  @param _value The new value.\\n     *  @param _ID The ID of the value.\\n     *  `O(log_k(n))` where\\n     *  `k` is the maximum number of childs per node in the tree,\\n     *   and `n` is the maximum number of nodes ever appended.\\n     */\\n    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) public {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\\n\\n        if (treeIndex == 0) { // No existing node.\\n            if (_value != 0) { // Non zero value.\\n                // Append.\\n                // Add node.\\n                if (tree.stack.length == 0) { // No vacant spots.\\n                    // Get the index and append the value.\\n                    treeIndex = tree.nodes.length;\\n                    tree.nodes.push(_value);\\n\\n                    // Potentially append a new node and make the parent a sum node.\\n                    if (treeIndex != 1 \\u0026\\u0026 (treeIndex - 1) % tree.K == 0) { // Is first child.\\n                        uint parentIndex = treeIndex / tree.K;\\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\\n                        uint newIndex = treeIndex + 1;\\n                        tree.nodes.push(tree.nodes[parentIndex]);\\n                        delete tree.nodeIndexesToIDs[parentIndex];\\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\\n                    }\\n                } else { // Some vacant spot.\\n                    // Pop the stack and append the value.\\n                    treeIndex = tree.stack[tree.stack.length - 1];\\n                    tree.stack.length--;\\n                    tree.nodes[treeIndex] = _value;\\n                }\\n\\n                // Add label.\\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\\n\\n                updateParents(self, _key, treeIndex, true, _value);\\n            }\\n        } else { // Existing node.\\n            if (_value == 0) { // Zero value.\\n                // Remove.\\n                // Remember value and set to 0.\\n                uint value = tree.nodes[treeIndex];\\n                tree.nodes[treeIndex] = 0;\\n\\n                // Push to stack.\\n                tree.stack.push(treeIndex);\\n\\n                // Clear label.\\n                delete tree.IDsToNodeIndexes[_ID];\\n                delete tree.nodeIndexesToIDs[treeIndex];\\n\\n                updateParents(self, _key, treeIndex, false, value);\\n            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.\\n                // Set.\\n                bool plusOrMinus = tree.nodes[treeIndex] \\u003c= _value;\\n                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;\\n                tree.nodes[treeIndex] = _value;\\n\\n                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\\n            }\\n        }\\n    }\\n\\n    /* Public Views */\\n\\n    /**\\n     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\\n     *  @param _key The key of the tree to get the leaves from.\\n     *  @param _cursor The pagination cursor.\\n     *  @param _count The number of items to return.\\n     *  @return The index at which leaves start, the values of the returned leaves, and whether there are more for pagination.\\n     *  `O(n)` where\\n     *  `n` is the maximum number of nodes ever appended.\\n     */\\n    function queryLeafs(\\n        SortitionSumTrees storage self,\\n        bytes32 _key,\\n        uint _cursor,\\n        uint _count\\n    ) public view returns(uint startIndex, uint[] memory values, bool hasMore) {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n\\n        // Find the start index.\\n        for (uint i = 0; i \\u003c tree.nodes.length; i++) {\\n            if ((tree.K * i) + 1 \\u003e= tree.nodes.length) {\\n                startIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // Get the values.\\n        uint loopStartIndex = startIndex + _cursor;\\n        values = new uint[](loopStartIndex + _count \\u003e tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);\\n        uint valuesIndex = 0;\\n        for (uint j = loopStartIndex; j \\u003c tree.nodes.length; j++) {\\n            if (valuesIndex \\u003c _count) {\\n                values[valuesIndex] = tree.nodes[j];\\n                valuesIndex++;\\n            } else {\\n                hasMore = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\\n     *  @param _key The key of the tree.\\n     *  @param _drawnNumber The drawn number.\\n     *  @return The drawn ID.\\n     *  `O(k * log_k(n))` where\\n     *  `k` is the maximum number of childs per node in the tree,\\n     *   and `n` is the maximum number of nodes ever appended.\\n     */\\n    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) public view returns(bytes32 ID) {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        uint treeIndex = 0;\\n        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\\n\\n        while ((tree.K * treeIndex) + 1 \\u003c tree.nodes.length)  // While it still has children.\\n            for (uint i = 1; i \\u003c= tree.K; i++) { // Loop over children.\\n                uint nodeIndex = (tree.K * treeIndex) + i;\\n                uint nodeValue = tree.nodes[nodeIndex];\\n\\n                if (currentDrawnNumber \\u003e= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\\n                else { // Pick this child.\\n                    treeIndex = nodeIndex;\\n                    break;\\n                }\\n            }\\n        \\n        ID = tree.nodeIndexesToIDs[treeIndex];\\n    }\\n\\n    /** @dev Gets a specified ID\\u0027s associated value.\\n     *  @param _key The key of the tree.\\n     *  @param _ID The ID of the value.\\n     *  @return The associated value.\\n     */\\n    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) public view returns(uint value) {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\\n\\n        if (treeIndex == 0) value = 0;\\n        else value = tree.nodes[treeIndex];\\n    }\\n\\n    /* Private */\\n\\n    /**\\n     *  @dev Update all the parents of a node.\\n     *  @param _key The key of the tree to update.\\n     *  @param _treeIndex The index of the node to start from.\\n     *  @param _plusOrMinus Wether to add (true) or substract (false).\\n     *  @param _value The value to add or substract.\\n     *  `O(log_k(n))` where\\n     *  `k` is the maximum number of childs per node in the tree,\\n     *   and `n` is the maximum number of nodes ever appended.\\n     */\\n    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n\\n        uint parentIndex = _treeIndex;\\n        while (parentIndex != 0) {\\n            parentIndex = (parentIndex - 1) / tree.K;\\n            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;\\n        }\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalAmountWin\",\"type\":\"uint256\"}],\"name\":\"EventWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationDateTime\",\"type\":\"uint256\"}],\"name\":\"PotEventCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ticketCount\",\"type\":\"uint256\"}],\"name\":\"TicketBought\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"potEventId\",\"type\":\"bytes32\"}],\"name\":\"buyEntry\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"potEventId\",\"type\":\"uint256\"}],\"name\":\"checkEventIfExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"potEventId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTicketThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createPotEntry\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"potEventId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"potDraws\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"netPrize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"drawn\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"potEntries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"potEventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTicketThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationDateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTicketCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"potEventId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"refundTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"potEventId\",\"type\":\"uint256\"}],\"name\":\"selectWinner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PotLuck","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"SortitionSumTreeFactory:d19a6e8cfde3cb759f1c06358a6ecf11a08dc0eb","LicenseType":"None","SwarmSource":"bzzr://07af1b72cb26b4879096aad08470a643e29da7a9ece497ea70453830473a8293"}]}