{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.2;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\r\n * `CREATE2` can be used to compute in advance the address where a smart\r\n * contract will be deployed, which allows for interesting new mechanisms known\r\n * as 'counterfactual interactions'.\r\n *\r\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\r\n * information.\r\n *\r\n * _Available since v2.5.0._\r\n */\r\nlibrary Create2 {\r\n    /**\r\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\r\n     * will be deployed can be known in advance via {computeAddress}. Note that\r\n     * a contract cannot be deployed twice using the same salt.\r\n     */\r\n    function deploy(bytes32 salt, bytes memory bytecode) internal returns (address) {\r\n        address addr;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\r\n        }\r\n        require(addr != address(0), \"Create2: Failed on deploy\");\r\n        return addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the `bytecode`\r\n     * or `salt` will result in a new destination address.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes memory bytecode) internal view returns (address) {\r\n        return computeAddress(salt, bytecode, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\r\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes memory bytecode, address deployer) internal pure returns (address) {\r\n        return computeAddress(salt, keccak256(bytecode), deployer);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\r\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\r\n        bytes32 _data = keccak256(\r\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\r\n        );\r\n        return address(bytes20(_data << 96));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * NOTE: This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n/**\r\n * A nonce store stores nonces\r\n */\r\ninterface IReplayProtectionAuthority {\r\n    /**\r\n     * Update a nonce in the store.\r\n     * It should update nonce for msg.sender.\r\n     * Must return TRUE or revert/false.\r\n     */\r\n    function update(bytes calldata nonce) external returns (bool);\r\n\r\n    /**\r\n     * Update a nonce in the store.\r\n     * It should update nonce for H(msg.sender || target).\r\n     * Must return TRUE or revert/false.\r\n     */\r\n    function updateFor(address target, bytes calldata nonce) external returns (bool);\r\n\r\n}\r\n\r\ncontract ReplayProtection {\r\n    mapping(bytes32 => uint256) public nonceStore;\r\n\r\n    /**\r\n     * Get Ethereum Chain ID\r\n     **/\r\n    function getChainID() public pure returns(uint) {\r\n        // Fetch chainId\r\n        uint256 chainId;\r\n        assembly {chainId := chainid() }\r\n        return chainId;\r\n    }\r\n\r\n    /**\r\n     * Checks the signer's replay protection and returns the signer's address.\r\n     * Reverts if fails.\r\n     *\r\n     * Why is there no signing authority? An attacker can supply an address that returns a fixed signer\r\n     * so we need to restrict it to a \"pre-approved\" list of authorities (DAO).\r\n\r\n     * @param _callData Function name and data to be called\r\n     * @param _replayProtectionAuthority What replay protection will we check?\r\n     * @param _replayProtection Encoded replay protection\r\n     * @param _signature Signer's signature\r\n     */\r\n    function verify(bytes memory _callData,\r\n        bytes memory _replayProtection,\r\n        address _replayProtectionAuthority,\r\n        bytes memory _signature) internal returns(address){\r\n\r\n        // Extract signer's address.\r\n        address signer = verifySig(_callData, _replayProtection, _replayProtectionAuthority, getChainID(), _signature);\r\n\r\n        // Check the user's replay protection.\r\n        if(_replayProtectionAuthority == address(0x0000000000000000000000000000000000000000)) {\r\n            // Assumes authority returns true or false. It may also revert.\r\n            require(nonce(signer, _replayProtection), \"Multinonce replay protection failed\");\r\n        } else if (_replayProtectionAuthority == address(0x0000000000000000000000000000000000000001)) {\r\n            require(bitflip(signer, _replayProtection), \"Bitflip replay protection failed\");\r\n        } else {\r\n            require(IReplayProtectionAuthority(_replayProtectionAuthority).updateFor(signer, _replayProtection), \"Replay protection from authority failed\");\r\n        }\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * Verify signature on the calldata and replay protection.\r\n     * @param _callData Contains target contract, value and function data.\r\n     * @param _replayProtection Contains the replay protection nonces.\r\n     * @param _replayProtectionAuthority Address to an external (or internal) relay protection mechanism.\r\n     */\r\n    function verifySig(bytes memory _callData,\r\n        bytes memory _replayProtection,\r\n        address _replayProtectionAuthority, uint chainId, bytes memory _signature) public view returns (address) {\r\n        bytes memory encodedData = abi.encode(_callData, _replayProtection, _replayProtectionAuthority, address(this), chainId);\r\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(encodedData)), _signature);\r\n    }\r\n\r\n    /**\r\n     * MultiNonce replay protection.\r\n     * Explained: https://github.com/PISAresearch/metamask-comp#multinonce\r\n     * Allows a user to send N queues of transactions, but transactions in each queue are accepted in order.\r\n     * If nonce1==0, then it is the same as replace-by-version (e.g. increment nonce each time).\r\n     * @param _replayProtection Contains a single nonce\r\n     */\r\n    function nonce(address _signer, bytes memory _replayProtection) internal returns(bool) {\r\n        uint256 nonce1;\r\n        uint256 nonce2;\r\n\r\n        (nonce1, nonce2) = abi.decode(_replayProtection, (uint256, uint256));\r\n        bytes32 index = keccak256(abi.encode(_signer, nonce1));\r\n        uint256 storedNonce = nonceStore[index];\r\n\r\n        // Increment stored nonce by one...\r\n        if(nonce2 == storedNonce) {\r\n            nonceStore[index] = storedNonce + 1;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Bitflip Replay Protection\r\n     * Explained: https://github.com/PISAresearch/metamask-comp#bitflip\r\n     * Allows a user to flip a bit in nonce2 as replay protection. Every nonce supports 256 bit flips.\r\n     */\r\n    function bitflip(address _signer, bytes memory _replayProtection) internal returns(bool) {\r\n        (uint256 nonce1, uint256 bitsToFlip) = abi.decode(_replayProtection, (uint256, uint256));\r\n\r\n        // It is unlikely that anyone will need to send 6174 concurrent transactions per block,\r\n        // plus 6174 is a cool af number.\r\n        require(nonce1 >= 6174, \"Nonce1 must be at least 6174 to separate multinonce and bitflip\");\r\n\r\n        // Combine with msg.sender to get unique indexes per caller\r\n        bytes32 senderIndex = keccak256(abi.encodePacked(_signer, nonce1));\r\n        uint256 currentBitmap = nonceStore[senderIndex];\r\n        require(currentBitmap & bitsToFlip != bitsToFlip, \"Bit already flipped.\");\r\n        nonceStore[senderIndex] = currentBitmap | bitsToFlip;\r\n    }\r\n}\r\n\r\n/**\r\n * We deploy a new contract to bypass the msg.sender problem.\r\n */\r\ncontract ProxyAccount is ReplayProtection {\r\n\r\n    address owner;\r\n    event Deployed(address owner, address addr);\r\n\r\n    /**\r\n     * Due to create clone, we need to use an init() method.\r\n     */\r\n    function init(address _owner) public {\r\n        require(owner == address(0), \"Signer is already set\");\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n     * Each signer has a proxy account (signers address => contract address).\r\n     * We check the signer has authorised the target contract and function call. Then, we pass it to the\r\n     * signer's proxy account to perform the final execution (to help us bypass msg.sender problem).\r\n     * @param _target Target contract\r\n     * @param _value Quantity of eth in account contract to send to target\r\n     * @param _callData Function name plus arguments\r\n     * @param _replayProtection Replay protection (e.g. multinonce)\r\n     * @param _replayProtectionAuthority Identify the Replay protection, default is address(0)\r\n     * @param _signature Signature from signer\r\n     */\r\n    function forward(\r\n        address _target,\r\n        uint _value, \r\n        bytes memory _callData,\r\n        bytes memory _replayProtection,\r\n        address _replayProtectionAuthority,\r\n        bytes memory _signature) public {\r\n\r\n        // Assumes that ProxyHub is ReplayProtection. \r\n        bytes memory encodedData = abi.encode(_target, _value, _callData);\r\n\r\n        // // Reverts if fails.\r\n        require(owner == verify(encodedData, _replayProtection, _replayProtectionAuthority, _signature));\r\n\r\n        // No need to check _target account since it will jump into the signer's proxy account first.\r\n        // e.g. we can never perform a .call() from ProxyHub directly.\r\n        (bool success,) = _target.call.value(_value)(abi.encodePacked(_callData));\r\n        require(success, \"Forwarding call failed.\");\r\n    }\r\n\r\n    /**\r\n     * User deploys a contract in a deterministic manner.\r\n     * It re-uses the replay protection to authorise deployment as part of the salt.\r\n     * @param _initCode Initialisation code for contract\r\n     * @param _replayProtectionAuthority Identify the Replay protection, default is address(0)\r\n     * @param _signature Signature from signer\r\n     */\r\n    function deployContract(\r\n        bytes memory _initCode,\r\n        bytes memory _replayProtection,\r\n        address _replayProtectionAuthority,\r\n        bytes memory _signature) public {\r\n\r\n        // Confirm the user wants to deploy the smart contract\r\n        require(owner == verify(_initCode, _replayProtection, _replayProtectionAuthority, _signature), \"Owner of proxy account must authorise deploying contract\");\r\n\r\n        // We can just abuse the replay protection as the salt :)\r\n        address deployed = Create2.deploy(keccak256(abi.encode(owner, _replayProtection)), _initCode);\r\n\r\n        emit Deployed(owner, deployed);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\r\n     * `bytecodeHash` or `salt` will result in a new destination address.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) public view returns (address) {\r\n        bytes32 _data = keccak256(\r\n            abi.encodePacked(bytes1(0xff), address(this), salt, bytecodeHash)\r\n        );\r\n        return address(bytes20(_data << 96));\r\n    }\r\n\r\n    /**\r\n     * Receives ETH\r\n     */\r\n    receive() external payable {}\r\n}\r\n\r\n\r\n/**\r\n * A minimal relay hub contract.\r\n * Verifies the signer's signature and replay protection before forwarding calldata to the target.\r\n * Delegates nonce verification to another contract.\r\n */\r\ncontract ProxyHub is ReplayProtection {\r\n\r\n    // TOOD:We can remove map once we can deterministically compute\r\n    // address and verify that it exists on-chain.\r\n    mapping(address => address payable) public accounts;\r\n    address payable public baseAccount;\r\n\r\n    /**\r\n     * Creates base Account for contracts\r\n     */\r\n    constructor() public {\r\n        baseAccount = address(new ProxyAccount());\r\n        ProxyAccount(baseAccount).init(address(this));\r\n    }\r\n\r\n    /**\r\n     * User can sign a message to authorise creating an account.\r\n     * There is only \"one type\" of account - does not really matter if signer authorised it.\r\n     * @param _signer User's signing key\r\n     */\r\n    function createProxyAccount(address _signer) public {\r\n        require(accounts[_signer] == address(0), \"Cannot install more than one account per signer\");\r\n        bytes32 salt = keccak256(abi.encodePacked(_signer));\r\n        address payable clone = createClone(salt);\r\n        accounts[_signer] = clone;\r\n        // Initialize it with signer's address\r\n        ProxyAccount(clone).init(_signer);\r\n    }\r\n\r\n    /**\r\n     * Modified https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol#L30\r\n     * to support Create2.\r\n     * @param _salt Salt for CREATE2\r\n     */\r\n    function createClone(bytes32 _salt) internal returns (address payable result) {\r\n        bytes20 targetBytes = bytes20(baseAccount);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create2(0, clone, 0x37, _salt)\r\n        }\r\n        return result;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAccount\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"createProxyAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nonceStore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_replayProtection\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_replayProtectionAuthority\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"verifySig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProxyHub","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://da408f7800da625f9a6f41e45425f03d38395cf842b5c46d2cd48599241628b1"}]}