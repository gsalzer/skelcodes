{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\n\ncontract IGetImplementation {\n    function implementation()\n    public\n    view\n    returns (address);\n}\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeyCampaign {\n\n    function getNumberOfUsersToContractor(\n        address _user\n    )\n    public\n    view\n    returns (uint);\n\n    function getReceivedFrom(\n        address _receiver\n    )\n    public\n    view\n    returns (address);\n\n    function balanceOf(\n        address _owner\n    )\n    public\n    view\n    returns (uint256);\n\n    function getReferrerCut(\n        address me\n    )\n    public\n    view\n    returns (uint256);\n\n    function getReferrerPlasmaBalance(\n        address _influencer\n    )\n    public\n    view\n    returns (uint);\n\n    function updateReferrerPlasmaBalance(\n        address _influencer,\n        uint _balance\n    )\n    public;\n\n    function updateModeratorRewards(\n        uint moderatorTokens\n    )\n    public;\n\n    address public logicHandler;\n    address public conversionHandler;\n\n}\n\ncontract ITwoKeyCampaignPublicAddresses {\n    address public twoKeySingletonesRegistry;\n    address public contractor; //contractor address\n    address public moderator; //moderator address\n    function publicLinkKeyOf(address me) public view returns (address);\n}\n\ncontract ITwoKeyConversionHandler {\n\n    bool public isFiatConversionAutomaticallyApproved;\n    address public twoKeyPurchasesHandler;\n\n    function supportForCreateConversion(\n        address _converterAddress,\n        uint256 _conversionAmount,\n        uint256 _maxReferralRewardETHWei,\n        bool isConversionFiat,\n        bool _isAnonymous,\n        uint conversionAmountCampaignCurrency\n    )\n    public\n    returns (uint);\n\n    function executeConversion(\n        uint _conversionId\n    )\n    public;\n\n\n    function getConverterConversionIds(\n        address _converter\n    )\n    external\n    view\n    returns (uint[]);\n\n\n    function getConverterPurchasesStats(\n        address _converter\n    )\n    public\n    view\n    returns (uint,uint,uint);\n\n\n    function getStateForConverter(\n        address _converter\n    )\n    public\n    view\n    returns (bytes32);\n\n    function getMainCampaignContractAddress()\n    public\n    view\n    returns (address);\n\n}\n\ncontract ITwoKeyDonationCampaign {\n    address public logicHandler;\n    function buyTokensForModeratorRewards(\n        uint moderatorFee\n    )\n    public;\n\n    function buyTokensAndDistributeReferrerRewards(\n        uint256 _maxReferralRewardETHWei,\n        address _converter,\n        uint _conversionId\n    )\n    public\n    returns (uint);\n\n    function updateReferrerPlasmaBalance(address _influencer, uint _balance) public;\n    function updateContractorProceeds(uint value) public;\n    function sendBackEthWhenConversionCancelledOrRejected(address _cancelledConverter, uint _conversionAmount) public;\n}\n\ncontract ITwoKeyDonationCampaignFetchAddresses {\n    address public twoKeyDonationConversionHandler;\n    address public twoKeyDonationCampaign;\n}\n\ncontract ITwoKeyEventSourceEvents {\n    // This 2 functions will be always in the interface since we need them very often\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n\n    function created(\n        address _campaign,\n        address _owner,\n        address _moderator\n    )\n    external;\n\n    function rewarded(\n        address _campaign,\n        address _to,\n        uint256 _amount\n    )\n    external;\n\n    function acquisitionCampaignCreated(\n        address proxyLogicHandler,\n        address proxyConversionHandler,\n        address proxyAcquisitionCampaign,\n        address proxyPurchasesHandler,\n        address contractor\n    )\n    external;\n\n    function donationCampaignCreated(\n        address proxyDonationCampaign,\n        address proxyDonationConversionHandler,\n        address proxyDonationLogicHandler,\n        address contractor\n    )\n    external;\n\n    function priceUpdated(\n        bytes32 _currency,\n        uint newRate,\n        uint _timestamp,\n        address _updater\n    )\n    external;\n\n    function userRegistered(\n        string _name,\n        address _address,\n        string _fullName,\n        string _email,\n        string _username_walletName\n    )\n    external;\n\n    function cpcCampaignCreated(\n        address proxyCPC,\n        address contractor\n    )\n    external;\n\n\n    function emitHandleChangedEvent(\n        address _userPlasmaAddress,\n        string _newHandle\n    )\n    public;\n\n\n}\n\ncontract ITwoKeyMaintainersRegistry {\n    function checkIsAddressMaintainer(address _sender) public view returns (bool);\n    function checkIsAddressCoreDev(address _sender) public view returns (bool);\n\n    function addMaintainers(address [] _maintainers) public;\n    function addCoreDevs(address [] _coreDevs) public;\n    function removeMaintainers(address [] _maintainers) public;\n    function removeCoreDevs(address [] _coreDevs) public;\n}\n\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestCampaignApprovedVersion(string campaignType) public view returns (string);\n}\n\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    * @param contractName is the name of the contract we added new version\n    */\n    event VersionAdded(string version, address implementation, string contractName);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract ITwoKeyCampaignValidatorStorage is IStructuredStorage {\n\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getContractProxyAddress(contractName);\n    }\n\n    function getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getNonUpgradableContractAddress(contractName);\n    }\n}\n\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\ncontract TwoKeyCampaignValidator is Upgradeable, ITwoKeySingletonUtils {\n\n    /**\n     * Storage keys are stored on the top. Here they are in order to avoid any typos\n     */\n    string constant _isCampaignValidated = \"isCampaignValidated\";\n    string constant _campaign2NonSingletonHash = \"campaign2NonSingletonHash\";\n\n    /**\n     * Keys for the addresses we're accessing\n     */\n    string constant _twoKeyFactory = \"TwoKeyFactory\";\n    string constant _twoKeyEventSource = \"TwoKeyEventSource\";\n\n\n    bool initialized;\n\n    // Pointer to the PROXY storage contract\n    ITwoKeyCampaignValidatorStorage public PROXY_STORAGE_CONTRACT;\n\n    /**\n     * @notice Function to set initial parameters in this contract\n     * @param _twoKeySingletoneRegistry is the address of TwoKeySingletoneRegistry contract\n     * @param _proxyStorage is the address of proxy of storage contract\n     */\n    function setInitialParams(\n        address _twoKeySingletoneRegistry,\n        address _proxyStorage\n    )\n    public\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletoneRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyCampaignValidatorStorage(_proxyStorage);\n\n        initialized = true;\n    }\n\n    // Modifier which will make function throw if caller is not TwoKeyFactory proxy contract\n    modifier onlyTwoKeyFactory {\n        address twoKeyFactory = getAddressFromTwoKeySingletonRegistry(_twoKeyFactory);\n        require(msg.sender == twoKeyFactory);\n        _;\n    }\n\n    /**\n     * @notice Function which will make newly created campaign validated\n     * @param campaign is the address of the campaign\n     * @param nonSingletonHash is the non singleton hash at the moment of campaign creation\n     */\n    function validateAcquisitionCampaign(\n        address campaign,\n        string nonSingletonHash\n    )\n    public\n    onlyTwoKeyFactory\n    {\n        address conversionHandler = ITwoKeyCampaign(campaign).conversionHandler();\n        address logicHandler = ITwoKeyCampaign(campaign).logicHandler();\n        address purchasesHandler = ITwoKeyConversionHandler(conversionHandler).twoKeyPurchasesHandler();\n\n        //Whitelist all campaign associated contracts\n        PROXY_STORAGE_CONTRACT.setBool(keccak256(_isCampaignValidated, conversionHandler), true);\n        PROXY_STORAGE_CONTRACT.setBool(keccak256(_isCampaignValidated, logicHandler), true);\n        PROXY_STORAGE_CONTRACT.setBool(keccak256(_isCampaignValidated, purchasesHandler), true);\n        PROXY_STORAGE_CONTRACT.setBool(keccak256(_isCampaignValidated,campaign), true);\n        PROXY_STORAGE_CONTRACT.setString(keccak256(_campaign2NonSingletonHash,campaign), nonSingletonHash);\n\n        emitCreatedEvent(campaign);\n    }\n\n    /**\n     * @notice Function which will make newly created campaign validated\n     * @param campaign is the campaign address\n     * @dev Validates all the required stuff, if the campaign is not validated, it can't update our singletones\n     */\n    function validateDonationCampaign(\n        address campaign,\n        address donationConversionHandler,\n        address donationLogicHandler,\n        string nonSingletonHash\n    )\n    public\n    onlyTwoKeyFactory\n    {\n        PROXY_STORAGE_CONTRACT.setBool(keccak256(_isCampaignValidated,campaign), true);\n        PROXY_STORAGE_CONTRACT.setBool(keccak256(_isCampaignValidated,donationConversionHandler), true);\n        PROXY_STORAGE_CONTRACT.setBool(keccak256(_isCampaignValidated,donationLogicHandler), true);\n\n        PROXY_STORAGE_CONTRACT.setString(keccak256(_campaign2NonSingletonHash,campaign), nonSingletonHash);\n\n        emitCreatedEvent(campaign);\n    }\n\n    function validateCPCCampaign(\n        address campaign,\n        string nonSingletonHash\n    )\n    public\n    onlyTwoKeyFactory\n    {\n        PROXY_STORAGE_CONTRACT.setBool(keccak256(_isCampaignValidated,campaign), true);\n        PROXY_STORAGE_CONTRACT.setString(keccak256(_campaign2NonSingletonHash,campaign), nonSingletonHash);\n\n        //Emit event that is created with moderator contractor and campaign address\n        emitCreatedEvent(campaign);\n    }\n\n\n    /**\n     * @notice Function which will return either is or not one of the campaign contracts validated\n     * @param campaign is any contract deployed during any campaign creation through TwoKeyFactory\n     */\n    function isCampaignValidated(address campaign) public view returns (bool) {\n        bytes32 hashKey = keccak256(_isCampaignValidated, campaign);\n        return PROXY_STORAGE_CONTRACT.getBool(hashKey);\n    }\n\n    /**\n     * @notice Function which is serving as getter for non-singleton hash at the time of campaign creation\n     * @param campaign is the address of strictly main campaign contract (TwoKeyAcquisitionCampaignERC20, TwoKeyDonationCampaign for now)\n     */\n    function campaign2NonSingletonHash(address campaign) public view returns (string) {\n        return PROXY_STORAGE_CONTRACT.getString(keccak256(_campaign2NonSingletonHash, campaign));\n    }\n\n    /**\n     * @notice Function to emit event on TwoKeyEventSource contract\n     */\n    function emitCreatedEvent(address campaign) internal {\n        address contractor = ITwoKeyCampaignPublicAddresses(campaign).contractor();\n        address moderator = ITwoKeyCampaignPublicAddresses(campaign).moderator();\n\n        //Get the event source address\n        address twoKeyEventSource = getAddressFromTwoKeySingletonRegistry(_twoKeyEventSource);\n        // Emit event\n        ITwoKeyEventSourceEvents(twoKeyEventSource).created(campaign,contractor,moderator);\n    }\n}\n\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_twoKeySingletoneRegistry\",\"type\":\"address\"},{\"name\":\"_proxyStorage\",\"type\":\"address\"}],\"name\":\"setInitialParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_STORAGE_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"campaign\",\"type\":\"address\"},{\"name\":\"nonSingletonHash\",\"type\":\"string\"}],\"name\":\"validateCPCCampaign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaign\",\"type\":\"address\"}],\"name\":\"isCampaignValidated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_KEY_SINGLETON_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaign\",\"type\":\"address\"}],\"name\":\"campaign2NonSingletonHash\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"campaign\",\"type\":\"address\"},{\"name\":\"donationConversionHandler\",\"type\":\"address\"},{\"name\":\"donationLogicHandler\",\"type\":\"address\"},{\"name\":\"nonSingletonHash\",\"type\":\"string\"}],\"name\":\"validateDonationCampaign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"campaign\",\"type\":\"address\"},{\"name\":\"nonSingletonHash\",\"type\":\"string\"}],\"name\":\"validateAcquisitionCampaign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TwoKeyCampaignValidator","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}