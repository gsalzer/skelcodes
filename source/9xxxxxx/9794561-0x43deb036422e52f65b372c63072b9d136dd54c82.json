{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract CommonConstants {\r\n    bytes4 constant internal ERC1155_ACCEPTED = 0xf23a6e61; \r\n    bytes4 constant internal ERC1155_BATCH_ACCEPTED = 0xbc197c81; \r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface ERC1155TokenReceiver {\r\n\r\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\r\n\r\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface ERC165 {\r\n\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IERC1155 /* is ERC165 */ {\r\n\r\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\r\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    event URI(string _value, uint256 indexed _id);\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\r\n\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\r\n\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract ERC1155Base is IERC1155, ERC165, CommonConstants\r\n{\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (uint256 => mapping(address => uint256)) internal balances; // id => (owner => balance)\r\n    mapping (address => mapping(address => bool)) internal operatorApproval; // owner => (operator => approved)\r\n\r\n/////////////////////////////////////////// ERC165 //////////////////////////////////////////////\r\n\r\n    bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\r\n    bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\r\n\r\n    function supportsInterface(bytes4 _interfaceId)\r\n    public\r\n    view\r\n    returns (bool) {\r\n         if (_interfaceId == INTERFACE_SIGNATURE_ERC165 ||\r\n             _interfaceId == INTERFACE_SIGNATURE_ERC1155) {\r\n            return true;\r\n         }\r\n\r\n         return false;\r\n    }\r\n\r\n/////////////////////////////////////////// ERC1155 //////////////////////////////////////////////\r\n\r\n\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\r\n\r\n        require(_to != address(0x0), \"_to must be non-zero.\");\r\n        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\r\n        balances[_id][_from] = balances[_id][_from].sub(_value);\r\n        balances[_id][_to]   = _value.add(balances[_id][_to]);\r\n\r\n        emit TransferSingle(msg.sender, _from, _to, _id, _value);\r\n\r\n        if (_to.isContract()) {\r\n            _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, _value, _data);\r\n        }\r\n    }\r\n\r\n\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\r\n        require(_to != address(0x0), \"destination address must be non-zero.\");\r\n        require(_ids.length == _values.length, \"_ids and _values array length must match.\");\r\n        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\r\n\r\n        for (uint256 i = 0; i < _ids.length; ++i) {\r\n            uint256 id = _ids[i];\r\n            uint256 value = _values[i];\r\n            balances[id][_from] = balances[id][_from].sub(value);\r\n            balances[id][_to]   = value.add(balances[id][_to]);\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, _from, _to, _ids, _values);\r\n\r\n        if (_to.isContract()) {\r\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, _from, _to, _ids, _values, _data);\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\r\n        return balances[_id][_owner];\r\n    }\r\n\r\n\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {\r\n        require(_owners.length == _ids.length);\r\n        uint256[] memory balances_ = new uint256[](_owners.length);\r\n        for (uint256 i = 0; i < _owners.length; ++i) {\r\n            balances_[i] = balances[_ids[i]][_owners[i]];\r\n        }\r\n        return balances_;\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        operatorApproval[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return operatorApproval[_owner][_operator];\r\n    }\r\n\r\n/////////////////////////////////////////// Internal //////////////////////////////////////////////\r\n\r\n    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {\r\n        require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, \"contract returned an unknown value from onERC1155Received\");\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {\r\n        require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _values, _data) == ERC1155_BATCH_ACCEPTED, \"contract returned an unknown value from onERC1155BatchReceived\");\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract ERC1155MixedFungible is ERC1155Base {\r\n\r\n    uint256 constant TYPE_MASK = uint256(uint128(~0)) << 128;\r\n    uint256 constant NF_INDEX_MASK = uint128(~0);\r\n    uint256 constant TYPE_NF_BIT = 1 << 255;\r\n    mapping (uint256 => address) nfOwners;\r\n\r\n    function isNonFungible(uint256 _id) public pure returns(bool) {\r\n        return _id & TYPE_NF_BIT == TYPE_NF_BIT;\r\n    }\r\n    function isFungible(uint256 _id) public pure returns(bool) {\r\n        return _id & TYPE_NF_BIT == 0;\r\n    }\r\n    function getNonFungibleIndex(uint256 _id) public pure returns(uint256) {\r\n        return _id & NF_INDEX_MASK;\r\n    }\r\n    function getNonFungibleBaseType(uint256 _id) public pure returns(uint256) {\r\n        return _id & TYPE_MASK;\r\n    }\r\n    function isNonFungibleBaseType(uint256 _id) public pure returns(bool) {\r\n        // A base type has the NF bit but does not have an index.\r\n        return (_id & TYPE_NF_BIT == TYPE_NF_BIT) && (_id & NF_INDEX_MASK == 0);\r\n    }\r\n    function isNonFungibleItem(uint256 _id) public pure returns(bool) {\r\n        // A base type has the NF bit but does has an index.\r\n        return (_id & TYPE_NF_BIT == TYPE_NF_BIT) && (_id & NF_INDEX_MASK != 0);\r\n    }\r\n    function ownerOf(uint256 _id) public view returns (address) {\r\n        return nfOwners[_id];\r\n    }\r\n\r\n    // override\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\r\n\r\n        require(_to != address(0x0), \"cannot send to zero address\");\r\n        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\r\n\r\n        if (isNonFungible(_id)) {\r\n            require(nfOwners[_id] == _from);\r\n            nfOwners[_id] = _to;\r\n            // You could keep balance of NF type in base type id like so:\r\n            uint256 baseType = getNonFungibleBaseType(_id);\r\n            balances[baseType][_from] = balances[baseType][_from].sub(_value);\r\n            balances[baseType][_to]   = balances[baseType][_to].add(_value);\r\n        } else {\r\n            balances[_id][_from] = balances[_id][_from].sub(_value);\r\n            balances[_id][_to]   = balances[_id][_to].add(_value);\r\n        }\r\n\r\n        emit TransferSingle(msg.sender, _from, _to, _id, _value);\r\n\r\n        if (_to.isContract()) {\r\n            _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, _value, _data);\r\n        }\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n      address _from, \r\n      address _to, \r\n      uint256[] calldata _ids, \r\n      uint256[] calldata _values, \r\n      bytes calldata _data\r\n    ) external {\r\n        require(_to != address(0x0), \"cannot send to zero address\");\r\n        require(_ids.length == _values.length, \"Array length must match\");\r\n        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\");\r\n\r\n        for (uint256 i = 0; i < _ids.length; ++i) {\r\n            uint256 id = _ids[i];\r\n            uint256 value = _values[i];\r\n            if (isNonFungible(id)) {\r\n                require(nfOwners[id] == _from);\r\n                nfOwners[id] = _to;\r\n                balances[getNonFungibleBaseType(id)][_from] = balances[getNonFungibleBaseType(id)][_from].sub(value);\r\n                balances[getNonFungibleBaseType(id)][_to]   = balances[getNonFungibleBaseType(id)][_to].add(value);\r\n            } else {\r\n                balances[id][_from] = balances[id][_from].sub(value);\r\n                balances[id][_to]   = value.add(balances[id][_to]);\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, _from, _to, _ids, _values);\r\n\r\n        if (_to.isContract()) {\r\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, _from, _to, _ids, _values, _data);\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\r\n        if (isNonFungibleItem(_id))\r\n            return nfOwners[_id] == _owner ? 1 : 0;\r\n        return balances[_id][_owner];\r\n    }\r\n\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {\r\n        require(_owners.length == _ids.length);\r\n        uint256[] memory balances_ = new uint256[](_owners.length);\r\n        for (uint256 i = 0; i < _owners.length; ++i) {\r\n            uint256 id = _ids[i];\r\n            if (isNonFungibleItem(id)) {\r\n                balances_[i] = nfOwners[id] == _owners[i] ? 1 : 0;\r\n            } else {\r\n            \tbalances_[i] = balances[id][_owners[i]];\r\n            }\r\n        }\r\n\r\n        return balances_;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract Elevate is ERC1155MixedFungible {\r\n\r\n    address public owner;\r\n    uint256 nonce;\r\n    mapping (uint256 => uint256) public maxIndex;\r\n    mapping (address => bool) public creators;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) allowances;\r\n    mapping(uint256 => uint256) public tokenSupply;\r\n    mapping(uint256 => uint256) public tokenSupplyLimit;\r\n\r\n\r\n    modifier creatorOnly() {\r\n        require(creators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n      owner = msg.sender;\r\n      creators[msg.sender] = true;\r\n    }\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 indexed _id, uint256 _oldValue, uint256 _value);\r\n    event SupplyLimit(uint256 indexed _id, uint256 _supplyLimit);\r\n\r\n    function create(\r\n        string calldata _uri,\r\n        bool   _isNF\r\n    ) external creatorOnly returns(uint256 _type) {\r\n        _type = (++nonce << 128);\r\n\r\n        if (_isNF)\r\n          _type = _type | TYPE_NF_BIT;\r\n\r\n\r\n        emit TransferSingle(msg.sender, address(0x0), address(0x0), _type, 0);\r\n\r\n        if (bytes(_uri).length > 0)\r\n            emit URI(_uri, _type);\r\n        return _type;\r\n    }\r\n\r\n    function setSupplyLimit(uint256 _typeOrId, uint256 _supplyLimit) external creatorOnly {\r\n      require(_supplyLimit > 0);\r\n      if(isNonFungibleItem(_typeOrId)) {\r\n        uint256 typeId = getNonFungibleBaseType(_typeOrId);\r\n        tokenSupplyLimit[typeId] = _supplyLimit;\r\n        emit SupplyLimit(typeId, _supplyLimit);\r\n      } else {\r\n        tokenSupplyLimit[_typeOrId] = _supplyLimit;\r\n        emit SupplyLimit(_typeOrId, _supplyLimit);\r\n      }\r\n    }\r\n\r\n    function mintNonFungible(uint256 _type, address[] calldata _to) external creatorOnly {\r\n        require(isNonFungible(_type));\r\n        uint256 index = maxIndex[_type] + 1;\r\n        maxIndex[_type] = _to.length.add(maxIndex[_type]);\r\n        for (uint256 i = 0; i < _to.length; ++i) {\r\n            address distributeTo = _to[i];\r\n            uint256 id  = _type | index + i;\r\n            require(tokenSupplyLimit[_type] == 0 || tokenSupply[_type].add(1) <= tokenSupplyLimit[_type], \"Token supply limit exceeded\");\r\n            nfOwners[id] = distributeTo;\r\n            tokenSupply[_type] = tokenSupply[_type].add(1);\r\n            balances[_type][distributeTo] = balances[_type][distributeTo].add(1);\r\n\r\n            emit TransferSingle(msg.sender, address(0x0), distributeTo, id, 1);\r\n\r\n            if (distributeTo.isContract()) {\r\n                _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, distributeTo, id, 1, '');\r\n            }\r\n        }\r\n    }\r\n\r\n    function mintFungible(uint256 _id, address[] calldata _to, uint256[] calldata _quantities) external creatorOnly {\r\n        require(isFungible(_id));\r\n        for (uint256 i = 0; i < _to.length; ++i) {\r\n            address to = _to[i];\r\n            uint256 quantity = _quantities[i];\r\n            require(tokenSupplyLimit[_id] == 0 || tokenSupply[_id].add(quantity) <= tokenSupplyLimit[_id], \"Token supply limit exceeded\");\r\n            balances[_id][to] = quantity.add(balances[_id][to]);\r\n            tokenSupply[_id] = tokenSupply[_id].add(quantity);\r\n\r\n            emit TransferSingle(msg.sender, address(0x0), to, _id, quantity);\r\n\r\n            if (to.isContract()) {\r\n                _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, to, _id, quantity, '');\r\n            }\r\n        }\r\n    }\r\n\r\n    function atomicSwap(\r\n      address _addressPartyA, \r\n      address _addressPartyB, \r\n      uint256[] calldata _idsPartyA, \r\n      uint256[] calldata _idsPartyB,\r\n      uint256[] calldata _valuesPartyA,\r\n      uint256[] calldata _valuesPartyB\r\n    ) external {\r\n      require(_addressPartyA != address(0x0), \"cannot send to zero address\");\r\n      require(_addressPartyB != address(0x0), \"cannot send to zero address\");\r\n      require(_idsPartyA.length == _valuesPartyA.length, \"Array length must match\");\r\n      require(_idsPartyB.length == _valuesPartyB.length, \"Array length must match\");\r\n\r\n      // Transfer party A tokens to party B\r\n      for (uint256 i = 0; i < _idsPartyA.length; ++i) {\r\n        require(allowances[_addressPartyA][msg.sender][_idsPartyA[i]] == _valuesPartyA[i]);\r\n        if(isFungible(_idsPartyA[i])) {\r\n          uint256 id = _idsPartyA[i];\r\n          balances[id][_addressPartyB] = balances[id][_addressPartyB].add(_valuesPartyA[i]);\r\n          balances[id][_addressPartyA] = balances[id][_addressPartyA].sub(_valuesPartyA[i]);\r\n        } else {\r\n          uint256 baseType = getNonFungibleBaseType(_idsPartyA[i]);\r\n          nfOwners[_idsPartyA[i]] = _addressPartyB;\r\n          balances[baseType][_addressPartyB] = balances[baseType][_addressPartyB].add(_valuesPartyA[i]);\r\n          balances[baseType][_addressPartyA] = balances[baseType][_addressPartyA].sub(_valuesPartyA[i]);\r\n        }\r\n        allowances[_addressPartyA][msg.sender][_idsPartyA[i]] = allowances[_addressPartyA][msg.sender][_idsPartyA[i]].sub(_valuesPartyA[i]);\r\n        if (_addressPartyA.isContract()) {\r\n            _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, _addressPartyA, _idsPartyA[i], _valuesPartyA[i], '');\r\n        }\r\n      }\r\n\r\n      // Transfer party B tokens to party A\r\n      for (uint256 i = 0; i < _idsPartyB.length; ++i) {\r\n        require(allowances[_addressPartyB][msg.sender][_idsPartyB[i]] == _valuesPartyB[i]);\r\n        if(isFungible(_idsPartyB[i])) {\r\n          uint256 id = _idsPartyB[i];\r\n          balances[id][_addressPartyA] = balances[id][_addressPartyA].add(_valuesPartyB[i]);\r\n          balances[id][_addressPartyB] = balances[id][_addressPartyB].sub(_valuesPartyB[i]);\r\n        } else {\r\n          uint256 baseType = getNonFungibleBaseType(_idsPartyB[i]);\r\n          nfOwners[_idsPartyB[i]] = _addressPartyA;\r\n          balances[baseType][_addressPartyA] = balances[baseType][_addressPartyA].add(_valuesPartyB[i]);\r\n          balances[baseType][_addressPartyB] = balances[baseType][_addressPartyB].sub(_valuesPartyB[i]);\r\n        }\r\n        allowances[_addressPartyB][msg.sender][_idsPartyB[i]] = allowances[_addressPartyB][msg.sender][_idsPartyB[i]].sub(_valuesPartyB[i]);\r\n        if (_addressPartyB.isContract()) {\r\n            _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, _addressPartyB, _idsPartyB[i], _valuesPartyB[i], '');\r\n        }\r\n      }\r\n\r\n        emit TransferBatch(msg.sender, _addressPartyA, _addressPartyB, _idsPartyA, _valuesPartyA);\r\n        emit TransferBatch(msg.sender, _addressPartyB, _addressPartyA, _idsPartyB, _valuesPartyB);\r\n      \r\n    }\r\n\r\n    function approveBatch(\r\n      address _spender, \r\n      uint256[] calldata _ids, \r\n      uint256[] calldata _currentValues, \r\n      uint256[] calldata _values\r\n    ) external {\r\n      require(_ids.length == _currentValues.length, \"Arrays must be same length\");\r\n      require(_currentValues.length == _values.length, \"Arrays must be same length\");\r\n      for(uint256 i = 0; i < _values.length; i++) {\r\n        uint256 id = _ids[i];\r\n        uint256 currentValue = _currentValues[i];\r\n        uint256 value = _values[i];\r\n        require(allowances[msg.sender][_spender][id] == currentValue);\r\n        allowances[msg.sender][_spender][id] = value;\r\n        emit Approval(msg.sender, _spender, id, currentValue, value);\r\n      }\r\n    }\r\n    \r\n    function batchAuthorizeCreators(address[] calldata _addresses) external {\r\n      require(msg.sender == owner);\r\n      for (uint256 i = 0; i < _addresses.length; ++i) {\r\n        creators[_addresses[i]] = true;\r\n      }\r\n    }\r\n\r\n    function allowance(address _owner, address _spender, uint256 _id) external view returns (uint256){\r\n        return allowances[_owner][_spender][_id];\r\n    }\r\n\r\n    function burn(address _from, uint256[] calldata _ids, uint256[] calldata _values\r\n    ) external {\r\n      require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party burn.\");\r\n      require(_ids.length > 0 && _ids.length == _values.length);\r\n      for(uint256 i = 0; i < _ids.length; i++) {\r\n        if(isFungible(_ids[i])) {\r\n          require(balances[_ids[i]][_from] >= _values[i]);\r\n          balances[_ids[i]][_from] = balances[_ids[i]][_from].sub(_values[i]);\r\n        } else {\r\n          require(isNonFungible(_ids[i]));\r\n          require(_values[i] == 1);\r\n          uint256 baseType = getNonFungibleBaseType(_ids[i]);\r\n          // --totalSupply? \r\n          balances[baseType][_from] = balances[baseType][_from].sub(1);\r\n          delete nfOwners[_ids[i]];\r\n        }\r\n        emit TransferSingle(msg.sender, _from, address(0x0), _ids[i], _values[i]);\r\n      }\r\n \r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_supplyLimit\",\"type\":\"uint256\"}],\"name\":\"SupplyLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_currentValues\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"approveBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressPartyA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressPartyB\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_idsPartyA\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_idsPartyB\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_valuesPartyA\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_valuesPartyB\",\"type\":\"uint256[]\"}],\"name\":\"atomicSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"batchAuthorizeCreators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_isNF\",\"type\":\"bool\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"creators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getNonFungibleBaseType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getNonFungibleIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isFungible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isNonFungible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isNonFungibleBaseType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isNonFungibleItem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_quantities\",\"type\":\"uint256[]\"}],\"name\":\"mintFungible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"}],\"name\":\"mintNonFungible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_typeOrId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supplyLimit\",\"type\":\"uint256\"}],\"name\":\"setSupplyLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSupplyLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Elevate","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://5460dc04fb9c44840b620c6f6986a79c1167f94b2be69a5990173b01d3d201c9"}]}