{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-04-29\r\n*/\r\n\r\npragma solidity ^0.5.4;\r\n\r\ncontract NiftyRegistry {\r\n    \r\n    \r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    \r\n    /**\r\n     * Constants\r\n     */ \r\n     \r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n    \r\n\r\n  /**\r\n   * @dev Modifiers, mostly from the Gnosis Multisig\r\n   */\r\n    modifier onlyOwner() {\r\n        require(isOwner[msg.sender] == true);\r\n        _;\r\n    }\r\n  \r\n   \r\n   /** \r\n    * @dev A mapping of all sender keys\r\n    */ \r\n    \r\n   mapping(address => bool) validNiftyKeys;\r\n   mapping (address => bool) public isOwner;\r\n   \r\n   /**\r\n    * @dev Static view functions to retrieve information \r\n    */\r\n     \r\n    /**\r\n    * @dev function to see if sending key is valid\r\n    */\r\n    \r\n    function isValidNiftySender(address sending_key) public view returns (bool) {\r\n      return(validNiftyKeys[sending_key]);\r\n    }\r\n    \r\n      \r\n      /**\r\n       * @dev Functions to alter master contract information, such as HSM signing wallet keys, static contract\r\n       * @dev All can only be changed by a multi sig transaciton so they have the onlyWallet modifier\r\n       */ \r\n    \r\n      /**\r\n       * @dev Functions to add and remove nifty keys\r\n       */\r\n       \r\n       function addNiftyKey(address new_sending_key) external onlyOwner {\r\n           validNiftyKeys[new_sending_key] = true;\r\n       }\r\n       \r\n       function removeNiftyKey(address sending_key) external onlyOwner {\r\n           validNiftyKeys[sending_key] = false;\r\n       }\r\n  \r\n  \r\n  /**\r\n   * Multisig transactions from https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol\r\n   * Used to call transactions that will modify the master contract\r\n   * Plus maintain owners, etc\r\n   */\r\n   \r\n   /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    constructor(address[] memory _owners, address[] memory signing_keys)\r\n        public\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != address(0));\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        for (uint i=0; i<signing_keys.length; i++) {\r\n            require(signing_keys[i] != address(0));\r\n            validNiftyKeys[signing_keys[i]] = true;\r\n        }\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        isOwner[owner] = true;\r\n        emit OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        isOwner[owner] = false;\r\n        emit OwnerRemoval(owner);\r\n    }\r\n\r\n \r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"signing_keys\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_sending_key\",\"type\":\"address\"}],\"name\":\"addNiftyKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sending_key\",\"type\":\"address\"}],\"name\":\"isValidNiftySender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sending_key\",\"type\":\"address\"}],\"name\":\"removeNiftyKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NiftyRegistry","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000003e6722f32cbe5b3c7bd3dca7017c7ffe1b9e5a2a0000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://fa92ab46cebf23cc230c9ac336bed63107c4e0dd1c46b446006a17f628bd6e05"}]}