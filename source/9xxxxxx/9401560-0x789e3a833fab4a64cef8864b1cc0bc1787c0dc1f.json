{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.13;\n\n\n/// @title Spawn\n/// @author 0age (@0age) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This contract provides creation code that is used by Spawner in order\n/// to initialize and deploy eip-1167 minimal proxies for a given logic contract.\ncontract Spawn {\n  constructor(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) public payable {\n    // delegatecall into the logic contract to perform initialization.\n    (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n    if (!ok) {\n      // pass along failure message from delegatecall and revert.\n      assembly {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n\n    // place eip-1167 runtime code in memory.\n    bytes memory runtimeCode = abi.encodePacked(\n      bytes10(0x363d3d373d3d3d363d73),\n      logicContract,\n      bytes15(0x5af43d82803e903d91602b57fd5bf3)\n    );\n\n    // return eip-1167 code to write it to spawned contract runtime.\n    assembly {\n      return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n    }\n  }\n}\n\n/// @title Spawner\n/// @author 0age (@0age) and Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This contract spawns and initializes eip-1167 minimal proxies that\n/// point to existing logic contracts. The logic contracts need to have an\n/// initializer function that should only callable when no contract exists at\n/// their current address (i.e. it is being `DELEGATECALL`ed from a constructor).\ncontract Spawner {\n  \n  /// @notice Internal function for spawning an eip-1167 minimal proxy using `CREATE2`.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @return The address of the newly-spawned contract.\n  function _spawn(\n    address creator,\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal returns (address spawnedContract) {\n\n    // get instance code and hash\n\n    bytes memory initCode;\n    bytes32 initCodeHash;\n    (initCode, initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\n\n    // get valid create2 target\n\n    (address target, bytes32 safeSalt) = _getNextNonceTargetWithInitCodeHash(creator, initCodeHash);\n\n    // spawn create2 instance and validate\n\n    return _executeSpawnCreate2(initCode, safeSalt, target);\n  }\n\n  /// @notice Internal function for spawning an eip-1167 minimal proxy using `CREATE2`.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @param salt bytes32 A user defined salt.\n  /// @return The address of the newly-spawned contract.\n  function _spawnSalty(\n    address creator,\n    address logicContract,\n    bytes memory initializationCalldata,\n    bytes32 salt\n  ) internal returns (address spawnedContract) {\n\n    // get instance code and hash\n\n    bytes memory initCode;\n    bytes32 initCodeHash;\n    (initCode, initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\n\n    // get valid create2 target\n\n    (address target, bytes32 safeSalt, bool validity) = _getSaltyTargetWithInitCodeHash(creator, initCodeHash, salt);\n    require(validity, \"contract already deployed with supplied salt\");\n\n    // spawn create2 instance and validate\n\n    return _executeSpawnCreate2(initCode, safeSalt, target);\n  }\n\n  /// @notice Private function for spawning an eip-1167 minimal proxy using `CREATE2`.\n  /// Reverts with appropriate error string if deployment is unsuccessful.\n  /// @param initCode bytes The spawner code and initialization calldata.\n  /// @param safeSalt bytes32 A valid salt hashed with creator address.\n  /// @param target address The expected address of the proxy.\n  /// @return The address of the newly-spawned contract.\n  function _executeSpawnCreate2(bytes memory initCode, bytes32 safeSalt, address target) private returns (address spawnedContract) {\n    assembly {\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      spawnedContract := create2(             // call `CREATE2` w/ 4 arguments.\n        callvalue,                            // forward any supplied endowment.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        safeSalt                              // pass in the salt value.\n      )\n\n      // pass along failure message from failed contract deployment and revert.\n      if iszero(spawnedContract) {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n\n    // validate spawned instance matches target\n    require(spawnedContract == target, \"attempted deployment to unexpected address\");\n\n    // explicit return\n    return spawnedContract;\n  }\n\n  /// @notice Internal view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\n  /// salt, and initialization calldata payload.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @param salt bytes32 A user defined salt.\n  /// @return target address The address of the newly-spawned contract.\n  /// @return validity bool True if the `target` is available.\n  function _getSaltyTarget(\n    address creator,\n    address logicContract,\n    bytes memory initializationCalldata,\n    bytes32 salt\n  ) internal view returns (address target, bool validity) {\n\n    // get initialization code\n\n    bytes32 initCodeHash;\n    ( , initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\n\n    // get valid target\n\n    (target, , validity) = _getSaltyTargetWithInitCodeHash(creator, initCodeHash, salt);\n\n    // explicit return\n    return (target, validity);\n  }\n\n  /// @notice Internal view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given initCodeHash, and salt.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param initCodeHash bytes32 The hash of initCode.\n  /// @param salt bytes32 A user defined salt.\n  /// @return target address The address of the newly-spawned contract.\n  /// @return safeSalt bytes32 A safe salt. Must include the msg.sender address for front-running protection.\n  /// @return validity bool True if the `target` is available.\n  function _getSaltyTargetWithInitCodeHash(\n    address creator,\n    bytes32 initCodeHash,\n    bytes32 salt\n  ) private view returns (address target, bytes32 safeSalt, bool validity) {\n    // get safeSalt from input\n    safeSalt = keccak256(abi.encodePacked(creator, salt));\n\n    // get expected target\n    target = _computeTargetWithCodeHash(initCodeHash, safeSalt);\n\n    // get target validity\n    validity = _getTargetValidity(target);\n\n    // explicit return\n    return (target, safeSalt, validity);\n  }\n\n  /// @notice Internal view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\n  /// nonce, and initialization calldata payload.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @return target address The address of the newly-spawned contract.\n  function _getNextNonceTarget(\n    address creator,\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal view returns (address target) {\n\n    // get initialization code\n\n    bytes32 initCodeHash;\n    ( , initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\n\n    // get valid target\n\n    (target, ) = _getNextNonceTargetWithInitCodeHash(creator, initCodeHash);\n\n    // explicit return\n    return target;\n  }\n\n  /// @notice Internal view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given initCodeHash, and nonce.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param initCodeHash bytes32 The hash of initCode.\n  /// @return target address The address of the newly-spawned contract.\n  /// @return safeSalt bytes32 A safe salt. Must include the msg.sender address for front-running protection.\n  function _getNextNonceTargetWithInitCodeHash(\n    address creator,\n    bytes32 initCodeHash\n  ) private view returns (address target, bytes32 safeSalt) {\n    // set the initial nonce to be provided when constructing the salt.\n    uint256 nonce = 0;\n\n    while (true) {\n      // get safeSalt from nonce\n      safeSalt = keccak256(abi.encodePacked(creator, nonce));\n\n      // get expected target\n      target = _computeTargetWithCodeHash(initCodeHash, safeSalt);\n\n      // validate no contract already deployed to the target address.\n      // exit the loop if no contract is deployed to the target address.\n      // otherwise, increment the nonce and derive a new salt.\n      if (_getTargetValidity(target))\n        break;\n      else\n        nonce++;\n    }\n    \n    // explicit return\n    return (target, safeSalt);\n  }\n\n  /// @notice Private pure function for obtaining the initCode and the initCodeHash of `logicContract` and `initializationCalldata`.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @return initCode bytes The spawner code and initialization calldata.\n  /// @return initCodeHash bytes32 The hash of initCode.\n  function _getInitCodeAndHash(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) private pure returns (bytes memory initCode, bytes32 initCodeHash) {\n    // place creation code and constructor args of contract to spawn in memory.\n    initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // get the keccak256 hash of the init code for address derivation.\n    initCodeHash = keccak256(initCode);\n\n    // explicit return\n    return (initCode, initCodeHash);\n  }\n  \n  /// @notice Private view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\n  /// salt, and initialization calldata payload.\n  /// @param initCodeHash bytes32 The hash of initCode.\n  /// @param safeSalt bytes32 A safe salt. Must include the msg.sender address for front-running protection.\n  /// @return The address of the proxy contract with the given parameters.\n  function _computeTargetWithCodeHash(\n    bytes32 initCodeHash,\n    bytes32 safeSalt\n  ) private view returns (address target) {\n    return address(    // derive the target deployment address.\n      uint160(                   // downcast to match the address type.\n        uint256(                 // cast to uint to truncate upper digits.\n          keccak256(             // compute CREATE2 hash using 4 inputs.\n            abi.encodePacked(    // pack all inputs to the hash together.\n              bytes1(0xff),      // pass in the control character.\n              address(this),     // pass in the address of this contract.\n              safeSalt,          // pass in the safeSalt from above.\n              initCodeHash       // pass in hash of contract creation code.\n            )\n          )\n        )\n      )\n    );\n  }\n\n  /// @notice Private view function to validate if the `target` address is an available deployment address.\n  /// @param target address The address to validate.\n  /// @return validity bool True if the `target` is available.\n  function _getTargetValidity(address target) private view returns (bool validity) {\n    // validate no contract already deployed to the target address.\n    uint256 codeSize;\n    assembly { codeSize := extcodesize(target) }\n    return codeSize == 0;\n  }\n}\n\n\n\n/// @title iRegistry\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\ninterface iRegistry {\n\n    enum FactoryStatus { Unregistered, Registered, Retired }\n\n    event FactoryAdded(address owner, address factory, uint256 factoryID, bytes extraData);\n    event FactoryRetired(address owner, address factory, uint256 factoryID);\n    event InstanceRegistered(address instance, uint256 instanceIndex, address indexed creator, address indexed factory, uint256 indexed factoryID);\n\n    // factory state functions\n\n    function addFactory(address factory, bytes calldata extraData ) external;\n    function retireFactory(address factory) external;\n\n    // factory view functions\n\n    function getFactoryCount() external view returns (uint256 count);\n    function getFactoryStatus(address factory) external view returns (FactoryStatus status);\n    function getFactoryID(address factory) external view returns (uint16 factoryID);\n    function getFactoryData(address factory) external view returns (bytes memory extraData);\n    function getFactoryAddress(uint16 factoryID) external view returns (address factory);\n    function getFactory(address factory) external view returns (FactoryStatus state, uint16 factoryID, bytes memory extraData);\n    function getFactories() external view returns (address[] memory factories);\n    function getPaginatedFactories(uint256 startIndex, uint256 endIndex) external view returns (address[] memory factories);\n\n    // instance state functions\n\n    function register(address instance, address creator, uint80 extraData) external;\n\n    // instance view functions\n\n    function getInstanceType() external view returns (bytes4 instanceType);\n    function getInstanceCount() external view returns (uint256 count);\n    function getInstance(uint256 index) external view returns (address instance);\n    function getInstances() external view returns (address[] memory instances);\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n}\n\n\n/// @title iFactory\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\ninterface iFactory {\n\n    event InstanceCreated(address indexed instance, address indexed creator, bytes callData);\n\n    function create(bytes calldata callData) external returns (address instance);\n    function createSalty(bytes calldata callData, bytes32 salt) external returns (address instance);\n    function getInitSelector() external view returns (bytes4 initSelector);\n    function getInstanceRegistry() external view returns (address instanceRegistry);\n    function getTemplate() external view returns (address template);\n    function getSaltyInstance(address creator, bytes calldata callData, bytes32 salt) external view returns (address instance, bool validity);\n    function getNextNonceInstance(address creator, bytes calldata callData) external view returns (address instance);\n\n    function getInstanceCreator(address instance) external view returns (address creator);\n    function getInstanceType() external view returns (bytes4 instanceType);\n    function getInstanceCount() external view returns (uint256 count);\n    function getInstance(uint256 index) external view returns (address instance);\n    function getInstances() external view returns (address[] memory instances);\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n}\n\n\n\n/// @title Template\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module is imported by all template contracts to implement core functionality associated with the factories.\ncontract Template {\n\n    address private _factory;\n\n    // modifiers\n\n    /// @notice Modifier which only allows to be `DELEGATECALL`ed from within a constructor on initialization of the contract.\n    modifier initializeTemplate() {\n        // set factory\n        _factory = msg.sender;\n\n        // only allow function to be `DELEGATECALL`ed from within a constructor.\n        uint32 codeSize;\n        assembly { codeSize := extcodesize(address) }\n        require(codeSize == 0, \"must be called within contract constructor\");\n        _;\n    }\n\n    // view functions\n\n    /// @notice Get the address that created this clone.\n    ///         Note, this cannot be trusted because it is possible to frontrun the create function and become the creator.\n    /// @return creator address that created this clone.\n    function getCreator() public view returns (address creator) {\n        // iFactory(...) would revert if _factory address is not actually a factory contract\n        return iFactory(_factory).getInstanceCreator(address(this));\n    }\n\n    /// @notice Validate if address matches the stored creator.\n    /// @param caller address to validate.\n    /// @return validity bool true if matching address.\n    function isCreator(address caller) internal view returns (bool validity) {\n        return (caller == getCreator());\n    }\n\n    /// @notice Get the address of the factory for this clone.\n    /// @return factory address of the factory.\n    function getFactory() public view returns (address factory) {\n        return _factory;\n    }\n\n}\n\n\n\n\n/// @title Factory\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice The factory contract implements a standard interface for creating EIP-1167 clones of a given template contract.\n///         The create functions accept abi-encoded calldata used to initialize the spawned templates.\ncontract Factory is Spawner, iFactory {\n    address[] private _instances;\n    mapping(address => address) private _instanceCreator;\n\n    /* NOTE: The following items can be hardcoded as constant to save ~200 gas/create */\n    address private _templateContract;\n    bytes4 private _initSelector;\n    address private _instanceRegistry;\n    bytes4 private _instanceType;\n\n    event InstanceCreated(\n        address indexed instance,\n        address indexed creator,\n        bytes callData\n    );\n\n    /// @notice Constructior\n    /// @param instanceRegistry address of the registry where all clones are registered.\n    /// @param templateContract address of the template used for making clones.\n    /// @param instanceType bytes4 identifier for the type of the factory. This must match the type of the registry.\n    /// @param initSelector bytes4 selector for the template initialize function.\n    function _initialize(\n        address instanceRegistry,\n        address templateContract,\n        bytes4 instanceType,\n        bytes4 initSelector\n    ) internal {\n        // set instance registry\n        _instanceRegistry = instanceRegistry;\n        // set logic contract\n        _templateContract = templateContract;\n        // set initSelector\n        _initSelector = initSelector;\n        // validate correct instance registry\n        // require(instanceType == iRegistry(instanceRegistry).getInstanceType(), 'incorrect instance type');\n        // set instanceType\n        _instanceType = instanceType;\n    }\n\n    // IFactory methods\n\n    /// @notice Create clone of the template using a nonce.\n    ///         The nonce is unique for clones with the same initialization calldata.\n    ///         The nonce can be used to determine the address of the clone before creation.\n    ///         The callData must be prepended by the function selector of the template's initialize function and include all parameters.\n    /// @param callData bytes blob of abi-encoded calldata used to initialize the template.\n    /// @return instance address of the clone that was created.\n    function create(bytes memory callData) public returns (address instance) {\n        // deploy new contract: initialize it & write minimal proxy to runtime.\n        instance = Spawner._spawn(msg.sender, getTemplate(), callData);\n\n        _createHelper(instance, callData);\n\n        return instance;\n    }\n\n    /// @notice Create clone of the template using a salt.\n    ///         The salt must be unique for clones with the same initialization calldata.\n    ///         The salt can be used to determine the address of the clone before creation.\n    ///         The callData must be prepended by the function selector of the template's initialize function and include all parameters.\n    /// @param callData bytes blob of abi-encoded calldata used to initialize the template.\n    /// @return instance address of the clone that was created.\n    function createSalty(bytes memory callData, bytes32 salt)\n        public\n        returns (address instance)\n    {\n        // deploy new contract: initialize it & write minimal proxy to runtime.\n        instance = Spawner._spawnSalty(\n            msg.sender,\n            getTemplate(),\n            callData,\n            salt\n        );\n\n        _createHelper(instance, callData);\n\n        return instance;\n    }\n\n    /// @notice Private function to help with the creation of the clone.\n    ///         Stores the address of the clone in this contract.\n    ///         Stores the creator of the clone in this contract.\n    ///         Registers the address of the clone in the registry. Fails if the factory is deprecated.\n    ///         Emits standard InstanceCreated event\n    /// @param instance address The address of the clone that was created.\n    /// @param callData bytes The initialization calldata to use on the clone.\n    function _createHelper(address instance, bytes memory callData) private {\n        // add the instance to the array\n        _instances.push(instance);\n        // set instance creator\n        _instanceCreator[instance] = msg.sender;\n        // add the instance to the instance registry\n        // iRegistry(getInstanceRegistry()).register(instance, msg.sender, uint80(0));\n        // emit event\n        emit InstanceCreated(instance, msg.sender, callData);\n    }\n\n    /// @notice Get the address of an instance for a given salt\n    function getSaltyInstance(\n        address creator,\n        bytes memory callData,\n        bytes32 salt\n    ) public view returns (address instance, bool validity) {\n        return Spawner._getSaltyTarget(creator, getTemplate(), callData, salt);\n    }\n\n    function getNextNonceInstance(address creator, bytes memory callData)\n        public\n        view\n        returns (address target)\n    {\n        return Spawner._getNextNonceTarget(creator, getTemplate(), callData);\n    }\n\n    function getInstanceCreator(address instance)\n        public\n        view\n        returns (address creator)\n    {\n        return _instanceCreator[instance];\n    }\n\n    function getInstanceType() public view returns (bytes4 instanceType) {\n        return _instanceType;\n    }\n\n    function getInitSelector() public view returns (bytes4 initSelector) {\n        return _initSelector;\n    }\n\n    function getInstanceRegistry()\n        public\n        view\n        returns (address instanceRegistry)\n    {\n        return _instanceRegistry;\n    }\n\n    function getTemplate() public view returns (address template) {\n        return _templateContract;\n    }\n\n    function getInstanceCount() public view returns (uint256 count) {\n        return _instances.length;\n    }\n\n    function getInstance(uint256 index) public view returns (address instance) {\n        require(index < _instances.length, 'index out of range');\n        return _instances[index];\n    }\n\n    function getInstances() public view returns (address[] memory instances) {\n        return _instances;\n    }\n\n    // Note: startIndex is inclusive, endIndex exclusive\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex)\n        public\n        view\n        returns (address[] memory instances)\n    {\n        require(startIndex < endIndex, 'startIndex must be less than endIndex');\n        require(endIndex <= _instances.length, 'end index out of range');\n\n        // initialize fixed size memory array\n        address[] memory range = new address[](endIndex - startIndex);\n\n        // Populate array with addresses in range\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            range[i - startIndex] = _instances[i];\n        }\n\n        // return array of addresses\n        return range;\n    }\n\n}\n\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n/// @author Stefan George - <stefan.george@consensys.net>\ncontract MultiSigWallet is Template {\n    /*\n     *  Events\n     */\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\n    event Revocation(address indexed sender, uint256 indexed transactionId);\n    event Submission(uint256 indexed transactionId);\n    event Execution(uint256 indexed transactionId);\n    event ExecutionFailure(uint256 indexed transactionId);\n    event Deposit(address indexed sender, uint256 value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint256 required);\n\n    /*\n     *  Constants\n     */\n    uint256 public constant MAX_OWNER_COUNT = 50;\n\n    /*\n     *  Storage\n     */\n    mapping(uint256 => Transaction) public transactions;\n    mapping(uint256 => mapping(address => bool)) public confirmations;\n    mapping(address => bool) public isOwner;\n    address[] public owners;\n    uint256 public required;\n    uint256 public transactionCount;\n\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        bool executed;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier onlyWallet() {\n        require(msg.sender == address(this));\n        _;\n    }\n\n    modifier ownerDoesNotExist(address owner) {\n        require(!isOwner[owner]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require(isOwner[owner]);\n        _;\n    }\n\n    modifier transactionExists(uint256 transactionId) {\n        require(transactions[transactionId].destination != address(0));\n        _;\n    }\n\n    modifier confirmed(uint256 transactionId, address owner) {\n        require(confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint256 transactionId, address owner) {\n        require(!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint256 transactionId) {\n        require(!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier validRequirement(uint256 ownerCount, uint256 _required) {\n        require(\n            ownerCount <= MAX_OWNER_COUNT &&\n                _required <= ownerCount &&\n                _required != 0 &&\n                ownerCount != 0\n        );\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function() external payable {\n        if (msg.value > 0) {\n            emit Deposit(msg.sender, msg.value);\n        }\n    }\n\n    function initialize(address[] memory _owners, uint256 _required)\n        public\n        initializeTemplate()\n        validRequirement(_owners.length, _required)\n    {\n        for (uint256 i = 0; i < _owners.length; i++) {\n            require(!isOwner[_owners[i]] && _owners[i] != address(0));\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        public\n        onlyWallet\n        ownerDoesNotExist(owner)\n        notNull(owner)\n        validRequirement(owners.length + 1, required)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner) public onlyWallet ownerExists(owner) {\n        isOwner[owner] = false;\n        for (uint256 i = 0; i < owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length) changeRequirement(owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param newOwner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        public\n        onlyWallet\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint256 i = 0; i < owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        emit OwnerRemoval(owner);\n        emit OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint256 _required)\n        public\n        onlyWallet\n        validRequirement(owners.length, _required)\n    {\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return Returns transaction ID.\n    function submitTransaction(\n        address destination,\n        uint256 value,\n        bytes memory data\n    ) public returns (uint256 transactionId) {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint256 transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint256 transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        emit Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint256 transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            if (\n                external_call(\n                    txn.destination,\n                    txn.value,\n                    txn.data.length,\n                    txn.data\n                )\n            ) {\n                emit Execution(transactionId);\n            } else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    // call has been separated into its own function in order to take advantage\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\n    function external_call(\n        address destination,\n        uint256 value,\n        uint256 dataLength,\n        bytes memory data\n    ) internal returns (bool) {\n        bool result;\n        assembly {\n            let x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n            result := call(\n                sub(gas, 34710), // 34710 is the value that solidity is currently emitting\n                // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n                // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n                destination,\n                value,\n                d,\n                dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n                x,\n                0 // Output is ignored, therefore the output size is zero\n            )\n        }\n        return result;\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint256 transactionId) public view returns (bool) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]]) count += 1;\n            if (count == required) return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return Returns transaction ID.\n    function addTransaction(\n        address destination,\n        uint256 value,\n        bytes memory data\n    ) internal notNull(destination) returns (uint256 transactionId) {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Number of confirmations.\n    function getConfirmationCount(uint256 transactionId)\n        public\n        view\n        returns (uint256 count)\n    {\n        for (uint256 i = 0; i < owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        view\n        returns (uint256 count)\n    {\n        for (uint256 i = 0; i < transactionCount; i++)\n            if (\n                (pending && !transactions[i].executed) ||\n                (executed && transactions[i].executed)\n            ) count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners() public view returns (address[] memory) {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Returns array of owner addresses.\n    function getConfirmations(uint256 transactionId)\n        public\n        view\n        returns (address[] memory _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint256 count = 0;\n        uint256 i;\n        for (i = 0; i < owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Returns array of transaction IDs.\n    function getTransactionIds(\n        uint256 from,\n        uint256 to,\n        bool pending,\n        bool executed\n    ) public view returns (uint256[] memory _transactionIds) {\n        uint256[] memory transactionIdsTemp = new uint256[](transactionCount);\n        uint256 count = 0;\n        uint256 i;\n        for (i = 0; i < transactionCount; i++)\n            if (\n                (pending && !transactions[i].executed) ||\n                (executed && transactions[i].executed)\n            ) {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint256[](to - from);\n        for (i = from; i < to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}\n\n\n\ncontract MultiSigWallet_Factory is Factory {\n    constructor(address instanceRegistry, address templateContract) public {\n        MultiSigWallet template;\n\n        // set instance type\n        bytes4 instanceType = bytes4(keccak256(bytes('Wallet')));\n        // set initSelector\n        bytes4 initSelector = template.initialize.selector;\n        // initialize factory params\n        Factory._initialize(\n            instanceRegistry,\n            templateContract,\n            instanceType,\n            initSelector\n        );\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"instanceRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"templateContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"InstanceCreated\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"createSalty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitSelector\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"initSelector\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInstance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstanceCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"getInstanceCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstanceRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instanceRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstanceType\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"instanceType\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"instances\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"getNextNonceInstance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getPaginatedInstances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"instances\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getSaltyInstance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"validity\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTemplate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MultiSigWallet_Factory","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b29eb3cc9a809ce4bb180862c5186346e3a09ef3","Library":"","LicenseType":"","SwarmSource":"bzzr://2b197d958e6aa037b4ea1b5676d0faa7118ab0b7287cbaf4fc24f96c8a3b1d05"}]}