{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\nabstract contract Proxy {\r\n\t/**\r\n\t * @dev Receive function.\r\n\t * Implemented entirely in `_fallback`.\r\n\t */\r\n\treceive() external payable virtual {\r\n\t\t_fallback();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Fallback function.\r\n\t * Implemented entirely in `_fallback`.\r\n\t */\r\n\tfallback() external payable {\r\n\t\t_fallback();\r\n\t}\r\n\r\n\t/**\r\n\t * @return impl The Address of the implementation.\r\n\t */\r\n\tfunction _implementation() internal virtual view returns (address impl);\r\n\r\n\t/**\r\n\t * @dev Delegates execution to an implementation contract.\r\n\t * This is a low level function that doesn't return to its internal call site.\r\n\t * It will return to the external caller whatever the implementation returns.\r\n\t * @param implementation Address to delegate.\r\n\t */\r\n\tfunction _delegate(address implementation) internal {\r\n\t\tassembly {\r\n\t\t\t// Copy msg.data. We take full control of memory in this inline assembly\r\n\t\t\t// block because it will not return to Solidity code. We overwrite the\r\n\t\t\t// Solidity scratch pad at memory position 0.\r\n\t\t\tcalldatacopy(0, 0, calldatasize())\r\n\r\n\t\t\t// Call the implementation.\r\n\t\t\t// out and outsize are 0 because we don't know the size yet.\r\n\t\t\tlet result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n\t\t\t// Copy the returned data.\r\n\t\t\treturndatacopy(0, 0, returndatasize())\r\n\r\n\t\t\tswitch result\r\n\t\t\t// delegatecall returns 0 on error.\r\n\t\t\tcase 0 { revert(0, returndatasize()) }\r\n\t\t\tdefault { return(0, returndatasize()) }\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that is run as the first thing in the fallback function.\r\n\t * Can be redefined in derived contracts to add functionality.\r\n\t * Redefinitions must call super._willFallback().\r\n\t */\r\n\tfunction _willFallback() internal virtual {\r\n\t}\r\n\r\n\t/**\r\n\t * @dev fallback implementation.\r\n\t * Extracted to enable manual triggering.\r\n\t */\r\n\tfunction _fallback() internal {\r\n\t\t_willFallback();\r\n\t\t_delegate(_implementation());\r\n\t}\r\n}\r\n\r\ninterface IERC1538 {\r\n\tevent CommitMessage(string message);\r\n\tevent FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n\t// Empty internal constructor, to prevent people from mistakenly deploying\r\n\t// an instance of this contract, which should be used via inheritance.\r\n\tconstructor () internal { }\r\n\r\n\tfunction _msgSender() internal view virtual returns (address payable) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes memory) {\r\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor () internal {\r\n\t\taddress msgSender = _msgSender();\r\n\t\t_owner = msgSender;\r\n\t\temit OwnershipTransferred(address(0), msgSender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\temit OwnershipTransferred(_owner, address(0));\r\n\t\t_owner = address(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\t_transferOwnership(newOwner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t */\r\n\tfunction _transferOwnership(address newOwner) internal virtual {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\temit OwnershipTransferred(_owner, newOwner);\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\n\r\nlibrary LibSet_bytes4 {\r\n\tstruct set\r\n\t{\r\n\t\tbytes4[] values;\r\n\t\tmapping(bytes4 => uint256) indexes;\r\n\t}\r\n\r\n\tfunction length(set storage _set)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _set.values.length;\r\n\t}\r\n\r\n\tfunction at(set storage _set, uint256 _index)\r\n\tinternal view returns (bytes4 )\r\n\t{\r\n\t\treturn _set.values[_index - 1];\r\n\t}\r\n\r\n\tfunction indexOf(set storage _set, bytes4  _value)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _set.indexes[_value];\r\n\t}\r\n\r\n\tfunction contains(set storage _set, bytes4  _value)\r\n\tinternal view returns (bool)\r\n\t{\r\n\t\treturn indexOf(_set, _value) != 0;\r\n\t}\r\n\r\n\tfunction content(set storage _set)\r\n\tinternal view returns (bytes4[] memory)\r\n\t{\r\n\t\treturn _set.values;\r\n\t}\r\n\r\n\tfunction add(set storage _set, bytes4  _value)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tif (contains(_set, _value))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t_set.values.push(_value);\r\n\t\t_set.indexes[_value] = _set.values.length;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction remove(set storage _set, bytes4  _value)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tif (!contains(_set, _value))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tuint256 i    = indexOf(_set, _value);\r\n\t\tuint256 last = length(_set);\r\n\r\n\t\tif (i != last)\r\n\t\t{\r\n\t\t\tbytes4  swapValue = _set.values[last - 1];\r\n\t\t\t_set.values[i - 1] = swapValue;\r\n\t\t\t_set.indexes[swapValue] = i;\r\n\t\t}\r\n\r\n\t\tdelete _set.indexes[_value];\r\n\t\t_set.values.pop();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction clear(set storage _set)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tfor (uint256 i = _set.values.length; i > 0; --i)\r\n\t\t{\r\n\t\t\tdelete _set.indexes[_set.values[i-1]];\r\n\t\t}\r\n\t\t_set.values = new bytes4[](0);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nlibrary LibMap2_bytes4_address_bytes {\r\n\tusing LibSet_bytes4 for LibSet_bytes4.set;\r\n\r\n\tstruct map\r\n\t{\r\n\t\tLibSet_bytes4.set keyset;\r\n\t\tmapping(bytes4 => address) values1;\r\n\t\tmapping(bytes4 => bytes) values2;\r\n\t}\r\n\r\n\tfunction length(map storage _map)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _map.keyset.length();\r\n\t}\r\n\r\n\tfunction value1(map storage _map, bytes4  _key)\r\n\tinternal view returns (address )\r\n\t{\r\n\t\treturn _map.values1[_key];\r\n\t}\r\n\r\n\tfunction value2(map storage _map, bytes4  _key)\r\n\tinternal view returns (bytes memory)\r\n\t{\r\n\t\treturn _map.values2[_key];\r\n\t}\r\n\r\n\tfunction keyAt(map storage _map, uint256 _index)\r\n\tinternal view returns (bytes4 )\r\n\t{\r\n\t\treturn _map.keyset.at(_index);\r\n\t}\r\n\r\n\tfunction at(map storage _map, uint256 _index)\r\n\tinternal view returns (bytes4 , address , bytes memory)\r\n\t{\r\n\t\tbytes4  key = keyAt(_map, _index);\r\n\t\treturn (key, value1(_map, key), value2(_map, key));\r\n\t}\r\n\r\n\tfunction indexOf(map storage _map, bytes4  _key)\r\n\tinternal view returns (uint256)\r\n\t{\r\n\t\treturn _map.keyset.indexOf(_key);\r\n\t}\r\n\r\n\tfunction contains(map storage _map, bytes4  _key)\r\n\tinternal view returns (bool)\r\n\t{\r\n\t\treturn _map.keyset.contains(_key);\r\n\t}\r\n\r\n\tfunction keys(map storage _map)\r\n\tinternal view returns (bytes4[] memory)\r\n\t{\r\n\t\treturn _map.keyset.content();\r\n\t}\r\n\r\n\tfunction set(\r\n\t\tmap storage _map,\r\n\t\tbytes4  _key,\r\n\t\taddress  _value1,\r\n\t\tbytes memory _value2)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\t_map.keyset.add(_key);\r\n\t\t_map.values1[_key] = _value1;\r\n\t\t_map.values2[_key] = _value2;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction del(map storage _map, bytes4  _key)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\t_map.keyset.remove(_key);\r\n\t\tdelete _map.values1[_key];\r\n\t\tdelete _map.values2[_key];\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction clear(map storage _map)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tfor (uint256 i = _map.keyset.length(); i > 0; --i)\r\n\t\t{\r\n\t\t\tbytes4  key = keyAt(_map, i);\r\n\t\t\tdelete _map.values1[key];\r\n\t\t\tdelete _map.values2[key];\r\n\t\t}\r\n\t\t_map.keyset.clear();\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract ERC1538Store is Ownable\r\n{\r\n\tusing LibMap2_bytes4_address_bytes for LibMap2_bytes4_address_bytes.map;\r\n\r\n\tLibMap2_bytes4_address_bytes.map internal m_funcs;\r\n}\r\n\r\ncontract ERC1538Core is IERC1538, ERC1538Store\r\n{\r\n\tbytes4 constant internal RECEIVE  = 0xd217fcc6; // bytes4(keccak256(\"receive\"));\r\n\tbytes4 constant internal FALLBACK = 0xb32cdf4d; // bytes4(keccak256(\"fallback\"));\r\n\r\n\tevent CommitMessage(string message);\r\n\tevent FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n\r\n\tfunction _setFunc(string memory funcSignature, address funcDelegate)\r\n\tinternal\r\n\t{\r\n\t\tbytes4 funcId = bytes4(keccak256(bytes(funcSignature)));\r\n\t\tif (funcId == RECEIVE ) { funcId = bytes4(0x00000000); }\r\n\t\tif (funcId == FALLBACK) { funcId = bytes4(0xFFFFFFFF); }\r\n\r\n\t\taddress oldDelegate = m_funcs.value1(funcId);\r\n\r\n\t\tif (funcDelegate == oldDelegate) // No change → skip\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if (funcDelegate == address(0)) // Delete\r\n\t\t{\r\n\t\t\tm_funcs.del(funcId);\r\n\t\t}\r\n\t\telse // Set / Update\r\n\t\t{\r\n\t\t\tm_funcs.set(funcId, funcDelegate, bytes(funcSignature));\r\n\t\t}\r\n\r\n\t\temit FunctionUpdate(funcId, oldDelegate, funcDelegate, funcSignature);\r\n\t}\r\n}\r\n\r\ncontract ERC1538Proxy is ERC1538Core, Proxy\r\n{\r\n\tconstructor(address _erc1538Delegate)\r\n\tpublic\r\n\t{\r\n\t\t_transferOwnership(msg.sender);\r\n\t\t_setFunc(\"updateContract(address,string,string)\", _erc1538Delegate);\r\n\t\temit CommitMessage(\"Added ERC1538 updateContract function at contract creation\");\r\n\t}\r\n\r\n\tfunction _implementation() internal override view returns (address)\r\n\t{\r\n\t\taddress delegateFunc = m_funcs.value1(msg.sig);\r\n\r\n\t\tif (delegateFunc != address(0))\r\n\t\t{\r\n\t\t\treturn delegateFunc;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn m_funcs.value1(0xFFFFFFFF);\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc1538Delegate\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"CommitMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"functionId\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDelegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"functionSignature\",\"type\":\"string\"}],\"name\":\"FunctionUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ERC1538Proxy","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000f3b4536cc9a3f5604d0d55559675d513aa8106f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d24d03da5c0af07060348adaf9368c37562adf7d53e06b4ebe9ac4a638db4a7f"}]}