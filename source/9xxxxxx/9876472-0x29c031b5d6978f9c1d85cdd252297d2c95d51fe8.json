{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.2;\r\npragma experimental ABIEncoderV2;\r\n// Some contracts in here taken from Open Zepplin\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n// This contract is taken from openzepplin-sdk\r\n// https://github.com/OpenZeppelin/openzeppelin-sdk/blob/master/packages/lib/contracts/Initializable.sol\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// @author Patrick McCorry\r\n// @title DataShard\r\n// @notice Stores data for a given epoch / interval.\r\n// @dev Storage contract.\r\n//      Associates msg.sender with a list of bytes32 (hash) -> uint (timestamp).\r\ncontract DataShard is Initializable, Ownable {\r\n   uint public creationBlock;\r\n\r\n   // Smart Contract Address => ID-based data storage\r\n   mapping (bytes32 => uint) records;\r\n\r\n   // @param _blockNo Provided by the DataRegistry\r\n   function initialize(address _newOwner) initializer onlyOwner public {\r\n       creationBlock = block.number;\r\n       _transferOwnership(_newOwner);\r\n   }\r\n\r\n   // @dev Destory contract (and all its entries)\r\n   function kill() public onlyOwner {\r\n       selfdestruct(payable(owner()));\r\n   }\r\n\r\n   // @returns Creation time (blocknumber) for this dataShard\r\n   function getCreationBlock() public view returns (uint) {\r\n       return creationBlock;\r\n   }\r\n\r\n   // @param _sc Smart contract address\r\n   // @param _id Unique identifier for record\r\n   // @returns A record (timestamp) or \"0\" if no record was found.\r\n   function fetchRecord(bytes32 _id) public view returns (uint) {\r\n       return records[_id];\r\n   }\r\n\r\n   // @param _sc Smart contract address\r\n   // @param _id Unique identifier for record\r\n   // @param _timestamp A timestamp\r\n   // @dev Only stores a record if it is NOT set. e.g. does not replace/update.\r\n   //      Throws exception if this id has already been set\r\n   function setRecord(bytes32 _id, uint _timestamp) external onlyOwner {\r\n      // we throw here if the record has already been set to allow callers to know if the record\r\n      // was already there.\r\n      require(records[_id] == 0, \"Record already set.\");\r\n      records[_id] = _timestamp;\r\n   }\r\n}\r\n// @author Patrick McCorry\r\n// @title DataShard\r\n// @notice Manages the creation and destruction of data shards. Helps us be Ethereum Enviromentally Friendly.\r\n// @dev In practice, we only need 2 dataShards for it to work well.\r\ncontract DataRegistry is Initializable {\r\n\r\n   // Shard ID => Address for DataShard\r\n   mapping (uint => address) public dataShards;\r\n   uint public interval; // Approximately 6000 blocks a day\r\n   uint constant TOTAL_SHARDS = 2; // Total number of data shards in rotation\r\n\r\n   // @returns Number of blocks for an interval.\r\n   function getInterval() public view returns (uint) {\r\n      return interval;\r\n   }\r\n\r\n   // @returns Number of shards in rotation.\r\n   function getTotalShards() public pure returns (uint) {\r\n      return TOTAL_SHARDS;\r\n   }\r\n\r\n   // @dev Values for interval and total_shards is hard-coded in the contract. Can be passed as constructor, but not big deal.\r\n   function initialize(uint _interval) initializer internal {\r\n      interval = _interval;\r\n\r\n      // We must initialize ALL shards to ensure we have a .kill() function when\r\n      // calling resetDataShard(). Otherwise it will always fail due to a revert.\r\n      for(uint i=0; i<TOTAL_SHARDS; i++) {\r\n         DataShard ds = new DataShard();\r\n         ds.initialize(address(this));\r\n         dataShards[i] = address(ds);\r\n      }\r\n   }\r\n\r\n   // @returns Instance of the DataShard\r\n   // @dev Call this function periodically to delete/create data shards.\r\n   function resetDataShard() public returns (DataShard) {\r\n      // We need to do full loop before deleting an old shard!\r\n      if(block.number - DataShard(dataShards[0]).getCreationBlock() >= interval) {\r\n          address toDelete = dataShards[1];\r\n          dataShards[1] = dataShards[0];\r\n          DataShard ds = new DataShard();\r\n          ds.initialize(address(this));\r\n          dataShards[0] = address(ds);\r\n          DataShard(toDelete).kill();\r\n      }\r\n   }\r\n\r\n   // @dev Returns the latest / most recently created data shard.\r\n   function getLatestDataShard() public view returns (address) {\r\n      return dataShards[0];\r\n   }\r\n\r\n   // @param _dataShard Index of data shard\r\n   // @param _sc Smart contract that recorded the log\r\n   // @param _id Unique identifier for the record\r\n   // @returns Record data (timestamp)\r\n   function fetchRecord(uint _dataShard, bytes32 _id) public view returns (uint) {\r\n       // Confirm the data shard exists so we can fetch data\r\n      if(dataShards[_dataShard] != address(0)) {\r\n          DataShard rc = DataShard(dataShards[_dataShard]);\r\n          return rc.fetchRecord(_id);\r\n      }\r\n   }\r\n   // @param _id Unique identifier for the record\r\n   // @param _timestamp A timestamp\r\n   // @dev We have integrated with the relay contract; so only relay can call it.\r\n   function setRecord(bytes32 _id, uint _timestamp) internal  {\r\n      // Fetch Index\r\n      address dataShardAddr = getLatestDataShard();\r\n      // Fetch the DataShard for this day. (It may reset it under the hood)\r\n      DataShard rc = DataShard(dataShardAddr);\r\n      // Update record!\r\n      rc.setRecord(_id, _timestamp);\r\n   }\r\n}\r\n\r\n\r\n// @author Patrick McCorry & Chris Buckland (PISA Research)\r\n// @title Relay\r\n// @notice Relay tx data structure\r\ncontract RelayTxStruct {\r\n\r\n    // @dev The relay transaction\r\n    struct RelayTx {\r\n        address to; // Address for external contract\r\n        address payable from; // Address for the user who hired the relayer\r\n        bytes data; // Call data that we need to send. Includes function call name, etc.\r\n        uint deadline; // Expiry block number for appointment\r\n        uint compensation; // How much should the operator compensation the user by?\r\n        uint gasLimit; // How much gas is allocated to this function call?\r\n        address relay; // The relay contract!\r\n    }\r\n\r\n    // @return Relay tx hash (bytes32)\r\n    // @dev Pack the encoding when computing the ID.\r\n    function computeRelayTxId(RelayTx memory self) public pure returns (bytes32) {\r\n      return keccak256(abi.encode(self.to, self.from, self.data, self.deadline, self.compensation, self.gasLimit, self.relay));\r\n    }\r\n}\r\n\r\n// @author PISA Research (Patrick & Chris)\r\n// @title Payment Deposit: Accept payments from customers\r\ncontract PaymentDeposit is Initializable, Ownable {\r\n    // We index the sender so that it's easy to look up all deposits\r\n    // from a given sender.\r\n    event Deposit(address indexed sender, uint amount);\r\n\r\n    // We index the sender so that it's easy to look up all withdraws\r\n    // from a given sender.\r\n    event Withdraw(address indexed sender, uint amount);\r\n    \r\n    // Two-step deployment process. \r\n    function initialize(address _newOwner) internal initializer onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * Supply a deposit for a specified recipient\r\n     */\r\n    function depositFor(address recipient) public payable { \r\n        require(msg.value > 0, \"No value provided to depositFor.\");\r\n        emit Deposit(recipient, msg.value);\r\n    }\r\n\r\n    /**\r\n     * As with the fallback, supply a deposit for msg.sender\r\n     */\r\n    function deposit() public payable {\r\n        require(msg.value > 0, \"No value provided to deposit.\");\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    receive() external payable {\r\n        require(msg.value > 0, \"No value provided to fallback.\");\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * Move funds out of the contract\r\n     */\r\n    function send(address payable recipient, uint amount) onlyOwner public {\r\n        recipient.transfer(amount);\r\n        emit Withdraw(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * Use admin privileges to migrate a user's deposits to another deposit contract\r\n     */\r\n    function migrate(address payable recipient, uint amount, PaymentDeposit otherDeposit) onlyOwner public {\r\n        require(address(this).balance >= amount, \"Not enough balance to migrate.\");\r\n        otherDeposit.depositFor.value(amount)(recipient);\r\n        emit Withdraw(recipient, amount);\r\n    }\r\n}\r\n\r\n// @author PISA Research (Patrick & Chris)\r\n// @title Relay: Executing relay transactions\r\n// @notice This contract only handles executing relay transactions.\r\n//         It does not have logic to handle the security deposit or proving fraud.\r\n// @dev The operator must supply gast refund this contract as it ms relayers the cost of submitting jobs.\r\ncontract Relay is DataRegistry, RelayTxStruct, PaymentDeposit {\r\n    mapping(address => bool) public relayers;\r\n\r\n    event RelayExecuted(bytes32 indexed relayTxId, bool success, address indexed from, address indexed to, uint gasUsed, uint gasPrice);\r\n    event RelayerInstalled(address relayer);\r\n    event RelayerUninstalled(address relayer);\r\n    event OutOfCoins();\r\n\r\n    // @param _newOwner Owner can install relayers\r\n    // @dev Behind the scenes, the DataRegistry is creating two shards via an internal constructor.\r\n    function initialize(address _newOwner, uint _shardInterval) public initializer onlyOwner {\r\n        PaymentDeposit.initialize(_newOwner);\r\n        DataRegistry.initialize(_shardInterval);\r\n    }\r\n\r\n    // @param _relayTx A relay tx containing the job to execute\r\n    // @param _gasRefund Whether the relayer requires a gas refund\r\n    // @dev Only authorised relayer can execute relay jobs and they are refunded gas at the end of the call.\r\n    //      Critically, if the relay job fails, we can simply catch exception and continue to record the log.\r\n    function execute(RelayTx memory _relayTx, bool _gasRefund) public {\r\n        uint gasStarted = gasleft();\r\n\r\n        // The msg.sender check protects against two problems:\r\n        // - Replay attacks across chains (chainid in transaction)\r\n        // - Re-entrancy attacks back into .execute() (signer required)\r\n        require(relayers[msg.sender], \"Relayer must call this function.\");\r\n        require(_relayTx.relay == address(this), \"Relay tx MUST be for this relay contract.\");\r\n\r\n        bytes32 relayTxId = computeRelayTxId(_relayTx);\r\n        // Only record log if a compensation is required\r\n        if(_relayTx.compensation != 0) {\r\n            // Record a log of executing the job, Each shard only records the first job since the first job has the\r\n            // earliest timestamp.\r\n            // This will throw if the id is already in the data registry, which provides some mild replay protection\r\n            // which can help to catch bugs in the relayer. It cannot be used as full replay protection because at the\r\n            // eventually the shard will be cycled away.\r\n            setRecord(relayTxId, block.number);\r\n        }\r\n\r\n        // We do not require the customer to sign the relay tx.\r\n        // Why? If relayer submits wrong relay tx, it wont have the correct RelayTxId.\r\n        // So the RelayTxId won't be recorded and the customer can easily prove\r\n        // the correct relay tx was never submitted for execution.\r\n\r\n        // In the worst case, the contract will only send 63/64 of the transaction's\r\n        // remaining gas due to https://eips.ethereum.org/EIPS/eip-150\r\n        // But this is problematic as outlined in https://eips.ethereum.org/EIPS/eip-1930\r\n        // so to fix... we need to make sure we supply 64/63 * gasLimit.\r\n        // Assumption: Underlying contract called did not have a minimum gas required check\r\n        // We add 1000 to cover the cost of calculating new gas limit - this should be a lot more than\r\n        // is required - measuring shows cost of 58\r\n        require(gasleft() > (_relayTx.gasLimit + _relayTx.gasLimit / 63) + 1000, \"Not enough gas supplied.\");\r\n\r\n        // execute the actual call\r\n        (bool success,) = _relayTx.to.call.gas(_relayTx.gasLimit)(_relayTx.data);\r\n\r\n        // we add some gas using hard coded opcode pricing for computation that we could measure\r\n        uint gasUsed = gasStarted - gasleft() + // execute cost\r\n                            (msg.data.length * 16) + // data input cost (add 1 for gasRefund bool)\r\n                            2355 + // cost of RelayExecuted event - 375 + 375 + 375 + (160 * 8)\r\n                            21000; // transaction cost\r\n\r\n        if(_gasRefund) {\r\n            gasUsed += (9000 + 1000); // refund cost, send + change for calculations\r\n            if(!msg.sender.send(gasUsed*tx.gasprice)) {\r\n                // Notify admin we need to provide more refund to this contract\r\n                emit OutOfCoins();\r\n            }\r\n        }\r\n\r\n        emit RelayExecuted(relayTxId, success, _relayTx.from, _relayTx.to, gasUsed, tx.gasprice);\r\n    }\r\n\r\n    // @param _relayer New relayer address\r\n    // @dev Only the owner can install a new relayer\r\n    function installRelayer(address _relayer) onlyOwner public {\r\n        require(!relayers[_relayer], \"Relayer is already installed.\");\r\n        require(_relayer != address(this), \"The relay contract cannot be installed as a relayer.\");\r\n\r\n        relayers[_relayer] = true;\r\n        emit RelayerInstalled(_relayer);\r\n    }\r\n\r\n    // @param _relayer New relayer address\r\n    // @dev Only the owner can uninstall a new relayer\r\n    function uninstallRelayer(address _relayer) onlyOwner public {\r\n        require(relayers[_relayer], \"Relayer must be installed.\");\r\n\r\n        relayers[_relayer] = false;\r\n        emit RelayerUninstalled(_relayer);\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for a contract that can be locked\r\n */\r\ninterface ILockable {\r\n    /**\r\n     * This contract considers itself to be in a \"locked\" state\r\n     */\r\n    function isLocked() external view returns(bool);\r\n}\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * NOTE: This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n Ã· 2 + 1, and for v in (282): v âˆˆ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n\r\n// @author Patrick McCorry and Chris Buckland (PISA Research)\r\n// @title Adjudicator: Fraud Proofs\r\n// @notice We have three contracts.\r\n// - Relay: Used by the relayer to submit responses.\r\n//   It inherits the DataRegistry to manage temporarily storage of records.\r\n// - Adjudicators: Accepts receipts (relay transactions signed by the relayer) and handles the customer's dispute process.\r\n//   If the relayer fails to provide a quality of service, then it must compensate the customer in a timely manner.\r\n// - LockableDeposit: Holds the relayer's security deposit. It will look up the adjudicator to determine\r\n//   if the deposit should be locked or released to the relayer.\r\n// The contracts ensure that our relayers are financially accountable and\r\n// that evidence/logs are automatically produced for later use.\r\n// @dev Dependency on the DataRegistry and Relayer contract\r\ncontract Adjudicator is RelayTxStruct, ILockable, Initializable {\r\n\r\n    using ECDSA for bytes32;\r\n\r\n    // Lock external deposits when relayer fails to compensate the user.\r\n    bool private locked;\r\n    function isLocked() override public view returns(bool) {\r\n        return locked;\r\n    }\r\n\r\n    // NONE = No compensation required,\r\n    // PENDING = User is waiting for compensation,\r\n    // COMPENSATED = Compensation issued by relayer,\r\n    // RESOLVED = User has claimed compensation,\r\n    // No need for \"locked\" as there is a dedicated value defined above.\r\n    enum CompensationStatus { NONE, PENDING, COMPENSATED, RESOLVED }\r\n\r\n    // Given an appointment, has the compensation been issued?\r\n    // We keep it around forever - should not be that many.\r\n    mapping(bytes32 => CompensationRecord) public compensationRecords;\r\n\r\n    // Required for looking up responses\r\n    Relay public relay;\r\n    address public receiptSigner; // All receipts are signed by this key.\r\n\r\n    // Time (blocks) to issue a compensation.\r\n    uint public compensationPeriod;\r\n\r\n    struct CompensationRecord {\r\n        CompensationStatus status; // Defaults to CompensationStatus.NONE\r\n        uint deadline; // User must be compensated by (or on) this block height\r\n    }\r\n\r\n    event RequestCompensation(bytes32 indexed relayTxId, address user, uint compensation, uint deadline);\r\n    event CompensationIssued(bytes32 indexed relayTxId, address relayer, address user, uint compensation);\r\n    event Locked();\r\n\r\n    // @param _relay Relay contract\r\n    // @param _receiptSigner Receipt signer\r\n    // @param _compensationPeriod Issue compensation grace period (number of blocks)\r\n    function initialize(Relay _relay, address _receiptSigner, uint _compensationPeriod) initializer public {\r\n        relay = _relay;\r\n        compensationPeriod = _compensationPeriod;\r\n        receiptSigner = _receiptSigner;\r\n    }\r\n    \r\n    // @param _relayTx RelayTx with the relay transaction\r\n    // @param _sig Relayer's signature for the relay tx.\r\n    // @Dev User can submit a receipt (relay tx + relayer sig) by the relayer and this contract will verify if the\r\n    // relayed transaction was performed. If not, it triggers the compensation process for the customer.\r\n    function requestCompensation(RelayTx memory _relayTx, bytes memory _sig) public {\r\n\r\n        require(_relayTx.relay == address(relay), \"Mismatching relay address in the relay tx.\");\r\n        require(block.number > _relayTx.deadline, \"The relayer still has time to finish the job.\");\r\n        require(_relayTx.compensation != 0, \"No compensation promised to customer in relay tx.\");\r\n\r\n        // All logs are recorded in the Relay's DataRegistry. It has two shards and each shard\r\n        // will be used for a fixed time INTERVAL. Why? We do not want to store lots forever in Ethereum.\r\n        // Let's consider a simple example.\r\n        // - All records are stored in shard1 during interval T1 -> T2.\r\n        // - All records are stored in shard2 during interval T2 -> T3.\r\n        // - When we re-visit shard1 during interval T3 -> T4, we will DELETE the shard and RECREATE it.\r\n        // - When we re-visit shard2 during interval T4 -> T5, we will DELETE the shard and RECREATE it.\r\n        // So the \"minimum\" life-time for a record is a single interval.\r\n        // If we set the record just before the end of T3, then it will be reset at the start of T5.\r\n        // Thus the record only remains in Ethereum it  during T3 -> T4.\r\n\r\n        // For us to stay secure, all receipts must satisfy the condition:\r\n        // INTERVAL > [time for anysender to do job] + [time for customer to provide evidence]\r\n        // So we allocate INTERVAL/2 = [time for customer to provide evidence]\r\n        // And [time for anysender to do job] must NEVER be greater than INTERVAL/2.\r\n        // In practice, the DataRegistry should be 30 days or more, so we are unlikely to accept a job\r\n        // longer than 60 days to relay.\r\n        uint intervalHalf = relay.getInterval()/2;\r\n\r\n        // Overflow is not an issue as .deadline must be a larger number (i.e. overflowing to 1 does not benefit attack).\r\n        require(_relayTx.deadline + intervalHalf > block.number, \"Record may no longer exist in the registry.\");\r\n\r\n        // We keep a log of all successful compensation records. It should be few, so lets prevent double-compensation.\r\n        bytes32 relayTxId = computeRelayTxId(_relayTx);\r\n        require(compensationRecords[relayTxId].status == CompensationStatus.NONE, \"Cannot request compensation twice.\");\r\n\r\n        // Relayer must have signed and accepted the job.\r\n        // Note: We don't need the user's signature due to how the relayTxId is constructed.\r\n        // i.e. a relayer cannot tamper with it and if they broadcast it early they just hurt themselves.\r\n        require(receiptSigner == relayTxId.toEthSignedMessageHash().recover(_sig), \"Relayer did not sign the receipt.\");\r\n\r\n        // Look up if the relayer responded in the DataRegistry\r\n        require(!checkDataRegistryRecord(relayTxId, _relayTx.deadline), \"No compensation as relay transaction was completed in time.\");\r\n\r\n        compensationRecords[relayTxId].status = CompensationStatus.PENDING;\r\n        compensationRecords[relayTxId].deadline = block.number + compensationPeriod;\r\n\r\n        emit RequestCompensation(relayTxId, _relayTx.from, _relayTx.compensation, compensationRecords[relayTxId].deadline);\r\n    }\r\n\r\n    // @param _relayTxId Unique identification hash for relay tx\r\n    // @param _deadline Expiry time from relay tx\r\n    // @dev The DataRegistry records when the relay tx was submitted (block number).\r\n    //      So we only care about the earliest record in a shard.\r\n    function checkDataRegistryRecord(bytes32 _relayTxId, uint _deadline) internal view returns (bool) {\r\n        // Look through every shard (should only be two)\r\n        uint shards = relay.getTotalShards();\r\n        for(uint i=0; i<shards; i++) {\r\n\r\n            // Relay's DataRegistry only stores timestamp.\r\n            uint response = relay.fetchRecord(i, _relayTxId);\r\n\r\n            // It cannot be 0 as this implies no response at all!\r\n            if(response > 0) {\r\n\r\n                // We should find one response before the deadline\r\n                if(_deadline >= response) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n       // No response.\r\n       return false;\r\n    }\r\n\r\n    // @param _relayTx Relay tx has the compensation information.\r\n    // @dev Relayer sends compensation to the user based on the compensation amount set in the relay tx.\r\n    function issueCompensation(RelayTx memory _relayTx) public payable {\r\n        bytes32 relayTxId = computeRelayTxId(_relayTx);\r\n        require(compensationRecords[relayTxId].status == CompensationStatus.PENDING, \"Compensation record must be in PENDING mode.\");\r\n        require(_relayTx.compensation == msg.value, \"Relayer must compensate the exact value.\");\r\n        compensationRecords[relayTxId].status = CompensationStatus.COMPENSATED;\r\n        emit CompensationIssued(relayTxId, msg.sender, _relayTx.from, msg.value);\r\n    }\r\n\r\n    // @param _relayTx Relay tx has the compensation information.\r\n    // @dev User can withdraw the compensation after it was issued by the relayer (in issueCompensation()).\r\n    function withdrawCompensation(RelayTx memory _relayTx) public {\r\n        bytes32 relayTxId = computeRelayTxId(_relayTx);\r\n        require(compensationRecords[relayTxId].status == CompensationStatus.COMPENSATED, \"Compensation record must be in COMPENSATED mode.\");\r\n        compensationRecords[relayTxId].status = CompensationStatus.RESOLVED;\r\n        uint toSend = _relayTx.compensation;\r\n        _relayTx.from.transfer(toSend);\r\n    }\r\n\r\n    // @param _relayTx Relay tx to lock this adjudicator\r\n    // Called by the user if their compensation is not issued in a timely manner.\r\n    function lock(RelayTx memory _relayTx) public {\r\n        bytes32 relayTxId = computeRelayTxId(_relayTx);\r\n        require(compensationRecords[relayTxId].status == CompensationStatus.PENDING, \"CompensationStatus must still be PENDING.\");\r\n        require(block.number > compensationRecords[relayTxId].deadline, \"Deadline for compensation must have passed.\");\r\n\r\n        // damnation.ðŸ˜±\r\n        locked = true;\r\n        emit Locked();\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"relayTxId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"}],\"name\":\"CompensationIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"relayTxId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"RequestCompensation\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"compensationPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"compensationRecords\",\"outputs\":[{\"internalType\":\"enum Adjudicator.CompensationStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"relay\",\"type\":\"address\"}],\"internalType\":\"struct RelayTxStruct.RelayTx\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"computeRelayTxId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Relay\",\"name\":\"_relay\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiptSigner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_compensationPeriod\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"relay\",\"type\":\"address\"}],\"internalType\":\"struct RelayTxStruct.RelayTx\",\"name\":\"_relayTx\",\"type\":\"tuple\"}],\"name\":\"issueCompensation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"relay\",\"type\":\"address\"}],\"internalType\":\"struct RelayTxStruct.RelayTx\",\"name\":\"_relayTx\",\"type\":\"tuple\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiptSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relay\",\"outputs\":[{\"internalType\":\"contract Relay\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"relay\",\"type\":\"address\"}],\"internalType\":\"struct RelayTxStruct.RelayTx\",\"name\":\"_relayTx\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"requestCompensation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"relay\",\"type\":\"address\"}],\"internalType\":\"struct RelayTxStruct.RelayTx\",\"name\":\"_relayTx\",\"type\":\"tuple\"}],\"name\":\"withdrawCompensation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Adjudicator","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://712f3337df5c1c36500202b62272f103fe1c4fe64222a5fb0b662039cd014962"}]}