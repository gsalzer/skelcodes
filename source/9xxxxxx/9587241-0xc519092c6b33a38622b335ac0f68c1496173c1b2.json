{"status":"1","message":"OK","result":[{"SourceCode":"{\"Covenant.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.6.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract Covenant is Ownable {\\r\\n\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  event NewSignatureAdded(uint sigId, string sigName, bool sigIsRV);\\r\\n  event SignatureDeleted(uint sigId, string sigName, bool sigIsRV);\\r\\n  \\r\\n  string covenantText;\\r\\n  \\r\\n  struct Signature {\\r\\n    string sigName;\\r\\n    bool sigIsRV;\\r\\n  }\\r\\n\\r\\n  Signature[] public Signatures;\\r\\n\\r\\n  function commitCovenantText(string calldata _covenantText) external onlyOwner {\\r\\n    covenantText = _covenantText;\\r\\n  }\\r\\n\\r\\n  function addSignature(string calldata _sigName, bool _sigType) external onlyOwner {\\r\\n    uint sigId = Signatures.push(Signature(_sigName, _sigType)) - 1;\\r\\n    emit NewSignatureAdded(sigId, _sigName, _sigType);\\r\\n  }\\r\\n\\r\\n  function upgradeSignature(string calldata _sigName) external onlyOwner {\\r\\n    for (uint i = 0; i \\u003c Signatures.length; i++) {\\r\\n      if (keccak256(abi.encodePacked(Signatures[i].sigName)) == keccak256(abi.encodePacked(_sigName))) {\\r\\n        Signatures[i].sigIsRV = true;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  function deleteSignature(string calldata _sigName) external onlyOwner {\\r\\n    for (uint i = 0; i \\u003c Signatures.length; i++) {\\r\\n      if (keccak256(abi.encodePacked(Signatures[i].sigName)) == keccak256(abi.encodePacked(_sigName))) {\\r\\n        bool _sigType = Signatures[i].sigIsRV;\\r\\n        Signatures[i] = Signatures[Signatures.length - 1];\\r\\n        delete Signatures[Signatures.length - 1];\\r\\n        Signatures.length--;\\r\\n        emit SignatureDeleted(i, _sigName, _sigType);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function countRV() external view onlyOwner returns(uint) {\\r\\n    uint counterRV = 0;\\r\\n    for (uint i = 0; i \\u003c Signatures.length; i++) {\\r\\n      if (Signatures[i].sigIsRV == true) {\\r\\n        counterRV++;\\r\\n      }\\r\\n    }\\r\\n    return counterRV;\\r\\n  }\\r\\n\\r\\n  function countNRV() external view onlyOwner returns(uint) {\\r\\n    uint counterNRV = 0;\\r\\n    for (uint i = 0; i \\u003c Signatures.length; i++) {\\r\\n      if (Signatures[i].sigIsRV == false) {\\r\\n        counterNRV++;\\r\\n      }\\r\\n    }\\r\\n    return counterNRV;\\r\\n  }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.6.0;\\r\\n\\r\\n/**\\r\\n* @title Ownable\\r\\n* @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n* functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n*/\\r\\ncontract Ownable {\\r\\n  address private _owner;\\r\\n\\r\\n  event OwnershipTransferred(\\r\\n    address indexed previousOwner,\\r\\n    address indexed newOwner\\r\\n  );\\r\\n\\r\\n  /**\\r\\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n  * account.\\r\\n  */\\r\\n  constructor() internal {\\r\\n    _owner = msg.sender;\\r\\n    emit OwnershipTransferred(address(0), _owner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @return the address of the owner.\\r\\n  */\\r\\n  function owner() public view returns(address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Throws if called by any account other than the owner.\\r\\n  */\\r\\n  modifier onlyOwner() {\\r\\n    require(isOwner());\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @return true if `msg.sender` is the owner of the contract.\\r\\n  */\\r\\n  function isOwner() public view returns(bool) {\\r\\n    return msg.sender == _owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Allows the current owner to relinquish control of the contract.\\r\\n  * @notice Renouncing to ownership will leave the contract without an owner.\\r\\n  * It will not be possible to call the functions with the `onlyOwner`\\r\\n  * modifier anymore.\\r\\n  */\\r\\n  function renounceOwnership() public onlyOwner {\\r\\n    emit OwnershipTransferred(_owner, address(0));\\r\\n    _owner = address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n  * @param newOwner The address to transfer ownership to.\\r\\n  */\\r\\n  function transferOwnership(address newOwner) public onlyOwner {\\r\\n    _transferOwnership(newOwner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Transfers control of the contract to a newOwner.\\r\\n  * @param newOwner The address to transfer ownership to.\\r\\n  */\\r\\n  function _transferOwnership(address newOwner) internal {\\r\\n    require(newOwner != address(0));\\r\\n    emit OwnershipTransferred(_owner, newOwner);\\r\\n    _owner = newOwner;\\r\\n  }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.6.0;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, throws on overflow.\\r\\n  */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint256 c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers, truncating the quotient.\\r\\n  */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    assert(b \\u003c= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, throws on overflow.\\r\\n  */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    assert(c \\u003e= a);\\r\\n    return c;\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title SafeMath32\\r\\n * @dev SafeMath library implemented for uint32\\r\\n */\\r\\nlibrary SafeMath32 {\\r\\n\\r\\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint32 c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n    uint32 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n    assert(b \\u003c= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n    uint32 c = a + b;\\r\\n    assert(c \\u003e= a);\\r\\n    return c;\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title SafeMath16\\r\\n * @dev SafeMath library implemented for uint16\\r\\n */\\r\\nlibrary SafeMath16 {\\r\\n\\r\\n  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint16 c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function div(uint16 a, uint16 b) internal pure returns (uint16) {\\r\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n    uint16 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\\r\\n    assert(b \\u003c= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  function add(uint16 a, uint16 b) internal pure returns (uint16) {\\r\\n    uint16 c = a + b;\\r\\n    assert(c \\u003e= a);\\r\\n    return c;\\r\\n  }\\r\\n}\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sigId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sigName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sigIsRV\",\"type\":\"bool\"}],\"name\":\"NewSignatureAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sigId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sigName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sigIsRV\",\"type\":\"bool\"}],\"name\":\"SignatureDeleted\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Signatures\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sigName\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"sigIsRV\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_sigName\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_sigType\",\"type\":\"bool\"}],\"name\":\"addSignature\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_covenantText\",\"type\":\"string\"}],\"name\":\"commitCovenantText\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countNRV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countRV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_sigName\",\"type\":\"string\"}],\"name\":\"deleteSignature\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_sigName\",\"type\":\"string\"}],\"name\":\"upgradeSignature\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Covenant","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://c13348d8e3b5c106eebf4381a1e93975c3742b794be5e8531dbb1f9879a0c02d"}]}