{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-04-17\r\n*/\r\n\r\npragma solidity ^0.5.10;\r\n\r\n// Golden Ratio Token Time Lock contract\r\n// \r\n// Token Project Website: https://goldenratiotoken.site\r\n// Time Lock Website: https://sovcube.com\r\n// \r\n// DO NOT SEND TOKENS DIRECTLY TO THIS CONTRACT!!!\r\n// THEY WILL BE LOST FOREVER!!!\r\n//\r\n// For instructions on how to use this contract, please see https://sovcube.com\r\n//\r\n// This contract locks all GRT for 365 days counting from the day the contract is deployed. Tokens can be added\r\n// within that period without resetting the timer.\r\n//\r\n// After the desired date is reached, users can withdraw tokens with a rate limit to prevent all holders\r\n// from withdrawing and selling at the same time. The limit is 1 GRT per week once the 365 days is hit.\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns(uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns(uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns(uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns(uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns(uint);\r\n    function balanceOf(address tokenOwner) public view returns(uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns(uint remaining);\r\n    function transfer(address to, uint tokens) public returns(bool success);\r\n    function approve(address spender, uint tokens) public returns(bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns(bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract LockMyTokens {\r\n\r\n    using SafeMath for uint;\r\n    \r\n    address constant tokenContract = 0xE6DC77fA9886e12774CB2c4ECd3dcc6E66750a45;\r\n    uint constant PRECISION = 1000000000000000000;\r\n    uint constant timeUntilUnlocked = 365 days;         // All tokens locked for 1 year after contract creation.\r\n    uint constant maxWithdrawalAmount = 1 * PRECISION;  // Max withdrawal of 1 token per week per user once 1 year is hit.\r\n    uint constant timeBetweenWithdrawals = 7 days;\r\n    uint unfreezeDate;\r\n\r\n\tmapping (address => uint) balance;\r\n\tmapping (address => uint) lastWithdrawal;\r\n\r\n    event TokensFrozen (\r\n        address indexed addr,\r\n        uint256 amt,\r\n        uint256 time\r\n\t);\r\n\r\n    event TokensUnfrozen (\r\n        address indexed addr,\r\n        uint256 amt,\r\n        uint256 time\r\n\t);\r\n\r\n    constructor() public {\r\n        unfreezeDate = now + timeUntilUnlocked;\r\n    }\r\n\r\n    function withdraw(uint _amount) public {\r\n        require(balance[msg.sender] >= _amount, \"You do not have enough tokens!\");\r\n        require(now >= unfreezeDate, \"Tokens are locked!\");\r\n        require(_amount <= maxWithdrawalAmount, \"Trying to withdraw too much at once!\");\r\n        require(now >= lastWithdrawal[msg.sender] + timeBetweenWithdrawals, \"Trying to withdraw too frequently!\");\r\n        require(ERC20Interface(tokenContract).transfer(msg.sender, _amount), \"Could not withdraw tokens!\");\r\n\r\n        balance[msg.sender] -= _amount;\r\n        lastWithdrawal[msg.sender] = now;\r\n        emit TokensUnfrozen(msg.sender, _amount, now);\r\n    }\r\n\r\n    function getBalance(address _addr) public view returns (uint256 _balance) {\r\n        return balance[_addr];\r\n    }\r\n    \r\n    function getLastWithdrawal(address _addr) public view returns (uint256 _lastWithdrawal) {\r\n        return lastWithdrawal[_addr];\r\n    }\r\n   \r\n    function getTimeLeft() public view returns (uint256 _timeLeft) {\r\n        require(unfreezeDate > now, \"The future is here!\");\r\n        return unfreezeDate - now;\r\n    } \r\n    \r\n    function onApprovalReceived(address _sender, uint256 _value, bytes memory _extraData) public returns(bytes4) {\r\n        require(msg.sender == tokenContract, \"Can only deposit GRT into this contract!\");\r\n        require(ERC20Interface(tokenContract).transferFrom(_sender, address(this), _value), \"Could not transfer GRT to Time Lock contract address.\");\r\n\r\n        balance[_sender] += _value;\r\n        emit TokensFrozen(_sender, _value, now);\r\n        return 0x7b04a2d0;\r\n    }\r\n    \r\n    function onTransferReceived(address _operator, address _sender, uint256 _value, bytes memory _extraData) public returns(bytes4) {\r\n        require(msg.sender == tokenContract, \"Can only deposit GRT into this contract!\");\r\n\r\n        balance[_sender] += _value;\r\n        emit TokensFrozen(_sender, _value, now);\r\n        return 0x88a7ca5c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getLastWithdrawal\",\"outputs\":[{\"name\":\"_lastWithdrawal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onApprovalReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onTransferReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"_timeLeft\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TokensFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TokensUnfrozen\",\"type\":\"event\"}]","ContractName":"LockMyTokens","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://cac85c48ec82ee537d79faaeee90dca6bd1d088b0fb3e74233d06d2b73c4cbf5"}]}