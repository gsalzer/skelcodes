{"status":"1","message":"OK","result":[{"SourceCode":"{\"ActionBzxPtokenBurnToToken.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./GelatoActionsStandard.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IBzxPtoken.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\ncontract ActionBzxPtokenBurnToToken is GelatoActionsStandard {\\n    // using SafeERC20 for IERC20; \\u003c- internal library methods vs. try/catch\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // actionSelector public state variable np due to this.actionSelector constant issue\\n    function actionSelector() external pure override returns(bytes4) {\\n        return this.action.selector;\\n    }\\n    uint256 public constant override actionGas = 4200000;\\n\\n    function action(\\n        // Standard Action Params\\n        address _user,  // \\\"receiver\\\"\\n        address _userProxy,\\n        address _sendToken,  // pToken\\n        uint256 _sendAmt,\\n        // Specific Action Params\\n        address _receiveToken\\n    )\\n        external\\n        virtual\\n    {\\n        require(address(this) == _userProxy, \\\"ActionBzxPtokenBurnToToken: ErrorUserProxy\\\");\\n\\n        IERC20 sendToken = IERC20(_sendToken);  // pToken!\\n        try sendToken.transferFrom(_user, _userProxy, _sendAmt) {} catch {\\n           revert(\\\"ErrorTransferFromPToken\\\");\\n        }\\n\\n        // !! Dapp Interaction !!\\n        try IBzxPtoken(_sendToken).burnToToken(\\n            _user,  // receiver\\n            _receiveToken,\\n            _sendAmt,\\n            0 // minPriceAllowed - 0 ignores slippage\\n        )\\n            returns(uint256 receiveAmt)\\n        {\\n            emit LogTwoWay(\\n                _user, // origin\\n                _sendToken,  // pToken\\n                _sendAmt,\\n                address(0),  // destination pToken -\\u003e burn\\n                _receiveToken,\\n                receiveAmt,\\n                _user  // receiver\\n            );\\n        } catch {\\n           revert(\\\"ErrorPtokenBurnToToken\\\");\\n        }\\n    }\\n\\n    // ======= ACTION CONDITIONS CHECK =========\\n    // Overriding and extending GelatoActionsStandard\\u0027s function (optional)\\n    function actionConditionsCheck(bytes calldata _actionPayloadWithSelector)\\n        external\\n        view\\n        override\\n        virtual\\n        returns(string memory)  // actionCondition\\n    {\\n        (address _user, address _userProxy, address _sendToken, uint256 _sendAmt) = abi.decode(\\n            _actionPayloadWithSelector[4:132],\\n            (address,address,address,uint256)\\n        );\\n        return _actionConditionsCheck(_user, _userProxy, _sendToken, _sendAmt);\\n    }\\n\\n    function _actionConditionsCheck(\\n        address _user,\\n        address _userProxy,\\n        address _sendToken,\\n        uint256 _sendAmt\\n    )\\n        internal\\n        view\\n        virtual\\n        returns(string memory)  // actionCondition\\n    {\\n        if (!_isUserOwnerOfUserProxy(_user, _userProxy))\\n            return \\\"ActionBzxPtokenBurnToToken: NotOkUserProxyOwner\\\";\\n\\n        if(!_sendToken.isContract())\\n            return \\\"ActionBzxPtokenBurnToToken: NotOkPTokenAddress\\\";\\n\\n        IERC20 sendToken = IERC20(_sendToken);  // pToken!\\n        try sendToken.balanceOf(_user) returns(uint256 userPtokenBalance) {\\n            if (userPtokenBalance \\u003c _sendAmt)\\n                return \\\"ActionBzxPtokenBurnToToken: NotOkUserPtokenBalance\\\";\\n        } catch {\\n            return \\\"ActionBzxPtokenBurnToToken: ErrorBalanceOf\\\";\\n        }\\n        try sendToken.allowance(_user, _userProxy) returns(uint256 userProxyPtokenAllowance) {\\n            if (userProxyPtokenAllowance \\u003c _sendAmt)\\n                return \\\"ActionBzxPtokenBurnToToken: NotOkUserProxyPtokenAllowance\\\";\\n        } catch {\\n            return \\\"ActionBzxPtokenBurnToToken: ErrorAllowance\\\";\\n        }\\n\\n        // STANDARD return string to signal actionConditions Ok\\n        return \\\"ok\\\";\\n    }\\n\\n\\n    // ============ API for FrontEnds ===========\\n    function getUsersSendTokenBalance(\\n        // Standard Action Params\\n        address _user,  // \\\"receiver\\\"\\n        address _userProxy,\\n        // Specific Action Params\\n        address _sendToken,\\n        uint256,\\n        address\\n    )\\n        external\\n        view\\n        virtual\\n        returns(uint256)\\n    {\\n        _userProxy;  // silence warning\\n        IERC20 sendToken = IERC20(_sendToken);\\n        try sendToken.balanceOf(_user) returns(uint256 userPTokenBalance) {\\n            return userPTokenBalance;\\n        } catch {\\n            revert(\\n                \\\"Error: ActionBzxPtokenBurnToToken.getUsersSendTokenBalance: balanceOf: balanceOf\\\"\\n            );\\n        }\\n    }\\n}\\n\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"},\"GelatoActionsStandard.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./IGelatoAction.sol\\\";\\nimport \\\"./IGelatoUserProxy.sol\\\";\\n\\n/// @title GelatoActionsStandard\\n/// @dev find all the NatSpecs inside IGelatoAction\\nabstract contract GelatoActionsStandard is IGelatoAction {\\n\\n    event LogOneWay(\\n        address origin,\\n        address sendToken,\\n        uint256 sendAmount,\\n        address destination\\n    );\\n\\n    event LogTwoWay(\\n        address origin,\\n        address sendToken,\\n        uint256 sendAmount,\\n        address destination,\\n        address receiveToken,\\n        uint256 receiveAmount,\\n        address receiver\\n    );\\n\\n    /* CAUTION: all actions must have their action() function according to the\\n    following standard format:\\n        function action(\\n            address _user,\\n            address _userProxy,\\n            address _source,\\n            uint256 _sourceAmount,\\n            address _destination,\\n            ...\\n        )\\n            external;\\n    action function not defined here because non-overridable, due to\\n    different arguments passed across different actions\\n    */\\n\\n    function actionConditionsCheck(bytes calldata)  // _actionPayloadWithSelector\\n        external\\n        view\\n        override\\n        virtual\\n        returns(string memory)  // actionCondition\\n    {\\n        this;\\n        // Standard return value for actionConditions fulfilled and no erros:\\n        return \\\"ok\\\";\\n    }\\n\\n    /// All actions must override this with their own implementation\\n    /*function getUsersSendTokenBalance(\\n        address _user,\\n        address _userProxy,\\n        address _source,\\n        uint256 _sourceAmount,\\n        address _destination,\\n        ...\\n    )\\n        external\\n        view\\n        override\\n        virtual\\n        returns(uint256 userSrcBalance);\\n    getUsersSendTokenBalance not defined here because non-overridable, due to\\n    different arguments passed across different actions\\n    */\\n\\n    function _isUserOwnerOfUserProxy(address _user, address _userProxy)\\n        internal\\n        view\\n        virtual\\n        returns(bool)\\n    {\\n        address owner = IGelatoUserProxy(_userProxy).user();\\n        return _user == owner;\\n    }\\n}\\n\"},\"GelatoCoreEnums.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nabstract contract GelatoCoreEnums {\\n\\n    enum CanExecuteResults {\\n        ExecutionClaimAlreadyExecutedOrCancelled,\\n        ExecutionClaimNonExistant,\\n        ExecutionClaimExpired,\\n        WrongCalldata,  // also returns if a not-selected executor calls fn\\n        ConditionNotOk,\\n        UnhandledConditionError,\\n        Executable\\n    }\\n\\n    // Not needed atm due to revert with string memory reason\\n    /* enum ExecutionResults {\\n        ActionGasNotOk,\\n        ActionNotOk,  // Mostly for caught/handled (by action) action errors\\n        DappNotOk,  // Mostly for caught/handled (by action) dapp errors\\n        UnhandledActionError,\\n        UnhandledUserProxyError,\\n        Success\\n    } */\\n\\n    enum StandardReason { Ok, NotOk, UnhandledError }\\n}\"},\"IBzxPtoken.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\ninterface IBzxPtoken {\\n\\n    // Margin Trading - pTokens\\n\\n    // === State-Changing Functions ====\\n    // https://docs.bzx.network/fulcrum-integration/trading-borrowing#state-changing-functions\\n\\n\\n    /**\\n     * @notice Deposit assets to the pToken, which in turn mints pTokens\\n        to the lender’s wallet at the current tokenPrice() rate.\\n     * @dev Prior ERC20 depositToken.approve(pTokenContractAddr, depositAmount) needed\\n     * @param receiver address that will receive the minted pTokens.\\n     * @param depositTokenAddress  Any supported KyberToken.  However, specifying\\n        a token other the asset returned by the loanTokenAddress() function will\\n        trigger a KyberSwap into the correct asset, being subject to any trade slippage\\n        that may occur.\\n     * @param depositAmount you can cap it at loanToken\\n     * @param maxPriceAllowed A slippage limit on the payout rate of the pTokens minted.\\n        This should be set to a value above the current price returned by `tokenPrice()`.\\n        A value of 0 is ignored.  ** footnote 1\\n     */\\n    function mintWithToken(\\n        address receiver,\\n        address depositTokenAddress,\\n        uint256 depositAmount,\\n        uint256 maxPriceAllowed\\n    )\\n        external\\n        returns (uint256);\\n\\n    // function mintWithEther() omitted because requires GelatoUserProxy to store ETH\\n\\n\\n    /**\\n    * @notice Called to redeem owned pTokens for an equivalent amount of the\\n    underlying asset based on remaining collateral, unpaid interest, and including\\n    any profits or losses on the position, at the current tokenPrice() rate.\\n    * @param receiver address that will receive the asset proceeds.\\n    * @param burnTokenAddress address of the asset receiver should get for pTokens burnt\\n    * @param burnAmount amount of pTokens to burn\\n    * @param minPriceAllowed Slippage limit - should be set to value below current price\\n       returnded by `tokenPrice()`. A value of 0 is ignored.\\n    */\\n    function burnToToken(\\n        address receiver,\\n        address burnTokenAddress,\\n        uint256 burnAmount,\\n        uint256 minPriceAllowed\\n    )\\n        external\\n        returns (uint256);\\n\\n    /**\\n    * @notice Called to redeem owned pTokens for an equivalent amount of ETH\\n       based on remaining collateral, unpaid interest, and including\\n       any profits or losses on the position, at the current tokenPrice() rate.\\n    * @param receiver address that will receive the asset proceeds.\\n    * @param burnAmount amount of pTokens to burn\\n    * @param minPriceAllowed Slippage limit - should be set to value below current price\\n       returnded by `tokenPrice()`. A value of 0 is ignored.\\n    */\\n    function burnToEther(\\n        address payable receiver,\\n        uint256 burnAmount,\\n        uint256 minPriceAllowed\\n    )\\n        external\\n        returns (uint256);\\n\\n    // === Read-Only Functions ====\\n    // https://docs.bzx.network/fulcrum-integration/trading-borrowing#read-only-functions\\n\\n    /// @notice Returns the address of the token that will be leveraged\\n    /// @dev if the depositTokenAddress != loanTokenAddress of pToken, a Kyber Swap\\n    ///  is triggered to convert depositToken into loanToken =\\u003e more gas costs than\\n    ///  if depositTokenAddress == loanTokenAddress.\\n    function loanTokenAddress() external view returns(address);\\n\\n    /// @notice Returns the current price of the pToken.\\n    /// Example: 1000000000000000000000 = 1 ETH per pToken\\n    function tokenPrice() external view returns (uint256 price);\\n\\n    /// @notice Returns price at which the underlying position should be liquidated\\n    ///  by the bZx protocol, or 0 if no position is open.\\n    function liquidationPrice() external view returns (uint256 price);\\n\\n\\n    /// @notice Returns the token price recorded during the last checkpoint for the user.\\n    ///  Checkpoints occur whenever there is a token balance changing action taken by\\n    ///   the user (minting, burning, or transferring).\\n    /// User profit since last checkpoint formula:\\n    ///  (tokenPrice() - checkpointPrice(user)) * balanceOf(user) / 10^36\\n    function checkpointPrice(address _user) external view returns (uint256 price);\\n\\n\\n    /// @notice marketLiquidityForLoan() will tell you the largest amount\\n    ///  you can deposit to mint pTokens based on available liquidity in the lending pools\\n    function marketLiquidityForLoan() external view returns(uint256 maxDepositAmount);\\n\\n    /// @notice Returns the owner\\u0027s balance of the underlying asset.\\n    /// @dev Identical to: pToken.balanceOf(_owner) * tokenPrice()\\n    function assetBalanceOf(address _owner) external view returns (uint256);\\n}\\n\\n/** Footnotes\\n\\ndepositA\\n\\nmaxPriceAllowed: maxPriceAllowed is to regulate the changes in tokenPrice() between\\n when it\\u0027s first queried off-chain, and when it\\u0027s mined later. it doesn\\u0027t really have\\n relevance if you query it during a transaction, then submit the mint\\n\\n*/\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IGelatoAction.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/// @title IGelatoAction - solidity interface of GelatoActionsStandard\\n/// @notice all the APIs and events of GelatoActionsStandard\\n/// @dev all the APIs are implemented inside GelatoActionsStandard\\ninterface IGelatoAction {\\n    function actionSelector() external pure returns(bytes4);\\n    function actionGas() external pure returns(uint256);\\n\\n    /* CAUTION: all actions must have their action() function according to the\\n    following standard format:\\n        function action(\\n            address _user,\\n            address _userProxy,\\n            address _source,\\n            uint256 _sourceAmount,\\n            address _destination,\\n            ...\\n        )\\n            external;\\n    action function not defined here because non-overridable, due to\\n    different arguments passed across different actions\\n    */\\n\\n    /**\\n     * @notice Returns whether the action-specific conditions are fulfilled\\n     * @dev if actions have specific conditions they should override and extend this fn\\n     * @param _actionPayloadWithSelector: the actionPayload (with actionSelector)\\n     * @return actionCondition\\n     */\\n    function actionConditionsCheck(bytes calldata _actionPayloadWithSelector)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// All actions must override this with their own implementation\\n    /*function getUsersSendTokenBalance(\\n        address _user,\\n        address _userProxy,\\n        address _source,\\n        uint256 _sourceAmount,\\n        address _destination,\\n        ...\\n    )\\n        external\\n        view\\n        override\\n        virtual\\n        returns(uint256 userSrcBalance);\\n    getUsersSendTokenBalance not defined here because non-overridable, due to\\n    different arguments passed across different actions\\n    */\\n}\"},\"IGelatoUserProxy.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./IGelatoAction.sol\\\";\\nimport \\\"./GelatoCoreEnums.sol\\\";\\n\\n/// @title IGelatoUserProxy - solidity interface of GelatoConditionsStandard\\n/// @notice GelatoUserProxy.execute() API called by gelatoCore during .execute()\\n/// @dev all the APIs are implemented inside GelatoUserProxy\\ninterface IGelatoUserProxy {\\n    function callAccount(address, bytes calldata) external payable returns(bool, bytes memory);\\n    function delegatecallAccount(address, bytes calldata) external payable returns(bool, bytes memory);\\n\\n    function delegatecallGelatoAction(\\n        IGelatoAction _action,\\n        bytes calldata _actionPayloadWithSelector,\\n        uint256 _actionGas\\n    )\\n        external\\n        payable;\\n\\n    function user() external view returns(address);\\n    function gelatoCore() external view returns(address);\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"LogOneWay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiveToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"LogTwoWay\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sendAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiveToken\",\"type\":\"address\"}],\"name\":\"action\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_actionPayloadWithSelector\",\"type\":\"bytes\"}],\"name\":\"actionConditionsCheck\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"actionGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"actionSelector\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getUsersSendTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ActionBzxPtokenBurnToToken","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://07ec50928f0ae566a411389f3eded959ddd3fa8ccf10ab12f28664e80b13f5d8"}]}