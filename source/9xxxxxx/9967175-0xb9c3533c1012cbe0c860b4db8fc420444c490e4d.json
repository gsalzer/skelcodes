{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\ninterface IUniswapExchange {\r\n    // Protocol Functions\r\n    function tokenAddress() external view returns (address);\r\n\r\n    function factoryAddress() external view returns (address);\r\n\r\n    // ERC20 Functions (Keep track of liquidity providers)\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        external\r\n        returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    // Pricing functions\r\n    function getEthToTokenInputPrice(uint256 eth_sold)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTokenToEthInputPrice(uint256 tokens_sold)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTokenToEthOutputPrice(uint256 eth_bought)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    // Add Liquidity\r\n    function setup(address token_addr) external;\r\n\r\n    function addLiquidity(\r\n        uint256 min_liquidity,\r\n        uint256 max_tokens,\r\n        uint256 deadline\r\n    ) external payable returns (uint256);\r\n\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline)\r\n        external\r\n        returns (uint256);\r\n\r\n    //Eth/Token Swap\r\n    //Sell all ETH\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256);\r\n\r\n    function ethToTokenTransferInput(\r\n        uint256 min_tokens,\r\n        uint256 deadline,\r\n        address recipient\r\n    ) external payable returns (uint256);\r\n\r\n    //Sell some ETH and get refund\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256);\r\n\r\n    function ethToTokenTransferOutput(\r\n        uint256 tokens_bought,\r\n        uint256 deadline,\r\n        address recipient\r\n    ) external payable returns (uint256);\r\n\r\n    //Token/Eth Swap\r\n    //Sell all tokens\r\n    function tokenToEthSwapInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_eth,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function tokenToEthTransferInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_eth,\r\n        uint256 deadline,\r\n        address recipient\r\n    ) external returns (uint256);\r\n\r\n    //Sell some tokens and get refund\r\n    function tokenToEthSwapOutput(\r\n        uint256 eth_bought,\r\n        uint256 max_tokens,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function tokenToEthTransferOutput(\r\n        uint256 eth_bought,\r\n        uint256 max_tokens,\r\n        uint256 deadline,\r\n        address recipient\r\n    ) external returns (uint256);\r\n\r\n    //Token/Token Swap\r\n    function tokenToTokenSwapInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_tokens_bought,\r\n        uint256 min_eth_bought,\r\n        uint256 deadline,\r\n        address token_addr\r\n    ) external returns (uint256);\r\n\r\n    function tokenToTokenTransferInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_tokens_bought,\r\n        uint256 min_eth_bought,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address token_addr\r\n    ) external returns (uint256);\r\n\r\n    function tokenToTokenSwapOutput(\r\n        uint256 tokens_bought,\r\n        uint256 max_tokens_sold,\r\n        uint256 max_eth_sold,\r\n        uint256 deadline,\r\n        address token_addr\r\n    ) external returns (uint256);\r\n\r\n    function tokenToTokenTransferOutput(\r\n        uint256 tokens_bought,\r\n        uint256 max_tokens_sold,\r\n        uint256 max_eth_sold,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address token_addr\r\n    ) external returns (uint256);\r\n\r\n    //Token/Exchange Swap\r\n    function tokenToExchangeSwapInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_tokens_bought,\r\n        uint256 min_eth_bought,\r\n        uint256 deadline,\r\n        address exchange_addr\r\n    ) external returns (uint256);\r\n\r\n    function tokenToExchangeTransferInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_tokens_bought,\r\n        uint256 min_eth_bought,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address exchange_addr\r\n    ) external returns (uint256);\r\n\r\n    function tokenToExchangeSwapOutput(\r\n        uint256 tokens_bought,\r\n        uint256 max_tokens_sold,\r\n        uint256 max_eth_sold,\r\n        uint256 deadline,\r\n        address exchange_addr\r\n    ) external returns (uint256);\r\n\r\n    function tokenToExchangeTransferOutput(\r\n        uint256 tokens_bought,\r\n        uint256 max_tokens_sold,\r\n        uint256 max_eth_sold,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address exchange_addr\r\n    ) external returns (uint256);\r\n}\r\n\r\ncontract UniswapOTC {\r\n    address public owner;\r\n    address public exchangeAddress;\r\n    address public tokenAddress;\r\n\r\n    uint256 public totalClients;\r\n    address[] public clients;\r\n    mapping (address => bool) public clientExists;\r\n    \r\n    mapping (address => uint256) public clientEthBalances;      //Client ETH balance\r\n    mapping (address => uint256) public clientMinTokens;        //Client Limit Order\r\n    mapping (address => uint256) public clientTokenBalances;    //Client Token balance\r\n    mapping (address => uint256) public clientTokenFees;        //Total OTC Fees\r\n    mapping (address => uint256) public purchaseTimestamp;        //Withdrawal timestamp\r\n    uint256 constant ONE_DAY_SECONDS = 86400;\r\n    uint256 constant FIVE_MINUTE_SECONDS = 300;\r\n    \r\n    mapping(address => bool) public triggerAddresses;           //Bot Trigger Addresses\r\n\r\n    IERC20 token;\r\n    IUniswapExchange exchange;\r\n\r\n    //Min volume values\r\n    uint256 public minEthLimit;     //Min Volume\r\n    uint256 public maxTokenPerEth;  //Min Price\r\n    \r\n    constructor(address _exchangeAddress, uint256 _minEthLimit, uint256 _maxTokenPerEth) public {\r\n        exchange = IUniswapExchange(_exchangeAddress);\r\n        exchangeAddress = _exchangeAddress;\r\n        tokenAddress = exchange.tokenAddress();\r\n        token = IERC20(tokenAddress);\r\n        owner = msg.sender;\r\n        minEthLimit = _minEthLimit;\r\n        maxTokenPerEth = _maxTokenPerEth;\r\n        totalClients = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev OTC Provider. Gives right to fee withdrawal.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Authorized Purchase Trigger addresses for mempool bot.\r\n     */\r\n    modifier onlyTrigger() {\r\n        require(msg.sender == owner || triggerAddresses[msg.sender], \"Unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Trigger Uniswap contract, drains client's ETH balance.\r\n     *      Computes fee as spread between execution price and limit price.\r\n     */\r\n    function executeLimitOrder(address _client, uint256 deadline)\r\n        public\r\n        onlyTrigger\r\n        returns (uint256, uint256)\r\n    {\r\n        //Avoids Uniswap Assert Failure when no liquidity (gas saving)\r\n        require(token.balanceOf(exchangeAddress) > 0, \"No liquidity on Uniswap!\"); //27,055 Gas\r\n\r\n        uint256 ethBalance = clientEthBalances[_client];\r\n        uint256 tokensBought = exchange.getEthToTokenInputPrice(ethBalance);\r\n        uint256 minTokens = clientMinTokens[_client];\r\n\r\n        require(tokensBought >= minTokens, \"Purchase amount below min tokens!\"); //27,055 Gas\r\n\r\n        uint256 spreadFee = tokensBought - minTokens;\r\n        //Tokens bought, set balance 0\r\n        clientEthBalances[_client] = 0; //Reset state\r\n        clientMinTokens[_client] = 0; //Reset state\r\n        clientTokenBalances[_client] += minTokens;  //Add to balance\r\n        clientTokenFees[_client] += spreadFee;      //Add to balance\r\n        purchaseTimestamp[_client] = block.timestamp + ONE_DAY_SECONDS;\r\n\r\n        //Call Uniswap contract\r\n        exchange.ethToTokenSwapInput.value(ethBalance)(\r\n            tokensBought,\r\n            deadline\r\n        );\r\n\r\n        return (minTokens, spreadFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Add Trigger address.\r\n     */\r\n    function setTriggerAddress(address _address, bool _authorized)\r\n        public\r\n        onlyOwner\r\n    {\r\n        triggerAddresses[_address] = _authorized;\r\n    }\r\n\r\n    /**\r\n     * @dev Get max limit price.\r\n     */\r\n    function getMaxTokens(uint256 _etherAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _etherAmount * maxTokenPerEth;\r\n    }\r\n\r\n    /**\r\n     * @dev Fund contract and set limit price (in the form of min purchased tokens).\r\n     * Excess value is refunded to sender in the case of a re-balancing.\r\n     */\r\n    function setLimitOrder(uint256 _tokenAmount, uint256 _etherAmount)\r\n        public\r\n        payable\r\n    {\r\n        require(_etherAmount >= minEthLimit, \"Insufficient ETH volume\");\r\n        require(_tokenAmount <= maxTokenPerEth  * _etherAmount, \"Excessive token per ETH\");\r\n        require(_etherAmount == clientEthBalances[msg.sender] + msg.value, \"Balance must equal purchase eth amount.\");\r\n\r\n        if (!clientExists[msg.sender]) {\r\n            clientExists[msg.sender] = true;\r\n            clients.push(msg.sender);\r\n            totalClients += 1;\r\n        }\r\n        \r\n        //Increment client balance\r\n        clientEthBalances[msg.sender] += msg.value;\r\n        clientMinTokens[msg.sender] = _tokenAmount;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Return if purchase would be autherized at current prices\r\n     */\r\n    function canPurchase(address _client)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        //Avoids Uniswap Assert Failure when no liquidity (gas saving)\r\n        if (token.balanceOf(exchangeAddress) == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 ethBalance = clientEthBalances[_client];\r\n        if (ethBalance == 0) {\r\n            return false;\r\n        }\r\n        \r\n        uint256 tokensBought = exchange.getEthToTokenInputPrice(ethBalance);\r\n        uint256 minTokens = clientMinTokens[_client];\r\n\r\n        //Only minimum amount of tokens\r\n        return tokensBought >= minTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw OTC provider fee tokens.\r\n     */\r\n    function withdrawFeeTokens(address _client) public onlyOwner {\r\n        require(clientTokenFees[_client] > 0, \"No fees!\");\r\n        require(block.timestamp > purchaseTimestamp[_client], \"Wait for client withdrawal.\");\r\n\r\n        uint256 sendFees = clientTokenFees[_client];\r\n        clientTokenFees[_client] = 0;\r\n\r\n        token.transfer(msg.sender, sendFees);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw OTC client purchased tokens.\r\n     */\r\n    function withdrawClientTokens() public {\r\n        require(clientTokenBalances[msg.sender] > 0, \"No tokens!\");\r\n\r\n        uint256 sendTokens = clientTokenBalances[msg.sender];\r\n        clientTokenBalances[msg.sender] = 0;\r\n        purchaseTimestamp[msg.sender] = block.timestamp + FIVE_MINUTE_SECONDS;  //Unlock in 5minutes\r\n\r\n        token.transfer(msg.sender, sendTokens);\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Withdraw OTC client ether.\r\n     */\r\n    function withdrawEther() public {\r\n        require(clientEthBalances[msg.sender] > 0, \"No ETH balance!\");\r\n\r\n        uint256 sendEth = clientEthBalances[msg.sender];\r\n        clientEthBalances[msg.sender] = 0;\r\n\r\n        payable(msg.sender).transfer(sendEth);\r\n    }\r\n\r\n    /**\r\n     * @dev Get eth balance of contract.\r\n     */\r\n    function contractEthBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Get token balance of contract\r\n     */\r\n    function contractTokenBalance() public view returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minEthLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTokenPerEth\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_client\",\"type\":\"address\"}],\"name\":\"canPurchase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clientEthBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clientExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clientMinTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clientTokenBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clientTokenFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"clients\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractEthBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_client\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"executeLimitOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_etherAmount\",\"type\":\"uint256\"}],\"name\":\"getMaxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokenPerEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minEthLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchaseTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_etherAmount\",\"type\":\"uint256\"}],\"name\":\"setLimitOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_authorized\",\"type\":\"bool\"}],\"name\":\"setTriggerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClients\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"triggerAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawClientTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_client\",\"type\":\"address\"}],\"name\":\"withdrawFeeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UniswapOTC","CompilerVersion":"v0.6.1+commit.e6f7d5a4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000730da6e3b948cda993a4bbd58fded7ccc8e820ca0000000000000000000000000000000000000000000000000000005d21dba0000000000000000000000000000000000000000000000000000000000000000208","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://2bce01bc4c059409785abff8e6ef009fe9068cb4a6051c2776ab72b16fa551d5"}]}