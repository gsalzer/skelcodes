{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-01-31\r\n*/\r\n\r\npragma solidity ^0.5.12;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// https://github.com/dapphub/ds-pause\r\ncontract DSPauseAbstract {\r\n    function setOwner(address) public;\r\n    // setAuthority address should conform to DSAuthorityAbstract\r\n    function setAuthority(address) public;\r\n    function setDelay(uint256) public;\r\n    // mapping (bytes32 => bool) public plans;\r\n    function plans(bytes32) public view returns (bool);\r\n    // DSPauseProxyAbstract public proxy;\r\n    function proxy() public view returns (address);\r\n    // uint256 public delay;\r\n    function delay() public view returns (uint256);\r\n    function plot(address, bytes32, bytes memory, uint256) public;\r\n    function drop(address, bytes32, bytes memory, uint256) public;\r\n    function exec(address, bytes32, bytes memory, uint256) public returns (bytes memory);\r\n}\r\n\r\n// https://github.com/makerdao/dss/blob/master/src/jug.sol\r\ncontract JugAbstract {\r\n    // mapping (address => uint) public wards;\r\n    function wards(address) public view returns (uint256);\r\n    function rely(address) external;\r\n    function deny(address) external;\r\n    struct Ilk {\r\n        uint256 duty;\r\n        uint256  rho;\r\n    }\r\n    // mapping (bytes32 => Ilk) public ilks;\r\n    function ilks(bytes32) public view returns (uint256, uint256);\r\n    // VatLike public vat;\r\n    function vat() public view returns (address);\r\n    // address public vow;\r\n    function vow() public view returns (address);\r\n    // uint256 public base;\r\n    function base() public view returns (address);\r\n    // uint256 constant ONE = 10 ** 27;\r\n    function ONE() public view returns (uint256);\r\n    function init(bytes32) external;\r\n    function file(bytes32, bytes32, uint256) external;\r\n    function file(bytes32, uint256) external;\r\n    function file(bytes32, address) external;\r\n    function drip(bytes32) external returns (uint256);\r\n}\r\n\r\n// https://github.com/makerdao/dss/blob/master/src/pot.sol\r\ncontract PotAbstract {\r\n    // mapping (address => uint256) public wards;\r\n    function wards(address) public view returns (uint256);\r\n    function rely(address) external;\r\n    function deny(address) external;\r\n    // mapping (address => uint256) public pie;  // user Savings Dai\r\n    function pie(address) public view returns (uint256);\r\n    // uint256 public Pie;  // total Savings Dai\r\n    function Pie() public view returns (uint256);\r\n    // uint256 public dsr;  // the Dai Savings Rate\r\n    function dsr() public view returns (uint256);\r\n    // uint256 public chi;  // the Rate Accumulator\r\n    function chi() public view returns (uint256);\r\n    // VatAbstract public vat;  // CDP engine\r\n    function vat() public view returns (address);\r\n    // address public vow;  // debt engine\r\n    function vow() public view returns (address);\r\n    // uint256 public rho;  // time of last drip\r\n    function rho() public view returns (uint256);\r\n    // uint256 public live;  // Access Flag\r\n    function live() public view returns (uint256);\r\n    function file(bytes32, uint256) external;\r\n    function file(bytes32, address) external;\r\n    function cage() external;\r\n    function drip() external returns (uint256);\r\n    function join(uint256) external;\r\n    function exit(uint256) external;\r\n}\r\n\r\ncontract VatAbstract {\r\n    // mapping (address => uint) public wards;\r\n    function wards(address) public view returns (uint256);\r\n    function rely(address) external;\r\n    function deny(address) external;\r\n    struct Ilk {\r\n        uint256 Art;   // Total Normalised Debt     [wad]\r\n        uint256 rate;  // Accumulated Rates         [ray]\r\n        uint256 spot;  // Price with Safety Margin  [ray]\r\n        uint256 line;  // Debt Ceiling              [rad]\r\n        uint256 dust;  // Urn Debt Floor            [rad]\r\n    }\r\n    struct Urn {\r\n        uint256 ink;   // Locked Collateral  [wad]\r\n        uint256 art;   // Normalised Debt    [wad]\r\n    }\r\n    // mapping (address => mapping (address => uint256)) public can;\r\n    function can(address, address) public view returns (uint256);\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n    // mapping (bytes32 => Ilk) public ilks;\r\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\r\n    // mapping (bytes32 => mapping (address => Urn)) public urns;\r\n    function urns(bytes32, address) public view returns (uint256, uint256);\r\n    // mapping (bytes32 => mapping (address => uint256)) public gem;  // [wad]\r\n    function gem(bytes32, address) public view returns (uint256);\r\n    // mapping (address => uint256) public dai;  // [rad]\r\n    function dai(address) public view returns (uint256);\r\n    // mapping (address => uint256) public sin;  // [rad]\r\n    function sin(address) public view returns (uint256);\r\n    // uint256 public debt;  // Total Dai Issued    [rad]\r\n    function debt() public view returns (uint256);\r\n    // uint256 public vice;  // Total Unbacked Dai  [rad]\r\n    function vice() public view returns (uint256);\r\n    // uint256 public Line;  // Total Debt Ceiling  [rad]\r\n    function Line() public view returns (uint256);\r\n    // uint256 public live;  // Access Flag\r\n    function live() public view returns (uint256);\r\n    function init(bytes32) external;\r\n    function file(bytes32, uint256) external;\r\n    function file(bytes32, bytes32, uint256) external;\r\n    function cage() external;\r\n    function slip(bytes32, address, int256) external;\r\n    function flux(bytes32, address, address, uint256) external;\r\n    function move(address, address, uint256) external;\r\n    function frob(bytes32, address, address, address, int256, int256) external;\r\n    function fork(bytes32, address, address, int256, int256) external;\r\n    function grab(bytes32, address, address, address, int256, int256) external;\r\n    function heal(uint256) external;\r\n    function suck(address, address, uint256) external;\r\n    function fold(bytes32, address, int256) external;\r\n}\r\n\r\ncontract SaiMomLike {\r\n    function setCap(uint256) external;\r\n    function setFee(uint256) external;\r\n}\r\n\r\ncontract SaiConstants {\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAD = 10 ** 45;\r\n    address constant public SAIMOM = 0xF2C5369cFFb8Ea6284452b0326e326DbFdCb867C;\r\n    uint256 constant public SCDCAP = 30000000;\r\n    uint256 constant public SCDFEE = 1000000002732676825177582095;\r\n}\r\n\r\ncontract SpellAction is SaiConstants, DSMath {\r\n    address constant public VAT = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\r\n    address constant public JUG = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\r\n    address constant public POT = 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7;\r\n\r\n    function execute() external {\r\n        // drip\r\n        PotAbstract(POT).drip();\r\n        JugAbstract(JUG).drip(\"ETH-A\");\r\n        JugAbstract(JUG).drip(\"BAT-A\");\r\n\r\n        // set dsr to 7.5%\r\n        PotAbstract(POT).file(\"dsr\", 1000000002293273137447730714);\r\n\r\n        // SF = 8%\r\n        uint256 sf = 1000000002440418608258400030;\r\n\r\n        // set ETH-A duty to 8%\r\n        JugAbstract(JUG).file(\"ETH-A\", \"duty\", sf);\r\n\r\n        // set BAT-A duty to 8%\r\n        JugAbstract(JUG).file(\"BAT-A\", \"duty\", sf);\r\n    }\r\n}\r\n\r\ncontract DssFebruary7Spell is SaiConstants, DSMath {\r\n    DSPauseAbstract  public pause =\r\n        DSPauseAbstract(0xbE286431454714F511008713973d3B053A2d38f3);\r\n    address          public action;\r\n    bytes32          public tag;\r\n    uint256          public eta;\r\n    bytes            public sig;\r\n    bool             public done;\r\n\r\n    constructor() public {\r\n        sig = abi.encodeWithSignature(\"execute()\");\r\n        action = address(new SpellAction());\r\n        bytes32 _tag;\r\n        address _action = action;\r\n        assembly { _tag := extcodehash(_action) }\r\n        tag = _tag;\r\n    }\r\n\r\n    function schedule() public {\r\n        require(eta == 0, \"spell-already-scheduled\");\r\n        eta = add(now, DSPauseAbstract(pause).delay());\r\n        pause.plot(action, tag, sig, eta);\r\n\r\n        // NOTE: 'eta' check should mimic the old behavior of 'done', thus\r\n        // preventing these SCD changes from being executed again.\r\n\r\n        // Lower Stability Fee in SCD to 9%\r\n        SaiMomLike(SAIMOM).setFee(SCDFEE);\r\n    }\r\n\r\n    function cast() public {\r\n        require(!done, \"spell-already-cast\");\r\n        done = true;\r\n        pause.exec(action, tag, sig, eta);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAIMOM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCDCAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCDFEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"action\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cast\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"done\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"contract DSPauseAbstract\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"schedule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tag\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DssFebruary7Spell","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://80b7f3fb6bd7c7116c7939fed4b9c23ba33c0bb5bdf2920c564fc1fa49ce0e75"}]}