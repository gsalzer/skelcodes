{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with buidler v1.2.0 https://buidler.dev\r\n\r\n// File @pie-dao/proxy/contracts/PProxyStorage.sol@v0.0.6\r\n\r\npragma solidity ^0.6.2;\r\n\r\ncontract PProxyStorage {\r\n\r\n    function readString(bytes32 _key) public view returns(string memory) {\r\n        return bytes32ToString(storageRead(_key));\r\n    }\r\n\r\n    function setString(bytes32 _key, string memory _value) internal {\r\n        storageSet(_key, stringToBytes32(_value));\r\n    }\r\n\r\n    function readBool(bytes32 _key) public view returns(bool) {\r\n        return storageRead(_key) == bytes32(uint256(1));\r\n    }\r\n\r\n    function setBool(bytes32 _key, bool _value) internal {\r\n        if(_value) {\r\n            storageSet(_key, bytes32(uint256(1)));\r\n        } else {\r\n            storageSet(_key, bytes32(uint256(0)));\r\n        }\r\n    }\r\n\r\n    function readAddress(bytes32 _key) public view returns(address) {\r\n        return bytes32ToAddress(storageRead(_key));\r\n    }\r\n\r\n    function setAddress(bytes32 _key, address _value) internal {\r\n        storageSet(_key, addressToBytes32(_value));\r\n    }\r\n\r\n    function storageRead(bytes32 _key) public view returns(bytes32) {\r\n        bytes32 value;\r\n        //solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            value := sload(_key)\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function storageSet(bytes32 _key, bytes32 _value) internal {\r\n        // targetAddress = _address;  // No!\r\n        bytes32 implAddressStorageKey = _key;\r\n        //solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            sstore(implAddressStorageKey, _value)\r\n        }\r\n    }\r\n\r\n    function bytes32ToAddress(bytes32 _value) public pure returns(address) {\r\n        return address(uint160(uint256(_value)));\r\n    }\r\n\r\n    function addressToBytes32(address _value) public pure returns(bytes32) {\r\n        return bytes32(uint256(_value));\r\n    }\r\n\r\n    function stringToBytes32(string memory _value) public pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(_value);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(_value, 32))\r\n        }\r\n    }\r\n\r\n    function bytes32ToString(bytes32 _value) public pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint256 j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(_value) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint256 j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\n\r\n// File @pie-dao/proxy/contracts/PProxy.sol@v0.0.6\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\ncontract PProxy is PProxyStorage {\r\n\r\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(abi.encodePacked(\"IMPLEMENTATION_SLOT\"));\r\n    bytes32 constant OWNER_SLOT = keccak256(abi.encodePacked(\"OWNER_SLOT\"));\r\n\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == readAddress(OWNER_SLOT), \"PProxy.onlyProxyOwner: msg sender not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor () public {\r\n        setAddress(OWNER_SLOT, msg.sender);\r\n    }\r\n\r\n    function getProxyOwner() public view returns (address) {\r\n       return readAddress(OWNER_SLOT);\r\n    }\r\n\r\n    function setProxyOwner(address _newOwner) onlyProxyOwner public {\r\n        setAddress(OWNER_SLOT, _newOwner);\r\n    }\r\n\r\n    function getImplementation() public view returns (address) {\r\n        return readAddress(IMPLEMENTATION_SLOT);\r\n    }\r\n\r\n    function setImplementation(address _newImplementation) onlyProxyOwner public {\r\n        setAddress(IMPLEMENTATION_SLOT, _newImplementation);\r\n    }\r\n\r\n\r\n    fallback () external payable {\r\n       return internalFallback();\r\n    }\r\n\r\n    function internalFallback() internal virtual {\r\n        address contractAddr = readAddress(IMPLEMENTATION_SLOT);\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), contractAddr, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File @pie-dao/proxy/contracts/PProxyPausable.sol@v0.0.6\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\ncontract PProxyPausable is PProxy {\r\n\r\n    bytes32 constant PAUSED_SLOT = keccak256(abi.encodePacked(\"PAUSED_SLOT\"));\r\n    bytes32 constant PAUZER_SLOT = keccak256(abi.encodePacked(\"PAUZER_SLOT\"));\r\n\r\n    constructor() PProxy() public {\r\n        setAddress(PAUZER_SLOT, msg.sender);\r\n    }\r\n\r\n    modifier onlyPauzer() {\r\n        require(msg.sender == readAddress(PAUZER_SLOT), \"PProxyPausable.onlyPauzer: msg sender not pauzer\");\r\n        _;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(!readBool(PAUSED_SLOT), \"PProxyPausable.notPaused: contract is paused\");\r\n        _;\r\n    }\r\n\r\n    function getPauzer() public view returns (address) {\r\n        return readAddress(PAUZER_SLOT);\r\n    }\r\n\r\n    function setPauzer(address _newPauzer) public onlyProxyOwner{\r\n        setAddress(PAUZER_SLOT, _newPauzer);\r\n    }\r\n\r\n    function renouncePauzer() public onlyPauzer {\r\n        setAddress(PAUZER_SLOT, address(0));\r\n    }\r\n\r\n    function getPaused() public view returns (bool) {\r\n        return readBool(PAUSED_SLOT);\r\n    }\r\n\r\n    function setPaused(bool _value) public onlyPauzer {\r\n        setBool(PAUSED_SLOT, _value);\r\n    }\r\n\r\n    function internalFallback() internal virtual override notPaused {\r\n        super.internalFallback();\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IBFactory.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IBFactory {\r\n    function newBPool() external returns (address);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IBPool.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is disstributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface IBPool {\r\n    function isBound(address token) external view returns(bool);\r\n    function getBalance(address token) external view returns (uint);\r\n    function rebind(address token, uint balance, uint denorm) external;\r\n    function setSwapFee(uint swapFee) external;\r\n    function setPublicSwap(bool _public) external;\r\n    function bind(address token, uint balance, uint denorm) external;\r\n    function unbind(address token) external;\r\n    function getDenormalizedWeight(address token) external view returns (uint);\r\n    function getTotalDenormalizedWeight() external view returns (uint);\r\n    function getCurrentTokens() external view returns(address[] memory);\r\n    function setController(address manager) external;\r\n    function isPublicSwap() external view returns(bool);\r\n    function getSwapFee() external view returns (uint256);\r\n    function gulp(address token) external;\r\n\r\n    function calcPoolOutGivenSingleIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint poolAmountOut);\r\n\r\n    function calcSingleInGivenPoolOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountOut,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint tokenAmountIn);\r\n\r\n    function calcSingleOutGivenPoolIn(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountIn,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint tokenAmountOut);\r\n\r\n    function calcPoolInGivenSingleOut(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint poolAmountIn);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _src, address indexed _dst, uint _amount);\r\n    event Transfer(address indexed _src, address indexed _dst, uint _amount);\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address _whom) external view returns (uint);\r\n    function allowance(address _src, address _dst) external view returns (uint);\r\n\r\n    function approve(address _dst, uint _amount) external returns (bool);\r\n    function transfer(address _dst, uint _amount) external returns (bool);\r\n    function transferFrom(\r\n        address _src, address _dst, uint _amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/Ownable.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\n// TODO move this generic contract to a seperate repo with all generic smart contracts\r\n\r\ncontract Ownable {\r\n\r\n    bytes32 constant public oSlot = keccak256(\"Ownable.storage.location\");\r\n\r\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Ownable struct\r\n    struct os {\r\n        address owner;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == los().owner, \"Ownable.onlyOwner: msg.sender not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @notice Transfer ownership to a new address\r\n        @param _newOwner Address of the new owner\r\n    */\r\n    function transferOwnership(address _newOwner) onlyOwner external {\r\n        _setOwner(_newOwner);\r\n    }\r\n\r\n    /**\r\n        @notice Internal method to set the owner\r\n        @param _newOwner Address of the new owner\r\n    */\r\n    function _setOwner(address _newOwner) internal {\r\n        emit OwnerChanged(los().owner, _newOwner);\r\n        los().owner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @notice Load ownable storage\r\n        @return s Storage pointer to the Ownable storage struct\r\n    */\r\n    function los() internal pure returns (os storage s) {\r\n        bytes32 loc = oSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IPSmartPool.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IPSmartPool is IERC20 {\r\n    function joinPool(uint256 _amount) external;\r\n    function exitPool(uint256 _amount) external;\r\n    function getController() external view returns(address);\r\n    function getTokens() external view returns(address[] memory);\r\n    function calcTokensForAmount(uint256 _amount) external view  returns(address[] memory tokens, uint256[] memory amounts);\r\n}\r\n\r\n\r\n// File contracts/PCTokenStorage.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ncontract PCTokenStorage {\r\n\r\n    bytes32 constant public ptSlot = keccak256(\"PCToken.storage.location\");\r\n    struct pts {\r\n        string name;\r\n        string symbol;\r\n        uint256 totalSupply;\r\n        mapping(address => uint256) balance;\r\n        mapping(address => mapping(address=>uint256)) allowance;\r\n    }\r\n\r\n    /**\r\n        @notice Load pool token storage\r\n        @return s Storage pointer to the pool token struct\r\n    */\r\n    function lpts() internal pure returns (pts storage s) {\r\n        bytes32 loc = ptSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/Math.sol\r\n\r\nlibrary Math {\r\n\r\n    uint internal constant BONE = 10**18;\r\n\r\n    // Add two numbers together checking for overflows\r\n    function badd(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    // subtract two numbers and return diffecerence when it underflows\r\n    function bsubSign(uint a, uint b)\r\n        internal pure\r\n        returns (uint, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    // Subtract two numbers checking for underflows\r\n    function bsub(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        (uint c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    // Multiply two 18 decimals numbers\r\n    function bmul(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    // Divide two 18 decimals numbers\r\n    function bdiv(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/PCToken.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.6.4;\r\n\r\n\r\n\r\n\r\n// Highly opinionated token implementation\r\n// Based on the balancer Implementation\r\n\r\n\r\ncontract PCToken is IERC20, PCTokenStorage {\r\n\r\n    using Math for uint256;\r\n\r\n    event Approval(address indexed _src, address indexed _dst, uint _amount);\r\n    event Transfer(address indexed _src, address indexed _dst, uint _amount);\r\n\r\n    uint8 public constant decimals = 18;\r\n\r\n    function _mint(uint _amount) internal {\r\n        pts storage s = lpts();\r\n        s.balance[address(this)] = s.balance[address(this)].badd(_amount);\r\n        s.totalSupply = s.totalSupply.badd(_amount);\r\n        emit Transfer(address(0), address(this), _amount);\r\n    }\r\n\r\n    function _burn(uint _amount) internal {\r\n        pts storage s = lpts();\r\n        require(s.balance[address(this)] >= _amount, \"ERR_INSUFFICIENT_BAL\");\r\n        s.balance[address(this)] = s.balance[address(this)].bsub(_amount);\r\n        s.totalSupply = s.totalSupply.bsub(_amount);\r\n        emit Transfer(address(this), address(0), _amount);\r\n    }\r\n\r\n    function _move(address _src, address _dst, uint _amount) internal {\r\n        pts storage s = lpts();\r\n        require(s.balance[_src] >= _amount, \"ERR_INSUFFICIENT_BAL\");\r\n        s.balance[_src] = s.balance[_src].bsub(_amount);\r\n        s.balance[_dst] = s.balance[_dst].badd(_amount);\r\n        emit Transfer(_src, _dst, _amount);\r\n    }\r\n\r\n    function _push(address _to, uint _amount) internal {\r\n        _move(address(this), _to, _amount);\r\n    }\r\n\r\n    function _pull(address _from, uint _amount) internal {\r\n        _move(_from, address(this), _amount);\r\n    }\r\n\r\n    function allowance(address _src, address _dst) external view override returns (uint) {\r\n        return lpts().allowance[_src][_dst];\r\n    }\r\n\r\n    function balanceOf(address _whom) external view override returns (uint) {\r\n        return lpts().balance[_whom];\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint) {\r\n        return lpts().totalSupply;\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return lpts().name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return lpts().symbol;\r\n    }\r\n\r\n    function approve(address _dst, uint _amount) external override returns (bool) {\r\n        lpts().allowance[msg.sender][_dst] = _amount;\r\n        emit Approval(msg.sender, _dst, _amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _dst, uint _amount) external returns (bool) {\r\n        pts storage s = lpts();\r\n        s.allowance[msg.sender][_dst] = s.allowance[msg.sender][_dst].badd(_amount);\r\n        emit Approval(msg.sender, _dst, s.allowance[msg.sender][_dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _dst, uint _amount) external returns (bool) {\r\n        pts storage s = lpts();\r\n        uint oldValue = s.allowance[msg.sender][_dst];\r\n        if (_amount > oldValue) {\r\n            s.allowance[msg.sender][_dst] = 0;\r\n        } else {\r\n            s.allowance[msg.sender][_dst] = oldValue.bsub(_amount);\r\n        }\r\n        emit Approval(msg.sender, _dst, s.allowance[msg.sender][_dst]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _dst, uint _amount) external override returns (bool) {\r\n        _move(msg.sender, _dst, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _src, address _dst, uint _amount) external override returns (bool) {\r\n        pts storage s = lpts();\r\n        require(msg.sender == _src || _amount <= s.allowance[_src][msg.sender], \"ERR_PCTOKEN_BAD_CALLER\");\r\n        _move(_src, _dst, _amount);\r\n        if (msg.sender != _src && s.allowance[_src][msg.sender] != uint256(-1)) {\r\n            s.allowance[_src][msg.sender] = s.allowance[_src][msg.sender].bsub(_amount);\r\n            emit Approval(msg.sender, _dst, s.allowance[_src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/ReentryProtection.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\n// TODO move this generic contract to a seperate repo with all generic smart contracts\r\n\r\ncontract ReentryProtection {\r\n\r\n    bytes32 constant public rpSlot = keccak256(\"ReentryProtection.storage.location\");\r\n\r\n    // reentry protection storage\r\n    struct rps {\r\n        uint256 lockCounter;\r\n    }\r\n\r\n    modifier noReentry {\r\n        // Use counter to only write to storage once\r\n        lrps().lockCounter ++;\r\n        uint256 lockValue = lrps().lockCounter;\r\n        _;\r\n        require(lockValue == lrps().lockCounter, \"ReentryProtection.noReentry: reentry detected\");\r\n    }\r\n\r\n    /**\r\n        @notice Load reentry protection storage\r\n        @return s Pointer to the reentry protection storage struct\r\n    */\r\n    function lrps() internal pure returns (rps storage s) {\r\n        bytes32 loc = rpSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/smart-pools/PBasicSmartPool.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\n\r\n\r\n\r\n\r\ncontract PBasicSmartPool is IPSmartPool, PCToken, ReentryProtection {\r\n    \r\n    // P Basic Smart Struct\r\n    bytes32 constant public pbsSlot = keccak256(\"PBasicSmartPool.storage.location\");\r\n    struct pbs {\r\n        IBPool bPool;\r\n        address controller;\r\n        address publicSwapSetter;\r\n        address tokenBinder;\r\n    }\r\n    \r\n    modifier ready() {\r\n        require(address(lpbs().bPool) != address(0), \"PBasicSmartPool.ready: not ready\");\r\n        _;\r\n    }   \r\n\r\n     event LOG_JOIN(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint256 tokenAmountIn\r\n    );\r\n\r\n    event LOG_EXIT(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    event TokensApproved();\r\n    event ControllerChanged(address indexed previousController, address indexed newController);\r\n    event PublicSwapSetterChanged(address indexed previousSetter, address indexed newSetter);\r\n    event TokenBinderChanged(address indexed previousTokenBinder, address indexed newTokenBinder);\r\n    event PublicSwapSet(address indexed setter, bool indexed value);\r\n    event SwapFeeSet(address indexed setter, uint256 newFee);\r\n    event PoolJoined(address indexed from, uint256 amount);\r\n    event PoolExited(address indexed from, uint256 amount);\r\n    event PoolExitedWithLoss(address indexed from, uint256 amount, address[] lossTokens);\r\n\r\n    modifier onlyController() {\r\n        require(msg.sender == lpbs().controller, \"PBasicSmartPool.onlyController: not controller\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPublicSwapSetter() {\r\n        require(msg.sender == lpbs().publicSwapSetter, \"PBasicSmartPool.onlyPublicSwapSetter: not public swap setter\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenBinder() {\r\n        require(msg.sender == lpbs().tokenBinder, \"PBasicSmartPool.onlyTokenBinder: not token binder\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @notice Initialises the contract\r\n        @param _bPool Address of the underlying balancer pool\r\n        @param _name Name for the smart pool token\r\n        @param _symbol Symbol for the smart pool token\r\n        @param _initialSupply Initial token supply to mint\r\n    */\r\n    function init(address _bPool, string calldata _name, string calldata _symbol, uint256 _initialSupply) external {\r\n        pbs storage s = lpbs();\r\n        require(address(s.bPool) == address(0), \"PBasicSmartPool.init: already initialised\");\r\n        require(_bPool != address(0), \"PBasicSmartPool.init: _bPool cannot be 0x00....000\");\r\n        require(_initialSupply != 0, \"PBasicSmartPool.init: _initialSupply can not zero\");\r\n        s.bPool = IBPool(_bPool);\r\n        s.controller = msg.sender;\r\n        s.publicSwapSetter = msg.sender;\r\n        s.tokenBinder = msg.sender;\r\n        lpts().name = _name;\r\n        lpts().symbol = _symbol;\r\n        _mintPoolShare(_initialSupply);\r\n        _pushPoolShare(msg.sender, _initialSupply);\r\n    }\r\n\r\n    /**\r\n        @notice Sets approval to all tokens to the underlying balancer pool\r\n        @dev It uses this function to save on gas in joinPool\r\n    */\r\n    function approveTokens() public noReentry {\r\n        IBPool bPool = lpbs().bPool;\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n        for(uint256 i = 0; i < tokens.length; i ++) {\r\n            IERC20(tokens[i]).approve(address(bPool), uint256(-1));\r\n        }\r\n        emit TokensApproved();\r\n    }\r\n\r\n    /**\r\n        @notice Sets the controller address. Can only be set by the current controller\r\n        @param _controller Address of the new controller\r\n    */\r\n    function setController(address _controller) onlyController noReentry external {\r\n        emit ControllerChanged(lpbs().controller, _controller);\r\n        lpbs().controller = _controller;\r\n    }\r\n\r\n    /**\r\n        @notice Sets public swap setter address. Can only be set by the controller\r\n        @param _newPublicSwapSetter Address of the new public swap setter\r\n    */\r\n    function setPublicSwapSetter(address _newPublicSwapSetter) onlyController noReentry external {\r\n        emit PublicSwapSetterChanged(lpbs().publicSwapSetter, _newPublicSwapSetter);\r\n        lpbs().publicSwapSetter = _newPublicSwapSetter;\r\n    }\r\n\r\n    /**\r\n        @notice Sets the token binder address. Can only be set by the controller\r\n        @param _newTokenBinder Address of the new token binder\r\n    */\r\n    function setTokenBinder(address _newTokenBinder) onlyController noReentry external {\r\n        emit TokenBinderChanged(lpbs().tokenBinder, _newTokenBinder);\r\n        lpbs().tokenBinder = _newTokenBinder;\r\n    }\r\n\r\n    /**\r\n        @notice Enables or disables public swapping on the underlying balancer pool. Can only be set by the controller\r\n        @param _public Public or not\r\n    */\r\n    function setPublicSwap(bool _public) onlyPublicSwapSetter noReentry external {\r\n        emit PublicSwapSet(msg.sender, _public);\r\n        lpbs().bPool.setPublicSwap(_public);\r\n    }\r\n\r\n    /**\r\n        @notice Set the swap fee on the underlying balancer pool. Can only be called by the controller\r\n        @param _swapFee The new swap fee\r\n    */\r\n    function setSwapFee(uint256 _swapFee) onlyController noReentry external {\r\n        emit SwapFeeSet(msg.sender, _swapFee);\r\n        lpbs().bPool.setSwapFee(_swapFee);\r\n    }\r\n\r\n    /** \r\n        @notice Mints pool shares in exchange for underlying assets\r\n        @param _amount Amount of pool shares to mint\r\n    */\r\n\r\n    function joinPool(uint256 _amount) external override virtual ready noReentry {\r\n        _joinPool(_amount);\r\n    }\r\n\r\n    /**\r\n        @notice Internal join pool function. See joinPool for more info\r\n        @param _amount Amount of pool shares to mint\r\n    */\r\n    function _joinPool(uint256 _amount) internal virtual ready {\r\n        IBPool bPool = lpbs().bPool;\r\n        uint poolTotal = totalSupply();\r\n        uint ratio = _amount.bdiv(poolTotal);\r\n        require(ratio != 0);\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint bal = bPool.getBalance(t);\r\n            uint tokenAmountIn = ratio.bmul(bal);\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn, bal);\r\n        }\r\n        _mintPoolShare(_amount);\r\n        _pushPoolShare(msg.sender, _amount);\r\n        emit PoolJoined(msg.sender, _amount);\r\n    }\r\n\r\n    /** \r\n        @notice Burns pool shares and sends back the underlying assets\r\n        @param _amount Amount of pool tokens to burn\r\n    */\r\n    function exitPool(uint256 _amount) external override ready noReentry {\r\n        IBPool bPool = lpbs().bPool;\r\n        uint poolTotal = totalSupply();\r\n        uint ratio = _amount.bdiv(poolTotal);\r\n        require(ratio != 0);\r\n\r\n        _pullPoolShare(msg.sender, _amount);\r\n        _burnPoolShare(_amount);\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint bal = bPool.getBalance(t);\r\n            uint tAo = ratio.bmul(bal);\r\n            emit LOG_EXIT(msg.sender, t, tAo);  \r\n            _pushUnderlying(t, msg.sender, tAo, bal);\r\n        }\r\n        emit PoolExited(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n        @notice Burns pool shares and sends back the underlying assets leaving some in the pool\r\n        @param _amount Amount of pool tokens to burn\r\n        @param _lossTokens Tokens skipped on redemption\r\n    */\r\n    function exitPoolTakingloss(uint256 _amount, address[] calldata _lossTokens) external ready noReentry {\r\n        IBPool bPool = lpbs().bPool;\r\n        uint poolTotal = totalSupply();\r\n        uint ratio = _amount.bdiv(poolTotal);\r\n        require(ratio != 0);\r\n\r\n        _pullPoolShare(msg.sender, _amount);\r\n        _burnPoolShare(_amount);\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            // If taking loss on token skip one iteration of the loop\r\n            if(_contains(tokens[i], _lossTokens)){\r\n                continue;\r\n            }\r\n            address t = tokens[i];\r\n            uint bal = bPool.getBalance(t);\r\n            uint tAo = ratio.bmul(bal);\r\n            emit LOG_EXIT(msg.sender, t, tAo);  \r\n            _pushUnderlying(t, msg.sender, tAo, bal);\r\n        }\r\n        emit PoolExitedWithLoss(msg.sender, _amount, _lossTokens);\r\n    }\r\n\r\n    /**\r\n        @notice Bind a token to the underlying balancer pool. Can only be called by the token binder\r\n        @param _token Token to bind\r\n        @param _balance Amount to bind\r\n        @param _denorm Denormalised weight\r\n    */\r\n    function bind(address _token, uint256 _balance, uint256 _denorm) external onlyTokenBinder noReentry {\r\n        IBPool bPool = lpbs().bPool;\r\n        IERC20 token = IERC20(_token);\r\n        require(token.transferFrom(msg.sender, address(this), _balance), \"PBasicSmartPool.bind: transferFrom failed\");\r\n        token.approve(address(bPool), uint256(-1));\r\n        bPool.bind(_token, _balance, _denorm);\r\n    }\r\n\r\n    /**\r\n        @notice Rebind a token to the pool\r\n        @param _token Token to bind\r\n        @param _balance Amount to bind\r\n        @param _denorm Denormalised weight\r\n    */\r\n    function rebind(address _token, uint256 _balance, uint256 _denorm) external onlyTokenBinder noReentry {\r\n        IBPool bPool = lpbs().bPool;\r\n        IERC20 token = IERC20(_token);\r\n        \r\n        // gulp old non acounted for token balance in the contract\r\n        bPool.gulp(_token);\r\n\r\n        uint256 oldBalance = token.balanceOf(address(bPool));\r\n        // If tokens need to be pulled from msg.sender\r\n        if(_balance > oldBalance) {\r\n            require(token.transferFrom(msg.sender, address(this), _balance.bsub(oldBalance)), \"PBasicSmartPool.rebind: transferFrom failed\");\r\n            token.approve(address(bPool), uint256(-1));\r\n        }\r\n\r\n        bPool.rebind(_token, _balance, _denorm);\r\n\r\n        // If any tokens are in this contract send them to msg.sender\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        if(tokenBalance > 0) {\r\n            require(token.transfer(msg.sender, tokenBalance), \"PBasicSmartPool.rebind: transfer failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Unbind a token\r\n        @param _token Token to unbind\r\n    */\r\n    function unbind(address _token) external onlyTokenBinder noReentry {\r\n        IBPool bPool = lpbs().bPool;\r\n        IERC20 token = IERC20(_token);\r\n        // unbind the token in the bPool\r\n        bPool.unbind(_token);\r\n\r\n        // If any tokens are in this contract send them to msg.sender\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        if(tokenBalance > 0) {\r\n            require(token.transfer(msg.sender, tokenBalance), \"PBasicSmartPool.unbind: transfer failed\");\r\n        }\r\n    }\r\n\r\n    function getTokens() external view override returns(address[] memory) {\r\n        return lpbs().bPool.getCurrentTokens();\r\n    }\r\n\r\n    /**\r\n        @notice Gets the underlying assets and amounts to mint specific pool shares.\r\n        @param _amount Amount of pool shares to calculate the values for\r\n        @return tokens The addresses of the tokens\r\n        @return amounts The amounts of tokens needed to mint that amount of pool shares\r\n    */\r\n    function calcTokensForAmount(uint256 _amount) external view override returns(address[] memory tokens, uint256[] memory amounts) {\r\n        tokens = lpbs().bPool.getCurrentTokens();\r\n        amounts = new uint256[](tokens.length);\r\n        uint256 ratio = _amount.bdiv(totalSupply());\r\n\r\n        for(uint256 i = 0; i < tokens.length; i ++) {\r\n            address t = tokens[i];\r\n            uint256 bal = lpbs().bPool.getBalance(t);\r\n            uint256 amount = ratio.bmul(bal);\r\n            amounts[i] = amount;\r\n        }\r\n    }\r\n\r\n    /** \r\n        @notice Get the address of the controller\r\n        @return The address of the pool\r\n    */\r\n    function getController() external view override returns(address) {\r\n        return lpbs().controller;\r\n    }\r\n\r\n    /** \r\n        @notice Get the address of the public swap setter\r\n        @return The public swap setter address\r\n    */\r\n    function getPublicSwapSetter() external view returns(address) {\r\n        return lpbs().publicSwapSetter;\r\n    }\r\n\r\n    /**\r\n        @notice Get the address of the token binder\r\n        @return The token binder address\r\n    */\r\n    function getTokenBinder() external view returns(address) {\r\n        return lpbs().tokenBinder;\r\n    }\r\n\r\n    /**\r\n        @notice Get if public swapping is enabled\r\n        @return If public swapping is enabled\r\n    */\r\n    function isPublicSwap() external view returns (bool) {\r\n        return lpbs().bPool.isPublicSwap();\r\n    }\r\n\r\n    /**\r\n        @notice Get the current swap fee\r\n        @return The current swap fee\r\n    */\r\n    function getSwapFee() external view returns (uint256) {\r\n        return lpbs().bPool.getSwapFee();\r\n    }\r\n\r\n    /**\r\n        @notice Get the address of the underlying Balancer pool\r\n        @return The address of the underlying balancer pool\r\n    */\r\n    function getBPool() external view returns(address) {\r\n        return address(lpbs().bPool);\r\n    }\r\n\r\n    /**\r\n        @notice Pull the underlying token from an address and rebind it to the balancer pool\r\n        @param _token Address of the token to pull\r\n        @param _from Address to pull the token from\r\n        @param _amount Amount of token to pull\r\n        @param _tokenBalance Balance of the token already in the balancer pool\r\n    */\r\n    function _pullUnderlying(address _token, address _from, uint256 _amount, uint256 _tokenBalance)\r\n        internal\r\n    {   \r\n        IBPool bPool = lpbs().bPool;\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint tokenWeight = bPool.getDenormalizedWeight(_token);\r\n\r\n        require(IERC20(_token).transferFrom(_from, address(this), _amount), \"PBasicSmartPool._pullUnderlying: transferFrom failed\");\r\n        bPool.rebind(_token, _tokenBalance.badd(_amount), tokenWeight);\r\n    }\r\n\r\n    /** \r\n        @notice Push a underlying token and rebind the token to the balancer pool\r\n        @param _token Address of the token to push\r\n        @param _to Address to pull the token to\r\n        @param _amount Amount of token to push\r\n        @param _tokenBalance Balance of the token already in the balancer pool\r\n    */\r\n    function _pushUnderlying(address _token, address _to, uint256 _amount, uint256 _tokenBalance)\r\n        internal\r\n    {   \r\n        IBPool bPool = lpbs().bPool;\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint tokenWeight = bPool.getDenormalizedWeight(_token);\r\n        bPool.rebind(_token, _tokenBalance.bsub(_amount), tokenWeight);\r\n\r\n        require(IERC20(_token).transfer(_to, _amount), \"PBasicSmartPool._pushUnderlying: transfer failed\");\r\n    }\r\n\r\n    /**\r\n        @notice Pull pool shares\r\n        @param _from Address to pull pool shares from\r\n        @param _amount Amount of pool shares to pull\r\n    */\r\n    function _pullPoolShare(address _from, uint256 _amount)\r\n        internal\r\n    {\r\n        _pull(_from, _amount);\r\n    }\r\n\r\n    /**\r\n        @notice Burn pool shares\r\n        @param _amount Amount of pool shares to burn\r\n    */\r\n    function _burnPoolShare(uint256 _amount)\r\n        internal\r\n    {\r\n        _burn(_amount);\r\n    }\r\n\r\n    /** \r\n        @notice Mint pool shares \r\n        @param _amount Amount of pool shares to mint\r\n    */\r\n    function _mintPoolShare(uint256 _amount)\r\n        internal\r\n    {\r\n        _mint(_amount);\r\n    }\r\n\r\n    /**\r\n        @notice Push pool shares to account\r\n        @param _to Address to push the pool shares to\r\n        @param _amount Amount of pool shares to push\r\n    */\r\n    function _pushPoolShare(address _to, uint256 _amount)\r\n        internal\r\n    {\r\n        _push(_to, _amount);\r\n    }\r\n\r\n    /**\r\n        @notice searches for an address in an array of addresses and returns if it contains the address\r\n        @param _needle Address to look for\r\n        @param _haystack Array to search\r\n        @return If value is found\r\n    */\r\n    function _contains(address _needle, address[] memory _haystack) internal pure returns(bool) {\r\n        for(uint256 i = 0; i < _haystack.length; i ++) {\r\n            if(_haystack[i] == _needle) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n        @notice Load PBasicPool storage\r\n        @return s Pointer to the storage struct\r\n    */\r\n    function lpbs() internal pure returns (pbs storage s) {\r\n        bytes32 loc = pbsSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/smart-pools/PCappedSmartPool.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ncontract PCappedSmartPool is PBasicSmartPool {\r\n\r\n    bytes32 constant public pcsSlot = keccak256(\"PCappedSmartPool.storage.location\");\r\n\r\n    event CapChanged(address indexed setter, uint256 oldCap, uint256 newCap);\r\n\r\n    struct pcs {\r\n        uint256 cap;\r\n    }\r\n\r\n    modifier withinCap() {\r\n        _;\r\n        require(totalSupply() < lpcs().cap, \"PCappedSmartPool.withinCap: Cap limit reached\");\r\n    }\r\n\r\n    /**\r\n        @notice Set the maximum cap of the contract\r\n        @param _cap New cap in wei\r\n    */\r\n    function setCap(uint256 _cap) onlyController noReentry external {\r\n        emit CapChanged(msg.sender, lpcs().cap, _cap);\r\n        lpcs().cap = _cap;\r\n    }\r\n\r\n    /**\r\n        @notice Takes underlying assets and mints smart pool tokens. Enforces the cap\r\n        @param _amount Amount of pool tokens to mint\r\n    */\r\n    function joinPool(uint256 _amount) external override withinCap noReentry {\r\n        super._joinPool(_amount);\r\n    }\r\n\r\n\r\n    /**\r\n        @notice Get the current cap\r\n        @return The current cap in wei\r\n    */\r\n    function getCap() external view returns(uint256) {\r\n        return lpcs().cap;\r\n    }\r\n\r\n    /**\r\n        @notice Load the PCappedSmartPool storage\r\n        @return s Pointer to the storage struct\r\n    */\r\n    function lpcs() internal pure returns (pcs storage s) {\r\n        bytes32 loc = pcsSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/factory/PProxiedFactory.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PProxiedFactory is Ownable {\r\n\r\n    IBFactory public balancerFactory;\r\n    address public smartPoolImplementation;\r\n    mapping(address => bool) public isPool;\r\n    address[] public pools;\r\n\r\n    event SmartPoolCreated(address indexed poolAddress, string name, string symbol);\r\n\r\n    function init(address _balancerFactory) public {\r\n        require(smartPoolImplementation == address(0), \"Already initialised\");\r\n        _setOwner(msg.sender);\r\n        balancerFactory = IBFactory(_balancerFactory);\r\n        \r\n        PCappedSmartPool implementation = new PCappedSmartPool();\r\n        // function init(address _bPool, string calldata _name, string calldata _symbol, uint256 _initialSupply) external {\r\n        implementation.init(address(1), \"IMPL\", \"IMPL\", 1 ether);\r\n        smartPoolImplementation = address(implementation);\r\n    }\r\n\r\n    function newProxiedSmartPool(\r\n        string memory _name, \r\n        string memory _symbol,\r\n        uint256 _initialSupply,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256[] memory _weights,\r\n        uint256 _cap\r\n    ) public onlyOwner returns(address) {\r\n        // Deploy proxy contract\r\n        PProxyPausable proxy = new PProxyPausable();\r\n        \r\n        // Setup proxy\r\n        proxy.setImplementation(smartPoolImplementation);\r\n        proxy.setPauzer(msg.sender);\r\n        proxy.setProxyOwner(msg.sender); \r\n        \r\n        // Setup balancer pool\r\n        address balancerPoolAddress = balancerFactory.newBPool();\r\n        IBPool bPool = IBPool(balancerPoolAddress);\r\n\r\n        for(uint256 i = 0; i < _tokens.length; i ++) {\r\n            IERC20 token = IERC20(_tokens[i]);\r\n            // Transfer tokens to this contract\r\n            token.transferFrom(msg.sender, address(this), _amounts[i]);\r\n            // Approve the balancer pool\r\n            token.approve(balancerPoolAddress, uint256(-1));\r\n            // Bind tokens\r\n            bPool.bind(_tokens[i], _amounts[i], _weights[i]);\r\n        }\r\n        bPool.setController(address(proxy));\r\n        \r\n        // Setup smart pool\r\n        PCappedSmartPool smartPool = PCappedSmartPool(address(proxy));\r\n    \r\n        smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\r\n        smartPool.setCap(_cap);\r\n        smartPool.setPublicSwapSetter(msg.sender);\r\n        smartPool.setTokenBinder(msg.sender);\r\n        smartPool.setController(msg.sender);\r\n        smartPool.approveTokens();\r\n        \r\n        isPool[address(smartPool)] = true;\r\n        pools.push(address(smartPool));\r\n\r\n        emit SmartPoolCreated(address(smartPool), _name, _symbol);\r\n\r\n        smartPool.transfer(msg.sender, _initialSupply);\r\n\r\n        return address(smartPool);\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/test/TestPCToken.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\n\r\ncontract TestPCToken is PCToken {\r\n\r\n    constructor(string memory _name, string memory _symbol) public {\r\n        lpts().name = _name;\r\n        lpts().symbol = _symbol;\r\n    }\r\n    function mint(address _to, uint256 _amount) external {\r\n        _mint(_amount);\r\n        _push(_to, _amount);\r\n    }\r\n\r\n    function burn(address _from, uint256 _amount) external {\r\n        _pull(_from, _amount);\r\n        _burn(_amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/test/TestReentryProtection.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\n\r\ncontract TestReentryProtection is ReentryProtection {\r\n\r\n    // This should fail\r\n    function test() external noReentry {\r\n        reenter();\r\n    }\r\n\r\n    function reenter() public noReentry {\r\n        // Do nothing\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IKyberNetwork.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IKyberNetwork {\r\n\r\n    function trade(\r\n        address src,\r\n        uint srcAmount,\r\n        address dest,\r\n        address payable destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    ) external payable returns(uint256);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapExchange.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IUniswapExchange {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    // bytes32 public name;\r\n    // bytes32 public symbol;\r\n    // uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapFactory.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IUniswapFactory {\r\n    // Create Exchange\r\n    function createExchange(address token) external returns (address exchange);\r\n    // Get Exchange and Token Info\r\n    function getExchange(address token) external view returns (address exchange);\r\n    function getToken(address exchange) external view returns (address token);\r\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\r\n    // Never use\r\n    function initializeFactory(address template) external;\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"}],\"name\":\"CapChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousController\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"ControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PoolExited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"lossTokens\",\"type\":\"address[]\"}],\"name\":\"PoolExitedWithLoss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PoolJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"PublicSwapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousSetter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSetter\",\"type\":\"address\"}],\"name\":\"PublicSwapSetterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"SwapFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTokenBinder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTokenBinder\",\"type\":\"address\"}],\"name\":\"TokenBinderChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokensApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denorm\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calcTokensForAmount\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_lossTokens\",\"type\":\"address[]\"}],\"name\":\"exitPoolTakingloss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPublicSwapSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenBinder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bPool\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pbsSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pcsSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ptSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denorm\",\"type\":\"uint256\"}],\"name\":\"rebind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rpSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_public\",\"type\":\"bool\"}],\"name\":\"setPublicSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPublicSwapSetter\",\"type\":\"address\"}],\"name\":\"setPublicSwapSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenBinder\",\"type\":\"address\"}],\"name\":\"setTokenBinder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"unbind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PCappedSmartPool","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"ipfs://921f99f5ce710bff49f531f343876943c17e23402c0aabbc85e67784411cf5e5"}]}