{"status":"1","message":"OK","result":[{"SourceCode":"// File: @digix/cacp-contracts/contracts/ACOwned.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title Owner based access control\r\n/// @author DigixGlobal\r\n\r\ncontract ACOwned {\r\n\r\n  address public owner;\r\n  address public new_owner;\r\n  bool is_ac_owned_init;\r\n\r\n  /// @dev Modifier to check if msg.sender is the contract owner\r\n  modifier if_owner() {\r\n    require(is_owner());\r\n    _;\r\n  }\r\n\r\n  function init_ac_owned()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (is_ac_owned_init == false) {\r\n      owner = msg.sender;\r\n      is_ac_owned_init = true;\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function is_owner()\r\n           private\r\n           constant\r\n           returns (bool _is_owner)\r\n  {\r\n    _is_owner = (msg.sender == owner);\r\n  }\r\n\r\n  function change_owner(address _new_owner)\r\n           if_owner()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    new_owner = _new_owner;\r\n    _success = true;\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(msg.sender == new_owner);\r\n    owner = new_owner;\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/cacp-contracts/contracts/ACGroups.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/// @title Owner based access control\r\n/// @author DigixGlobal\r\n\r\ncontract ACGroups is ACOwned {\r\n\r\n  bool is_ac_groups_init = false;\r\n\r\n  struct Group {\r\n    mapping(address => bool) members;\r\n  }\r\n\r\n  mapping (bytes32 => Group) groups;\r\n\r\n  modifier if_group(bytes32 _group_name) {\r\n    require(groups[_group_name].members[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function init_ac_groups()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if(is_ac_owned_init == false) {\r\n      init_ac_owned();\r\n    }\r\n    if(is_ac_groups_init == false) {\r\n      groups[\"admins\"].members[msg.sender] = true;\r\n      is_ac_groups_init = true;\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function register_admin(address _newadmin)\r\n           if_owner\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    groups[\"admins\"].members[_newadmin] = true;\r\n    _success = true;\r\n  }\r\n\r\n  function unregister_admin(address _oldadmin)\r\n           if_owner\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    groups[\"admins\"].members[_oldadmin] = false;\r\n    _success = true;\r\n  }\r\n\r\n  function add_user_to_group(bytes32 _group, address _user)\r\n           if_group(\"admins\")\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(_group != \"admins\");\r\n    groups[_group].members[_user] = true;\r\n    _success = true;\r\n  }\r\n\r\n  function delete_user_from_group(bytes32 _group, address _user)\r\n           if_group(\"admins\")\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(_group != \"admins\");\r\n    groups[_group].members[_user] = false;\r\n    _success = true;\r\n  }\r\n\r\n  function is_group_member_of(bytes32 _group, address _user)\r\n           public\r\n           constant\r\n           returns (bool _ismember)\r\n  {\r\n    _ismember = groups[_group].members[_user];\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    // revoke admins role of old owner, add new owner to admins\r\n    groups[\"admins\"].members[owner] = false;\r\n    groups[\"admins\"].members[new_owner] = true;\r\n    _success = super.claim_ownership();\r\n  }\r\n}\r\n\r\n// File: @digix/cacp-contracts/contracts/Constants.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title Some useful constants\r\n/// @author DigixGlobal\r\n\r\ncontract Constants {\r\n  address constant NULL_ADDRESS = address(0x0);\r\n  uint256 constant ZERO = uint256(0);\r\n  bytes32 constant EMPTY = bytes32(0x0);\r\n}\r\n\r\n// File: @digix/cacp-contracts/contracts/ContractResolver.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n/// @title Contract Name Registry\r\n/// @author DigixGlobal\r\n\r\ncontract ContractResolver is ACGroups, Constants {\r\n\r\n  mapping (bytes32 => address) contracts;\r\n  event RegisterEvent(bytes32 indexed _contract_name,\r\n                      address indexed _contract_address);\r\n  event UnRegisterEvent(bytes32 indexed _contract_name);\r\n  bool public locked;\r\n  bool public time_locked;\r\n  uint public grace_period;\r\n\r\n  modifier unless_registered(bytes32 _key) {\r\n    require(contracts[_key] == NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier if_owner_origin() {\r\n    require(tx.origin == owner);\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  modifier locked_after_period() {\r\n    if (time_locked == false) {\r\n      _;\r\n    } else {\r\n      require(grace_period >= now);\r\n      _;\r\n    }\r\n  }\r\n\r\n  modifier if_not_locked() {\r\n    require(locked == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev ContractResolver constructor will perform the following: 1. Set msg.sender as the contract owner.  2. Adds msg.sender to the default groups 'admins' and 'nsadmins'\r\n  function ContractResolver() public\r\n  {\r\n    require(init_ac_groups());\r\n    groups[\"nsadmins\"].members[owner] = true;\r\n    locked = false;\r\n  }\r\n\r\n  /// TODO: this function can basically do everything register_contract can do (except for emitting an event). Maybe we should require that this function can only be called by a contract?\r\n  /// @dev Called at contract initialization\r\n  /// @param _key bytestring for CACP name\r\n  /// @param _contract_address The address of the contract to be registered\r\n  /// @return _success if the operation is successful\r\n  function init_register_contract(bytes32 _key, address _contract_address)\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           unless_registered(_key)\r\n           locked_after_period()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    contracts[_key] = _contract_address;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Lock the resolver from any further modifications.  This can only be called from an account that is part of the nsadmins group\r\n  /// @return _success if the operation is successful\r\n  function lock_resolver()\r\n           if_group(\"nsadmins\")\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    locked = true;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Unlock the resolver to allow further modifications.  This can only be called from an account that is part of the nsadmins group\r\n  /// @return _success if the operation is successful\r\n  function unlock_resolver()\r\n           if_group(\"nsadmins\")\r\n           public\r\n           returns (bool _success)\r\n  {\r\n     locked = false;\r\n     _success = true;\r\n  }\r\n\r\n  /// @dev Enable time locking. This is potentially dangerous and must be from the owner\r\n  /// @param _grace_period the unix timestamp when the resolver is locked forever\r\n  function enable_time_locking(uint _grace_period)\r\n           if_owner()\r\n           locked_after_period()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    grace_period = _grace_period;\r\n    time_locked = true;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Register a contract.  This can only be called from an account that is part of the nsadmins group\r\n  /// @param _key the bytestring of the contract name\r\n  /// @param _contract the address of the contract\r\n  /// @return _success if the operation is successful\r\n  function register_contract(bytes32 _key, address _contract)\r\n           if_group(\"nsadmins\")\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           locked_after_period()\r\n           unless_registered(_key)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    contracts[_key] = _contract;\r\n    RegisterEvent(_key, _contract);\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Unregister a contract.  This can only be called from the contract with the key itself, which should be destroyed in the process\r\n  /// this must also be originated from the owner of this ContractResolver as well.\r\n  /// @param _key the bytestring of the contract name\r\n  /// @return _success if the operation is successful\r\n  function unregister_contract(bytes32 _key)\r\n           locked_after_period()\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           if_sender_is(_key)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    delete contracts[_key];\r\n    UnRegisterEvent(_key);\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Get address of a contract\r\n  /// @param _key the bytestring name of the contract to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           constant\r\n           returns (address _contract)\r\n  {\r\n    require(contracts[_key] != NULL_ADDRESS);\r\n    _contract = contracts[_key];\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    // revoke nsadmins role of old owner, add new owner to nsadmins\r\n    groups[\"nsadmins\"].members[owner] = false;\r\n    groups[\"nsadmins\"].members[new_owner] = true;\r\n    _success = super.claim_ownership();\r\n  }\r\n}\r\n\r\n// File: @digix/cacp-contracts/contracts/ResolverClient.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n/// @title Contract Resolver Interface\r\n/// @author DigixGlobal\r\n\r\ncontract ResolverClient {\r\n\r\n  /// The address of the resolver contract for this project\r\n  address public resolver;\r\n  bytes32 public key;\r\n\r\n  /// Make our own address available to us as a constant\r\n  address public CONTRACT_ADDRESS;\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == ContractResolver(resolver).get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check resolver's locking status.\r\n  modifier unless_resolver_is_locked() {\r\n    require(is_locked() == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev Initialize new contract\r\n  /// @param _key the resolver key for this contract\r\n  /// @return _success if the initialization is successful\r\n  function init(bytes32 _key, address _resolver)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(_resolver).locked();\r\n    if (_is_locked == false) {\r\n      CONTRACT_ADDRESS = address(this);\r\n      resolver = _resolver;\r\n      key = _key;\r\n      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\r\n      _success = true;\r\n    }  else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Destroy the contract and unregister self from the ContractResolver\r\n  /// @dev Can only be called by the owner of ContractResolver\r\n  function destroy()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(resolver).locked();\r\n    require(!_is_locked);\r\n\r\n    address _owner_of_contract_resolver = ContractResolver(resolver).owner();\r\n    require(msg.sender == _owner_of_contract_resolver);\r\n\r\n    _success = ContractResolver(resolver).unregister_contract(key);\r\n    require(_success);\r\n\r\n    selfdestruct(_owner_of_contract_resolver);\r\n  }\r\n\r\n  /// @dev Check if resolver is locked\r\n  /// @return _locked if the resolver is currently locked\r\n  function is_locked()\r\n           private\r\n           constant\r\n           returns (bool _locked)\r\n  {\r\n    _locked = ContractResolver(resolver).locked();\r\n  }\r\n\r\n  /// @dev Get the address of a contract\r\n  /// @param _key the resolver key to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           constant\r\n           returns (address _contract)\r\n  {\r\n    _contract = ContractResolver(resolver).get_contract(_key);\r\n  }\r\n}\r\n\r\n// File: contracts/common/DigixConstants.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\ncontract DigixConstants {\r\n    /// general constants\r\n    uint256 constant SECONDS_IN_A_DAY = 24 * 60 * 60;\r\n\r\n    /// asset events\r\n    uint256 constant ASSET_EVENT_CREATED_VENDOR_ORDER = 1;\r\n    uint256 constant ASSET_EVENT_CREATED_TRANSFER_ORDER = 2;\r\n    uint256 constant ASSET_EVENT_CREATED_REPLACEMENT_ORDER = 3;\r\n    uint256 constant ASSET_EVENT_FULFILLED_VENDOR_ORDER = 4;\r\n    uint256 constant ASSET_EVENT_FULFILLED_TRANSFER_ORDER = 5;\r\n    uint256 constant ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER = 6;\r\n    uint256 constant ASSET_EVENT_MINTED = 7;\r\n    uint256 constant ASSET_EVENT_MINTED_REPLACEMENT = 8;\r\n    uint256 constant ASSET_EVENT_RECASTED = 9;\r\n    uint256 constant ASSET_EVENT_REDEEMED = 10;\r\n    uint256 constant ASSET_EVENT_FAILED_AUDIT = 11;\r\n    uint256 constant ASSET_EVENT_ADMIN_FAILED = 12;\r\n    uint256 constant ASSET_EVENT_REMINTED = 13;\r\n\r\n    /// roles\r\n    uint256 constant ROLE_ZERO_ANYONE = 0;\r\n    uint256 constant ROLE_ROOT = 1;\r\n    uint256 constant ROLE_VENDOR = 2;\r\n    uint256 constant ROLE_XFERAUTH = 3;\r\n    uint256 constant ROLE_POPADMIN = 4;\r\n    uint256 constant ROLE_CUSTODIAN = 5;\r\n    uint256 constant ROLE_AUDITOR = 6;\r\n    uint256 constant ROLE_MARKETPLACE_ADMIN = 7;\r\n    uint256 constant ROLE_KYC_ADMIN = 8;\r\n    uint256 constant ROLE_FEES_ADMIN = 9;\r\n    uint256 constant ROLE_DOCS_UPLOADER = 10;\r\n    uint256 constant ROLE_KYC_RECASTER = 11;\r\n    uint256 constant ROLE_FEES_DISTRIBUTION_ADMIN = 12;\r\n\r\n    /// states\r\n    uint256 constant STATE_ZERO_UNDEFINED = 0;\r\n    uint256 constant STATE_CREATED = 1;\r\n    uint256 constant STATE_VENDOR_ORDER = 2;\r\n    uint256 constant STATE_TRANSFER = 3;\r\n    uint256 constant STATE_CUSTODIAN_DELIVERY = 4;\r\n    uint256 constant STATE_MINTED = 5;\r\n    uint256 constant STATE_AUDIT_FAILURE = 6;\r\n    uint256 constant STATE_REPLACEMENT_ORDER = 7;\r\n    uint256 constant STATE_REPLACEMENT_DELIVERY = 8;\r\n    uint256 constant STATE_RECASTED = 9;\r\n    uint256 constant STATE_REDEEMED = 10;\r\n    uint256 constant STATE_ADMIN_FAILURE = 11;\r\n\r\n\r\n\r\n    /// interactive contracts\r\n    bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER = \"i:asset:explorer\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_DIGIX_DIRECTORY = \"i:directory\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE = \"i:mp\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN = \"i:mpadmin\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_POPADMIN = \"i:popadmin\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_PRODUCTS_LIST = \"i:products\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_TOKEN = \"i:token\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_BULK_WRAPPER = \"i:bulk-wrapper\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_TOKEN_CONFIG = \"i:token:config\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_TOKEN_INFORMATION = \"i:token:information\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION = \"i:mp:information\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_IDENTITY = \"i:identity\";\r\n\r\n\r\n    /// controller contracts\r\n    bytes32 constant CONTRACT_CONTROLLER_ASSETS = \"c:asset\";\r\n    bytes32 constant CONTRACT_CONTROLLER_ASSETS_RECAST = \"c:asset:recast\";\r\n    bytes32 constant CONTRACT_CONTROLLER_ASSETS_EXPLORER = \"c:explorer\";\r\n    bytes32 constant CONTRACT_CONTROLLER_DIGIX_DIRECTORY = \"c:directory\";\r\n    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE = \"c:mp\";\r\n    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN = \"c:mpadmin\";\r\n    bytes32 constant CONTRACT_CONTROLLER_PRODUCTS_LIST = \"c:products\";\r\n\r\n    bytes32 constant CONTRACT_CONTROLLER_TOKEN_APPROVAL = \"c:token:approval\";\r\n    bytes32 constant CONTRACT_CONTROLLER_TOKEN_CONFIG = \"c:token:config\";\r\n    bytes32 constant CONTRACT_CONTROLLER_TOKEN_INFO = \"c:token:info\";\r\n    bytes32 constant CONTRACT_CONTROLLER_TOKEN_TRANSFER = \"c:token:transfer\";\r\n\r\n    bytes32 constant CONTRACT_CONTROLLER_JOB_ID = \"c:jobid\";\r\n    bytes32 constant CONTRACT_CONTROLLER_IDENTITY = \"c:identity\";\r\n\r\n    /// storage contracts\r\n    bytes32 constant CONTRACT_STORAGE_ASSETS = \"s:asset\";\r\n    bytes32 constant CONTRACT_STORAGE_ASSET_EVENTS = \"s:asset:events\";\r\n    bytes32 constant CONTRACT_STORAGE_DIGIX_DIRECTORY = \"s:directory\";\r\n    bytes32 constant CONTRACT_STORAGE_MARKETPLACE = \"s:mp\";\r\n    bytes32 constant CONTRACT_STORAGE_PRODUCTS_LIST = \"s:products\";\r\n    bytes32 constant CONTRACT_STORAGE_GOLD_TOKEN = \"s:goldtoken\";\r\n    bytes32 constant CONTRACT_STORAGE_JOB_ID = \"s:jobid\";\r\n    bytes32 constant CONTRACT_STORAGE_IDENTITY = \"s:identity\";\r\n\r\n    /// service contracts\r\n    bytes32 constant CONTRACT_SERVICE_TOKEN_DEMURRAGE = \"sv:tdemurrage\";\r\n    bytes32 constant CONTRACT_SERVICE_MARKETPLACE = \"sv:mp\";\r\n    bytes32 constant CONTRACT_SERVICE_DIRECTORY = \"sv:directory\";\r\n\r\n    /// fees distributors\r\n    bytes32 constant CONTRACT_DEMURRAGE_FEES_DISTRIBUTOR = \"fees:distributor:demurrage\";\r\n    bytes32 constant CONTRACT_RECAST_FEES_DISTRIBUTOR = \"fees:distributor:recast\";\r\n    bytes32 constant CONTRACT_TRANSFER_FEES_DISTRIBUTOR = \"fees:distributor:transfer\";\r\n\r\n}\r\n\r\n// File: contracts/common/DigixConstantsElectron.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\ncontract DigixConstantsElectron {\r\n    uint256 constant ROLE_ELECTRON_MARKETPLACE_ADMIN = 13; // This role is for confirming the fiat purchases in Electron\r\n    uint256 constant ROLE_ASSET_RECAST_SIGNER = 14; // This role is for signing KYC information during a recast operation\r\n\r\n    /// storage contracts\r\n    bytes32 constant CONTRACT_STORAGE_MARKETPLACE_ELECTRON = \"s:mp:electron\";\r\n    bytes32 constant CONTRACT_STORAGE_ASSETS_ELECTRON = \"s:assets:electron\";\r\n    bytes32 constant CONTRACT_SERVICE_VERIFICATION = \"service:verification\";\r\n    bytes32 constant CONTRACT_CONTROLLER_ASSETS_ELECTRON = \"c:assets:electron\";\r\n    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_ELECTRON = \"c:mpadmin:electron\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ELECTRON = \"i:mp:electron\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN_ELECTRON = \"i:mpadmin:electron\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER_ELECTRON = \"i:assets:explorer:electron\";\r\n\r\n    uint256 constant TOKEN_INDEX_FIAT = 1;\r\n    uint256 constant TOKEN_INDEX_ETHER = 2;\r\n    uint256 constant TOKEN_INDEX_DAI = 3;\r\n\r\n    uint256 constant MAX_INTEGER = uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n    uint256 constant DUMMY_NONCE = 123;\r\n    /* bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN_EXTRAS = \"c:mpadmin:extras\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_V2 = \"i:mp:v2\";\r\n    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN_EXTRAS = \"i:mpadmin:extras\"; */\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/lib/DoublyLinkedList.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\nlibrary DoublyLinkedList {\r\n\r\n  struct Item {\r\n    bytes32 item;\r\n    uint256 previous_index;\r\n    uint256 next_index;\r\n  }\r\n\r\n  struct Data {\r\n    uint256 first_index;\r\n    uint256 last_index;\r\n    uint256 count;\r\n    mapping(bytes32 => uint256) item_index;\r\n    mapping(uint256 => bool) valid_indexes;\r\n    Item[] collection;\r\n  }\r\n\r\n  struct IndexedUint {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedAddress {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedBytes {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct Address {\r\n    Data data;\r\n  }\r\n\r\n  struct Bytes {\r\n    Data data;\r\n  }\r\n\r\n  struct Uint {\r\n    Data data;\r\n  }\r\n\r\n  uint256 constant NONE = uint256(0);\r\n  bytes32 constant EMPTY_BYTES = bytes32(0x0);\r\n  address constant NULL_ADDRESS = address(0x0);\r\n\r\n  function find(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    if ((self.item_index[_item] == NONE) && (self.count == NONE)) {\r\n      _item_index = NONE;\r\n    } else {\r\n      _item_index = self.item_index[_item];\r\n    }\r\n  }\r\n\r\n  function get(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    if (self.valid_indexes[_item_index] == true) {\r\n      _item = self.collection[_item_index - 1].item;\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function append(Data storage self, bytes32 _data)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (find(self, _data) != NONE || _data == bytes32(\"\")) { // rejects addition of empty values\r\n      _success = false;\r\n    } else {\r\n      uint256 _index = uint256(self.collection.push(Item({item: _data, previous_index: self.last_index, next_index: NONE})));\r\n      if (self.last_index == NONE) {\r\n        if ((self.first_index != NONE) || (self.count != NONE)) {\r\n          revert();\r\n        } else {\r\n          self.first_index = self.last_index = _index;\r\n          self.count = 1;\r\n        }\r\n      } else {\r\n        self.collection[self.last_index - 1].next_index = _index;\r\n        self.last_index = _index;\r\n        self.count++;\r\n      }\r\n      self.valid_indexes[_index] = true;\r\n      self.item_index[_data] = _index;\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n  function remove(Data storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (self.valid_indexes[_index] == true) {\r\n      Item memory item = self.collection[_index - 1];\r\n      if (item.previous_index == NONE) {\r\n        self.first_index = item.next_index;\r\n      } else {\r\n        self.collection[item.previous_index - 1].next_index = item.next_index;\r\n      }\r\n\r\n      if (item.next_index == NONE) {\r\n        self.last_index = item.previous_index;\r\n      } else {\r\n        self.collection[item.next_index - 1].previous_index = item.previous_index;\r\n      }\r\n      delete self.collection[_index - 1];\r\n      self.valid_indexes[_index] = false;\r\n      delete self.item_index[item.item];\r\n      self.count--;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function remove_item(Data storage self, bytes32 _item)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    uint256 _item_index = find(self, _item);\r\n    if (_item_index != NONE) {\r\n      require(remove(self, _item_index));\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n    return _success;\r\n  }\r\n\r\n  function total(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = self.count;\r\n  }\r\n\r\n  function start(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.first_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function start_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = start(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function end(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.last_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function end_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = end(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function valid(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = self.valid_indexes[_item_index];\r\n    //_yes = ((_item_index - 1) < self.collection.length);\r\n  }\r\n\r\n  function valid_item(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    uint256 _item_index = self.item_index[_item];\r\n    _yes = self.valid_indexes[_item_index];\r\n  }\r\n\r\n  function previous(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _previous_index = self.collection[_current_index - 1].previous_index;\r\n    } else {\r\n      _previous_index = NONE;\r\n    }\r\n  }\r\n\r\n  function previous_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _previous_index = previous(self, _current_index);\r\n      _previous_item = get(self, _previous_index);\r\n    } else {\r\n      _previous_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function next(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _next_index = self.collection[_current_index - 1].next_index;\r\n    } else {\r\n      _next_index = NONE;\r\n    }\r\n  }\r\n\r\n  function next_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _next_index = next(self, _current_index);\r\n      _next_item = get(self, _next_index);\r\n    } else {\r\n      _next_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function find(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function append(Uint storage self, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Uint storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n  function remove_item(Uint storage self, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data));\r\n  }\r\n\r\n  function valid(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function find(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = address(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function find(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function get(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data[_collection_index], _item_index));\r\n  }\r\n\r\n\r\n  function append(IndexedUint storage self, bytes32 _collection_index, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedUint storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n  function remove_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function append(Address storage self, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Address storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Address storage self, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data));\r\n  }\r\n\r\n  function valid(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function append(IndexedAddress storage self, bytes32 _collection_index, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedAddress storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedAddress storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n\r\n  function find(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, _item);\r\n  }\r\n\r\n  function get(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = get(self.data, _item_index);\r\n  }\r\n\r\n\r\n  function append(Bytes storage self, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, _data);\r\n  }\r\n\r\n  function remove(Bytes storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, _item);\r\n  }\r\n\r\n  function total(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = start_item(self.data);\r\n  }\r\n\r\n\r\n  function end(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = end_item(self.data);\r\n  }\r\n\r\n  function valid(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, _item);\r\n  }\r\n\r\n  function previous(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = previous_item(self.data, _current_item);\r\n  }\r\n\r\n  function next(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = next_item(self.data, _current_item);\r\n  }\r\n\r\n  function append(IndexedBytes storage self, bytes32 _collection_index, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedBytes storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = bytes32(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = bytes32(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedBytes storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = bytes32(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = bytes32(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n\r\n}\r\n\r\n// File: @digix/solidity-statemachine/contracts/lib/StateMachine.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\nlibrary StateMachine {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n\r\n  struct System {\r\n    mapping(bytes32 => Item) items;\r\n    mapping(address => uint256) to_role;\r\n    mapping(uint256 => mapping (uint256 => mapping(uint256 => bool))) access_control;\r\n    mapping(uint256 => DoublyLinkedList.Bytes) lists_by_state;\r\n    mapping(uint256 => bytes32) state_ids_to_name;\r\n    mapping(uint256 => bytes32) role_ids_to_name;\r\n    DoublyLinkedList.Bytes global_list;\r\n    bytes32 seed;\r\n  }\r\n\r\n  struct Item {\r\n    uint256 state;\r\n  }\r\n\r\n  function set_state_name(System storage _system, uint256 _state_id, bytes32 _state_name)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _system.state_ids_to_name[_state_id] = _state_name;\r\n    _success = true;\r\n  }\r\n\r\n  function get_state_name(System storage _system, uint256 _state_id)\r\n           internal\r\n           constant\r\n           returns (bytes32 _state_name)\r\n  {\r\n    if (_state_id == 0) {\r\n      _state_name = bytes32(\"none\");\r\n    } else {\r\n      _state_name = _system.state_ids_to_name[_state_id];\r\n    }\r\n  }\r\n\r\n  function get_item_state_id(System storage _system, bytes32 _item)\r\n           internal\r\n           constant\r\n           returns (uint256 _state_id)\r\n  {\r\n    _state_id = _system.items[_item].state;\r\n  }\r\n\r\n  function get_item_state_name(System storage _system, bytes32 _item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _state_name)\r\n  {\r\n    _state_name = get_state_name(_system, get_item_state_id(_system, _item));\r\n  }\r\n\r\n  function set_role_name(System storage _system, uint256 _role_id, bytes32 _role_name)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _system.role_ids_to_name[_role_id] = _role_name;\r\n    _success = true;\r\n  }\r\n\r\n  function get_role_name(System storage _system, uint256 _role_id)\r\n           internal\r\n           constant\r\n           returns (bytes32 _role_name)\r\n  {\r\n    if (_role_id == 0) {\r\n      _role_name = bytes32(\"none\");\r\n    } else {\r\n      _role_name = _system.role_ids_to_name[_role_id];\r\n    }\r\n  }\r\n\r\n  function get_entity_role_id(System storage _system, address _entity)\r\n           internal\r\n           constant\r\n           returns (uint256 _role_id)\r\n  {\r\n    _role_id = _system.to_role[_entity];\r\n  }\r\n\r\n  function set_role(System storage _system, address _entity, uint256 _role_id)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _system.to_role[_entity] = _role_id;\r\n    _success = true;\r\n  }\r\n\r\n  function unset_role(System storage _system, address _entity)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (_system.to_role[_entity] == 0) {\r\n      _success = false;\r\n    } else {\r\n      delete _system.to_role[_entity];\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n  function grant_access(System storage _system, uint256 _by_role, uint256 _from_state, uint256 _to_state)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (_system.access_control[_by_role][_from_state][_to_state] == false) {\r\n      _system.access_control[_by_role][_from_state][_to_state] = true;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function revoke_access(System storage _system, uint256 _by_role, uint256 _from_state, uint256 _to_state)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if(_system.access_control[_by_role][_from_state][_to_state] == true) {\r\n      _system.access_control[_by_role][_from_state][_to_state] = false;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function init(System storage _system)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(_system.seed == bytes32(0x0));\r\n    _system.seed = bytes32(address(this));\r\n    _success = true;\r\n  }\r\n\r\n  function get_new_identifier(System storage _system)\r\n           internal\r\n           returns (bytes32 _new_id)\r\n  {\r\n    require(_system.seed != bytes32(0x0));\r\n    _system.seed = keccak256(_system.seed, now);\r\n    _new_id = _system.seed;\r\n  }\r\n\r\n  function create_item(System storage _system, uint256 _by_role)\r\n           internal\r\n           returns (bool _success, bytes32 _item)\r\n  {\r\n    require(_system.seed != bytes32(0x0)); // system must be init-ed first, and hence seed must already have value\r\n    if (_system.access_control[_by_role][0][1] == true) {\r\n      _item = get_new_identifier(_system);\r\n      _system.items[_item].state = 1;\r\n      require(_system.global_list.append(_item));\r\n      require(_system.lists_by_state[1].append(_item));\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n      _item = bytes32(0x0);\r\n    }\r\n  }\r\n\r\n  function change_item_state(System storage _system, uint256 _by_role, bytes32 _item, uint256 _to_state)\r\n           internal\r\n           returns (bool _success, uint256 _from_state, uint256 _new_state)\r\n  {\r\n\r\n    _from_state = _system.items[_item].state;\r\n\r\n    bool _append_success;\r\n    bool _remove_success;\r\n    _new_state = _from_state;\r\n    _success = false;\r\n\r\n    if (_system.access_control[0][_from_state][_to_state] == true) {\r\n      _by_role = 0;\r\n    }\r\n\r\n    if (_system.access_control[_by_role][_from_state][_to_state] == true) {\r\n      _system.items[_item].state = _to_state;\r\n      _append_success = _system.lists_by_state[_to_state].append(_item);\r\n      _remove_success = _system.lists_by_state[_from_state].remove_item(_item);\r\n      _new_state = _system.items[_item].state;\r\n      _success = (_append_success && _remove_success);\r\n    }\r\n  }\r\n\r\n  function total_in_state(System storage _system, uint256 _state_id)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = _system.lists_by_state[_state_id].total();\r\n  }\r\n\r\n  function total(System storage _system)\r\n           public\r\n           constant\r\n           returns (uint256 _global_count)\r\n  {\r\n    _global_count = _system.global_list.total();\r\n  }\r\n\r\n  function get_first_in_global(System storage _system)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.global_list.start_item();\r\n  }\r\n\r\n  function get_last_in_global(System storage _system)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.global_list.end_item();\r\n  }\r\n\r\n  function get_next_from_in_global(System storage _system, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.global_list.next_item(_current_item);\r\n  }\r\n\r\n  function get_previous_from_in_global(System storage _system, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.global_list.previous_item(_current_item);\r\n  }\r\n\r\n  function get_first_in_state(System storage _system, uint256 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.lists_by_state[_state_id].start_item();\r\n  }\r\n\r\n  function get_last_in_state(System storage _system, uint256 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.lists_by_state[_state_id].end_item();\r\n  }\r\n\r\n  function get_next_from_in_state(System storage _system, uint256 _state_id, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.lists_by_state[_state_id].next_item(_current_item);\r\n  }\r\n\r\n  function get_previous_from_in_state(System storage _system, uint256 _state_id, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _system.lists_by_state[_state_id].previous_item(_current_item);\r\n  }\r\n\r\n  function check_role_access(System storage _system, uint256 _role_id, uint256 _from_state, uint256 _to_state)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = _system.access_control[_role_id][_from_state][_to_state];\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/IndexedBytesIteratorStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n  @title Indexed Bytes Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n  @notice This contract utilizes: [Doubly Linked List](/DoublyLinkedList)\r\n*/\r\ncontract IndexedBytesIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedBytes;\r\n\r\n  /**\r\n    @notice Reads the first item from an Indexed Bytes Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\":\"The first item from the specified `_list`\"}\r\n  */\r\n  function read_first_from_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.start_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the last item from an Indexed Bytes Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\":\"The last item from the specified `_list`\"}\r\n  */\r\n  function read_last_from_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.end_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item from an Indexed Bytes Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\":\"The next item from the specified `_current_item`\"}\r\n  */\r\n  function read_next_from_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.next_item(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item from an Indexed Bytes Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Collection Index\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\":\"The previous item from the specified `_current_item`\"}\r\n  */\r\n  function read_previous_from_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.previous_item(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the list of Indexed Bytes and returns length of the list\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_count\":\"\"}\r\n  */\r\n  function read_total_indexed_bytesarray(DoublyLinkedList.IndexedBytes storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total(_collection_index);\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/BytesIteratorStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n/**\r\n  @title Bytes Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract BytesIteratorStorage {\r\n\r\n  // Initialize Doubly Linked List of Bytes\r\n  using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n\r\n  /**\r\n    @notice Reads the first item from the list of Bytes\r\n    @param _list The source list\r\n    @return {\"_item\": \"The first item from the list\"}\r\n  */\r\n  function read_first_from_bytesarray(DoublyLinkedList.Bytes storage _list)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.start_item();\r\n  }\r\n\r\n  /**\r\n    @notice Reads the last item from the list of Bytes\r\n    @param _list The source list\r\n    @return {\"_item\": \"The last item from the list\"}\r\n  */\r\n  function read_last_from_bytesarray(DoublyLinkedList.Bytes storage _list)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.end_item();\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item on the list of Bytes\r\n    @param _list The source list\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\": \"The next item from the list based on the specieid `_current_item`\"}\r\n    TODO: Need to verify what happens if the specified `_current_item` is the last item from the list\r\n  */\r\n  function read_next_from_bytesarray(DoublyLinkedList.Bytes storage _list, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.next_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item on the list of Bytes\r\n    @param _list The source list\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\": \"The previous item from the list based on the spcified `_current_item`\"}\r\n    TODO: Need to verify what happens if the specified `_current_item` is the first item from the list\r\n  */\r\n  function read_previous_from_bytesarray(DoublyLinkedList.Bytes storage _list, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.previous_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the list of Bytes and returns the length of the list\r\n    @param _list The source list\r\n    @return {\"count\": \"`uint256` The lenght of the list\"}\r\n\r\n  */\r\n  function read_total_bytesarray(DoublyLinkedList.Bytes storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total();\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/storage/AssetsStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AssetsStorage is ResolverClient, IndexedBytesIteratorStorage, BytesIteratorStorage, DigixConstants {\r\n\r\n  using StateMachine for StateMachine.System;\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedBytes;\r\n  using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n\r\n  struct Item {\r\n    uint256 product_id;\r\n    uint256 ng_weight;\r\n    uint256 effective_ng_weight;\r\n    bytes32 serial;\r\n    uint256 time_minted;\r\n    uint256 redeem_deadline;\r\n    address mint_target;\r\n    address redeem_for;\r\n    bytes32 replaced_by; // id of the item that replaces this item if it fails audit\r\n    bytes32 replaces; // id of the item that this item replaces\r\n  }\r\n\r\n  struct System {\r\n    StateMachine.System state_machine;\r\n    DoublyLinkedList.Bytes global_audit_documents;\r\n    DoublyLinkedList.IndexedBytes asset_documents;\r\n    DoublyLinkedList.IndexedBytes user_recasts;\r\n    mapping (bytes32 => Item) items_by_id;\r\n    uint256 last_global_audit_time;\r\n    uint256 redeem_period;              // Recaster has to redeem the asset within redeem_period days\r\n    // last_asset_with_serial[serial_no] is the asset id of the latest asset that was added into the system with that serial_no\r\n    // note that a gold bar with the same serial number can go through multiple cycles of minting and redeeming\r\n    // and last_asset_with_serial records the asset id in the last cycle\r\n    mapping (bytes32 => bytes32) last_asset_with_serial;\r\n  }\r\n\r\n  System system;\r\n\r\n  function AssetsStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_ASSETS, _resolver));\r\n    require(system.state_machine.init());\r\n    system.redeem_period = 31; // default to 31 days\r\n\r\n    // roles\r\n    system.state_machine.set_role_name(ROLE_VENDOR, \"vendor\");\r\n    system.state_machine.set_role_name(ROLE_XFERAUTH, \"xferauth\");\r\n    system.state_machine.set_role_name(ROLE_POPADMIN, \"popadmin\");\r\n    system.state_machine.set_role_name(ROLE_CUSTODIAN, \"custodian\");\r\n    system.state_machine.set_role_name(ROLE_AUDITOR, \"auditor\");\r\n\r\n    // state names\r\n    system.state_machine.set_state_name(STATE_CREATED, \"created\");\r\n    system.state_machine.set_state_name(STATE_VENDOR_ORDER, \"vendor_order\");\r\n    system.state_machine.set_state_name(STATE_TRANSFER, \"transfer\");\r\n    system.state_machine.set_state_name(STATE_CUSTODIAN_DELIVERY, \"custodian_delivery\");\r\n    system.state_machine.set_state_name(STATE_MINTED, \"minted\");\r\n    system.state_machine.set_state_name(STATE_AUDIT_FAILURE, \"audit_failure\");\r\n    system.state_machine.set_state_name(STATE_REPLACEMENT_ORDER, \"replacement_order\");\r\n    system.state_machine.set_state_name(STATE_REPLACEMENT_DELIVERY, \"replacement_delivery\");\r\n    system.state_machine.set_state_name(STATE_RECASTED, \"recasted\");\r\n    system.state_machine.set_state_name(STATE_REDEEMED, \"redeemed\");\r\n    system.state_machine.set_state_name(STATE_ADMIN_FAILURE, \"admin_failure\");\r\n\r\n    // popadmin: create an asset item\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_ZERO_UNDEFINED, STATE_CREATED);\r\n\r\n    // popadmin: change a newly created asset to 'vendor_order'\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_CREATED, STATE_VENDOR_ORDER);\r\n\r\n    // popadmin: change a newly created asset to 'transfer'\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_CREATED, STATE_TRANSFER);\r\n\r\n    // vendor: vendor_order to custodian_delivery\r\n    system.state_machine.grant_access(ROLE_VENDOR, STATE_VENDOR_ORDER, STATE_CUSTODIAN_DELIVERY);\r\n\r\n    // xferauth: transfer to custodian_delivery\r\n    system.state_machine.grant_access(ROLE_XFERAUTH, STATE_TRANSFER, STATE_CUSTODIAN_DELIVERY);\r\n\r\n    // custodian: custodian_delivery to minted\r\n    system.state_machine.grant_access(ROLE_CUSTODIAN, STATE_CUSTODIAN_DELIVERY, STATE_MINTED);\r\n\r\n    // auditor: minted to audit_failure\r\n    system.state_machine.grant_access(ROLE_AUDITOR, STATE_MINTED, STATE_AUDIT_FAILURE);\r\n\r\n    // popadmin: created to replacement_order\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_CREATED, STATE_REPLACEMENT_ORDER);\r\n\r\n    // vendor: replacement_order to replacement_delivery\r\n    system.state_machine.grant_access(ROLE_VENDOR, STATE_REPLACEMENT_ORDER, STATE_REPLACEMENT_DELIVERY);\r\n\r\n    // popadmin: vendor_order to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_VENDOR_ORDER, STATE_ADMIN_FAILURE);\r\n\r\n    // popadmin: transfer to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_TRANSFER, STATE_ADMIN_FAILURE);\r\n\r\n    // popadmin: custodian_delivery to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_CUSTODIAN_DELIVERY, STATE_ADMIN_FAILURE);\r\n\r\n    // popadmin: replacement_order to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_REPLACEMENT_ORDER, STATE_ADMIN_FAILURE);\r\n\r\n    // popadmin: replacement_delivery to admin_failure\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_REPLACEMENT_DELIVERY, STATE_ADMIN_FAILURE);\r\n\r\n    // custodian: replacement_delivery to minted\r\n    system.state_machine.grant_access(ROLE_CUSTODIAN, STATE_REPLACEMENT_DELIVERY, STATE_MINTED);\r\n\r\n    // any: minted to recasted\r\n    system.state_machine.grant_access(ROLE_ZERO_ANYONE, STATE_MINTED, STATE_RECASTED);\r\n\r\n    // popadmin: recasted to redeemed\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_RECASTED, STATE_REDEEMED);\r\n\r\n    // popadmin: recasted to minted\r\n    system.state_machine.grant_access(ROLE_POPADMIN, STATE_RECASTED, STATE_MINTED);\r\n\r\n    // kycrecaster: recasted to minted (only if reminted by recaster)\r\n    system.state_machine.grant_access(ROLE_KYC_RECASTER, STATE_RECASTED, STATE_MINTED);\r\n  }\r\n\r\n  function read_asset_info(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight,\r\n                    bytes32 _serial, uint256 _state_id, uint256 _documents_count, uint256 _time_minted, uint256 _redeem_deadline)\r\n  {\r\n    _product_id = system.items_by_id[_item].product_id;\r\n    _ng_weight = system.items_by_id[_item].ng_weight;\r\n    _effective_ng_weight = system.items_by_id[_item].effective_ng_weight;\r\n    _serial = system.items_by_id[_item].serial;\r\n    _state_id = system.state_machine.get_item_state_id(_item);\r\n    _documents_count = read_total_asset_documents(_item);\r\n    _time_minted = system.items_by_id[_item].time_minted;\r\n    _redeem_deadline = system.items_by_id[_item].redeem_deadline;\r\n  }\r\n\r\n  function read_last_asset_with_serial(bytes32 _serial)\r\n           public\r\n           constant\r\n           returns (bytes32 _asset_id)\r\n  {\r\n    _asset_id = system.last_asset_with_serial[_serial];\r\n  }\r\n\r\n  function read_asset_state(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _state_id)\r\n  {\r\n    _state_id = system.state_machine.get_item_state_id(_item);\r\n  }\r\n\r\n  function read_redeem_period()\r\n           public\r\n           constant\r\n           returns (uint256 _redeem_period)\r\n  {\r\n    _redeem_period = system.redeem_period;\r\n  }\r\n\r\n  function read_asset_details(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (address _mint_target, address _redeem_for, bytes32 _replaced_by, bytes32 _replaces)\r\n  {\r\n    _mint_target = system.items_by_id[_item].mint_target;\r\n    _redeem_for = system.items_by_id[_item].redeem_for;\r\n    _replaced_by = system.items_by_id[_item].replaced_by;\r\n    _replaces = system.items_by_id[_item].replaces;\r\n  }\r\n\r\n  function read_last_global_audit_time()\r\n           public\r\n           constant\r\n           returns (uint256 _last_global_audit_time)\r\n  {\r\n    _last_global_audit_time = system.last_global_audit_time;\r\n  }\r\n\r\n  function read_state_name(uint256 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _state_name)\r\n  {\r\n    _state_name = system.state_machine.get_state_name(_state_id);\r\n  }\r\n\r\n  function read_item_state_name(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bytes32 _state_name)\r\n  {\r\n    _state_name = read_state_name(system.state_machine.get_item_state_id(_item));\r\n  }\r\n\r\n  function read_first_item_in_state(bytes32 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = system.state_machine.get_first_in_state(uint256(_state_id));\r\n  }\r\n\r\n  function read_last_item_in_state(bytes32 _state_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = system.state_machine.get_last_in_state(uint256(_state_id));\r\n  }\r\n\r\n  function read_next_item_from_item_in_state(bytes32 _state_id, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = system.state_machine.get_next_from_in_state(uint256(_state_id), _current_item);\r\n  }\r\n\r\n  function read_previous_item_from_item_in_state(bytes32 _state_id, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = system.state_machine.get_previous_from_in_state(uint256(_state_id), _current_item);\r\n  }\r\n\r\n  function read_total_items_in_state(bytes32 _state_id)\r\n           public\r\n           constant\r\n           returns (uint256 _total_items)\r\n  {\r\n    _total_items = system.state_machine.total_in_state(uint256(_state_id));\r\n  }\r\n\r\n\r\n  function read_total_asset_documents(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = read_total_indexed_bytesarray(system.asset_documents, _item);\r\n  }\r\n\r\n  function read_first_asset_document(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_first_from_indexed_bytesarray(system.asset_documents, _item);\r\n  }\r\n\r\n  function read_last_asset_document(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_last_from_indexed_bytesarray(system.asset_documents, _item);\r\n  }\r\n\r\n  function read_next_asset_document_from_document(bytes32 _item, bytes32 _current_document)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_next_from_indexed_bytesarray(system.asset_documents, _item, _current_document);\r\n  }\r\n\r\n\r\n  function read_previous_asset_document_from_document(bytes32 _item, bytes32 _current_document)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_previous_from_indexed_bytesarray(system.asset_documents, _item, _current_document);\r\n  }\r\n\r\n  function read_first_global_audit()\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_first_from_bytesarray(system.global_audit_documents);\r\n  }\r\n\r\n  function read_last_global_audit()\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_last_from_bytesarray(system.global_audit_documents);\r\n  }\r\n\r\n  function read_next_global_audit_from_audit(bytes32 _current_document)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_next_from_bytesarray(system.global_audit_documents, _current_document);\r\n  }\r\n\r\n\r\n  function read_previous_global_audit_from_audit(bytes32 _current_document)\r\n           public\r\n           constant\r\n           returns (bytes32 _document)\r\n  {\r\n    _document = read_previous_from_bytesarray(system.global_audit_documents, _current_document);\r\n  }\r\n\r\n  function read_total_global_audits()\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = system.global_audit_documents.total();\r\n  }\r\n\r\n  function read_user_first_recast(bytes32 _user)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = read_first_from_indexed_bytesarray(system.user_recasts, _user);\r\n  }\r\n\r\n  function read_user_last_recast(bytes32 _user)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = read_last_from_indexed_bytesarray(system.user_recasts, _user);\r\n  }\r\n\r\n  function read_user_next_recast_from_item(bytes32 _user, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = read_next_from_indexed_bytesarray(system.user_recasts, _user, _current_item);\r\n  }\r\n\r\n  function read_user_previous_recast_from_item(bytes32 _user, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = read_previous_from_indexed_bytesarray(system.user_recasts, _user, _current_item);\r\n  }\r\n\r\n  function read_user_total_recasts(bytes32 _user)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = read_total_indexed_bytesarray(system.user_recasts, _user);\r\n  }\r\n\r\n  function create_global_audit(bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    _success = system.global_audit_documents.append(_document);\r\n    require(_success);\r\n    system.last_global_audit_time = now;\r\n  }\r\n\r\n  /**\r\n  @notice create a new asset item to the `vendor_order` state\r\n  */\r\n  function create_init_item(uint256 _role_id, uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight, address _mint_target)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, bytes32 _item)\r\n  {\r\n    (_success, _item) = system.state_machine.create_item(_role_id);\r\n    require(_success);\r\n    system.state_machine.change_item_state(_role_id, _item, STATE_VENDOR_ORDER);\r\n    system.items_by_id[_item].product_id = _product_id;\r\n    system.items_by_id[_item].ng_weight = _ng_weight;\r\n    system.items_by_id[_item].effective_ng_weight = _effective_ng_weight;\r\n    system.items_by_id[_item].mint_target = _mint_target;\r\n  }\r\n\r\n  /**\r\n  @notice create a new asset item to be transfered in, set it to `transfer` state\r\n  */\r\n  function create_init_item_transfer(uint256 _role_id, uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight, address _mint_target)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, bytes32 _item)\r\n  {\r\n    (_success, _item) = system.state_machine.create_item(_role_id);\r\n    require(_success);\r\n    system.state_machine.change_item_state(_role_id, _item, STATE_TRANSFER);\r\n    system.items_by_id[_item].product_id = _product_id;\r\n    system.items_by_id[_item].ng_weight = _ng_weight;\r\n    system.items_by_id[_item].effective_ng_weight = _effective_ng_weight;\r\n    system.items_by_id[_item].mint_target = _mint_target;\r\n  }\r\n\r\n  function internal_check_duplicate_serial_when_fulfilling_order(bytes32 _item, bytes32 _serial)\r\n           internal\r\n  {\r\n    bytes32 _last_asset_with_same_serial = system.last_asset_with_serial[_serial];\r\n    if (_last_asset_with_same_serial != bytes32(0x0)) {\r\n      uint256 _existing_asset_state_id = system.state_machine.get_item_state_id(_last_asset_with_same_serial);\r\n      require(_existing_asset_state_id == STATE_ADMIN_FAILURE\r\n        || _existing_asset_state_id == STATE_AUDIT_FAILURE\r\n        || _existing_asset_state_id == STATE_REDEEMED);\r\n    }\r\n    system.last_asset_with_serial[_serial] = _item;\r\n  }\r\n\r\n  /**\r\n  @notice Update an item from either `vendor_order` or `transfer` state to `custodian_delivery` state;\r\n          Save the asset's serial and the related document\r\n  */\r\n  function update_item_fulfill(uint256 _role_id, bytes32 _item, bytes32 _serial, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, uint256 _from_state, uint256 _new_state)\r\n  {\r\n    (_success, _from_state, _new_state) = system.state_machine.change_item_state(_role_id, _item, STATE_CUSTODIAN_DELIVERY);\r\n    require(_success);\r\n    internal_check_duplicate_serial_when_fulfilling_order(_item, _serial);\r\n    system.asset_documents.append(_item, _document);\r\n    system.items_by_id[_item].serial = _serial;\r\n  }\r\n\r\n  /// @notice (custodian) accepts an asset item to the `minted` state\r\n  function update_item_mint(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, address _mint_target, uint256 _effective_ng_weight, uint256 _from_state, uint256 _new_state)\r\n  {\r\n    _mint_target = system.items_by_id[_item].mint_target;\r\n    _effective_ng_weight = system.items_by_id[_item].effective_ng_weight;\r\n    (_success, _from_state, _new_state) = system.state_machine.change_item_state(_role_id, _item, STATE_MINTED);\r\n    require(_success);\r\n    system.items_by_id[_item].time_minted = now;\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice update a minted asset to the `recasted` state\r\n  function update_item_recast(uint256 _role_id, bytes32 _item, address _redeem_for, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_RECASTED);\r\n    require(_success);\r\n    system.items_by_id[_item].redeem_for = _redeem_for;\r\n    system.items_by_id[_item].redeem_deadline = now + system.redeem_period * SECONDS_IN_A_DAY;\r\n    system.user_recasts.append(bytes32(_redeem_for), _item);\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice update a recasted item to the `redeemed` state\r\n  function update_item_redeem(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_REDEEMED);\r\n    require(_success);\r\n    address _redeem_for = system.items_by_id[_item].redeem_for;\r\n    system.user_recasts.remove_item(bytes32(_redeem_for), _item);\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice update a recasted item to the `minted` state\r\n  function update_item_remint(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_MINTED);\r\n    require(_success);\r\n    address _redeem_for = system.items_by_id[_item].redeem_for;\r\n    system.user_recasts.remove_item(bytes32(_redeem_for), _item);\r\n    system.items_by_id[_item].redeem_for = address(0x0); // reset the redeem_for field of this minted asset\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  function update_item_to_audit_failure(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, uint256 _from_state, uint256 _new_state)\r\n  {\r\n    (_success, _from_state, _new_state) = system.state_machine.change_item_state(_role_id, _item, STATE_AUDIT_FAILURE);\r\n    require(_success);\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice (popadmin) create a new asset item to replace an item that failed audit, mark it as `replacement_order`\r\n  function create_init_item_as_replacement(uint256 _role_id, uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight, bytes32 _old_item)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, bytes32 _replacement_item)\r\n  {\r\n    (_success, _replacement_item) = system.state_machine.create_item(_role_id);\r\n    require(_success);\r\n    system.state_machine.change_item_state(_role_id, _replacement_item, STATE_REPLACEMENT_ORDER);\r\n    system.items_by_id[_replacement_item].product_id = _product_id;\r\n    system.items_by_id[_replacement_item].ng_weight = _ng_weight;\r\n    system.items_by_id[_replacement_item].effective_ng_weight = _effective_ng_weight;\r\n    system.items_by_id[_replacement_item].replaces = _old_item;\r\n    system.items_by_id[_old_item].replaced_by = _replacement_item;\r\n  }\r\n\r\n  /// @notice (vendor) change the state of an asset item from `replacement_order` to `replacement_delivery`\r\n  function update_item_fulfill_replacement(uint256 _role_id, bytes32 _item, bytes32 _serial, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_REPLACEMENT_DELIVERY);\r\n    require(_success);\r\n    internal_check_duplicate_serial_when_fulfilling_order(_item, _serial);\r\n    system.asset_documents.append(_item, _document);\r\n    system.items_by_id[_item].serial = _serial;\r\n  }\r\n\r\n  /// @notice (custodian) accepts an asset item from `replacement_delivery` state to `minted` state\r\n  function update_item_mint_replacement(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success, uint256 _effective_ng_weight)\r\n  {\r\n    _effective_ng_weight = system.items_by_id[_item].effective_ng_weight;\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_MINTED);\r\n    require(_success);\r\n    system.items_by_id[_item].time_minted = now;\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  /// @notice (popadmin) fail an asset that has not been minted\r\n  function update_item_admin_fail(uint256 _role_id, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    (_success,,) = system.state_machine.change_item_state(_role_id, _item, STATE_ADMIN_FAILURE);\r\n    require(_success);\r\n    system.asset_documents.append(_item, _document);\r\n  }\r\n\r\n  function update_item_add_document(bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           returns (bool _success)\r\n  {\r\n    _success = system.asset_documents.append(_item, _document);\r\n    require(_success);\r\n  }\r\n\r\n  function update_redeem_period(uint256 _redeem_period)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.redeem_period = _redeem_period;\r\n    _success = true;\r\n  }\r\n}\r\n\r\n// File: contracts/storage/AssetEventsStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract AssetEventsStorage is ResolverClient, DigixConstants {\r\n  struct PoPEvent {\r\n    uint256 event_type;\r\n    uint256 timestamp;\r\n  }\r\n\r\n  struct AssetEventsData {\r\n    PoPEvent[] events;\r\n    uint256 count;\r\n  }\r\n\r\n  mapping(bytes32 => AssetEventsData) system;\r\n\r\n  function AssetEventsStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_ASSET_EVENTS, _resolver));\r\n  }\r\n\r\n  function add_asset_event(bytes32 _asset_item, uint256 _event_type)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(msg.sender == get_contract(CONTRACT_CONTROLLER_ASSETS) || msg.sender == get_contract(CONTRACT_CONTROLLER_ASSETS_RECAST));\r\n    uint256 _event_count = system[_asset_item].count;\r\n    system[_asset_item].events.push(PoPEvent(_event_type, now));\r\n    system[_asset_item].count = _event_count + 1;\r\n    _success = true;\r\n  }\r\n\r\n  function read_asset_events_count(bytes32 _asset_item)\r\n           public\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = system[_asset_item].count;\r\n  }\r\n\r\n  function read_asset_event_details(bytes32 _asset_item, uint256 _index)\r\n           public\r\n           constant\r\n           returns (uint256 _event_type, uint256 _timestamp)\r\n  {\r\n    _event_type = system[_asset_item].events[_index].event_type;\r\n    _timestamp = system[_asset_item].events[_index].timestamp;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/storage/GoldTokenStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract GoldTokenStorage is ResolverClient, DigixConstants {\r\n\r\n  struct FeeConfiguration {\r\n    uint256 base;\r\n    uint256 rate;\r\n  }\r\n\r\n  struct GlobalConfig {\r\n    bytes32 current_version;\r\n    bool no_demurrage_fee;\r\n    bool no_transfer_fee;\r\n    uint256 minimum_transfer_amount;\r\n    Fees fees;\r\n  }\r\n\r\n  struct Fees {\r\n    FeeConfiguration demurrage;\r\n    FeeConfiguration recast;\r\n    FeeConfiguration transfer;\r\n  }\r\n\r\n  struct Collectors {\r\n    address demurrage;\r\n    address recast;\r\n    address transfer;\r\n  }\r\n\r\n  struct UserConfig {\r\n    bool no_demurrage_fee;\r\n    bool no_transfer_fee;\r\n    bool no_recast_fee;\r\n  }\r\n\r\n  struct UserData {\r\n    uint256 last_payment_date;\r\n    uint256 raw_balance;\r\n    mapping (address => uint256) spender_allowances;\r\n  }\r\n\r\n  struct User {\r\n    UserConfig config;\r\n    UserData data;\r\n  }\r\n\r\n  struct System {\r\n    Collectors collectors;\r\n    GlobalConfig config;\r\n    uint256 total_supply;\r\n    uint256 effective_total_supply;\r\n    mapping (address => User) users;\r\n  }\r\n\r\n  System system;\r\n\r\n  function GoldTokenStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_GOLD_TOKEN, _resolver));\r\n\r\n    address _demurrage_collector;\r\n    address _transfer_collector;\r\n    address _recast_collector;\r\n\r\n    assembly {\r\n      _demurrage_collector := create(0,0,0)\r\n      _transfer_collector := create(0,0,0)\r\n      _recast_collector := create(0,0,0)\r\n    }\r\n    system.collectors.demurrage = _demurrage_collector;\r\n    system.collectors.recast = _recast_collector;\r\n    system.collectors.transfer = _transfer_collector;\r\n    system.config.fees.demurrage.base = 10000000;\r\n    system.config.fees.demurrage.rate = 165;\r\n    system.config.fees.recast.base = 100000000000;\r\n    system.config.fees.recast.rate = 1000000000;\r\n    system.config.fees.transfer.base = 10000;\r\n    system.config.fees.transfer.rate = 13;\r\n    system.config.minimum_transfer_amount = 1000000;\r\n    system.config.no_demurrage_fee = false;\r\n    system.config.no_transfer_fee = false;\r\n    system.config.current_version = \"1.0.0\";\r\n    system.total_supply = 0;\r\n    system.effective_total_supply = 0;\r\n  }\r\n\r\n\r\n /////////////////////////////////////////////////////\r\n///    functions to read global configs           ///\r\n/////////////////////////////////////////////////////\r\n\r\n  /// @notice read the total number of tokens\r\n  function read_total_supply()\r\n           constant\r\n           public\r\n           returns (uint256 _total_supply)\r\n  {\r\n    _total_supply = system.total_supply;\r\n  }\r\n\r\n  /// @notice read the effective total, which is the number of nanograms of gold that is backing the Gold tokens\r\n  function read_effective_total_supply()\r\n           constant\r\n           public\r\n           returns (uint256 _effective_total_supply)\r\n  {\r\n    _effective_total_supply = system.effective_total_supply;\r\n  }\r\n\r\n  /// @notice read both the total_supply and effective_total_supply\r\n  function read_supply()\r\n           constant\r\n           public\r\n           returns (uint256 _total_supply, uint256 _effective_total_supply)\r\n  {\r\n    _total_supply = read_total_supply();\r\n    _effective_total_supply = read_effective_total_supply();\r\n  }\r\n\r\n  /// @notice read general global configs: no_demurrage_fee, no_transfer_fee, minimum_transfer_amount, current_version\r\n  function read_general_config()\r\n           constant\r\n           public\r\n           returns (bytes32 _current_version, bool _no_demurrage_fee, bool _no_transfer_fee, uint256 _minimum_transfer_amount)\r\n  {\r\n    _current_version = system.config.current_version;\r\n    _no_demurrage_fee = system.config.no_demurrage_fee;\r\n    _no_transfer_fee = system.config.no_transfer_fee;\r\n    _minimum_transfer_amount = system.config.minimum_transfer_amount;\r\n  }\r\n\r\n  function read_collectors_addresses()\r\n           constant\r\n           public\r\n           returns (address[3] _collectors)\r\n  {\r\n    /* _collectors = new address[](3); */\r\n    _collectors[0] = system.collectors.demurrage;\r\n    _collectors[1] = system.collectors.recast;\r\n    _collectors[2] = system.collectors.transfer;\r\n  }\r\n\r\n\r\n ///////////////////////////////////////////////\r\n///    functions to read users' configs     ///\r\n///////////////////////////////////////////////\r\n\r\n  /// @notice read all details of a user\r\n  function read_user(address _account)\r\n           public\r\n           constant\r\n           returns (bool _exists,\r\n                    uint256 _raw_balance,\r\n                    uint256 _payment_date,\r\n                    bool _no_demurrage_fee,\r\n                    bool _no_recast_fee,\r\n                    bool _no_transfer_fee)\r\n  {\r\n    _exists = (system.users[_account].data.last_payment_date > 0);\r\n    _raw_balance = system.users[_account].data.raw_balance;\r\n    _payment_date = system.users[_account].data.last_payment_date;\r\n    (_no_demurrage_fee, _no_transfer_fee, _no_recast_fee) = read_user_fees_configs(_account);\r\n  }\r\n\r\n  function read_user_fees_configs(address _account)\r\n           public\r\n           constant\r\n           returns (bool _no_demurrage_fee,\r\n                    bool _no_transfer_fee,\r\n                    bool _no_recast_fee)\r\n  {\r\n    _no_demurrage_fee = system.users[_account].config.no_demurrage_fee;\r\n    _no_transfer_fee = system.users[_account].config.no_transfer_fee;\r\n    _no_recast_fee = system.users[_account].config.no_recast_fee;\r\n  }\r\n\r\n  /// @notice read a user's spender allowance\r\n  function read_account_spender_allowance(address _account,\r\n                                          address _spender)\r\n           public\r\n           constant\r\n           returns (uint256 _spender_allowance)\r\n  {\r\n    _spender_allowance = system.users[_account].data.spender_allowances[_spender];\r\n  }\r\n\r\n\r\n //////////////////////////////////////////////////\r\n///    Update functions regarding users        ///\r\n//////////////////////////////////////////////////\r\n\r\n  /// @notice called by TokenApprovalController to update an account's spender allowance of a _spender\r\n  function update_account_spender_allowance(address _account,\r\n                                            address _spender,\r\n                                            uint256 _new_allowance)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_APPROVAL)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_account].data.spender_allowances[_spender] = _new_allowance;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update the _user balance and the global total supply after minting some tokens\r\n  function update_balances_after_mint(address _user, uint256 _user_new_balance, uint256 _new_total_supply, uint256 _new_effective_total_supply)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_user].data.raw_balance = _user_new_balance;\r\n    system.total_supply = _new_total_supply;\r\n    system.effective_total_supply = _new_effective_total_supply;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update a user's fees configs\r\n  function update_user_fees_configs(address _user, bool _no_demurrage_fee, bool _no_transfer_fee, bool _no_recast_fee)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_user].config.no_demurrage_fee = _no_demurrage_fee;\r\n    system.users[_user].config.no_transfer_fee = _no_transfer_fee;\r\n    system.users[_user].config.no_recast_fee = _no_recast_fee;\r\n    _success = true;\r\n  }\r\n\r\n\r\n ///////////////////////////////////////////////////////////\r\n///    Update functions to change global configs        ///\r\n///////////////////////////////////////////////////////////\r\n\r\n  /// @notice called by AssetsController to update the effective supply (when an item failed audit or is replaced)\r\n  function update_effective_supply(uint256 _effective_total_supply)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.effective_total_supply = _effective_total_supply;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update configs for recast fees\r\n  function update_config_recast(uint256 _base, uint256 _rate)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.config.fees.recast.base = _base;\r\n    system.config.fees.recast.rate = _rate;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update configs for demurrage fees\r\n  function update_config_demurrage(uint256 _base, uint256 _rate, bool _no_demurrage_fee)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.config.fees.demurrage.base = _base;\r\n    system.config.fees.demurrage.rate = _rate;\r\n    system.config.no_demurrage_fee = _no_demurrage_fee;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice update configs for transfer fees\r\n  function update_config_transfer(uint256 _base, uint256 _rate, bool _no_transfer_fee, uint256 _minimum_transfer_amount)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.config.fees.transfer.base = _base;\r\n    system.config.fees.transfer.rate = _rate;\r\n    system.config.no_transfer_fee = _no_transfer_fee;\r\n    system.config.minimum_transfer_amount = _minimum_transfer_amount;\r\n    _success = true;\r\n  }\r\n\r\n\r\n /////////////////////////////////////////////\r\n///    Demurrage-related functions        ///\r\n/////////////////////////////////////////////\r\n\r\n  /// @notice called by TokenDemurrageService to get the global demurrage configs\r\n  function read_demurrage_config()\r\n           constant\r\n           public\r\n           returns (uint256 _collector_balance,\r\n                    uint256 _base,\r\n                    uint256 _rate,\r\n                    address _collector)\r\n  {\r\n    _collector_balance = system.users[system.collectors.demurrage].data.raw_balance;\r\n    bool _global_demurrage_disabled = system.config.no_demurrage_fee;\r\n    _collector = system.collectors.demurrage;\r\n\r\n    if (_global_demurrage_disabled) {\r\n      _base = 0;\r\n      _rate = 0;\r\n    } else {\r\n      _base = system.config.fees.demurrage.base;\r\n      _rate = system.config.fees.demurrage.rate;\r\n    }\r\n  }\r\n\r\n  function read_demurrage_config_underlying()\r\n           public\r\n           constant\r\n           returns (uint256 _base,\r\n                    uint256 _rate,\r\n                    address _collector,\r\n                    bool _no_demurrage_fee)\r\n  {\r\n    _base = system.config.fees.demurrage.base;\r\n    _rate = system.config.fees.demurrage.rate;\r\n    _collector = system.collectors.demurrage;\r\n    _no_demurrage_fee = system.config.no_demurrage_fee;\r\n  }\r\n\r\n  /// @notice called by TokenDemurrageService to get the user's information needed to deduct his demurrage fees\r\n  function read_user_for_demurrage(address _account)\r\n           public\r\n           constant\r\n           returns (uint256 _raw_balance, uint256 _payment_date, bool _no_demurrage_fee)\r\n  {\r\n    _raw_balance = system.users[_account].data.raw_balance;\r\n    _payment_date = system.users[_account].data.last_payment_date;\r\n    _no_demurrage_fee = system.users[_account].config.no_demurrage_fee || system.config.no_demurrage_fee;\r\n  }\r\n\r\n  /// @notice called by TokenDemurrageService to deduct demurrage fees from a user's balance\r\n  function update_user_for_demurrage(address _user, uint256 _user_new_balance, uint256 _user_new_payment_date, uint256 _collector_new_balance)\r\n           if_sender_is(CONTRACT_SERVICE_TOKEN_DEMURRAGE)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[system.collectors.demurrage].data.raw_balance = _collector_new_balance;\r\n    system.users[_user].data.raw_balance = _user_new_balance;\r\n    system.users[_user].data.last_payment_date = _user_new_payment_date;\r\n    _success = true;\r\n  }\r\n\r\n\r\n ////////////////////////////////////////\r\n///    Recast-related functions      ///\r\n////////////////////////////////////////\r\n\r\n  /// @notice called by AssetsController to read global info to recast an asset item\r\n  function read_recast_config()\r\n           constant\r\n           public\r\n           returns (uint256 _base,\r\n                    uint256 _rate,\r\n                    uint256 _total_supply,\r\n                    uint256 _effective_total_supply,\r\n                    address _collector,\r\n                    uint256 _collector_balance)\r\n  {\r\n    _base = system.config.fees.recast.base;\r\n    _rate = system.config.fees.recast.rate;\r\n    _total_supply = system.total_supply;\r\n    _effective_total_supply = system.effective_total_supply;\r\n    _collector = system.collectors.recast;\r\n    _collector_balance = system.users[system.collectors.recast].data.raw_balance;\r\n  }\r\n\r\n  /// @notice called by AssetsController to read a user's configs for recasting assets\r\n  function read_user_for_recast(address _account)\r\n           public\r\n           constant\r\n           returns (uint256 _raw_balance, bool _no_recast_fee)\r\n  {\r\n    _raw_balance = system.users[_account].data.raw_balance;\r\n    _no_recast_fee = system.users[_account].config.no_recast_fee;\r\n  }\r\n\r\n  /// @notice called by AssetsController to recast an asset item\r\n  function update_balances_after_recast(address _recaster,\r\n                               uint256 _recaster_new_balance,\r\n                               uint256 _recast_fee_collector_new_balance,\r\n                               uint256 _new_total_supply,\r\n                               uint256 _new_effective_total_supply)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_recaster].data.raw_balance = _recaster_new_balance;\r\n    system.users[system.collectors.recast].data.raw_balance = _recast_fee_collector_new_balance;\r\n    system.total_supply = _new_total_supply;\r\n    system.effective_total_supply = _new_effective_total_supply;\r\n    _success = true;\r\n  }\r\n\r\n\r\n ////////////////////////////////////////\r\n///    Transfer-related functions    ///\r\n////////////////////////////////////////\r\n\r\n  /// @notice called by TokenTransferController to read global configs for transfering tokens\r\n  function read_transfer_config()\r\n           public\r\n           constant\r\n           returns (uint256 _collector_balance,\r\n                    uint256 _base,\r\n                    uint256 _rate,\r\n                    address _collector,\r\n                    bool _no_transfer_fee,\r\n                    uint256 _minimum_transfer_amount)\r\n  {\r\n    _collector_balance = system.users[system.collectors.transfer].data.raw_balance;\r\n    _base = system.config.fees.transfer.base;\r\n    _rate = system.config.fees.transfer.rate;\r\n    _collector = system.collectors.transfer;\r\n    _no_transfer_fee = system.config.no_transfer_fee;\r\n    _minimum_transfer_amount = system.config.minimum_transfer_amount;\r\n  }\r\n\r\n  /// @notice called by TokenTransferController to read a user's configs for tranfering tokens\r\n  function read_user_for_transfer(address _account)\r\n           public\r\n           constant\r\n           returns (uint256 _raw_balance, bool _no_transfer_fee)\r\n  {\r\n    _raw_balance = system.users[_account].data.raw_balance;\r\n    _no_transfer_fee = system.users[_account].config.no_transfer_fee;\r\n  }\r\n\r\n  /// @notice called by TokenTransferController to update user balances after transfering\r\n  function update_transfer_balance(address _sender, uint256 _sender_new_balance, address _recipient,\r\n                                   uint256 _recipient_new_balance, uint256 _transfer_fee_collector_new_balance)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_TRANSFER)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_sender].data.raw_balance = _sender_new_balance;\r\n    system.users[_recipient].data.raw_balance = _recipient_new_balance;\r\n    system.users[system.collectors.transfer].data.raw_balance = _transfer_fee_collector_new_balance;\r\n    _success = true;\r\n  }\r\n\r\n  /// @notice called by TokenTransferController to update balances after transfering from\r\n  function update_transfer_from_balance(address _sender, uint256 _sender_new_balance, address _recipient,\r\n                                        uint256 _recipient_new_balance, uint256 _transfer_fee_collector_new_balance,\r\n                                        address _spender, uint256 _spender_new_allowance)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_TRANSFER)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    system.users[_sender].data.raw_balance = _sender_new_balance;\r\n    system.users[_recipient].data.raw_balance = _recipient_new_balance;\r\n    system.users[system.collectors.transfer].data.raw_balance = _transfer_fee_collector_new_balance;\r\n    system.users[_sender].data.spender_allowances[_spender] = _spender_new_allowance;\r\n    _success = true;\r\n  }\r\n\r\n  ////////////////////////////////////////\r\n ///    transfer fees to distributors  ///\r\n ////////////////////////////////////////\r\n  function internal_move_balance(address _from, address _to)\r\n           internal\r\n           returns (uint256 _fees)\r\n  {\r\n    _fees = system.users[_from].data.raw_balance;\r\n    system.users[_to].data.raw_balance += _fees;\r\n    system.users[_from].data.raw_balance = 0;\r\n  }\r\n\r\n  function move_fees_to_distributors(address _demurrage_fees_distributor, address _recast_fees_distributor, address _transfer_fees_distributor)\r\n          if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n          public\r\n          returns (bool _success, uint256[3] _fees_array)\r\n  {\r\n    /* _fees_array = new uint256[](3); */\r\n    _fees_array[0] = internal_move_balance(system.collectors.demurrage, _demurrage_fees_distributor);\r\n    _fees_array[1] = internal_move_balance(system.collectors.recast, _recast_fees_distributor);\r\n    _fees_array[2] = internal_move_balance(system.collectors.transfer, _transfer_fees_distributor);\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/storage/IdentityStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract IdentityStorage is ResolverClient, DigixConstants {\r\n\r\n  struct User {\r\n    uint256 id_expiration;\r\n    bytes32 doc;  // Our current system doesnt use this yet, but we might need it in the future\r\n  }\r\n\r\n  mapping(address => User) users;\r\n\r\n  function IdentityStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_IDENTITY, _resolver));\r\n  }\r\n\r\n  function read_user(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _id_expiration, bytes32 _doc)\r\n  {\r\n    _id_expiration = users[_user].id_expiration;\r\n    _doc = users[_user].doc;\r\n  }\r\n\r\n  function read_user_kyc_valid(address _user)\r\n           public\r\n           constant\r\n           returns (bool _kyc_valid)\r\n  {\r\n    _kyc_valid = users[_user].id_expiration > now;\r\n  }\r\n\r\n  function update_user_id_expiration(address _user, uint256 _id_expiration)\r\n           if_sender_is(CONTRACT_CONTROLLER_IDENTITY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    users[_user].id_expiration = _id_expiration;\r\n    _success = true;\r\n  }\r\n\r\n  function update_user_doc(address _user, bytes32 _doc)\r\n           if_sender_is(CONTRACT_CONTROLLER_IDENTITY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    users[_user].doc = _doc;\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/solidity-core-libraries/contracts/MathUtils.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title Digix Math Library\r\n/// @author DigixGlobal\r\n\r\nlibrary MathUtils {\r\n\r\n  /*modifier if_safe_to_add(uint256 _x, uint256 _y) {\r\n    require(is_safe_to_add(_x, _y) == true);\r\n    _;\r\n  }\r\n\r\n  modifier if_safe_to_subtract(uint256 _x, uint256 _y) {\r\n    require(is_safe_to_subtract(_x, _y) == true);\r\n    _;\r\n  }*/\r\n\r\n  /*uint256 constant ONE_DAY = 1 days;*/\r\n\r\n  /// DEPRECATED\r\n  /// @notice Call with two integers to determine if they are safe to add\r\n  /// @dev Catches integer overflow\r\n  /// param _a Integer to add\r\n  /// param _b Integer to add\r\n  /// @return _issafe True if the integers are safe to add\r\n  /*function is_safe_to_add(uint256 _a, uint256 _b)\r\n           public\r\n           constant\r\n           returns (bool _is_safe)\r\n  {\r\n    _is_safe = (_a + _b >= _a);\r\n    return _is_safe;\r\n  }*/\r\n\r\n  /// @notice Returns sum of two safely-added integers\r\n  /// @dev Uses `safeToAdd` internally; throws if unsafe\r\n  /// @param _a Integer to add\r\n  /// @param _b Integer to add\r\n  /// @return _result Sum of inputs\r\n  function add(uint256 _a, uint256 _b)\r\n           public\r\n           pure\r\n           returns (uint256 _result)\r\n  {\r\n    _result = _a + _b;\r\n    require(_result > _a);\r\n  }\r\n\r\n  /// DEPRECATED\r\n  /// @notice Call with two integers to determine if they are safe to subtract\r\n  /// @dev Catches integer overflow\r\n  /// param _a Integer to subtract from\r\n  /// param _b Integer to subtract\r\n  /// @return _issafe True if the integers are safe to subtract\r\n  /*function is_safe_to_subtract(uint256 _a, uint256 _b)\r\n           public\r\n           constant\r\n           returns (bool _is_safe)\r\n  {\r\n    _is_safe = (_b <= _a);\r\n    return _is_safe;\r\n  }*/\r\n\r\n  /// @notice Returns result of two safely-subtracted integers\r\n  /// @dev Uses `safeToSubtract` internally; throws if unsafe\r\n  /// @param _a Integer to subtract from\r\n  /// @param _b Integer to subtract\r\n  /// @return _result Result of subtraction\r\n  function subtract(uint256 _a, uint256 _b)\r\n           public\r\n           pure\r\n           returns (uint _result)\r\n  {\r\n    require(_a >= _b);\r\n    _result = _a - _b;\r\n  }\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculates the rate of ???\r\n  ///# @dev `((_unit * _a) + _b / 2) / _b`\r\n  ///# paramm _a ??\r\n  ///# paramm _b ??\r\n  ///# paramm _places Number of decimal places\r\n  ///# @return _result Result of subtraction\r\n  /*function rate_of(uint256 _a, uint256 _b, uint256 _places)\r\n           public\r\n           constant\r\n           returns (uint256 _result)\r\n  {\r\n    var _unit = 10 ** _places;\r\n    _result = add((_unit * _a), (_b / 2)) / _b;\r\n    return _result;\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculates the rate from ???\r\n  ///# @dev `(_amount * _baserate) / (10 ** _places)`\r\n  ///# paramm _amount ??\r\n  ///# paramm _baserate ??\r\n  ///# paramm _places ??\r\n  ///# @return _fee Calculated Fee\r\n  /*function from_rate(uint256 _amount, uint256 _baserate, uint256 _places)\r\n           returns (uint256 _fee)\r\n  {\r\n    _fee = ((_amount * _baserate) / (10 ** _places));\r\n    return _fee;\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculate demurrage time values\r\n  ///# paramm _current_time Current block time\r\n  ///# paramm _last_payment_date Last demurrage payment date\r\n  ///# @return {\r\n  ///   \"_next_payment_date\": \"Next payment date as unix time\",\r\n  ///   \"_demurrage_days\": \"Demurrage days calculated\"\r\n  /// }\r\n  /*function calculate_demurrage_time(uint256 _current_time, uint256 _last_payment_date)\r\n           returns (uint256 _next_payment_date, uint256 _demurrage_days)\r\n  {\r\n    var _time_difference = subtract(_current_time, _last_payment_date);\r\n    _demurrage_days = _time_difference / (1 days);\r\n    var _remainder = _time_difference % (1 days);\r\n    var _demurrage_seconds = _demurrage_days * (1 days);\r\n    _next_payment_date = subtract(add(_last_payment_date, _demurrage_seconds), _remainder);\r\n    return (_next_payment_date, _demurrage_days);\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculate demurrage fee\r\n  ///# paramm _demurrage_days Days since last demurrage payment\r\n  ///# paramm _unit_size Minimum amount for demurrage fees\r\n  ///# paramm _fee_per_unit Amount of daily demurrage to deduct for every `_demurrage_minimum`\r\n  ///# paramm _raw_balance Account balance\r\n  ///# @return _demurrage_fee The demurrage fee due\r\n  /*function calculate_demurrage_fee(uint256 _demurrage_days, uint256 _unit_size, uint256 _fee_per_unit, uint256 _raw_balance)\r\n           returns (uint256 _demurrage_fee)\r\n  {\r\n    if (_demurrage_days == 0) {\r\n      _demurrage_fee = 0;\r\n    } else {\r\n      var _billable_amount = (_raw_balance / _unit_size);\r\n      _demurrage_fee = (_billable_amount * _demurrage_days * _fee_per_unit);\r\n    }\r\n    return _demurrage_fee;\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Get demurrage info\r\n  ///# paramm _current_time Current block time\r\n  ///# paramm _last_payment_date Last demurrage payment date\r\n  ///# paramm _raw_balance Account balance\r\n  ///# paramm _unit_size Minimum amount needed to charge demurrage fees\r\n  ///# paramm _fee_per_unit The amount of daily demurrage deduct for every `_minimum_for_demurrage`\r\n  /// @return {\r\n  ///    \"_demurrage_fee\": \"Fee charged against current balance\",\r\n  ///    \"_demurrage_days\": \"Demurrage days calculated\",\r\n  ///    \"_billable_amount\": \"Amount eligible for demurrage calculation\",\r\n  ///    \"_next_payment_date\": \"Timestamp to use for next payment date\"\r\n  /// }\r\n  /*function get_demurrage_info(uint256 _current_time, uint256 _last_payment_date, uint256 _raw_balance, uint256 _unit_size, uint256 _fee_per_unit)\r\n           returns (uint256 _demurrage_fee, uint256 _demurrage_days, uint256 _balance_after, uint256 _next_payment_date)\r\n  {\r\n    _demurrage_days = (subtract(_current_time, _last_payment_date)) / ONE_DAY;\r\n    uint256 _billable_amount = (_raw_balance / _unit_size);\r\n    if (_demurrage_days == 0) {\r\n      _demurrage_fee = 0;\r\n      _next_payment_date = _last_payment_date;\r\n      _balance_after = _raw_balance;\r\n    } else {\r\n      _demurrage_fee = (_billable_amount * _demurrage_days * _fee_per_unit);\r\n      var _remainder = subtract(_current_time, _last_payment_date) % ONE_DAY;\r\n      _next_payment_date = subtract(add(_last_payment_date, (_demurrage_days * ONE_DAY)), _remainder);\r\n      _balance_after = subtract(_raw_balance, _demurrage_fee);\r\n    }\r\n    return (_demurrage_fee, _demurrage_days, _balance_after, _next_payment_date);\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  ///# @notice Calculate Transaction Fee\r\n  ///# paramm _sending_amount The amount being sent\r\n  ///# paramm _unit_size The minimum amount that can be sent\r\n  ///# paramm _fee_per_unit The fee per unit\r\n  ///# @return _tx_fee The transaction fee due\r\n  /*function get_tx_fee(uint256 _sending_amount, uint256 _unit_size, uint256 _fee_per_unit)\r\n           returns (uint256 _tx_fee)\r\n  {\r\n    _tx_fee = (_sending_amount / _unit_size) * _fee_per_unit;\r\n    return _tx_fee;\r\n  }*/\r\n\r\n  function calculate_recast_fee(uint256 _asset_weight, uint256 _unit_size, uint256 _fee_per_unit)\r\n           public\r\n           pure\r\n           returns (uint256 _recast_fee)\r\n  {\r\n    uint256 _weight_times_fee_per_unit = _asset_weight * _fee_per_unit;\r\n    require(_weight_times_fee_per_unit / _asset_weight == _fee_per_unit);\r\n    _recast_fee = _weight_times_fee_per_unit / _unit_size;\r\n    return _recast_fee;\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/solidity-core-libraries/contracts/Types.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\nlibrary Types {\r\n\r\n  struct MutableUint {\r\n    uint256 pre;\r\n    uint256 post;\r\n  }\r\n\r\n  struct MutableTimestamp {\r\n    MutableUint time;\r\n    uint256 in_units;\r\n  }\r\n\r\n  function advance_by(MutableTimestamp memory _original, uint256 _units)\r\n           internal\r\n           constant\r\n           returns (MutableTimestamp _transformed)\r\n  {\r\n    _transformed = _original;\r\n    require(now >= _original.time.pre);\r\n    uint256 _lapsed = now - _original.time.pre;\r\n    _transformed.in_units = _lapsed / _units;\r\n    uint256 _ticks = _transformed.in_units * _units;\r\n    if (_transformed.in_units == 0) {\r\n      _transformed.time.post = _original.time.pre;\r\n    } else {\r\n      _transformed.time = add(_transformed.time, _ticks);\r\n    }\r\n  }\r\n\r\n  // DEPRECATED\r\n  /*function add_two(MutableUint memory _original, uint256 _first, uint256 _second)\r\n           internal\r\n           constant\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require((_original.pre + _first + _second) >= _original.pre);\r\n    _transformed = _original;\r\n    _transformed.post = (_original.pre + _first + _second);\r\n  }*/\r\n\r\n  function subtract_two(MutableUint memory _original, uint256 _first, uint256 _second)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require(_original.pre >= _first);\r\n    uint256 _after_first = _original.pre - _first;\r\n    require(_after_first >= _second);\r\n    _transformed = _original;\r\n    _original.post = (_after_first - _second);\r\n  }\r\n\r\n  function subtract_and_add(MutableUint memory _original, uint256 _to_subtract, uint256 _to_add)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require(_original.pre >= _to_subtract);\r\n    uint256 _after_subtract = _original.pre - _to_subtract;\r\n    require((_after_subtract + _to_add) >= _after_subtract);\r\n    _transformed.post = _after_subtract + _to_add;\r\n  }\r\n\r\n  /// DEPRECATED\r\n  /*function increment(MutableUint memory _original)\r\n           internal\r\n           constant\r\n           returns (MutableUint _transformed)\r\n  {\r\n    _transformed = _original;\r\n    _transformed.post = _original.pre + 1;\r\n  }*/\r\n\r\n  /// DEPRECATED\r\n  /*function decrement(MutableUint memory _original)\r\n           internal\r\n           constant\r\n           returns (MutableUint _transformed)\r\n  {\r\n    _transformed = _original;\r\n    require((_original.pre + 1) > _original.pre);\r\n    _transformed.post = _original.pre - 1;\r\n  }*/\r\n\r\n  function add_and_subtract(MutableUint memory _original, uint256 _to_add, uint256 _to_subtract)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require((_original.pre + _to_add) >= _original.pre);\r\n    uint256 _after_add = _original.pre + _to_add;\r\n    require(_after_add >= _to_subtract);\r\n    _transformed = _original;\r\n    _transformed.post = (_after_add - _to_subtract);\r\n  }\r\n\r\n  function add(MutableUint memory _original, uint256 _amount)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require((_original.pre + _amount) >= _original.pre);\r\n    _transformed = _original;\r\n    _transformed.post = _original.pre + _amount;\r\n  }\r\n\r\n  function subtract(MutableUint memory _original, uint256 _amount)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed)\r\n  {\r\n    require(_amount <= _original.pre);\r\n    _transformed = _original;\r\n    _transformed.post = _original.pre - _amount;\r\n  }\r\n\r\n  function swap(MutableUint memory _original_a, MutableUint memory _original_b)\r\n           internal\r\n           pure\r\n           returns (MutableUint _transformed_a, MutableUint _transformed_b)\r\n  {\r\n    _transformed_a = _original_a;\r\n    _transformed_b = _original_b;\r\n    _transformed_a.post = _original_b.pre;\r\n    _transformed_b.post = _original_a.pre;\r\n  }\r\n\r\n  /*function transfer(MutableUint memory _original_from, MutableUint memory _original_to, uint256 _amount)\r\n           internal\r\n           constant\r\n           returns (MutableUint _transformed_from, MutableUint _transformed_to)\r\n  {\r\n    _original_from = _transformed_from;\r\n    _original_to = _transformed_to;\r\n    _transformed_from.post = subtract(_transformed_from, _amount).post;\r\n    _transformed_to.post = add(_transformed_to, _amount).post;\r\n  }*/\r\n\r\n}\r\n\r\n// File: contracts/common/TokenLoggerCallback.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract TokenLoggerCallback is ResolverClient, DigixConstants {\r\n\r\n  event Transfer(address indexed _from,  address indexed _to,  uint256 _value);\r\n  event Approval(address indexed _owner,  address indexed _spender,  uint256 _value);\r\n\r\n  function log_mint(address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\r\n           public\r\n  {\r\n    Transfer(address(0x0), _to, _value);\r\n  }\r\n\r\n  function log_recast_fees(address _from, address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n           public\r\n  {\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function log_recast(address _from, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n           public\r\n  {\r\n    Transfer(_from, address(0x0), _value);\r\n  }\r\n\r\n  function log_demurrage_fees(address _from, address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_SERVICE_TOKEN_DEMURRAGE)\r\n           public\r\n  {\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function log_move_fees(address _from, address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\r\n           public\r\n  {\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function log_transfer(address _from, address _to, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_TRANSFER)\r\n           public\r\n  {\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function log_approve(address _owner, address _spender, uint256 _value)\r\n           if_sender_is(CONTRACT_CONTROLLER_TOKEN_APPROVAL)\r\n           public\r\n  {\r\n    Approval(_owner, _spender, _value);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/service/TokenDemurrageService.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenDemurrageService is ResolverClient, DigixConstants {\r\n\r\n  using Types for Types.MutableUint;\r\n  using Types for Types.MutableTimestamp;\r\n\r\n  struct User {\r\n    address account;\r\n    bool no_demurrage_fee;\r\n    Types.MutableUint balance;\r\n    Types.MutableTimestamp payment_date;\r\n  }\r\n\r\n  struct Config {\r\n    Types.MutableUint collector_balance;\r\n    uint256 base;\r\n    uint256 rate;\r\n    address collector;\r\n  }\r\n\r\n  struct Demurrage {\r\n    Config config;\r\n    User user;\r\n    uint256 collected_fee;\r\n  }\r\n\r\n  function TokenDemurrageService(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_SERVICE_TOKEN_DEMURRAGE, _resolver));\r\n  }\r\n\r\n  function gold_token_storage()\r\n           internal\r\n           constant\r\n           returns (GoldTokenStorage _contract)\r\n  {\r\n    _contract = GoldTokenStorage(get_contract(CONTRACT_STORAGE_GOLD_TOKEN));\r\n  }\r\n\r\n  function get_demurrage_data(address _user)\r\n           internal\r\n           constant\r\n           returns (Demurrage _demurrage)\r\n  {\r\n    (_demurrage.config.collector_balance.pre, _demurrage.config.base, _demurrage.config.rate, _demurrage.config.collector) =\r\n      gold_token_storage().read_demurrage_config();\r\n    _demurrage.user.account = _user;\r\n    (_demurrage.user.balance.pre, _demurrage.user.payment_date.time.pre, _demurrage.user.no_demurrage_fee) = gold_token_storage().read_user_for_demurrage(_user);\r\n  }\r\n\r\n  function calculate_demurrage(Demurrage memory _demurrage)\r\n           internal\r\n           constant\r\n           returns (Demurrage _calculated)\r\n  {\r\n    if (_demurrage.user.payment_date.time.pre == 0) {\r\n      _demurrage.user.payment_date.time.pre = now;\r\n    }\r\n    if (_demurrage.user.no_demurrage_fee == true || _demurrage.user.account == _demurrage.config.collector) { // demurrage collector is never deducted for demurrage\r\n      _demurrage.user.balance.post = _demurrage.user.balance.pre;\r\n      _demurrage.config.collector_balance.post = _demurrage.config.collector_balance.pre;\r\n      _demurrage.user.payment_date.time.post = now;\r\n    } else {\r\n      _demurrage.user.payment_date = _demurrage.user.payment_date.advance_by(1 days);\r\n      if (_demurrage.user.payment_date.in_units == 0) {\r\n        _demurrage.user.balance.post = _demurrage.user.balance.pre;\r\n        _demurrage.config.collector_balance.post = _demurrage.config.collector_balance.pre;\r\n      } else {\r\n        _demurrage.collected_fee = (_demurrage.user.payment_date.in_units * _demurrage.user.balance.pre * _demurrage.config.rate) / _demurrage.config.base;\r\n        _demurrage.user.balance = _demurrage.user.balance.subtract(_demurrage.collected_fee);\r\n        _demurrage.config.collector_balance = _demurrage.config.collector_balance.add(_demurrage.collected_fee);\r\n      }\r\n    }\r\n    _calculated = _demurrage;\r\n  }\r\n\r\n  function show_demurraged_balance(address _user)\r\n           public\r\n           constant\r\n           returns ( uint256 _actual_balance)\r\n  {\r\n    Demurrage memory _demurrage = get_demurrage_data(_user);\r\n    _demurrage = calculate_demurrage(_demurrage);\r\n    _actual_balance = _demurrage.user.balance.post;\r\n  }\r\n\r\n  function deduct_demurrage(address _user)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    Demurrage memory _demurrage = get_demurrage_data(_user);\r\n    _demurrage = calculate_demurrage(_demurrage);\r\n    require(gold_token_storage().update_user_for_demurrage(_demurrage.user.account, _demurrage.user.balance.post, _demurrage.user.payment_date.time.post, _demurrage.config.collector_balance.post) == true);\r\n    if (_demurrage.collected_fee > 0) {\r\n      TokenLoggerCallback(get_contract(CONTRACT_INTERACTIVE_TOKEN)).log_demurrage_fees(_user, _demurrage.config.collector, _demurrage.collected_fee);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function bulk_deduct_demurrage(address[] _users)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    uint256 _length = _users.length;\r\n    for (uint256 i=0;i<_length; i++) {\r\n      deduct_demurrage(_users[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/common/ERCTwenty.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\ncontract ERCTwenty {\r\n  function decimals() constant public returns (uint _decimals);\r\n  function totalSupply() constant public returns (uint supply);\r\n  function balanceOf( address who ) constant public returns (uint value);\r\n  function allowance( address owner, address spender ) constant public returns (uint _allowance);\r\n  function transfer( address to, uint value) public returns (bool ok);\r\n  function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n  function approve( address spender, uint value ) public returns (bool ok);\r\n  event Transfer( address indexed from, address indexed to, uint value);\r\n  event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// File: contracts/storage/MarketplaceStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n// Contracts that need to be deployed for this contract to work:\r\n//    DoublyLinkedList, CoreStorage, MathUtils, TokenTransferController, TokenInfoController,\r\n//    TokenDemurrageService, TokenApprovalController, Token, ContractResolver\r\n\r\ncontract MarketplaceStorage is ResolverClient, DigixConstants {\r\n\r\n  struct Config {\r\n    uint256 global_daily_dgx_ng_limit;\r\n    uint256 minimum_purchase_dgx_ng;\r\n    uint256 maximum_block_drift;\r\n    address payment_collector;\r\n    uint256 max_dgx_available_daily;\r\n    uint256 price_floor_wei_per_dgx_mg;\r\n  }\r\n\r\n  struct Purchase {\r\n    address recipient; // the recipient is not necessarily the user who purchased\r\n    uint256 timestamp;\r\n    uint256 amount;\r\n    uint256 price;\r\n  }\r\n\r\n  struct User {\r\n    uint256 overwrite_daily_dgx_ng_limit;\r\n    Purchase[] purchases;\r\n  }\r\n\r\n  struct Marketplace {\r\n    Config config;\r\n    Purchase[] purchases;\r\n    mapping (address => User) users;\r\n    mapping (address => bool) approved_signers;\r\n    mapping (uint => mapping (uint => bool)) used_nonces;\r\n  }\r\n\r\n  Marketplace marketplace;\r\n\r\n  function MarketplaceStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_MARKETPLACE, _resolver));\r\n    marketplace.config.global_daily_dgx_ng_limit = 102000000000;\r\n    marketplace.config.minimum_purchase_dgx_ng = 10000000;\r\n  }\r\n\r\n  function token_contract()\r\n           internal\r\n           constant\r\n           returns (ERCTwenty _contract)\r\n  {\r\n    _contract = ERCTwenty(get_contract(CONTRACT_INTERACTIVE_TOKEN));\r\n  }\r\n\r\n  function read_total_number_of_purchases()\r\n           public\r\n           constant\r\n           returns (uint256 _total_number_of_purchases)\r\n  {\r\n    _total_number_of_purchases = marketplace.purchases.length;\r\n  }\r\n\r\n  function read_total_number_of_user_purchases(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _total_number_of_user_purchases)\r\n  {\r\n    _total_number_of_user_purchases = marketplace.users[_user].purchases.length;\r\n  }\r\n\r\n  function read_purchase_at_index(uint256 _index)\r\n           public\r\n           constant\r\n           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\r\n  {\r\n    Purchase memory _purchase = marketplace.purchases[_index];\r\n    _recipient = _purchase.recipient;\r\n    _timestamp = _purchase.timestamp;\r\n    _amount = _purchase.amount;\r\n    _price = _purchase.price;\r\n  }\r\n\r\n  function read_user_purchase_at_index(address _user, uint256 _index)\r\n           public\r\n           constant\r\n           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\r\n  {\r\n    Purchase memory _purchase = marketplace.users[_user].purchases[_index];\r\n    _recipient = _purchase.recipient;\r\n    _timestamp = _purchase.timestamp;\r\n    _amount = _purchase.amount;\r\n    _price = _purchase.price;\r\n  }\r\n\r\n  function create_user(address _user, uint256 _overwrite_daily_dgx_ng_limit)\r\n           if_sender_is(CONTRACT_CONTROLLER_IDENTITY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.users[_user].overwrite_daily_dgx_ng_limit = _overwrite_daily_dgx_ng_limit;\r\n    _success = true;\r\n  }\r\n\r\n  function update_user_purchase(address _recipient_user, address _buyer, uint256 _purchase_amount, uint256 _purchase_price, uint256 _block_number, uint256 _nonce)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.used_nonces[_block_number][_nonce] = true;\r\n    Purchase memory _purchase;\r\n    _purchase.recipient = _recipient_user;\r\n    _purchase.timestamp = now;\r\n    _purchase.amount = _purchase_amount;\r\n    _purchase.price = _purchase_price;\r\n    marketplace.users[_buyer].purchases.push(_purchase);\r\n    marketplace.purchases.push(_purchase);\r\n    require(token_contract().transfer(_recipient_user, _purchase_amount) == true);\r\n    _success = true;\r\n  }\r\n\r\n  function update_config(uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.config.global_daily_dgx_ng_limit = _global_daily_dgx_ng_limit;\r\n    marketplace.config.minimum_purchase_dgx_ng = _minimum_purchase_dgx_ng;\r\n    marketplace.config.payment_collector = _payment_collector;\r\n    marketplace.config.maximum_block_drift = _maximum_block_drift;\r\n    _success = true;\r\n  }\r\n\r\n  function move_inventory(address _destination, uint256 _amount)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(token_contract().transfer(_destination, _amount));\r\n    _success = true;\r\n  }\r\n\r\n  function update_max_dgx_available_daily(uint256 _max_dgx_available_daily)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.config.max_dgx_available_daily = _max_dgx_available_daily;\r\n    _success = true;\r\n  }\r\n\r\n  function read_max_dgx_available_daily()\r\n           public\r\n           constant\r\n           returns (uint256 _max_dgx_available_daily)\r\n  {\r\n    _max_dgx_available_daily = marketplace.config.max_dgx_available_daily;\r\n  }\r\n\r\n  function update_price_floor(uint256 _price_floor_wei_per_dgx_mg)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.config.price_floor_wei_per_dgx_mg = _price_floor_wei_per_dgx_mg;\r\n    _success = true;\r\n  }\r\n\r\n  function read_price_floor()\r\n           public\r\n           constant\r\n           returns (uint256 _price_floor_wei_per_dgx_mg)\r\n  {\r\n    _price_floor_wei_per_dgx_mg = marketplace.config.price_floor_wei_per_dgx_mg;\r\n  }\r\n\r\n  function update_signer_approval(address _signer, bool _approve)\r\n           if_sender_is(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    marketplace.approved_signers[_signer] = _approve;\r\n    _success = true;\r\n  }\r\n\r\n  function read_config()\r\n           public\r\n           constant\r\n           returns (uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector)\r\n  {\r\n    _global_daily_dgx_ng_limit = marketplace.config.global_daily_dgx_ng_limit;\r\n    _minimum_purchase_dgx_ng = marketplace.config.minimum_purchase_dgx_ng;\r\n    _maximum_block_drift = marketplace.config.maximum_block_drift;\r\n    _payment_collector = marketplace.config.payment_collector;\r\n  }\r\n\r\n  function read_is_approved_signer(address _signer)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = marketplace.approved_signers[_signer];\r\n  }\r\n\r\n  function read_total_purchased_today(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _total_purchased_today)\r\n  {\r\n    _total_purchased_today = 0;\r\n    uint256 _i = marketplace.users[_user].purchases.length;\r\n    while((_i >= 1) && (scope_timestamp_is_from_today(marketplace.users[_user].purchases[_i - 1].timestamp) == true)) {\r\n      _total_purchased_today += marketplace.users[_user].purchases[_i - 1].amount;\r\n      _i--;\r\n    }\r\n  }\r\n\r\n  function read_total_global_purchased_today()\r\n           public\r\n           constant\r\n           returns (uint256 _total_global_purchased_today)\r\n  {\r\n    _total_global_purchased_today = 0;\r\n    uint256 _i = marketplace.purchases.length;\r\n    while((_i >= 1) && (scope_timestamp_is_from_today(marketplace.purchases[_i - 1].timestamp) == true)) {\r\n      _total_global_purchased_today += marketplace.purchases[_i - 1].amount;\r\n      _i--;\r\n    }\r\n  }\r\n\r\n  function read_dgx_inventory_balance_ng()\r\n           public\r\n           constant\r\n           returns (uint256 _balance)\r\n  {\r\n    _balance = token_contract().balanceOf(address(this));\r\n  }\r\n\r\n  function scope_timestamp_is_from_today(uint256 _timestamp)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = (_timestamp >= (now - 1 days));\r\n  }\r\n\r\n  function read_for_purchase(address _user, uint256 _block_number, uint256 _nonce, address _signer)\r\n           public\r\n           constant\r\n           returns (uint256 _daily_dgx_limit, uint256 _total_purchased_today,\r\n                    bool _used_nonce, bool _approved_signer)\r\n  {\r\n    _daily_dgx_limit = read_user_daily_limit(_user);\r\n    _used_nonce = marketplace.used_nonces[_block_number][_nonce];\r\n    _approved_signer = marketplace.approved_signers[_signer];\r\n    _total_purchased_today = read_total_purchased_today(_user);\r\n  }\r\n\r\n  function read_user(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _daily_dgx_limit, uint256 _total_purchased_today)\r\n  {\r\n    _daily_dgx_limit = read_user_daily_limit(_user);\r\n    _total_purchased_today = read_total_purchased_today(_user);\r\n  }\r\n\r\n  /// user daily limit = max(user's overwrite_daily_dgx_ng_limit, global_daily_dgx_ng_limit)\r\n  function read_user_daily_limit(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _daily_dgx_limit)\r\n  {\r\n    _daily_dgx_limit = marketplace.users[_user].overwrite_daily_dgx_ng_limit;\r\n    if (_daily_dgx_limit < marketplace.config.global_daily_dgx_ng_limit) {\r\n      _daily_dgx_limit = marketplace.config.global_daily_dgx_ng_limit;\r\n    }\r\n  }\r\n\r\n  function read_user_purchases_count(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = marketplace.users[_user].purchases.length;\r\n  }\r\n\r\n  function read_user_purchase_details(address _user, uint256 _index)\r\n           public\r\n           constant\r\n           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\r\n  {\r\n    _recipient = marketplace.users[_user].purchases[_index].recipient;\r\n    _timestamp = marketplace.users[_user].purchases[_index].timestamp;\r\n    _amount = marketplace.users[_user].purchases[_index].amount;\r\n    _price = marketplace.users[_user].purchases[_index].price;\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/UintIteratorStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n  @title Uint Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract UintIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  /**\r\n    @notice Returns the first item from a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_item\": \"The first item\"}\r\n  */\r\n  function read_first_from_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.start_item();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the last item from a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_item\": \"The last item\"}\r\n  */\r\n  function read_last_from_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.end_item();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the next item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The next item\"}\r\n  */\r\n  function read_next_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.next_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the previous item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The previous item\"}\r\n  */\r\n  function read_previous_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.previous_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the total count of itemsfrom a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_count\": \"The total count of items\"}\r\n  */\r\n  function read_total_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total();\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/storage/ProductsListStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\ncontract ProductsListStorage is UintIteratorStorage, ResolverClient, DigixConstants {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  struct System {\r\n    mapping (uint256 => Product) products_by_id;\r\n    DoublyLinkedList.Uint products_list;\r\n  }\r\n\r\n  struct Product {\r\n    bytes32 document;\r\n    bool enabled;\r\n    uint256 ng_weight;\r\n    uint256 effective_ng_weight;\r\n  }\r\n\r\n  System system;\r\n\r\n  function ProductsListStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_PRODUCTS_LIST, _resolver));\r\n  }\r\n\r\n  /// @notice add a new product to the product list\r\n  /// @param _document the dijix ipfs document\r\n  /// @param _ng_weight the weight of the product\r\n  /// @param _effective_ng_weight the effective weight of the product\r\n  /// @return _success whether the product is successfully added\r\n  /// @return _product_id the product id of the newly created product\r\n  function create_product(bytes32 _document, uint256 _ng_weight, uint256 _effective_ng_weight)\r\n           if_sender_is(CONTRACT_CONTROLLER_PRODUCTS_LIST)\r\n           public\r\n           returns (bool _success, uint256 _product_id)\r\n  {\r\n    require(_ng_weight > 0);\r\n    require(_effective_ng_weight > 0);\r\n    _product_id = system.products_list.total() + 1;\r\n    system.products_by_id[_product_id].enabled = true;\r\n    system.products_by_id[_product_id].document = _document;\r\n    system.products_by_id[_product_id].ng_weight = _ng_weight;\r\n    system.products_by_id[_product_id].effective_ng_weight = _effective_ng_weight;\r\n    _success = system.products_list.append(_product_id);\r\n  }\r\n\r\n  /// @notice enable an existing disabled product in the product list\r\n  /// @param _product_id the product id\r\n  /// @return _success whether the product is successfully enabled\r\n  function enable_product(uint256 _product_id)\r\n           if_sender_is(CONTRACT_CONTROLLER_PRODUCTS_LIST)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    if (system.products_by_id[_product_id].enabled == true || system.products_by_id[_product_id].ng_weight == 0 ) {\r\n      // if product is already enabled or product doesnt exist\r\n      _success = false;\r\n    } else {\r\n      system.products_by_id[_product_id].enabled = true;\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n  /// @notice disable an existing enabled product in the product list\r\n  /// @param _product_id the product id\r\n  /// @return _success whether the product is successfully disabled\r\n  function disable_product(uint256 _product_id)\r\n           if_sender_is(CONTRACT_CONTROLLER_PRODUCTS_LIST)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    if (system.products_by_id[_product_id].enabled == false) {\r\n      _success = false;\r\n    } else {\r\n      system.products_by_id[_product_id].enabled = false;\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n\r\n  /// @notice read information of an existing product\r\n  /// @param _product_id the product id\r\n  /// @return _document the dijix ipfs document\r\n  /// @return _ng_weight the weight of the product\r\n  /// @return _effective_ng_weight the effective weight of the product\r\n  /// @return _enabled whether the product is enabled\r\n  function read_product(uint256 _product_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _document, uint256 _ng_weight, uint256 _effective_ng_weight, bool _enabled)\r\n  {\r\n    if (system.products_by_id[_product_id].enabled == true) {\r\n      _ng_weight = system.products_by_id[_product_id].ng_weight;\r\n      _effective_ng_weight = system.products_by_id[_product_id].effective_ng_weight;\r\n      _enabled = system.products_by_id[_product_id].enabled;\r\n      _document = system.products_by_id[_product_id].document;\r\n    } else {\r\n      _ng_weight = 0;\r\n      _effective_ng_weight = 0;\r\n      _enabled = system.products_by_id[_product_id].enabled;\r\n      _document = \"\";\r\n    }\r\n  }\r\n\r\n  /// @notice read weight and effective weight of an existing product\r\n  /// @param _product_id the product id\r\n  /// @return _ng_weight the weight of the product\r\n  /// @return _effective_ng_weight the effective weight of the product\r\n  function read_product_ng_weight_and_effective_ng_weight(uint256 _product_id)\r\n           public\r\n           constant\r\n           returns (uint256 _ng_weight, uint256 _effective_ng_weight)\r\n  {\r\n    if (system.products_by_id[_product_id].enabled == true) {\r\n      _ng_weight = system.products_by_id[_product_id].ng_weight;\r\n      _effective_ng_weight = system.products_by_id[_product_id].effective_ng_weight;\r\n    } else {\r\n      _ng_weight = 0;\r\n      _effective_ng_weight = 0;\r\n    }\r\n  }\r\n\r\n  /// @notice read the total number of products in product list\r\n  /// @return _total_count total number of products\r\n  function read_products_total()\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = read_total_uints(system.products_list);\r\n  }\r\n\r\n  /// @notice read the first product in product list\r\n  /// @return _item first product\r\n  function read_first_product()\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = read_first_from_uints(system.products_list);\r\n  }\r\n\r\n  /// @notice read the last product in product list\r\n  /// @return _item last product\r\n  function read_last_product()\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = read_last_from_uints(system.products_list);\r\n  }\r\n\r\n  /// @notice read the next product after some product\r\n  /// @param _current_item the current item\r\n  /// @return _item next product\r\n  function read_next_from_product(uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = read_next_from_uints(system.products_list, _current_item);\r\n  }\r\n\r\n  /// @notice read the previous product after some product\r\n  /// @param _current_item the current item\r\n  /// @return _item previous product\r\n  function read_previous_from_product(uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = read_previous_from_uints(system.products_list, _current_item);\r\n  }\r\n}\r\n\r\n// File: @digix/cdap/contracts/service/DirectoryService.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/**\r\n@title Directory Service\r\n@author DigixGlobal\r\n*/\r\ncontract DirectoryService {\r\n\r\n  /**\r\n  @notice Returns the user's role id\r\n  @param _read_role_id_function Function that returns a role id of a user\r\n  @param _user Id of the user\r\n  @return {\"_role_id\": \"Role id of the user\"}\r\n  */\r\n  function internal_get_user_role_id(function (address) external constant returns (uint256) _read_role_id_function, address _user)\r\n           internal\r\n           constant\r\n           returns (uint256 _role_id)\r\n  {\r\n    _role_id = _read_role_id_function(_user);\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/IndexedAddressIteratorStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n  @title Indexed Address IteratorStorage\r\n  @author DigixGlobal Pte Ltd\r\n  @notice This contract utilizes: [Doubly Linked List](/DoublyLinkedList)\r\n*/\r\ncontract IndexedAddressIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\r\n  /**\r\n    @notice Reads the first item from an Indexed Address Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\" : \"First item on the list\"}\r\n  */\r\n  function read_first_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.start_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the last item from an Indexed Address Doubly Linked list\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\" : \"First item on the list\"}\r\n  */\r\n  function read_last_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.end_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item from an Indexed Address Doubly Linked List based on the specified `_current_item`\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to use as base line\r\n    @return {\"_item\": \"The next item on the list\"}\r\n  */\r\n  function read_next_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.next_item(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item from an Index Address Doubly Linked List based on the specified `_current_item`\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to use as base line\r\n    @return {\"_item\" : \"The previous item on the list\"}\r\n  */\r\n  function read_previous_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.previous_item(_collection_index, _current_item);\r\n  }\r\n\r\n\r\n  /**\r\n    @notice Reads the total number of items in an Indexed Address Doubly Linked List\r\n    @param _list  The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_count\": \"Length of the Doubly Linked list\"}\r\n  */\r\n  function read_total_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total(_collection_index);\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/cdap/contracts/storage/DirectoryStorage.sol\r\n\r\npragma solidity ^0.4.16;\r\n\r\n\r\n\r\n/**\r\n@title Directory Storage contains information of a directory\r\n@author DigixGlobal\r\n*/\r\ncontract DirectoryStorage is IndexedAddressIteratorStorage, UintIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  struct User {\r\n    bytes32 document;\r\n    bool active;\r\n  }\r\n\r\n  struct Group {\r\n    bytes32 name;\r\n    bytes32 document;\r\n    uint256 role_id;\r\n    mapping(address => User) members_by_address;\r\n  }\r\n\r\n  struct System {\r\n    DoublyLinkedList.Uint groups;\r\n    DoublyLinkedList.IndexedAddress groups_collection;\r\n    mapping (uint256 => Group) groups_by_id;\r\n    mapping (address => uint256) group_ids_by_address;\r\n    mapping (uint256 => bytes32) roles_by_id;\r\n    bool initialized;\r\n    uint256 total_groups;\r\n  }\r\n\r\n  System system;\r\n\r\n  /**\r\n  @notice Initializes directory settings\r\n  @return _success If directory initialization is successful\r\n  */\r\n  function initialize_directory()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(system.initialized == false);\r\n    system.total_groups = 0;\r\n    system.initialized = true;\r\n    internal_create_role(1, \"root\");\r\n    internal_create_group(1, \"root\", \"\");\r\n    _success = internal_update_add_user_to_group(1, tx.origin, \"\");\r\n  }\r\n\r\n  /**\r\n  @notice Creates a new role with the given information\r\n  @param _role_id Id of the new role\r\n  @param _name Name of the new role\r\n  @return {\"_success\": \"If creation of new role is successful\"}\r\n  */\r\n  function internal_create_role(uint256 _role_id, bytes32 _name)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(_role_id > 0);\r\n    require(_name != bytes32(0x0));\r\n    system.roles_by_id[_role_id] = _name;\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the role's name of a role id\r\n  @param _role_id Id of the role\r\n  @return {\"_name\": \"Name of the role\"}\r\n  */\r\n  function read_role(uint256 _role_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _name)\r\n  {\r\n    _name = system.roles_by_id[_role_id];\r\n  }\r\n\r\n  /**\r\n  @notice Creates a new group with the given information\r\n  @param _role_id Role id of the new group\r\n  @param _name Name of the new group\r\n  @param _document Document of the new group\r\n  @return {\r\n    \"_success\": \"If creation of the new group is successful\",\r\n    \"_group_id: \"Id of the new group\"\r\n  }\r\n  */\r\n  function internal_create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\r\n           internal\r\n           returns (bool _success, uint256 _group_id)\r\n  {\r\n    require(_role_id > 0);\r\n    require(read_role(_role_id) != bytes32(0x0));\r\n    _group_id = ++system.total_groups;\r\n    system.groups.append(_group_id);\r\n    system.groups_by_id[_group_id].role_id = _role_id;\r\n    system.groups_by_id[_group_id].name = _name;\r\n    system.groups_by_id[_group_id].document = _document;\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the group's information\r\n  @param _group_id Id of the group\r\n  @return {\r\n    \"_role_id\": \"Role id of the group\",\r\n    \"_name: \"Name of the group\",\r\n    \"_document: \"Document of the group\"\r\n  }\r\n  */\r\n  function read_group(uint256 _group_id)\r\n           public\r\n           constant\r\n           returns (uint256 _role_id, bytes32 _name, bytes32 _document, uint256 _members_count)\r\n  {\r\n    if (system.groups.valid_item(_group_id)) {\r\n      _role_id = system.groups_by_id[_group_id].role_id;\r\n      _name = system.groups_by_id[_group_id].name;\r\n      _document = system.groups_by_id[_group_id].document;\r\n      _members_count = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n    } else {\r\n      _role_id = 0;\r\n      _name = \"invalid\";\r\n      _document = \"\";\r\n      _members_count = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Adds new user with the given information to a group\r\n  @param _group_id Id of the group\r\n  @param _user Address of the new user\r\n  @param _document Information of the new user\r\n  @return {\"_success\": \"If adding new user to a group is successful\"}\r\n  */\r\n  function internal_update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (system.groups_by_id[_group_id].members_by_address[_user].active == false && system.group_ids_by_address[_user] == 0 && system.groups_by_id[_group_id].role_id != 0) {\r\n\r\n      system.groups_by_id[_group_id].members_by_address[_user].active = true;\r\n      system.group_ids_by_address[_user] = _group_id;\r\n      system.groups_collection.append(bytes32(_group_id), _user);\r\n      system.groups_by_id[_group_id].members_by_address[_user].document = _document;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Removes user from its group\r\n  @param _user Address of the user\r\n  @return {\"_success\": \"If removing of user is successful\"}\r\n  */\r\n  function internal_destroy_group_user(address _user)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    uint256 _group_id = system.group_ids_by_address[_user];\r\n    if ((_group_id == 1) && (system.groups_collection.total(bytes32(_group_id)) == 1)) {\r\n      _success = false;\r\n    } else {\r\n      system.groups_by_id[_group_id].members_by_address[_user].active = false;\r\n      system.group_ids_by_address[_user] = 0;\r\n      delete system.groups_by_id[_group_id].members_by_address[_user];\r\n      _success = system.groups_collection.remove_item(bytes32(_group_id), _user);\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Returns the role id of a user\r\n  @param _user Address of a user\r\n  @return {\"_role_id\": \"Role id of the user\"}\r\n  */\r\n  function read_user_role_id(address _user)\r\n           constant\r\n           public\r\n           returns (uint256 _role_id)\r\n  {\r\n    uint256 _group_id = system.group_ids_by_address[_user];\r\n    _role_id = system.groups_by_id[_group_id].role_id;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the user's information\r\n  @param _user Address of the user\r\n  @return {\r\n    \"_group_id\": \"Group id of the user\",\r\n    \"_role_id\": \"Role id of the user\",\r\n    \"_document\": \"Information of the user\"\r\n  }\r\n  */\r\n  function read_user(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _group_id, uint256 _role_id, bytes32 _document)\r\n  {\r\n    _group_id = system.group_ids_by_address[_user];\r\n    _role_id = system.groups_by_id[_group_id].role_id;\r\n    _document = system.groups_by_id[_group_id].members_by_address[_user].document;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the first group\r\n  @return {\"_group_id\": \"Id of the first group\"}\r\n  */\r\n  function read_first_group()\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_first_from_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the last group\r\n  @return {\"_group_id\": \"Id of the last group\"}\r\n  */\r\n  function read_last_group()\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_last_from_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the previous group depending on the given current group\r\n  @param _current_group_id Id of the current group\r\n  @return {\"_group_id\": \"Id of the previous group\"}\r\n  */\r\n  function read_previous_group_from_group(uint256 _current_group_id)\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_previous_from_uints(system.groups, _current_group_id);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the next group depending on the given current group\r\n  @param _current_group_id Id of the current group\r\n  @return {\"_group_id\": \"Id of the next group\"}\r\n  */\r\n  function read_next_group_from_group(uint256 _current_group_id)\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_next_from_uints(system.groups, _current_group_id);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the total number of groups\r\n  @return {\"_total_groups\": \"Total number of groups\"}\r\n  */\r\n  function read_total_groups()\r\n           view\r\n           external\r\n           returns (uint256 _total_groups)\r\n  {\r\n    _total_groups = read_total_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the first user of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_user\": \"Address of the user\"}\r\n  */\r\n  function read_first_user_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_first_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n\r\n  /**\r\n  @notice Returns the last user of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_user\": \"Address of the user\"}\r\n  */\r\n  function read_last_user_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_last_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n\r\n  /**\r\n  @notice Returns the next user of a group depending on the given current user\r\n  @param _group_id Id of the group\r\n  @param _current_user Address of the current user\r\n  @return {\"_user\": \"Address of the next user\"}\r\n  */\r\n  function read_next_user_in_group(bytes32 _group_id, address _current_user)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_next_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the previous user of a group depending on the given current user\r\n  @param _group_id Id of the group\r\n  @param _current_user Address of the current user\r\n  @return {\"_user\": \"Address of the last user\"}\r\n  */\r\n  function read_previous_user_in_group(bytes32 _group_id, address _current_user)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_previous_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the total number of users of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_total_users\": \"Total number of users\"}\r\n  */\r\n  function read_total_users_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (uint256 _total_users)\r\n  {\r\n    _total_users = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n}\r\n\r\n// File: contracts/storage/DigixDirectoryStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\ncontract DigixDirectoryStorage is DirectoryStorage, ResolverClient, DigixConstants {\r\n\r\n  function DigixDirectoryStorage(address _resolver) public {\r\n    require(init(CONTRACT_STORAGE_DIGIX_DIRECTORY, _resolver));\r\n    require(initialize_directory());\r\n  }\r\n\r\n  function create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\r\n           if_sender_is(CONTRACT_CONTROLLER_DIGIX_DIRECTORY)\r\n           public\r\n           returns (bool _success, uint256 _group_id)\r\n  {\r\n    (_success, _group_id) = internal_create_group(_role_id, _name, _document);\r\n    require(_success);\r\n  }\r\n\r\n  function create_role(uint256 _role_id, bytes32 _name)\r\n           if_sender_is(CONTRACT_CONTROLLER_DIGIX_DIRECTORY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = internal_create_role(_role_id, _name);\r\n    require(_success);\r\n  }\r\n\r\n  function update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\r\n           if_sender_is(CONTRACT_CONTROLLER_DIGIX_DIRECTORY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = internal_update_add_user_to_group(_group_id, _user, _document);\r\n    require(_success);\r\n  }\r\n\r\n  function update_remove_group_user(address _user)\r\n           if_sender_is(CONTRACT_CONTROLLER_DIGIX_DIRECTORY)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = internal_destroy_group_user(_user);\r\n    require(_success);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/service/DigixDirectoryService.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\ncontract DigixDirectoryService is DirectoryService, ResolverClient, DigixConstants {\r\n\r\n  function DigixDirectoryService(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_SERVICE_DIRECTORY, _resolver));\r\n  }\r\n\r\n  function directory_storage()\r\n           internal\r\n           constant\r\n           returns (DigixDirectoryStorage _contract)\r\n  {\r\n    _contract = DigixDirectoryStorage(get_contract(CONTRACT_STORAGE_DIGIX_DIRECTORY));\r\n  }\r\n\r\n  function get_user_role_id(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _role_id)\r\n  {\r\n    _role_id = internal_get_user_role_id(directory_storage().read_user_role_id, _user);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/common/Controller.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/// @title Common controller functions\r\n/// @author DigixGlobal Pte Ltd\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Controller is ResolverClient, DigixConstants {\r\n\r\n  function products_list_storage()\r\n           internal\r\n           constant\r\n           returns (ProductsListStorage _contract)\r\n  {\r\n    _contract = ProductsListStorage(get_contract(CONTRACT_STORAGE_PRODUCTS_LIST));\r\n  }\r\n\r\n  function digix_directory_service()\r\n           internal\r\n           constant\r\n           returns (DigixDirectoryService _contract)\r\n  {\r\n    _contract = DigixDirectoryService(get_contract(CONTRACT_SERVICE_DIRECTORY));\r\n  }\r\n\r\n  function token_demurrage_service()\r\n           internal\r\n           constant\r\n           returns (TokenDemurrageService _contract)\r\n  {\r\n    _contract = TokenDemurrageService(get_contract(CONTRACT_SERVICE_TOKEN_DEMURRAGE));\r\n  }\r\n\r\n  function assets_storage()\r\n           internal\r\n           constant\r\n           returns (AssetsStorage _contract)\r\n  {\r\n    _contract = AssetsStorage(get_contract(CONTRACT_STORAGE_ASSETS));\r\n  }\r\n\r\n  function marketplace_storage()\r\n           internal\r\n           constant\r\n           returns (MarketplaceStorage _contract)\r\n  {\r\n    _contract = MarketplaceStorage(get_contract(CONTRACT_STORAGE_MARKETPLACE));\r\n  }\r\n\r\n  function gold_token_storage()\r\n           internal\r\n           constant\r\n           returns (GoldTokenStorage _contract)\r\n  {\r\n    _contract = GoldTokenStorage(get_contract(CONTRACT_STORAGE_GOLD_TOKEN));\r\n  }\r\n\r\n  function asset_events_storage()\r\n           internal\r\n           constant\r\n           returns (AssetEventsStorage _contract)\r\n  {\r\n    _contract = AssetEventsStorage(get_contract(CONTRACT_STORAGE_ASSET_EVENTS));\r\n  }\r\n\r\n  function identity_storage()\r\n           internal\r\n           constant\r\n           returns (IdentityStorage _contract)\r\n  {\r\n    _contract = IdentityStorage(get_contract(CONTRACT_STORAGE_IDENTITY));\r\n  }\r\n\r\n\r\n  modifier if_caller_is_role(address _caller, uint256 _intended_role_id) {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == _intended_role_id);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/storage/JobIdStorage.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract JobIdStorage is ResolverClient, DigixConstants {\r\n\r\n  mapping (bytes32 => bool) used_job_ids;\r\n  mapping (bytes32 => bool) failed_job_ids;\r\n\r\n  function JobIdStorage(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_STORAGE_JOB_ID, _resolver));\r\n  }\r\n\r\n  function read_if_job_id_is_used(bytes32 _job_id)\r\n           public\r\n           constant\r\n           returns (bool _is_used)\r\n  {\r\n    _is_used = used_job_ids[_job_id];\r\n  }\r\n\r\n  function read_if_job_id_is_failed(bytes32 _job_id)\r\n           public\r\n           constant\r\n           returns (bool _is_used)\r\n  {\r\n    _is_used = failed_job_ids[_job_id];\r\n  }\r\n\r\n  function set_job_id_as_used(bytes32 _job_id)\r\n           if_sender_is(CONTRACT_CONTROLLER_JOB_ID)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    used_job_ids[_job_id] = true;\r\n    _success = true;\r\n  }\r\n\r\n  function set_job_id_as_failed(bytes32 _job_id)\r\n           if_sender_is(CONTRACT_CONTROLLER_JOB_ID)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    failed_job_ids[_job_id] = true;\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/controller/JobIdController.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract JobIdController is Controller {\r\n\r\n  function JobIdController(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_CONTROLLER_JOB_ID, _resolver));\r\n  }\r\n\r\n  function job_id_storage()\r\n           internal\r\n           constant\r\n           returns (JobIdStorage _contract)\r\n  {\r\n     _contract = JobIdStorage(get_contract(CONTRACT_STORAGE_JOB_ID));\r\n  }\r\n\r\n  function mark_job_id_as_used(bytes32 _job_id)\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = job_id_storage().set_job_id_as_used(_job_id);\r\n  }\r\n\r\n  function mark_job_id_as_failed(address _caller, bytes32 _job_id)\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == ROLE_POPADMIN);\r\n    // make sure the job id is not already used\r\n    bool _job_id_is_used = job_id_storage().read_if_job_id_is_used(_job_id);\r\n    require(!_job_id_is_used);\r\n    _success = job_id_storage().set_job_id_as_failed(_job_id);\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/UintIteratorController.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/**\r\n  @title Uint Iterator Interactive\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\n\r\n\r\ncontract UintIteratorController {\r\n\r\n  /**\r\n    @notice Returns the first item from the list\r\n    @param _function Function that returns the first item\r\n    @return {\"_item\": \"The first item\"}\r\n  */\r\n  function get_first_from_uints(function () constant external returns (uint256) _function)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _function();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the last item from the list\r\n    @param _function Function that returns the last item\r\n    @return {\"_item\": \"The last item\"}\r\n  */\r\n  function get_last_from_uints(function () constant external returns (uint256) _function)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _function();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the next item from the list based on the `_current_item`\r\n    @param _function Function that returns the next item\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The next item\"}\r\n  */\r\n  function get_next_from_uints(function (uint256) constant external returns (uint256) _function, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _function(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the previous item from the list based on the `_current_item`\r\n    @param _function Function that returns the previous item\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The next item\"}\r\n  */\r\n  function get_previous_from_uints(function (uint256) constant external returns (uint256) _function, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _function(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the total number of items from the list\r\n    @param _function Function that returns the total number of items\r\n    @return {\"_total_count\": \"The total number of items\"}\r\n  */\r\n  function get_total_uints(function () constant external returns (uint256) _function)\r\n           internal\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = _function();\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/controller/ProductsListController.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\ncontract ProductsListController is Controller, UintIteratorController {\r\n\r\n  function ProductsListController(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_CONTROLLER_PRODUCTS_LIST, _resolver));\r\n  }\r\n\r\n  /// @notice add a new product to the product list\r\n  /// @param _document the dijix ipfs document\r\n  /// @param _ng_weight the weight of the product\r\n  /// @param _effective_ng_weight the effective weight of the product\r\n  /// @return _success whether the product is successfully added\r\n  /// @return _product_id the product id of the newly created product\r\n  function put_product(bytes32 _document, uint256 _ng_weight, uint256 _effective_ng_weight)\r\n           if_sender_is(CONTRACT_INTERACTIVE_PRODUCTS_LIST)\r\n           public\r\n           returns (bool _success, uint256 _product_id)\r\n  {\r\n    (_success, _product_id) = products_list_storage().create_product(_document, _ng_weight, _effective_ng_weight);\r\n  }\r\n\r\n  /// @notice get information of an existing product\r\n  /// @param _item the product id\r\n  /// @return _document the dijix ipfs document\r\n  /// @return _ng_weight the weight of the product\r\n  /// @return _effective_ng_weight the effective weight of the product\r\n  /// @return _enabled whether the product is enabled\r\n  function get_product(uint256 _item)\r\n           public\r\n           constant\r\n           returns (bytes32 _document, uint256 _ng_weight, uint256 _effective_ng_weight, bool _enabled)\r\n  {\r\n    (_document, _ng_weight, _effective_ng_weight, _enabled) = products_list_storage().read_product(_item);\r\n  }\r\n\r\n  /// @notice enable an existing disabled product in the product list\r\n  /// @param _item the product id\r\n  /// @return _success whether the product is successfully enabled\r\n  function enable_product(uint256 _item)\r\n           if_sender_is(CONTRACT_INTERACTIVE_PRODUCTS_LIST)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = products_list_storage().enable_product(_item);\r\n  }\r\n\r\n  /// @notice disable an existing enabled product in the product list\r\n  /// @param _item the product id\r\n  /// @return _success whether the product is successfully disabled\r\n  function disable_product(uint256 _item)\r\n           if_sender_is(CONTRACT_INTERACTIVE_PRODUCTS_LIST)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = products_list_storage().disable_product(_item);\r\n  }\r\n\r\n  /// @notice get the total number of products in product list\r\n  /// @return _total_count total number of products\r\n  function get_products_total()\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = get_total_uints(products_list_storage().read_products_total);\r\n  }\r\n\r\n  /// @notice get the first product in product list\r\n  /// @return _item first product\r\n  function get_first_product()\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = get_first_from_uints(products_list_storage().read_first_product);\r\n  }\r\n\r\n  /// @notice get the last product in product list\r\n  /// @return _item last product\r\n  function get_last_product()\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = get_last_from_uints(products_list_storage().read_last_product);\r\n  }\r\n\r\n  /// @notice get the next product after some product\r\n  /// @param _current_item the current item\r\n  /// @return _item next product\r\n  function get_next_from_product(uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = get_next_from_uints(products_list_storage().read_next_from_product, _current_item);\r\n  }\r\n\r\n  /// @notice get the previous product after some product\r\n  /// @param _current_item the current item\r\n  /// @return _item previous product\r\n  function get_previous_from_product(uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = get_previous_from_uints(products_list_storage().read_previous_from_product, _current_item);\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/IndexedBytesIteratorController.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n  @title Indexed Bytes Iterator Controller\r\n  @author DigixGlobal Pte Ltd\r\n  @notice This contract utilizes: [Indexed Bytes Iterator Storage](/IndexedBytesIteratorStorage)\r\n*/\r\ncontract IndexedBytesIteratorController {\r\n\r\n  /**\r\n    @notice Gets the first item from an indexed Bytes Doubly Linked List\r\n    @param _function Function that returns the first item in the collection\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\":\"First item in the list\"}\r\n  */\r\n  function get_first_from_indexed_bytesarray(function (bytes32) constant external returns (bytes32) _function, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _function(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Gets the last item from an indexed Bytes Doubly Linked List\r\n    @param _function Function that returns the last item in the collection\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\": \"The last item in the list\"}\r\n  */\r\n  function get_last_from_indexed_bytesarray(function (bytes32) constant external returns (bytes32) _function, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _function(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Gets the next item from an indexed Bytes Doubly Linked List using the spcified `_current_item`\r\n    @param _function Function that returns the next item in the collection\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\":\"The next item in the list\"}\r\n  */\r\n  function get_next_from_indexed_bytesarray(function (bytes32, bytes32) constant external returns (bytes32) _function, bytes32 _collection_index, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _function(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Gets the previous item from an indexed Bytes Doubly Linked List using the spcified `_current_item`\r\n    @param _function Function that returns the previous item in the collection\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\":\"The previous item in the list\"}\r\n  */\r\n  function get_previous_from_indexed_bytesarray(function (bytes32, bytes32) constant external returns (bytes32) _function, bytes32 _collection_index, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _function(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Gets the total number of items in an Indexed Bytes Doubly Linked List\r\n    @param _function Function that returns the length of the collection\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_total_count\":\"length of the Doubly Linked List\"}\r\n  */\r\n  function get_total_indexed_bytesarray(function (bytes32) constant external returns (uint256) _function, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = _function(_collection_index);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/controller/AssetsController.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AssetsController is IndexedBytesIteratorController, Controller {\r\n\r\n  using Types for Types.MutableUint;\r\n\r\n  function AssetsController(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_CONTROLLER_ASSETS, _resolver));\r\n  }\r\n\r\n  function products_list_controller()\r\n           internal\r\n           constant\r\n           returns (ProductsListController _contract)\r\n  {\r\n    _contract = ProductsListController(get_contract(CONTRACT_CONTROLLER_PRODUCTS_LIST));\r\n  }\r\n\r\n  /// @notice called by popadmin to create a new asset item and put it to `vendor_order` state\r\n  function put_init_item(address _caller, uint256 _product_id, address _mint_target)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success, bytes32 _item)\r\n  {\r\n     uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n     bool _enabled;\r\n     uint256 _ng_weight;\r\n     uint256 _effective_ng_weight;\r\n     require(_mint_target != address(0x0));\r\n\r\n     (,_ng_weight,_effective_ng_weight,_enabled) = products_list_controller().get_product(_product_id);\r\n     require(_enabled);\r\n     (_success, _item) = assets_storage().create_init_item(_role_id, _product_id, _ng_weight, _effective_ng_weight, _mint_target);\r\n     if (_success) {\r\n       asset_events_storage().add_asset_event(_item, ASSET_EVENT_CREATED_VENDOR_ORDER);\r\n     }\r\n  }\r\n\r\n  function put_init_item_transfer(address _caller, uint256 _product_id, address _mint_target)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success, bytes32 _item)\r\n  {\r\n     uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n     bool _enabled;\r\n     uint256 _ng_weight;\r\n     uint256 _effective_ng_weight;\r\n     require(_mint_target != address(0x0));\r\n\r\n     (,_ng_weight,_effective_ng_weight,_enabled) = products_list_controller().get_product(_product_id);\r\n     require(_enabled);\r\n     (_success, _item) = assets_storage().create_init_item_transfer(_role_id, _product_id, _ng_weight, _effective_ng_weight, _mint_target);\r\n     if (_success) {\r\n       asset_events_storage().add_asset_event(_item, ASSET_EVENT_CREATED_TRANSFER_ORDER);\r\n     }\r\n  }\r\n\r\n  function put_global_audit(address _caller, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == ROLE_AUDITOR);\r\n    _success = assets_storage().create_global_audit(_document);\r\n  }\r\n\r\n  /// @notice called by a vendor to fulfill a vendor order, or by an xferauth to fulfill a transfered-in item\r\n  function patch_item_fulfill_order(address _caller, bytes32 _item, bytes32 _serial, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success, uint256 _from_state, uint256 _new_state)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    (_success, _from_state, _new_state) = assets_storage().update_item_fulfill(_role_id, _item, _serial, _document);\r\n    if (_success) {\r\n      if (_role_id == ROLE_VENDOR) {  // if this is a vendor\r\n        asset_events_storage().add_asset_event(_item, ASSET_EVENT_FULFILLED_VENDOR_ORDER);\r\n      } else {\r\n        asset_events_storage().add_asset_event(_item, ASSET_EVENT_FULFILLED_TRANSFER_ORDER);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice called by a custodian to accept an asset into their vault, hence minting new tokens\r\n  function patch_item_mint(address _caller, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success, address _mint_target, uint256 _effective_ng_weight, uint256 _from_state, uint256 _new_state)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    (_success, _mint_target, _effective_ng_weight, _from_state, _new_state) = assets_storage().update_item_mint(_role_id, _item, _document);\r\n    if (_success) {\r\n      require(token_demurrage_service().deduct_demurrage(_mint_target));\r\n      Types.MutableUint memory _user_balance;\r\n      Types.MutableUint memory _total_supply;\r\n      Types.MutableUint memory _effective_total_supply;\r\n\r\n      _user_balance.pre = token_demurrage_service().show_demurraged_balance(_mint_target);\r\n      (_total_supply.pre, _effective_total_supply.pre) = gold_token_storage().read_supply();\r\n\r\n      _user_balance = _user_balance.add(_effective_ng_weight);\r\n      _total_supply = _total_supply.add(_effective_ng_weight);\r\n      _effective_total_supply = _effective_total_supply.add(_effective_ng_weight);\r\n\r\n      require(gold_token_storage().update_balances_after_mint(_mint_target, _user_balance.post, _total_supply.post, _effective_total_supply.post));\r\n      asset_events_storage().add_asset_event(_item, ASSET_EVENT_MINTED);\r\n      TokenLoggerCallback(get_contract(CONTRACT_INTERACTIVE_TOKEN)).log_mint(_mint_target, _effective_ng_weight);\r\n    }\r\n  }\r\n\r\n  /// @notice called by popadmin to let a KYC approved user who has previously recasted to get a gold bar\r\n  function patch_item_redeem(address _caller, bytes32 _item, address _redeem_user, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    address _redeem_for;\r\n    uint256 _redeem_deadline;\r\n\r\n    (,,,,,,,_redeem_deadline) = assets_storage().read_asset_info(_item);\r\n    (,_redeem_for,,) = assets_storage().read_asset_details(_item);\r\n    require(_redeem_for == _redeem_user); // make sure that _redeem_user matches _redeem_for of the asset item\r\n    require(now < _redeem_deadline); // must redeem before the redeem deadline;\r\n\r\n    _success = assets_storage().update_item_redeem(_role_id, _item, _document);\r\n    if (_success) {\r\n      asset_events_storage().add_asset_event(_item, ASSET_EVENT_REDEEMED);\r\n    }\r\n  }\r\n\r\n  /// @notice (an auditor) change an asset item's state to `audit_failure`\r\n  /// @param _caller the address of the caller (should be an auditor)\r\n  /// @param _item the id of the asset item to be marked as `audit_failure`\r\n  /// @param _document the support document supplied by the auditor\r\n  /// @return _success whether the item is successfully marked as `audit_failure`\r\n  /// @return _from_state the old state of the asset item (should be `minted`)\r\n  /// @return _to_state the new state of the asset item (should be `audit_failure`)\r\n  function patch_item_to_audit_failure(address _caller, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success, uint256 _from_state, uint256 _new_state)\r\n  {\r\n    // update token effective supply, set state, add document\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    (_success, _from_state, _new_state) = assets_storage().update_item_to_audit_failure(_role_id, _item, _document);\r\n    if (_success) {\r\n      uint256 _effective_ng_weight;\r\n      ( ,,_effective_ng_weight,,,,,) = assets_storage().read_asset_info(_item);\r\n      uint256 _effective_total_supply = gold_token_storage().read_effective_total_supply();\r\n      _effective_total_supply = MathUtils.subtract(_effective_total_supply, _effective_ng_weight);\r\n      _success = _success && gold_token_storage().update_effective_supply(_effective_total_supply);\r\n      if (_success) {\r\n        asset_events_storage().add_asset_event(_item, ASSET_EVENT_FAILED_AUDIT);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice (a popadmin/the recaster) remint a recasted asset to the recaster\r\n  function patch_item_remint(address _caller, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    address _recaster;\r\n    uint256 _effective_ng_weight;\r\n    uint256 _redeem_deadline;\r\n    (,,_effective_ng_weight,,,,,_redeem_deadline) = assets_storage().read_asset_info(_item);\r\n    (,_recaster,,) = assets_storage().read_asset_details(_item);\r\n    require(token_demurrage_service().deduct_demurrage(_recaster));\r\n\r\n    // must be a popadmin after 30 days, or the recaster himself\r\n    if (_role_id == ROLE_POPADMIN) {\r\n      require(now > _redeem_deadline);\r\n    } else {\r\n      require(_caller == _recaster);\r\n      _role_id = ROLE_KYC_RECASTER;\r\n    }\r\n    _success = assets_storage().update_item_remint(_role_id, _item, _document);\r\n\r\n    // now mint back the bar, update effective and total supply\r\n    Types.MutableUint memory _user_balance;\r\n    Types.MutableUint memory _total_supply;\r\n    Types.MutableUint memory _effective_total_supply;\r\n\r\n    _user_balance.pre = token_demurrage_service().show_demurraged_balance(_recaster);\r\n    (_total_supply.pre, _effective_total_supply.pre) = gold_token_storage().read_supply();\r\n\r\n    _user_balance = _user_balance.add(_effective_ng_weight);\r\n    _total_supply = _total_supply.add(_effective_ng_weight);\r\n    _effective_total_supply = _effective_total_supply.add(_effective_ng_weight);\r\n\r\n    require(gold_token_storage().update_balances_after_mint(_recaster, _user_balance.post, _total_supply.post, _effective_total_supply.post));\r\n    asset_events_storage().add_asset_event(_item, ASSET_EVENT_REMINTED);\r\n    TokenLoggerCallback(get_contract(CONTRACT_INTERACTIVE_TOKEN)).log_mint(_recaster, _effective_ng_weight);\r\n  }\r\n\r\n  struct Replacement {\r\n    bool product_enabled;\r\n    uint256 product_effective_ng_weight;\r\n    uint256 product_ng_weight;\r\n    uint256 failed_item_effective_ng_weight;\r\n    uint256 failed_item_state_id;\r\n    bytes32 current_replacement_item;\r\n    uint256 state_of_current_replacement_item;\r\n  }\r\n  /// @notice (popadmin) create a new asset item to replace an item that failed audit\r\n  function put_init_item_as_replacement(address _caller, uint256 _product_id, bytes32 _old_item)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success, bytes32 _replacement_item)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    Replacement memory _replacement;\r\n\r\n    ( ,,_replacement.failed_item_effective_ng_weight,,_replacement.failed_item_state_id,,,) = assets_storage().read_asset_info(_old_item);\r\n    (,,_replacement.current_replacement_item,) = assets_storage().read_asset_details(_old_item);\r\n    (,_replacement.product_ng_weight, _replacement.product_effective_ng_weight, _replacement.product_enabled) = products_list_controller().get_product(_product_id);\r\n\r\n    if (_replacement.current_replacement_item != 0) {\r\n      // the failed item A is already being replaced by some asset B\r\n      // we will only allow re-replacing A if B is currently in admin_failure\r\n      _replacement.state_of_current_replacement_item = assets_storage().read_asset_state(_replacement.current_replacement_item);\r\n      require(_replacement.state_of_current_replacement_item == STATE_ADMIN_FAILURE);\r\n    }\r\n\r\n    if (_replacement.product_enabled && _replacement.failed_item_state_id == STATE_AUDIT_FAILURE && _replacement.failed_item_effective_ng_weight == _replacement.product_effective_ng_weight) {\r\n      (_success, _replacement_item) = assets_storage().create_init_item_as_replacement(_role_id, _product_id, _replacement.product_ng_weight, _replacement.product_effective_ng_weight, _old_item);\r\n      if (_success) {\r\n        asset_events_storage().add_asset_event(_replacement_item, ASSET_EVENT_CREATED_REPLACEMENT_ORDER);\r\n      }\r\n    } else {\r\n      _success = false;\r\n      _replacement_item = \"\";\r\n    }\r\n  }\r\n\r\n  /// @notice (vendor) change the state of an asset item from `replacement_order` to `replacement_delivery`\r\n  function patch_item_fulfill_replacement_order(address _caller, bytes32 _item, bytes32 _serial, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    _success = assets_storage().update_item_fulfill_replacement(_role_id, _item, _serial, _document);\r\n    if (_success) {\r\n      asset_events_storage().add_asset_event(_item, ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER);\r\n    }\r\n  }\r\n\r\n  /// @notice (custodian) accepts an asset item from `replacement_delivery` state to `minted`\r\n  function patch_item_mint_replacement(address _caller, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success, uint256 _effective_ng_weight)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    (_success, _effective_ng_weight) = assets_storage().update_item_mint_replacement(_role_id, _item, _document);\r\n    if (_success) {\r\n      uint256 _effective_total_supply = gold_token_storage().read_effective_total_supply();\r\n      _effective_total_supply = MathUtils.add(_effective_total_supply, _effective_ng_weight);\r\n      require(gold_token_storage().update_effective_supply(_effective_total_supply));\r\n      asset_events_storage().add_asset_event(_item, ASSET_EVENT_MINTED_REPLACEMENT);\r\n    }\r\n  }\r\n\r\n  /// @notice (popadmin) change an asset item that has not been minted to `audit_failure`\r\n  function patch_item_admin_fail(address _caller, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    _success = assets_storage().update_item_admin_fail(_role_id, _item, _document);\r\n    if (_success) {\r\n      asset_events_storage().add_asset_event(_item, ASSET_EVENT_ADMIN_FAILED);\r\n    }\r\n  }\r\n\r\n  function patch_item_add_document(address _caller, bytes32 _item, bytes32 _document)\r\n           public\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           returns (bool _success)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    if (_role_id == ROLE_POPADMIN) {\r\n      _success = assets_storage().update_item_add_document(_item, _document);\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function change_redeem_period(address _caller, uint256 _redeem_period)\r\n           if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == ROLE_POPADMIN);\r\n    _success = assets_storage().update_redeem_period(_redeem_period);\r\n  }\r\n}\r\n\r\n// File: contracts/service/VerificationService.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\ncontract VerificationService is ResolverClient, DigixConstantsElectron  {\r\n\r\n    function VerificationService(address _resolver) public {\r\n        require(init(CONTRACT_SERVICE_VERIFICATION, _resolver));\r\n    }\r\n\r\n    struct Message {\r\n        bytes userAddress;\r\n        bytes kycTier;\r\n        bytes kycExpiry;\r\n        bytes blockNumber;\r\n        bytes price;\r\n    }\r\n\r\n    struct KycMessage {\r\n        bytes userAddress;\r\n        bytes kycTier;\r\n        bytes kycExpiry;\r\n        bytes blockNumber;\r\n    }\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    function convertToBytes(\r\n        address user_address,\r\n        uint kyc_tier,\r\n        uint kyc_expiry,\r\n        uint block_number,\r\n        uint price\r\n    )\r\n        internal\r\n        pure\r\n        returns (Message)\r\n    {\r\n        return Message(\r\n            addressToBytes(user_address),\r\n            intToBytes(kyc_tier),\r\n            intToBytes(kyc_expiry),\r\n            intToBytes(block_number),\r\n            intToBytes(price)\r\n        );\r\n    }\r\n\r\n    function convertKycMessageToBytes(\r\n        address user_address,\r\n        uint kyc_tier,\r\n        uint kyc_expiry,\r\n        uint block_number\r\n    )\r\n        internal\r\n        pure\r\n        returns (KycMessage)\r\n    {\r\n        return KycMessage(\r\n            addressToBytes(user_address),\r\n            intToBytes(kyc_tier),\r\n            intToBytes(kyc_expiry),\r\n            intToBytes(block_number)\r\n        );\r\n    }\r\n\r\n    function verify_user_kyc(\r\n        address user_address,\r\n        uint kyc_tier,\r\n        uint kyc_expiry,\r\n        uint block_number,\r\n        bytes signature,\r\n        address signer\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bytes memory delimiter = new bytes(1);\r\n        delimiter[0] = 0x3a;\r\n\r\n        KycMessage memory _m = convertKycMessageToBytes(user_address, kyc_tier, kyc_expiry, block_number);\r\n\r\n        bytes memory lengthBytes = intToBytes(_m.userAddress.length + _m.kycTier.length + _m.kycExpiry.length + _m.blockNumber.length + 4);\r\n\r\n        bytes memory message = concat_bytes(\r\n            concat_bytes(\r\n                concat_bytes(\"\\x19Ethereum Signed Message:\\n\", lengthBytes),\r\n                concat_bytes(delimiter, _m.userAddress)\r\n            ),\r\n            concat_bytes(\r\n                concat_bytes(\r\n                    concat_bytes(delimiter, _m.kycTier),\r\n                    concat_bytes(delimiter, _m.kycExpiry)\r\n                ),\r\n                concat_bytes(delimiter, _m.blockNumber)\r\n            )\r\n        );\r\n\r\n        Signature memory _s = parse_signature(signature);\r\n        return ecrecover(keccak256(message), _s.v, _s.r, _s.s) == signer;\r\n    }\r\n\r\n    function verify_signed_price(\r\n        address user_address,\r\n        uint kyc_tier,\r\n        uint kyc_expiry,\r\n        uint block_number,\r\n        uint price,\r\n        bytes signature,\r\n        address signer\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bytes memory delimiter = new bytes(1);\r\n        delimiter[0] = 0x3a;\r\n\r\n        Message memory _m = convertToBytes(user_address, kyc_tier, kyc_expiry, block_number, price);\r\n\r\n        bytes memory lengthBytes = intToBytes(_m.userAddress.length + _m.kycTier.length + _m.kycExpiry.length + _m.blockNumber.length + _m.price.length + 5);\r\n\r\n        bytes memory message = concat_bytes(\r\n            concat_bytes(\r\n                concat_bytes(\"\\x19Ethereum Signed Message:\\n\", lengthBytes),\r\n                concat_bytes(\r\n                    concat_bytes(delimiter, _m.userAddress),\r\n                      concat_bytes(delimiter, _m.kycTier)\r\n                )\r\n            ),\r\n            concat_bytes(\r\n                concat_bytes(\r\n                    concat_bytes(delimiter, _m.kycExpiry),\r\n                    concat_bytes(delimiter, _m.blockNumber)\r\n                ),\r\n                concat_bytes(delimiter, _m.price)\r\n            )\r\n        );\r\n\r\n        Signature memory _s = parse_signature(signature);\r\n        return ecrecover(keccak256(message), _s.v, _s.r, _s.s) == signer;\r\n    }\r\n\r\n    function parse_signature(bytes _sigbytes) internal pure returns (Signature) {\r\n        bytes32 _r;\r\n        bytes32 _s;\r\n        uint8 _v;\r\n\r\n        assembly {\r\n            _r := mload(add(_sigbytes, 32))\r\n            _s := mload(add(_sigbytes, 64))\r\n            _v := byte(0, mload(add(_sigbytes, 96)))\r\n        }\r\n        if (_v < 27) {\r\n            _v += 27;\r\n        }\r\n\r\n        require(_v == 27 || _v == 28);\r\n        return Signature(_r, _s, _v);\r\n    }\r\n\r\n    function concat_bytes(bytes b1, bytes b2) internal pure returns (bytes b) {\r\n        b = new bytes(b1.length + b2.length);\r\n\r\n        for (uint i=0; i<b1.length;i++) {\r\n            b[i] = b1[i];\r\n        }\r\n        for (i=0; i<b2.length; i++) {\r\n            b[i + b1.length] = b2[i];\r\n        }\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns (bytes result) {\r\n        bytes32 temp = bytes32(a);\r\n        result = new bytes(40);\r\n        for (uint i=0;i<20;i++) {\r\n            result[i*2] = hexToChar(uint8(temp[12+i]) / 16);\r\n            result[i*2+1] = hexToChar(uint8(temp[12+i]) % 16);\r\n        }\r\n    }\r\n\r\n    function hexToChar(uint8 hexadecimal) internal pure returns (byte c) {\r\n        if (hexadecimal >= 10) {\r\n            c = byte(hexadecimal + 97 - 10); // 97 = 'a'\r\n        } else {\r\n            c = byte(hexadecimal + 48); // 48 = '0'\r\n        }\r\n    }\r\n\r\n    function intToBytes(uint256 number) internal pure returns (bytes result) {\r\n        require(number > 0);\r\n        bytes memory fullString = new bytes(32);\r\n        uint l = 0;\r\n        while (number != 0) {\r\n            fullString[l++] = byte(number % 10 + 48);\r\n            number = number / 10;\r\n        }\r\n\r\n        result = new bytes(l);\r\n\r\n        for (uint i=0;i<l;i++) {\r\n            result[i] = fullString[l-i-1];\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/storage/AssetsStorageElectron.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AssetsStorageElectron is ResolverClient, BytesIteratorStorage, DigixConstants, DigixConstantsElectron {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n\r\n  uint256 public recast_block_threshold;\r\n  mapping (bytes32 => bytes32) custodian_by_asset_id;\r\n  mapping (bytes32 => bytes32) custodian_by_global_audit_doc;\r\n  mapping (bytes32 => uint256) global_audit_timestamp;\r\n  mapping (bytes32 => bool) valid_custodians;\r\n  DoublyLinkedList.Bytes all_custodians;\r\n\r\n  mapping(bytes32 => uint256) public remint_item_blocked_at;\r\n  uint256 public remint_item_block_duration;\r\n\r\n  function AssetsStorageElectron(address _resolver) public {\r\n    require(init(CONTRACT_STORAGE_ASSETS_ELECTRON, _resolver));\r\n    recast_block_threshold = 20;\r\n    remint_item_block_duration = 1 days;\r\n  }\r\n\r\n  function set_remint_item_block_duration(uint256 _duration)\r\n    public\r\n    if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n  {\r\n    remint_item_block_duration = _duration;\r\n  }\r\n\r\n  function set_remint_item_blocked_at(bytes32 _item, uint256 _timestamp)\r\n    public\r\n    if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\r\n  {\r\n    remint_item_blocked_at[_item] = _timestamp;\r\n  }\r\n\r\n  function add_custodian(bytes32 _custodian)\r\n    public\r\n    if_sender_is(CONTRACT_CONTROLLER_ASSETS_ELECTRON)\r\n    returns (bool _success)\r\n  {\r\n    if (valid_custodians[_custodian] == false) {\r\n      valid_custodians[_custodian] = true;\r\n      _success = all_custodians.append(_custodian);\r\n    }\r\n  }\r\n\r\n  function set_asset_custodian(bytes32 _item, bytes32 _custodian)\r\n    public\r\n    if_sender_is(CONTRACT_CONTROLLER_ASSETS_ELECTRON)\r\n    returns (bool _success)\r\n  {\r\n    require(custodian_by_asset_id[_item] == bytes32(0x0));\r\n    custodian_by_asset_id[_item] = _custodian;\r\n    _success = true;\r\n  }\r\n\r\n  function set_audit_custodian(bytes32 _doc, bytes32 _custodian)\r\n    public\r\n    if_sender_is(CONTRACT_CONTROLLER_ASSETS_ELECTRON)\r\n    returns (bool _success)\r\n  {\r\n    require(custodian_by_global_audit_doc[_doc] == bytes32(0x0));\r\n    custodian_by_global_audit_doc[_doc] = _custodian;\r\n    _success = true;\r\n  }\r\n\r\n  function set_audit_timestamp(bytes32 _doc, uint256 _timestamp)\r\n    public\r\n    if_sender_is(CONTRACT_CONTROLLER_ASSETS_ELECTRON)\r\n    returns (bool _success)\r\n  {\r\n    require(global_audit_timestamp[_doc] == 0);\r\n    global_audit_timestamp[_doc] = _timestamp;\r\n    _success = true;\r\n  }\r\n\r\n  function set_recast_block_threshold(uint256 _block_threshold)\r\n    public\r\n    if_sender_is(CONTRACT_CONTROLLER_ASSETS_ELECTRON)\r\n    returns (bool _success)\r\n  {\r\n    recast_block_threshold = _block_threshold;\r\n    _success = true;\r\n  }\r\n\r\n  function update_asset_custodian(bytes32 _item, bytes32 _custodian)\r\n    public\r\n    if_sender_is(CONTRACT_CONTROLLER_ASSETS_ELECTRON)\r\n    returns (bool _success)\r\n  {\r\n    require(custodian_by_asset_id[_item] != bytes32(0x0));\r\n    custodian_by_asset_id[_item] = _custodian;\r\n    _success = true;\r\n  }\r\n\r\n  function read_asset_custodian(bytes32 _item)\r\n    public\r\n    constant\r\n    returns (bytes32 _custodian)\r\n  {\r\n    _custodian = custodian_by_asset_id[_item];\r\n  }\r\n\r\n  function read_audit_custodian(bytes32 _doc)\r\n    public\r\n    constant\r\n    returns (bytes32 _custodian)\r\n  {\r\n    _custodian = custodian_by_global_audit_doc[_doc];\r\n  }\r\n\r\n  function read_audit_info(bytes32 _doc)\r\n    public\r\n    constant\r\n    returns (bytes32 _custodian, uint256 _timestamp)\r\n  {\r\n    _custodian = custodian_by_global_audit_doc[_doc];\r\n    _timestamp = global_audit_timestamp[_doc];\r\n  }\r\n\r\n  function is_valid_custodian(bytes32 _custodian)\r\n    public\r\n    constant\r\n    returns (bool _valid)\r\n  {\r\n    _valid = valid_custodians[_custodian];\r\n  }\r\n\r\n  function read_first_custodian()\r\n    public\r\n    constant\r\n    returns (bytes32 _custodian)\r\n  {\r\n    _custodian = read_first_from_bytesarray(all_custodians);\r\n  }\r\n\r\n  function read_last_custodian()\r\n    public\r\n    constant\r\n    returns (bytes32 _custodian)\r\n  {\r\n    _custodian = read_last_from_bytesarray(all_custodians);\r\n  }\r\n\r\n  function read_next_custodian(bytes32 _custodian)\r\n    public\r\n    constant\r\n    returns (bytes32 _next_custodian)\r\n  {\r\n    _next_custodian = read_next_from_bytesarray(all_custodians, _custodian);\r\n  }\r\n\r\n  function read_previous_custodian(bytes32 _custodian)\r\n    public\r\n    constant\r\n    returns (bytes32 _previous_custodian)\r\n  {\r\n    _previous_custodian = read_previous_from_bytesarray(all_custodians, _custodian);\r\n  }\r\n\r\n  function read_total_custodians()\r\n    public\r\n    constant\r\n    returns (uint256 _total_count)\r\n  {\r\n    _total_count = all_custodians.total();\r\n  }\r\n}\r\n\r\n// File: contracts/controller_electron/AssetsRecastControllerElectron.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AssetsRecastControllerElectron is IndexedBytesIteratorController, Controller, DigixConstantsElectron {\r\n\r\n  using Types for Types.MutableUint;\r\n\r\n  function AssetsRecastControllerElectron(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_CONTROLLER_ASSETS_RECAST, _resolver));\r\n  }\r\n\r\n  function products_list_controller()\r\n           internal\r\n           constant\r\n           returns (ProductsListController _contract)\r\n  {\r\n    _contract = ProductsListController(get_contract(CONTRACT_CONTROLLER_PRODUCTS_LIST));\r\n  }\r\n\r\n  function verification_service()\r\n      internal\r\n      constant\r\n      returns (VerificationService _contract)\r\n  {\r\n      _contract = VerificationService(get_contract(CONTRACT_SERVICE_VERIFICATION));\r\n  }\r\n\r\n  function assets_storage_electron()\r\n      internal\r\n      constant\r\n      returns (AssetsStorageElectron _contract)\r\n  {\r\n      _contract = AssetsStorageElectron(get_contract(CONTRACT_STORAGE_ASSETS_ELECTRON));\r\n  }\r\n\r\n  struct User {\r\n    address account;\r\n    Types.MutableUint balance;\r\n    bool no_recast_fee;\r\n    uint256 to_be_deducted;\r\n  }\r\n\r\n  struct Config {\r\n    Types.MutableUint collector_balance;\r\n    uint256 base;\r\n    uint256 rate;\r\n    address collector;\r\n  }\r\n\r\n  struct Recast {\r\n    User user;\r\n    Config config;\r\n    Types.MutableUint total_supply;\r\n    Types.MutableUint effective_total_supply;\r\n    uint256 fee;\r\n  }\r\n\r\n  function calculate_recast_struct(\r\n      address _recast_user,\r\n      uint256 _effective_ng_weight\r\n  )\r\n      internal\r\n      returns (Recast _recast)\r\n  {\r\n    require(token_demurrage_service().deduct_demurrage(_recast_user));\r\n\r\n    (_recast.config.base, _recast.config.rate, _recast.total_supply.pre, _recast.effective_total_supply.pre, _recast.config.collector, _recast.config.collector_balance.pre) = gold_token_storage().read_recast_config();\r\n    (_recast.user.balance.pre, _recast.user.no_recast_fee) = gold_token_storage().read_user_for_recast(_recast_user);\r\n\r\n    // to_be_deducted is the amount to be deducted from user's balance after the recast\r\n    _recast.user.to_be_deducted = _effective_ng_weight;\r\n\r\n    if (_recast.user.no_recast_fee == false) {\r\n      _recast.fee = MathUtils.calculate_recast_fee(_effective_ng_weight, _recast.config.base, _recast.config.rate);\r\n      _recast.user.to_be_deducted = MathUtils.add(_recast.user.to_be_deducted, _recast.fee);\r\n    } else {\r\n      _recast.fee = 0; //just to make it explicit\r\n    }\r\n  }\r\n\r\n  /// @notice check if kyc information is valid for this user\r\n  function check_user_kyc(\r\n      address _recaster,\r\n      uint256 _kyc_tier,\r\n      uint256 _kyc_expiry,\r\n      uint256 _block_number,\r\n      address _signer,\r\n      bytes _signature\r\n  )\r\n      public\r\n      constant\r\n      if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n      returns (bool)\r\n  {\r\n      // verify that the signature is valid\r\n      require(verification_service().verify_user_kyc(\r\n          _recaster, _kyc_tier, _kyc_expiry,\r\n          _block_number, _signature, _signer\r\n      ));\r\n\r\n      // make sure the block number is within the threshold for recast signatures\r\n      uint256 threshold_allowed = assets_storage_electron().recast_block_threshold();\r\n      require(_block_number + threshold_allowed >= block.number);\r\n\r\n      // make sure the kyc data comes under kyc approved\r\n      require((_kyc_tier == 2) && (_kyc_expiry > now));\r\n\r\n      // make sure the signer is the valid role for this purpose\r\n      uint256 _role_id = digix_directory_service().get_user_role_id(_signer);\r\n      require(_role_id == ROLE_ASSET_RECAST_SIGNER);\r\n\r\n      return true;\r\n  }\r\n\r\n  /// @notice called by a KYC approved user to recast an asset item\r\n  function patch_item_recast(\r\n      address _recast_user,\r\n      bytes32 _item,\r\n      bytes32 _document\r\n  )\r\n      public\r\n      if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n      returns (bool _success, uint256 _effective_ng_weight)\r\n  {\r\n    Recast memory _recast;\r\n    (,,_effective_ng_weight,,,,,) = assets_storage().read_asset_info(_item);\r\n\r\n    _recast = calculate_recast_struct(_recast_user, _effective_ng_weight);\r\n\r\n    require(_recast.config.collector != _recast_user); // disallow the recast collector to recast\r\n\r\n    _recast.user.balance = _recast.user.balance.subtract(_recast.user.to_be_deducted);\r\n    _recast.total_supply = _recast.total_supply.subtract(_effective_ng_weight);\r\n    _recast.effective_total_supply = _recast.effective_total_supply.subtract(_effective_ng_weight);\r\n    _recast.config.collector_balance = _recast.config.collector_balance.add(_recast.fee);\r\n\r\n    require(gold_token_storage().update_balances_after_recast(_recast_user, _recast.user.balance.post, _recast.config.collector_balance.post, _recast.total_supply.post, _recast.effective_total_supply.post));\r\n    // mark asset item in AssetsStorage as `recasted` only at the end\r\n    require(assets_storage().update_item_recast(0, _item, _recast_user, _document));\r\n    asset_events_storage().add_asset_event(_item, ASSET_EVENT_RECASTED);\r\n    if (_recast.fee > 0) {\r\n      TokenLoggerCallback(get_contract(CONTRACT_INTERACTIVE_TOKEN)).log_recast_fees(_recast_user, _recast.config.collector, _recast.fee);\r\n    }\r\n    TokenLoggerCallback(get_contract(CONTRACT_INTERACTIVE_TOKEN)).log_recast(_recast_user, _effective_ng_weight);\r\n    _success = true;\r\n  }\r\n\r\n  function update_remint_item_block_duration(address _caller, uint256 _duration)\r\n      public\r\n      if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN_ELECTRON)\r\n  {\r\n      uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n      require(_role_id == ROLE_ELECTRON_MARKETPLACE_ADMIN);\r\n\r\n      assets_storage_electron().set_remint_item_block_duration(_duration);\r\n  }\r\n\r\n  function is_remint_item_blocked(bytes32 _item)\r\n      public\r\n      returns (bool _blocked)\r\n  {\r\n      uint256 _block_duration = assets_storage_electron().remint_item_block_duration();\r\n      uint256 _blocked_at = assets_storage_electron().remint_item_blocked_at(_item);\r\n\r\n      if (now < _blocked_at + _block_duration) {\r\n        _blocked = true;\r\n      }\r\n  }\r\n\r\n  function set_remint_item_blocked(address _caller, bytes32 _item)\r\n      public\r\n      if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n  {\r\n      uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n      require(_role_id == ROLE_POPADMIN);\r\n\r\n      require(assets_storage().read_asset_state(_item) == STATE_RECASTED);\r\n\r\n      assets_storage_electron().set_remint_item_blocked_at(_item, now);\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/BytesIteratorController.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n  @title Bytes Iterator Controller\r\n  @author DigixGlobal Pte Ltd\r\n  @notice This contract utilizes: [Bytes Iterator Storage](/BytesIteratorStorage)\r\n*/\r\ncontract BytesIteratorController {\r\n\r\n  /**\r\n    @notice Encapsulated function that gets the first item from the list of Bytes\r\n    @param _function Function that returns the First item\r\n    @return {\"_item\": \"The first item\"}\r\n  */\r\n  function get_first_from_bytesarray(function () constant external returns (bytes32) _function)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _function();\r\n  }\r\n\r\n  /**\r\n    @notice Encapsulated function that gets the last item from the list of Bytes\r\n    @param _function Function that returns the Last item\r\n    @return {\"_item\": \"The last item\"}\r\n  */\r\n  function get_last_from_bytesarray(function () constant external returns (bytes32) _function)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _function();\r\n  }\r\n\r\n  /**\r\n    @notice Encapsulated function that gets the next item from the list of Bytes based on the specified `_current_item`\r\n    @param _function Function that returns the Next item\r\n    @param _current_item The item to be used as base line\r\n    @return {\"_item\": \"The next item\"}\r\n  */\r\n  function get_next_from_bytesarray(function (bytes32) constant external returns (bytes32) _function, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _function(_current_item);\r\n  }\r\n\r\n   /**\r\n    @notice Encapsulated function that gets the previous item from the list of Bytes based on the specified `_current_item`\r\n    @param _function Function that returns the Previous item\r\n    @param _current_item The item to be used as base line\r\n    @return {\"_item\": \"The previous item\"}\r\n  */\r\n  function get_previous_from_bytesarray(function (bytes32) constant external returns (bytes32) _function, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _function(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Encapsulate function that gets the length of list\r\n    @param _function Function that returns the length of the list\r\n    @return {\"_total_count\": \"Length of the list\"}\r\n  */\r\n  function get_total_bytesarray(function () constant external returns (uint256) _function)\r\n           internal\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = _function();\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/controller_electron/AssetsControllerElectron.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\ncontract AssetsControllerElectron is Controller, BytesIteratorController, DigixConstantsElectron {\r\n\r\n  function assets_storage_electron()\r\n    internal\r\n    constant\r\n    returns (AssetsStorageElectron _contract)\r\n  {\r\n    _contract = AssetsStorageElectron(get_contract(CONTRACT_STORAGE_ASSETS_ELECTRON));\r\n  }\r\n\r\n  function AssetsControllerElectron(address _resolver) public {\r\n    require(init(CONTRACT_CONTROLLER_ASSETS_ELECTRON, _resolver));\r\n  }\r\n\r\n  function put_custodian(address _caller, bytes32 _custodian)\r\n    public\r\n    if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == ROLE_POPADMIN);\r\n    require(assets_storage_electron().is_valid_custodian(_custodian) == false);\r\n    require(assets_storage_electron().add_custodian(_custodian));\r\n  }\r\n\r\n  function put_asset_custodian(address _caller, bytes32 _item, bytes32 _custodian)\r\n    public\r\n    if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == ROLE_POPADMIN);\r\n    require(assets_storage_electron().is_valid_custodian(_custodian));\r\n    require(assets_storage_electron().set_asset_custodian(_item, _custodian));\r\n  }\r\n\r\n  function put_audit_custodian(address _caller, bytes32 _audit_doc, bytes32 _custodian, uint256 _timestamp)\r\n    public\r\n    if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == ROLE_AUDITOR);\r\n    require(_timestamp < now);\r\n    require(assets_storage_electron().is_valid_custodian(_custodian));\r\n    require(assets_storage_electron().set_audit_custodian(_audit_doc, _custodian));\r\n    require(assets_storage_electron().set_audit_timestamp(_audit_doc, _timestamp));\r\n  }\r\n\r\n  function put_recast_block_threshold(address _caller, uint256 _block_threshold)\r\n    public\r\n    if_sender_is(CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN_ELECTRON)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == ROLE_ELECTRON_MARKETPLACE_ADMIN);\r\n    require(assets_storage_electron().set_recast_block_threshold(_block_threshold));\r\n  }\r\n\r\n  function update_asset_custodian(address _caller, bytes32 _item, bytes32 _custodian)\r\n    public\r\n    if_sender_is(CONTRACT_INTERACTIVE_POPADMIN)\r\n  {\r\n    uint256 _role_id = digix_directory_service().get_user_role_id(_caller);\r\n    require(_role_id == ROLE_POPADMIN);\r\n    require(assets_storage_electron().update_asset_custodian(_item, _custodian));\r\n  }\r\n\r\n  function get_first_custodian()\r\n    public\r\n    constant\r\n    returns (bytes32 _custodian)\r\n  {\r\n    _custodian = get_first_from_bytesarray(assets_storage_electron().read_first_custodian);\r\n  }\r\n\r\n  function get_last_custodian()\r\n    public\r\n    constant\r\n    returns (bytes32 _custodian)\r\n  {\r\n    _custodian = get_last_from_bytesarray(assets_storage_electron().read_last_custodian);\r\n  }\r\n\r\n  function get_next_custodian(bytes32 _custodian)\r\n    public\r\n    constant\r\n    returns (bytes32 _next_custodian)\r\n  {\r\n    _next_custodian = get_next_from_bytesarray(assets_storage_electron().read_next_custodian, _custodian);\r\n  }\r\n\r\n  function get_previous_custodian(bytes32 _custodian)\r\n    public\r\n    constant\r\n    returns (bytes32 _previous_custodian)\r\n  {\r\n    _previous_custodian = get_previous_from_bytesarray(assets_storage_electron().read_previous_custodian, _custodian);\r\n  }\r\n\r\n  function get_total_custodians()\r\n    public\r\n    constant\r\n    returns (uint256 _count_custodians)\r\n  {\r\n    _count_custodians = get_total_bytesarray(assets_storage_electron().read_total_custodians);\r\n  }\r\n}\r\n\r\n// File: contracts/interactive_electron/PoPAdminElectron.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Interactive functions to be called by POP admin role\r\n/// @author Digix Holdings Pte Ltd\r\n/// @notice Use this contract (POP admin role) for taking actions in the POP protocol\r\ncontract PoPAdminElectron is ResolverClient, DigixConstants, DigixConstantsElectron {\r\n\r\n  event NewOrder(uint256 indexed _product_id, bytes32 indexed _item, address _mint_target, bytes32 _custodian);\r\n  event NewTransferOrder(uint256 indexed _product_id, bytes32 indexed _item, address _mint_target);\r\n  event NewReplacementOrder(uint256 indexed _product_id, bytes32 indexed _item);\r\n  event OrderFulfillment(bytes32 indexed _item, bytes32 indexed _serial, bytes32 indexed _document);\r\n  event MintToken(bytes32 indexed _item, bytes32 indexed _document);\r\n  event AuditFailure(bytes32 indexed _item, bytes32 _document);\r\n  event AdminFailure(bytes32 indexed _item, bytes32 _document);\r\n  event AssetRedemption(bytes32 indexed _item, bytes32 _document);\r\n  event AssetRecast(bytes32 indexed _item, address _recast_user, bytes32 _document);\r\n\r\n  function PoPAdminElectron(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_INTERACTIVE_POPADMIN, _resolver));\r\n  }\r\n\r\n  function assets_controller()\r\n           internal\r\n           constant\r\n           returns (AssetsController _contract)\r\n  {\r\n     _contract = AssetsController(get_contract(CONTRACT_CONTROLLER_ASSETS));\r\n  }\r\n\r\n  function assets_storage()\r\n           internal\r\n           constant\r\n           returns (AssetsStorage _contract)\r\n  {\r\n     _contract = AssetsStorage(get_contract(CONTRACT_STORAGE_ASSETS));\r\n  }\r\n\r\n  function assets_storage_electron()\r\n           internal\r\n           constant\r\n           returns (AssetsStorageElectron _contract)\r\n  {\r\n     _contract = AssetsStorageElectron(get_contract(CONTRACT_STORAGE_ASSETS_ELECTRON));\r\n  }\r\n\r\n  function job_id_storage()\r\n           internal\r\n           constant\r\n           returns (JobIdStorage _contract)\r\n  {\r\n     _contract = JobIdStorage(get_contract(CONTRACT_STORAGE_JOB_ID));\r\n  }\r\n\r\n  function job_id_controller()\r\n           internal\r\n           constant\r\n           returns (JobIdController _contract)\r\n  {\r\n     _contract = JobIdController(get_contract(CONTRACT_CONTROLLER_JOB_ID));\r\n  }\r\n\r\n  function assets_recast_controller_electron()\r\n           internal\r\n           constant\r\n           returns (AssetsRecastControllerElectron _contract)\r\n  {\r\n     _contract = AssetsRecastControllerElectron(get_contract(CONTRACT_CONTROLLER_ASSETS_RECAST));\r\n  }\r\n\r\n  function assets_controller_electron()\r\n    internal\r\n    constant\r\n    returns (AssetsControllerElectron _contract)\r\n  {\r\n    _contract = AssetsControllerElectron(get_contract(CONTRACT_CONTROLLER_ASSETS_ELECTRON));\r\n  }\r\n\r\n  modifier check_and_update_job_id(bytes32 _job_id)\r\n  {\r\n    bool _job_id_is_used = job_id_storage().read_if_job_id_is_used(_job_id);\r\n    bool _job_id_is_failed = job_id_storage().read_if_job_id_is_failed(_job_id);\r\n    require(!_job_id_is_used);\r\n    require(!_job_id_is_failed);\r\n    _;\r\n    require(job_id_controller().mark_job_id_as_used(_job_id));\r\n  }\r\n\r\n\r\n  /////////////////////////////////////////////////     newOrder\r\n\r\n  /// The internal function that will actually call the controller\r\n  function processNewOrder(address _caller, uint256 _product_id, address _mint_target, bytes32 _custodian)\r\n           internal\r\n           returns (bytes32 _item)\r\n  {\r\n    bool _success;\r\n    (_success, _item) = assets_controller().put_init_item(_caller, _product_id, _mint_target);\r\n    assets_controller_electron().put_asset_custodian(_caller, _item, _custodian);\r\n    require(_success);\r\n    NewOrder(_product_id, _item, _mint_target, _custodian);\r\n  }\r\n\r\n  /// @dev vendor orders in bulk\r\n  /// @param _product_ids the IDs of products that have been provided by vendor\r\n  /// @param _mint_targets addresses at which the DGX tokens will be minted after accepting this order in future\r\n  /// @param _job_id the Job ID of the bulk operation (must not be used before, or marked as failed)\r\n  /// @return {\r\n  ///   \"_success\": \"true if all the new order operations went successfully, throws if any one failed\",\r\n  ///   \"_items\": \"the asset items that were created on processing the new orders\"\r\n  /// }\r\n  function bulkNewOrder(uint256[] _product_ids, address[] _mint_targets, bytes32[] _custodians, bytes32 _job_id)\r\n           check_and_update_job_id(_job_id)\r\n           public\r\n           returns (bool _success, bytes32[] _items)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _product_ids.length;\r\n    _items = new bytes32[](_length);\r\n    for (uint256 i=0;i<_length;i++) {\r\n      _items[i] = processNewOrder(_caller, _product_ids[i], _mint_targets[i], _custodians[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n\r\n  /////////////////////////////////////////////////     newTransferOrder\r\n\r\n  /// The main function that will actually call the controller\r\n  function processNewTransferOrder(address _caller, uint256 _product_id, address _mint_target)\r\n           internal\r\n           returns (bytes32 _item)\r\n  {\r\n    bool _success;\r\n    (_success, _item) = assets_controller().put_init_item_transfer(_caller, _product_id, _mint_target);\r\n    require(_success);\r\n    NewTransferOrder(_product_id, _item, _mint_target);\r\n  }\r\n\r\n  /// @dev put new transfer orders in bulk\r\n  /// @param _product_ids IDs of products\r\n  /// @param _mint_targets Ethereum addresses at which tokens will be minted on processing transfer orders\r\n  /// @param _job_id job ID of this bulk operation (must not be used before, or marked as failed)\r\n  /// @return {\r\n  ///   \"_success\": \"true if all the transfer orders were processed successfully, throws if any one failed\",\r\n  ///   \"_items\": \"the asset items that were created on the transfer orders\"\r\n  /// }\r\n  function bulkNewTransferOrder(uint256[] _product_ids, address[] _mint_targets, bytes32 _job_id)\r\n           check_and_update_job_id(_job_id)\r\n           public\r\n           returns (bool _success, bytes32[] _items)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _product_ids.length;\r\n    _items = new bytes32[](_length);\r\n    for (uint256 i=0;i<_length;i++) {\r\n      _items[i] = processNewTransferOrder(_caller, _product_ids[i], _mint_targets[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n\r\n  /////////////////////////////////////////////////     fulfillOrder\r\n\r\n  /// The main function that will actually call the controller\r\n  function processFulfillOrder(address _caller, bytes32 _item, bytes32 _serial, bytes32 _document)\r\n           internal\r\n  {\r\n    bool _success;\r\n    (_success,,) = assets_controller().patch_item_fulfill_order(_caller, _item, _serial, _document);\r\n    require(_success);\r\n    OrderFulfillment(_item, _serial, _document);\r\n  }\r\n\r\n  /// @dev fulfull orders of asset items in bulk\r\n  /// @param _items asset items whose order is to be fulfilled\r\n  /// @param _serials serials of these asset items\r\n  /// @param _documents IPFS hashes of the information regarding order fulfillment of asset items\r\n  /// @return _success true if all fulfill orders were successful, throw is any one failed\r\n  function bulkFulfillOrder(bytes32[] _items, bytes32[] _serials, bytes32[] _documents)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _items.length;\r\n    for (uint256 i=0;i<_length;i++) {\r\n      processFulfillOrder(_caller, _items[i], _serials[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     acceptDelivery\r\n\r\n  /// The main function that will actually call the controller\r\n  function processAcceptDelivery(address _caller, bytes32 _item, bytes32 _document)\r\n           internal\r\n           returns (address _mint_target, uint256 _effective_ng_weight)\r\n  {\r\n    bool _success;\r\n    (_success, _mint_target, _effective_ng_weight,,) = assets_controller().patch_item_mint(_caller, _item, _document);\r\n    require(_success);\r\n    MintToken(_item, _document);\r\n  }\r\n\r\n  /// @dev accept delivery of asset item in bulk\r\n  /// @param _items asset items delivered\r\n  /// @param _documents IPFS hashes of the information regarding those asset items\r\n  /// @return {\r\n  ///   \"_success\": \"true if all the delivery processes were successful, throws if any one failed\",\r\n  ///   \"_mint_targets\": \"the ethereum addresses to which the equivalent DGX tokens were minted to, on accepting the delivery of these asset items\",\r\n  ///   \"_effective_ng_weights\": \"the effective weights in nanograms of the accepted asset items, or the number of DGX tokens that were minted for each asset item\"\r\n  /// }\r\n  function bulkAcceptDelivery(bytes32[] _items, bytes32[] _documents)\r\n           public\r\n           returns (bool _success, address[] _mint_targets, uint256[] _effective_ng_weights)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _items.length;\r\n    _mint_targets = new address[](_length);\r\n    _effective_ng_weights = new uint256[](_length);\r\n    for (uint256 i=0;i<_length;i++) {\r\n      (_mint_targets[i], _effective_ng_weights[i]) = processAcceptDelivery(_caller, _items[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     redeemAsset\r\n\r\n  /// The main function that will actually call the controller\r\n  function processRedeemAsset(address _caller, bytes32 _item, address _redeem_user, bytes32 _document)\r\n           internal\r\n  {\r\n    bool _success;\r\n    _success = assets_controller().patch_item_redeem(_caller, _item, _redeem_user, _document);\r\n    require(_success);\r\n    AssetRedemption(_item, _document);\r\n  }\r\n\r\n  /// @dev redeem asset items in bulk\r\n  /// @param _items asset items to be redeemed by user\r\n  /// @param _users addresses of users who are redeeming those assets\r\n  /// @param _documents IPFS hashes of the information in redeeming every item\r\n  /// @return _success true if all the redeem processes done successfully, throws if any one failed\r\n  function bulkRedeemAsset(bytes32[] _items, address[] _users, bytes32[] _documents)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _items.length;\r\n    for (uint256 i=0;i<_length;i++) {\r\n      processRedeemAsset(_caller, _items[i], _users[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     newReplacementOrder\r\n\r\n  /// The main function that will actually call the controller\r\n  /// @notice called by a popadmin to order a replacement for an item that has failed audit\r\n  function processNewReplacementOrder(address _caller, bytes32 _failed_item, uint256 _replacement_product_id)\r\n           internal\r\n           returns (bytes32 _replacement_item)\r\n  {\r\n    bool _success;\r\n    (_success, _replacement_item) = assets_controller().put_init_item_as_replacement(_caller, _replacement_product_id, _failed_item);\r\n    require(_success);\r\n    NewReplacementOrder(_replacement_product_id, _failed_item);\r\n  }\r\n\r\n  /// @dev put new replacement orders in bulk\r\n  /// @param _failed_items asset items that have audit failed, that need to be replaced\r\n  /// @param _product_ids IDs of products that will replace these failed items\r\n  /// @param _job_id job ID of this bulk job (must not be re-used or marked as failed)\r\n  /// @return {\r\n  ///   \"_success\": \"true if all the replacement orders were saved successfully\",\r\n  ///   \"_replacement_items\": \"asset items that will be replacing the failed items\"\r\n  /// }\r\n  function bulkNewReplacementOrder(bytes32[] _failed_items, uint256[] _product_ids, bytes32 _job_id)\r\n           check_and_update_job_id(_job_id)\r\n           public\r\n           returns (bool _success, bytes32[] _replacement_items)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _failed_items.length;\r\n    _replacement_items = new bytes32[](_length);\r\n    for (uint256 i=0;i<_length;i++) {\r\n      _replacement_items[i] = processNewReplacementOrder(_caller, _failed_items[i], _product_ids[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     fulfillReplacementOrder\r\n\r\n  /// The main function that will actually call the controller\r\n  /// @notice called by a vendor to fulfill a replacement order\r\n  function processFulfillReplacementOrder(address _caller, bytes32 _item, bytes32 _serial, bytes32 _document)\r\n           internal\r\n  {\r\n    bool _success;\r\n    _success = assets_controller().patch_item_fulfill_replacement_order(_caller, _item, _serial, _document);\r\n    require(_success);\r\n    OrderFulfillment(_item, _serial, _document);\r\n  }\r\n\r\n  /// @dev fulfill the replacement orders for asset items in bulk\r\n  /// @param _items asset items to be replaced\r\n  /// @param _serials serial IDs of the asset items\r\n  /// @param _documents IPFS hashes of the information for each fulfill replacement order\r\n  /// @return _success true if every replacement order fulfilled successfully, throws if any one failed\r\n  function bulkFulfillReplacementOrder(bytes32[] _items, bytes32[] _serials, bytes32[] _documents)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _items.length;\r\n    for (uint256 i=0;i<_length;i++) {\r\n      processFulfillReplacementOrder(_caller, _items[i], _serials[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     acceptReplacementDelivery\r\n\r\n  /// The main function that will actually call the controller\r\n  /// @notice called by a custodian to accept delivery of a replacement item\r\n  function processAcceptReplacementDelivery(address _caller, bytes32 _item, bytes32 _document)\r\n           internal\r\n           returns (uint256 _effective_ng_weight)\r\n  {\r\n    bool _success;\r\n    (_success, _effective_ng_weight) = assets_controller().patch_item_mint_replacement(_caller, _item, _document);\r\n    require(_success);\r\n    MintToken(_item, _document);\r\n  }\r\n\r\n  /// @dev mark replacement asset items as accepted\r\n  /// @param _items asset items to be marked accepted for replacement delivery. These are the items that are replacing other failed assets\r\n  /// @param _documents IPFS hashes of the information uploaded regarding this accepted replacement for other items\r\n  /// @return {\r\n  ///   \"_success\": \"true if the bulk operation of acception the replacement items was successful, throws if any one operation failed\",\r\n  ///   \"_effective_ng_weights\": \"effective nanogram weights of the gold, or the number of DGX tokens in these replacement asset items\"\r\n  /// }\r\n  function bulkAcceptReplacementDelivery(bytes32[] _items, bytes32[] _documents)\r\n           public\r\n           returns (bool _success, uint256[] _effective_ng_weights)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _items.length;\r\n    _effective_ng_weights = new uint256[](_length);\r\n    for (uint256 i=0;i<_length;i++) {\r\n      _effective_ng_weights[i] = processAcceptReplacementDelivery(_caller, _items[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     reportAuditFailure\r\n\r\n  /// The main function that will actually call the controller\r\n  /// @notice called by an auditor to report that an asset item has failed audit\r\n  function processReportAuditFailure(address _caller, bytes32 _item, bytes32 _document)\r\n           internal\r\n  {\r\n    bool _success;\r\n    (_success,,) = assets_controller().patch_item_to_audit_failure(_caller, _item, _document);\r\n    require(_success);\r\n    AuditFailure(_item, _document);\r\n  }\r\n\r\n  /// @dev set audit failure for asset items in bulk\r\n  /// @param _items asset items to be market audit failure\r\n  /// @param _documents IPFS hashes of the information while audit failure of these items\r\n  /// @return _success true if all items successfully market audit failure, throws if any one item failed\r\n  function bulkReportAuditFailure(bytes32[] _items, bytes32[] _documents)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _items.length;\r\n    for (uint256 i=0;i<_length;i++) {\r\n      processReportAuditFailure(_caller, _items[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     adminFail\r\n\r\n  /// The main function that will actually call the controller\r\n  /// @notice called by a popadmin to fail an asset that has not been minted\r\n  function processAdminFail(address _caller, bytes32 _item, bytes32 _document)\r\n           internal\r\n  {\r\n    bool _success;\r\n    _success = assets_controller().patch_item_admin_fail(_caller, _item, _document);\r\n    require(_success);\r\n    AdminFailure(_item, _document);\r\n  }\r\n\r\n  /// @dev fail multiple asset items in bulk\r\n  /// @param _items asset items to be marked as failed\r\n  /// @param _documents the IPFS hashes of the information linked to failing of these asset items\r\n  /// @return _success true if all asset items were failed successfully, throws if any one of them could not be failed\r\n  function bulkAdminFail(bytes32[] _items, bytes32[] _documents)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _items.length;\r\n    for (uint256 i=0;i<_length;i++) {\r\n      processAdminFail(_caller, _items[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     remint\r\n\r\n  /// The main function that will actually call the controller\r\n  /// @notice called by a popadmin to fail an asset that has not been minted\r\n  function processRemint(address _caller, bytes32 _item, bytes32 _document)\r\n           internal\r\n  {\r\n    bool _success;\r\n    require(assets_recast_controller_electron().is_remint_item_blocked(_item) == false);\r\n    _success = assets_controller().patch_item_remint(_caller, _item, _document);\r\n    require(_success);\r\n    MintToken(_item, _document);\r\n  }\r\n\r\n  /// @dev remint assets that were not redeemed in time, or are reminted by the recaster\r\n  /// @param _items asset items to be reminted\r\n  /// @param _documents IPFS hashes of the information linked to reminting assets\r\n  /// @return _success true if all assets were reminted successfully, throws if any one of them failed\r\n  function bulkRemint(bytes32[] _items, bytes32[] _documents)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    address _caller = msg.sender;\r\n    uint256 _length = _items.length;\r\n    for (uint256 i=0;i<_length;i++) {\r\n      processRemint(_caller, _items[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     recast\r\n  function processRecastAsset(\r\n    address _caller,\r\n    bytes32 _item,\r\n    bytes32 _document\r\n  )\r\n    internal\r\n    returns (uint256 _effective_ng_weight)\r\n  {\r\n    bool _success;\r\n    (_success, _effective_ng_weight) = assets_recast_controller_electron().patch_item_recast(\r\n      _caller, _item, _document\r\n    );\r\n    require(_success);\r\n    AssetRecast(_item, _caller, _document);\r\n  }\r\n\r\n  /// @dev recast assets in bulk\r\n  /// @param _items the asset items to be recasted\r\n  /// @param _documents the IPFS hashes of the information that is linked to recasting these asset items\r\n  /// @return {\r\n  ///   \"_success\": \"true if all the recasts were done successfully. throws if any one was not successful\",\r\n  ///   \"_effective_ng_weight\": \"the total effecive weights of the items that were recasted\"\r\n  /// }\r\n  function bulkRecastAsset(\r\n    bytes32[] _items,\r\n    bytes32[] _documents,\r\n    uint256 _kyc_tier,\r\n    uint256 _kyc_expiry,\r\n    uint256 _block_number,\r\n    address _signer,\r\n    bytes _signature\r\n  )\r\n    public\r\n    returns (bool _success, uint256[] _effective_ng_weights)\r\n  {\r\n    address _caller = msg.sender;\r\n\r\n    require(assets_recast_controller_electron().check_user_kyc(\r\n      _caller, _kyc_tier, _kyc_expiry, _block_number, _signer, _signature\r\n    ));\r\n\r\n    uint256 _length = _items.length;\r\n    _effective_ng_weights = new uint256[](_length);\r\n    for (uint256 i=0;i<_length;i++) {\r\n      _effective_ng_weights[i] = processRecastAsset(_caller, _items[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  /////////////////////////////////////////////////     append documents\r\n  function processAppendNewDocument(address _caller, bytes32 _item, bytes32 _document)\r\n           internal\r\n  {\r\n    require(assets_controller().patch_item_add_document(_caller, _item, _document));\r\n  }\r\n\r\n  /// TODO\r\n  /// @dev append new documents for asset items with jobID\r\n  /// @param _items assets items for which documents have to be added\r\n  /// @param _documents the IPFS hashes of the informations\r\n  /// @param _job_id jobID for this task (should not be already used, or marked as fail)\r\n  /// @return _success true if documents were appended successfully\r\n  function bulkAppendNewDocument(bytes32[] _items, bytes32[] _documents, bytes32 _job_id)\r\n           check_and_update_job_id(_job_id)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    uint256 _length = _items.length;\r\n    for (uint256 i=0;i<_length;i++) {\r\n      processAppendNewDocument(msg.sender, _items[i], _documents[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  ////////////////////////////////////////////////// other functions\r\n\r\n  /// TODO\r\n  /// @dev add document for global audit\r\n  /// @param _document the IPFS hash of the information that is to be uploaded\r\n  /// @return _success true if audit doc was added successfully, throw otherwise\r\n  function addGlobalAudit(bytes32 _document, bytes32 _custodian, uint256 _timestamp)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    address _caller = msg.sender;\r\n    _success = assets_controller().put_global_audit(_caller, _document);\r\n    assets_controller_electron().put_audit_custodian(_caller, _document, _custodian, _timestamp);\r\n  }\r\n\r\n  /// @dev update the redeem period of any recasted asset\r\n  /// @param _redeem_period the new redeem period\r\n  /// @return _success true if updated successfully, throw otherwise\r\n  function updateRedeemPeriod(uint256 _redeem_period)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    address _caller = msg.sender;\r\n    _success = assets_controller().change_redeem_period(_caller, _redeem_period);\r\n  }\r\n\r\n  /// @dev check the status of job IDs, whether they are already used or marked as failed\r\n  /// @param _job_ids job IDs, whose status to be checked\r\n  /// @return {\r\n  ///   \"_used\": \"array of booleans, true if that job ID at that index is used, false otherwise\",\r\n  ///   \"_failed\": \"array of booleans, true if job ID at that index is marked as fail, otherwise false\"\r\n  /// }\r\n  function bulkCheckJobIds(bytes32[] _job_ids)\r\n           public\r\n           constant\r\n           returns (bool[] _used, bool[] _failed)\r\n  {\r\n    uint256 _length = _job_ids.length;\r\n    _used = new bool[](_length);\r\n    _failed = new bool[](_length);\r\n\r\n    for (uint256 i=0;i<_length;i++) {\r\n      _used[i] = job_id_storage().read_if_job_id_is_used(_job_ids[i]);\r\n      _failed[i] = job_id_storage().read_if_job_id_is_failed(_job_ids[i]);\r\n    }\r\n  }\r\n\r\n  function failJobId(bytes32 _job_id)\r\n           internal\r\n  {\r\n    require(job_id_controller().mark_job_id_as_failed(msg.sender, _job_id));\r\n  }\r\n\r\n  /// @dev mark these job IDs as failed in bulk\r\n  /// @param _job_ids the job IDs to be marked as failed\r\n  /// @return _success true if job IDs were marked as fail successfully\r\n  function bulkFailJobId(bytes32[] _job_ids)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    uint256 _length = _job_ids.length;\r\n    for (uint256 i=0;i<_length;i++) {\r\n      failJobId(_job_ids[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function processAddCustodian(address _caller, bytes32 _custodian)\r\n    internal\r\n  {\r\n    assets_controller_electron().put_custodian(_caller, _custodian);\r\n  }\r\n\r\n  function bulkAddCustodian(bytes32[] _custodians)\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    uint256 _length = _custodians.length;\r\n    for (uint256 i=0;i<_length;i++) {\r\n      processAddCustodian(msg.sender, _custodians[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function bulkAddAssetCustodian(bytes32[] _items, bytes32 _custodian)\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    uint256 _length = _items.length;\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      assets_controller_electron().put_asset_custodian(msg.sender, _items[i], _custodian);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function bulkAddAuditCustodian(bytes32[] _docs, uint256[] _timestamps, bytes32 _custodian)\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    uint256 _length = _docs.length;\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      assets_controller_electron().put_audit_custodian(msg.sender, _docs[i], _custodian, _timestamps[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function bulkUpdateAssetCustodian(bytes32[] _items, bytes32 _custodian)\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    require(assets_storage_electron().is_valid_custodian(_custodian));\r\n    uint256 _length = _items.length;\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      assets_controller_electron().update_asset_custodian(msg.sender, _items[i], _custodian);\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function bulkBlockAssetRemint(bytes32[] _items)\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    uint256 _length = _items.length;\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      assets_recast_controller_electron().set_remint_item_blocked(msg.sender, _items[i]);\r\n    }\r\n    _success = true;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_failed_items\",\"type\":\"bytes32[]\"},{\"name\":\"_product_ids\",\"type\":\"uint256[]\"},{\"name\":\"_job_id\",\"type\":\"bytes32\"}],\"name\":\"bulkNewReplacementOrder\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_replacement_items\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"name\":\"bulkAcceptDelivery\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_mint_targets\",\"type\":\"address[]\"},{\"name\":\"_effective_ng_weights\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_serials\",\"type\":\"bytes32[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"name\":\"bulkFulfillReplacementOrder\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"key\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"get_contract\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"name\":\"bulkAdminFail\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_product_ids\",\"type\":\"uint256[]\"},{\"name\":\"_mint_targets\",\"type\":\"address[]\"},{\"name\":\"_job_id\",\"type\":\"bytes32\"}],\"name\":\"bulkNewTransferOrder\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_items\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"name\":\"bulkAcceptReplacementDelivery\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_effective_ng_weights\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_document\",\"type\":\"bytes32\"},{\"name\":\"_custodian\",\"type\":\"bytes32\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"addGlobalAudit\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_custodian\",\"type\":\"bytes32\"}],\"name\":\"bulkUpdateAssetCustodian\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_custodian\",\"type\":\"bytes32\"}],\"name\":\"bulkAddAssetCustodian\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_serials\",\"type\":\"bytes32[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"name\":\"bulkFulfillOrder\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"}],\"name\":\"bulkBlockAssetRemint\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_product_ids\",\"type\":\"uint256[]\"},{\"name\":\"_mint_targets\",\"type\":\"address[]\"},{\"name\":\"_custodians\",\"type\":\"bytes32[]\"},{\"name\":\"_job_id\",\"type\":\"bytes32\"}],\"name\":\"bulkNewOrder\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_items\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"},{\"name\":\"_job_id\",\"type\":\"bytes32\"}],\"name\":\"bulkAppendNewDocument\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_custodians\",\"type\":\"bytes32[]\"}],\"name\":\"bulkAddCustodian\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"},{\"name\":\"_kyc_tier\",\"type\":\"uint256\"},{\"name\":\"_kyc_expiry\",\"type\":\"uint256\"},{\"name\":\"_block_number\",\"type\":\"uint256\"},{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"bulkRecastAsset\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_effective_ng_weights\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_job_ids\",\"type\":\"bytes32[]\"}],\"name\":\"bulkFailJobId\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"name\":\"bulkRemint\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_job_ids\",\"type\":\"bytes32[]\"}],\"name\":\"bulkCheckJobIds\",\"outputs\":[{\"name\":\"_used\",\"type\":\"bool[]\"},{\"name\":\"_failed\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_redeem_period\",\"type\":\"uint256\"}],\"name\":\"updateRedeemPeriod\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"name\":\"bulkReportAuditFailure\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_docs\",\"type\":\"bytes32[]\"},{\"name\":\"_timestamps\",\"type\":\"uint256[]\"},{\"name\":\"_custodian\",\"type\":\"bytes32\"}],\"name\":\"bulkAddAuditCustodian\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"},{\"name\":\"_users\",\"type\":\"address[]\"},{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"name\":\"bulkRedeemAsset\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_product_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_item\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_mint_target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_custodian\",\"type\":\"bytes32\"}],\"name\":\"NewOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_product_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_item\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_mint_target\",\"type\":\"address\"}],\"name\":\"NewTransferOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_product_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_item\",\"type\":\"bytes32\"}],\"name\":\"NewReplacementOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_item\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_serial\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_document\",\"type\":\"bytes32\"}],\"name\":\"OrderFulfillment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_item\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_document\",\"type\":\"bytes32\"}],\"name\":\"MintToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_item\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_document\",\"type\":\"bytes32\"}],\"name\":\"AuditFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_item\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_document\",\"type\":\"bytes32\"}],\"name\":\"AdminFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_item\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_document\",\"type\":\"bytes32\"}],\"name\":\"AssetRedemption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_item\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_recast_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_document\",\"type\":\"bytes32\"}],\"name\":\"AssetRecast\",\"type\":\"event\"}]","ContractName":"PoPAdminElectron","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000db2ddb220b8a55e0e4412130e6ae74d136c04ba2","Library":"","LicenseType":"BSD-3-Clause","SwarmSource":"bzzr://e34909ce7df25e0dc1135eb888c63b138e9a33c815948bf5a0e3b72169a8cd9b"}]}