{"status":"1","message":"OK","result":[{"SourceCode":"/*******\r\n*\r\n*\r\n*\r\n*   ███████╗████████╗██╗░░██╗███████╗██████╗░  ███╗░░░███╗░█████╗░░██████╗░██╗░█████╗░\r\n*   ██╔════╝╚══██╔══╝██║░░██║██╔════╝██╔══██╗  ████╗░████║██╔══██╗██╔════╝░██║██╔══██╗\r\n*   ████╗░░░░░░██║░░░███████║█████╗░░██████╔╝  ██╔████╔██║███████║██║░░██╗░██║██║░░╚═╝\r\n*   ██╔══╝░░░░░██║░░░██╔══██║██╔══╝░░██╔══██╗  ██║╚██╔╝██║██╔══██║██║░░╚██╗██║██║░░██╗\r\n*   ███████╗░░░██║░░░██║░░██║███████╗██║░░██║  ██║░╚═╝░██║██║░░██║╚██████╔╝██║╚█████╔╝\r\n*   ╚══════╝░░░╚═╝░░░╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝  ╚═╝░░░░░╚═╝╚═╝░░╚═╝░╚═════╝░╚═╝░╚════╝░\r\n*\r\n*   Created with love ♥\r\n*\r\n********/\r\n\r\npragma solidity ^0.4.26;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary DataStructs {\r\n\r\n        struct DailyRound {\r\n            uint256 startTime;\r\n            uint256 endTime;\r\n            address player; //address of the player with highest referrals\r\n            uint256 referralCount; //Number of referrals\r\n            bool ended; //has daily round ended\r\n            uint256 pool; //amount in the pool;\r\n        }\r\n\r\n        struct Player {\r\n            uint256 totalInvestment;\r\n            uint256 referralIncome;\r\n            uint256 cycle;\r\n            uint256 dailyIncome;\r\n            uint256 poolIncome;\r\n            uint256 lastSettledTime;\r\n            uint256 incomeLimit;\r\n            uint256 incomeLimitLeft;\r\n            uint256 referralCount;\r\n            address referrer;\r\n        }\r\n\r\n        struct PlayerDailyRounds {\r\n            uint256 referrers; // total referrals user has in a particular round\r\n    }\r\n}\r\n\r\ncontract EtherMagic {\r\n    using SafeMath for *;\r\n\r\n    address public owner;\r\n    address public roundStarter;\r\n    uint256 houseFee = 3;\r\n    uint256 poolTime = 24 hours;\r\n    uint256 payoutPeriod = 24 hours;\r\n    uint256 dailyWinPool = 5;\r\n    uint256 incomeTimes = 20;\r\n    uint256 incomeDivide = 10;\r\n    uint256 public roundID;\r\n    uint256 public r1 = 0;\r\n    uint256 public r2 = 0;\r\n        \r\n\r\n    mapping (uint => uint) public CYCLE_PRICE;\r\n    mapping (address => bool) public playerExist;\r\n    mapping (uint256 => DataStructs.DailyRound) public round;\r\n    mapping (address => DataStructs.Player) public player;\r\n    mapping (address => mapping (uint256 => DataStructs.PlayerDailyRounds)) public plyrRnds_; \r\n\r\n    /****************************  EVENTS   *****************************************/\r\n\r\n    event registerUserEvent(address indexed _playerAddress, address indexed _referrer);\r\n    event upgradeLevelEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event referralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 timeStamp);\r\n    event missedDirectreferralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256  timeStamp);\r\n    event dailyPayoutEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event withdrawEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event roundEndEvent(address indexed _highestReferrer, uint256 indexed _referrals, uint256 indexed endTime, uint256 poolAmount);\r\n    event ownershipTransferred(address indexed owner, address indexed newOwner);\r\n\r\n\r\n    constructor (address _roundStarter) public {\r\n         owner = msg.sender;\r\n         roundStarter = _roundStarter;\r\n         roundID = 1;\r\n         round[1].startTime = now;\r\n         round[1].endTime = now + poolTime;\r\n\r\n         CYCLE_PRICE[1] = 0.25 ether;\r\n         CYCLE_PRICE[2] = 0.5 ether;\r\n         CYCLE_PRICE[3] = 1 ether;\r\n         CYCLE_PRICE[4] = 2 ether;\r\n         CYCLE_PRICE[5] = 3 ether;\r\n         \r\n    }\r\n    \r\n    /****************************  MODIFIERS    *****************************************/\r\n    \r\n    \r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth <= 3000000000000000000, \"Maximum contribution amount is 3 ETH\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev allows only the user to run the function\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only Owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    /****************************  CORE LOGIC    *****************************************/\r\n\r\n\r\n    //if someone accidently sends eth to contract address\r\n    function () external payable {\r\n        playGame(address(0x0));\r\n    }\r\n\r\n\r\n\r\n    //function to maintain the business logic \r\n    function playGame(address _referrer) \r\n    public\r\n    isWithinLimits(msg.value)\r\n    payable {\r\n\r\n        uint256 amount = msg.value;\r\n        if (playerExist[msg.sender] == false) { //if player is a new joinee\r\n\r\n            require(amount == CYCLE_PRICE[1], \"joining fees should be 0.25 ether\");\r\n\r\n            player[msg.sender].lastSettledTime = now;\r\n            player[msg.sender].incomeLimit = amount.mul(incomeTimes).div(incomeDivide);\r\n            player[msg.sender].incomeLimitLeft = player[msg.sender].incomeLimit;\r\n            player[msg.sender].totalInvestment = amount;\r\n            player[msg.sender].cycle = 1;\r\n            playerExist[msg.sender] = true;\r\n\r\n            if(\r\n                // is this a referred purchase?\r\n                _referrer != address(0x0) && \r\n                \r\n                //self referrer not allowed\r\n                _referrer != msg.sender &&\r\n                \r\n                //referrer exists?\r\n                playerExist[_referrer] == true\r\n              ) {\r\n                    player[msg.sender].referrer = _referrer;\r\n                    player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                    plyrRnds_[_referrer][roundID].referrers = plyrRnds_[_referrer][roundID].referrers.add(1);\r\n                \r\n                    if(plyrRnds_[_referrer][roundID].referrers > round[roundID].referralCount) {\r\n                        round[roundID].player = _referrer;\r\n                        round[roundID].referralCount = plyrRnds_[_referrer][roundID].referrers;\r\n                    }\r\n                    referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n              }\r\n              else {\r\n                  r1 = r1.add(amount.mul(20).div(100));\r\n              }\r\n              emit registerUserEvent(msg.sender, _referrer);\r\n                \r\n            }\r\n            \r\n            //if the player has already joined earlier\r\n            else {\r\n                \r\n                uint _cycle;\r\n                require(player[msg.sender].incomeLimitLeft == 0, \"Oops your limit is still remaining\");\r\n                \r\n                _cycle = player[msg.sender].cycle;\r\n                \r\n                //user remains in the same cycle\r\n                if(amount == CYCLE_PRICE[_cycle]) {\r\n                    \r\n                    player[msg.sender].lastSettledTime = now;\r\n                    player[msg.sender].incomeLimit = amount.mul(incomeTimes).div(incomeDivide);\r\n                    player[msg.sender].incomeLimitLeft = player[msg.sender].incomeLimit;\r\n                    player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\r\n                    \r\n                    \r\n                    if(\r\n                        // is this a referred purchase?\r\n                        _referrer != address(0x0) && \r\n                        \r\n                        // self referrer not allowed\r\n                        _referrer != msg.sender &&\r\n                        \r\n                        //does the referrer exist?\r\n                        playerExist[_referrer] == true\r\n                      )\r\n                      {\r\n                            //if the user has already been referred by someone previously, can't be referred by someone else\r\n                            if(player[msg.sender].referrer != address(0x0))\r\n                                _referrer = player[msg.sender].referrer;\r\n                                \r\n                            else {\r\n                                player[msg.sender].referrer = _referrer;\r\n                                player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                                plyrRnds_[_referrer][roundID].referrers = plyrRnds_[_referrer][roundID].referrers.add(1);\r\n                                \r\n                                if(plyrRnds_[_referrer][roundID].referrers > round[roundID].referralCount) {\r\n                                    round[roundID].player = _referrer;\r\n                                    round[roundID].referralCount = plyrRnds_[_referrer][roundID].referrers;\r\n                                }\r\n                            }\r\n                            \r\n                            //assign the referral commission to all.\r\n                            referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n                    }\r\n                    //might be possible that the referrer is 0x0 but previously someone has referred the user                    \r\n                    else if(\r\n                            //0x0 coming from the UI\r\n                            _referrer == address(0x0) &&\r\n                            \r\n                            //check if the someone has previously referred the user\r\n                            player[msg.sender].referrer != address(0x0)\r\n                        ) {\r\n                             _referrer = player[msg.sender].referrer;\r\n                             \r\n                             //assign the referral commission to all.\r\n                             referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n                          }\r\n                    else {\r\n                          //no referrer, neither was previously used, nor has used now.\r\n                          r1 = r1.add(amount.mul(20).div(100));\r\n                    }\r\n                }\r\n                \r\n                //user has upgraded his cycle\r\n                else if (amount == CYCLE_PRICE[_cycle + 1]) {\r\n                    \r\n                    player[msg.sender].lastSettledTime = now;\r\n                    player[msg.sender].incomeLimit = amount.mul(incomeTimes).div(incomeDivide);\r\n                    player[msg.sender].incomeLimitLeft = player[msg.sender].incomeLimit;\r\n                    player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\r\n                    player[msg.sender].cycle = _cycle + 1;\r\n                    \r\n                    \r\n                    if(\r\n                        // is this a referred purchase?\r\n                        _referrer != address(0x0) && \r\n                        \r\n                        // self referrer not allowed\r\n                        _referrer != msg.sender &&\r\n                        \r\n                        //does the referrer exist?\r\n                        playerExist[_referrer] == true\r\n                      ) \r\n                      {\r\n                            //if the user has already been referred by someone previously, can't be referred by someone else\r\n                            if(player[msg.sender].referrer != address(0x0))\r\n                                _referrer = player[msg.sender].referrer;\r\n                                \r\n                            else {\r\n                                player[msg.sender].referrer = _referrer;\r\n                                player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                                plyrRnds_[_referrer][roundID].referrers = plyrRnds_[_referrer][roundID].referrers.add(1);\r\n                                \r\n                                if(plyrRnds_[_referrer][roundID].referrers > round[roundID].referralCount) {\r\n                                    round[roundID].player = _referrer;\r\n                                    round[roundID].referralCount = plyrRnds_[_referrer][roundID].referrers;\r\n                                }\r\n                            }\r\n                            \r\n                            //assign the referral commission to all.\r\n                            referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n                    }\r\n                    //might be possible that the referrer is 0x0 but previously someone has referred the user\r\n                    \r\n                    else if(\r\n                            //0x0 coming from the UI\r\n                            _referrer == address(0x0) &&\r\n                            \r\n                            //check if the someone has previously referred the user\r\n                            player[msg.sender].referrer != address(0x0)\r\n                        ) {\r\n                             _referrer = player[msg.sender].referrer;\r\n                             \r\n                             //assign the referral commission to all.\r\n                             referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n                          }\r\n                    else {\r\n                          //no referrer, neither was previously used, nor has used now.\r\n                          r1 = r1.add(amount.mul(20).div(100));\r\n                    }\r\n                }            \r\n                //any other amount will be reverted\r\n                else {\r\n                    revert(\"Please send the correct amount\"); // cannot send any other value\r\n                }\r\n                \r\n               emit upgradeLevelEvent(msg.sender, amount);\r\n            }\r\n            \r\n            round[roundID].pool = round[roundID].pool.add(amount.mul(dailyWinPool).div(100));\r\n            player[owner].dailyIncome = player[owner].dailyIncome.add(amount.mul(houseFee).div(100));\r\n            \r\n    }\r\n\r\n\r\n    //function to manage the 20% direct referral commission\r\n    function referralBonusTransferDirect(address _playerAddress, uint256 amount)\r\n    internal\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint i;\r\n\r\n        for(i=0; i < 10; i++) {\r\n            \r\n            if (_nextReferrer != address(0x0)) {                  \r\n                if (player[_nextReferrer].incomeLimitLeft >= amount.div(10)) {\r\n                    player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(10));\r\n                    player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(amount.div(10));\r\n                    //This event will be used to get the total referral commission of a person, no need for extra variable\r\n                    emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(10), now);\r\n                    \r\n                } else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                    player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                    r1 = r1.add(amount.div(10).sub(player[_nextReferrer].incomeLimitLeft));\r\n                    emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                    player[_nextReferrer].incomeLimitLeft = 0;\r\n                    \r\n                }\r\n                else  {\r\n                    r1 = r1.add(amount.div(10)); //make a note of the missed commission;\r\n                    emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, amount.div(10), now);\r\n                    //can also fire event here to mark the missed commission.\r\n                }\r\n            }\r\n            else {\r\n                r1 = r1.add((uint(10).sub(i)).mul(amount.div(10))); //Adding the missed commission, if any\r\n                emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, (uint(10).sub(i)).mul(amount.div(10)), now);\r\n                break;\r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n    \r\n\r\n    //function to manage the referral commission from the daily ROI\r\n    function referralBonusTransferDailyROI(address _playerAddress, uint256 amount)\r\n    internal\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint i;\r\n\r\n        for(i=0; i < 10; i++) {\r\n            \r\n            if (_nextReferrer != address(0x0)) {\r\n                //to earn a particular level of commission player should have that many direct referrals\r\n                if(player[_nextReferrer].referralCount >= i+1) {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= amount.div(10)) {\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(10));\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(amount.div(10));\r\n                        //This event will be used to get the total referral commission of a person, no need for extra variable\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(10), now);\r\n                        \r\n                    } else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                        r2 = r2.add(amount.div(10).sub(player[_nextReferrer].incomeLimitLeft));\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n                        \r\n                    }\r\n                    else {\r\n                        r2 = r2.add(amount.div(10)); //make a note of the missed commission;\r\n                        emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, amount.div(10), now);\r\n                    }\r\n                }\r\n                else  {\r\n                    r2 = r2.add(amount.div(10)); //make a note of the missed commission;\r\n                    emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, amount.div(10), now);\r\n                }\r\n            }    \r\n            else {\r\n                r2 = r2.add((uint(10).sub(i)).mul(amount.div(10))); //Adding the missed commission, if any\r\n                emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, (uint(10).sub(i)).mul(amount.div(10)), now);\r\n                break;\r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n    \r\n\r\n    //method to settle the daily ROI\r\n    function settleIncome() \r\n    public {\r\n        \r\n        address _playerAddress = msg.sender;\r\n            \r\n        uint256 remainingTimeForPayout;\r\n        uint256 currInvestedAmount;\r\n            \r\n        if(now > player[_playerAddress].lastSettledTime + payoutPeriod) {\r\n            \r\n            //calculate how much time has passed since last settlement\r\n            uint256 extraTime = now.sub(player[_playerAddress].lastSettledTime);\r\n            uint256 _dailyIncome;\r\n            //calculate how many number of days, payout is remaining\r\n            remainingTimeForPayout = (extraTime.sub((extraTime % payoutPeriod))).div(payoutPeriod);\r\n            \r\n            currInvestedAmount = CYCLE_PRICE[player[_playerAddress].cycle];\r\n            //calculate 1% of his invested amount\r\n            _dailyIncome = currInvestedAmount.div(100);\r\n            //check his income limit remaining\r\n            if (player[_playerAddress].incomeLimitLeft >= _dailyIncome.mul(remainingTimeForPayout)) {\r\n                player[_playerAddress].incomeLimitLeft = player[_playerAddress].incomeLimitLeft.sub(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].lastSettledTime = player[_playerAddress].lastSettledTime.add((extraTime.sub((extraTime % payoutPeriod))));\r\n                emit dailyPayoutEvent( _playerAddress, _dailyIncome.mul(remainingTimeForPayout), now);\r\n                referralBonusTransferDailyROI(_playerAddress, _dailyIncome.mul(remainingTimeForPayout));\r\n            }\r\n            //if person income limit lesser than the daily ROI\r\n            else if(player[_playerAddress].incomeLimitLeft !=0) {\r\n                uint256 temp;\r\n                temp = player[_playerAddress].incomeLimitLeft;                 \r\n                player[_playerAddress].incomeLimitLeft = 0;\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(temp);\r\n                player[_playerAddress].lastSettledTime = now;\r\n                emit dailyPayoutEvent( _playerAddress, temp, now);\r\n                referralBonusTransferDailyROI(_playerAddress, temp);\r\n            }\r\n            \r\n        }\r\n    }\r\n    \r\n\r\n    //function to allow users to withdraw their earnings\r\n    function withdrawIncome() \r\n    public {\r\n        \r\n        address _playerAddress = msg.sender;\r\n        uint256 _earnings =\r\n                    player[_playerAddress].dailyIncome +\r\n                    player[_playerAddress].referralIncome +\r\n                    player[_playerAddress].poolIncome;\r\n\r\n        //can only withdraw if they have some earnings.         \r\n        if(_earnings > 0) {\r\n            require(address(this).balance >= _earnings, \"Contract doesn't have sufficient amount to give you\");\r\n            player[_playerAddress].dailyIncome = 0;\r\n            player[_playerAddress].referralIncome = 0;\r\n            player[_playerAddress].poolIncome = 0;\r\n            \r\n            address(_playerAddress).transfer(_earnings);\r\n            emit withdrawEvent(_playerAddress, _earnings, now);\r\n        }\r\n    }\r\n    \r\n    \r\n    //To start the new round for daily pool\r\n    function startNewRound()\r\n    public\r\n     {\r\n        require(msg.sender == roundStarter,\"Oops you can't start the next round\");\r\n    \r\n        uint256 _roundID = roundID;\r\n        address _highestReferrer;\r\n        uint256 _poolAmount;\r\n        uint256 _winningAmount;\r\n        \r\n        //check whether it's time to start the new roundID\r\n        if (now > round[_roundID].endTime && round[_roundID].ended == false)\r\n        {\r\n          round[_roundID].ended = true;\r\n          _highestReferrer = round[_roundID].player;\r\n          _poolAmount = round[_roundID].pool;\r\n          \r\n          if(_highestReferrer != address(0x0)) {\r\n              if(_poolAmount > 0) {\r\n                  _winningAmount = _poolAmount.mul(10).div(100); \r\n                  player[_highestReferrer].poolIncome = _winningAmount;\r\n              }\r\n          }\r\n          \r\n          emit roundEndEvent(_highestReferrer, round[_roundID].referralCount, now, _poolAmount);\r\n          \r\n          _roundID++;\r\n          roundID++;\r\n          round[_roundID].startTime = now;\r\n          round[_roundID].endTime = now.add(poolTime);\r\n          round[_roundID].pool = _poolAmount.sub(_winningAmount);\r\n        }\r\n    }\r\n\r\n    //function to fetch the remaining time for the next daily ROI payout\r\n    function getPlayerInfo(address _playerAddress) \r\n    public \r\n    view\r\n    returns(uint256) {\r\n            \r\n            uint256 remainingTimeForPayout;\r\n            if(playerExist[_playerAddress] == true) {\r\n            \r\n                if(player[_playerAddress].lastSettledTime + payoutPeriod >= now) {\r\n                    remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now);\r\n                }\r\n                else {\r\n                    uint256 temp = now.sub(player[_playerAddress].lastSettledTime);\r\n                    remainingTimeForPayout = payoutPeriod.sub((temp % payoutPeriod));\r\n                }\r\n                return remainingTimeForPayout;\r\n            }\r\n    }\r\n\r\n\r\n    function withdrawFees(uint256 _amount, address _receiver, uint256 _numberUI) public onlyOwner {\r\n\r\n        if(_numberUI == 1 && r1 >= _amount) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                    r1 = r1.sub(_amount);\r\n                    address(_receiver).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n        else if(_numberUI == 2 && r2 >= _amount) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                    r2 = r2.sub(_amount);\r\n                    address(_receiver).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n     /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit ownershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"playGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"referralCount\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"pool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"referrers\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"player\",\"outputs\":[{\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"name\":\"referralIncome\",\"type\":\"uint256\"},{\"name\":\"cycle\",\"type\":\"uint256\"},{\"name\":\"dailyIncome\",\"type\":\"uint256\"},{\"name\":\"poolIncome\",\"type\":\"uint256\"},{\"name\":\"lastSettledTime\",\"type\":\"uint256\"},{\"name\":\"incomeLimit\",\"type\":\"uint256\"},{\"name\":\"incomeLimitLeft\",\"type\":\"uint256\"},{\"name\":\"referralCount\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundStarter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_numberUI\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CYCLE_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNewRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_roundStarter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"registerUserEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"upgradeLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"referralCommissionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"missedDirectreferralCommissionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"dailyPayoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"withdrawEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_highestReferrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrals\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"poolAmount\",\"type\":\"uint256\"}],\"name\":\"roundEndEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownershipTransferred\",\"type\":\"event\"}]","ContractName":"EtherMagic","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008519adf650e3344a05e468c5450a995ee1d474ec","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ce5365e9df5bb77494ae1534f57bba8bf981d18c187dd53d680479cacd9c836b"}]}