{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/implementation/FixedPoint.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Library for fixed point arithmetic on uints\r\n */\r\nlibrary FixedPoint {\r\n    using SafeMath for uint256;\r\n\r\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\r\n    // Can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\r\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\r\n\r\n    struct Unsigned {\r\n        uint256 rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`.\r\n     * @param a uint to convert into a FixedPoint.\r\n     * @return the converted FixedPoint.\r\n     */\r\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue == fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue == b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue > fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue < fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice The minimum of `a` and `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the minimum of `a` and `b`.\r\n     */\r\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return a.rawValue < b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice The maximum of `a` and `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the maximum of `a` and `b`.\r\n     */\r\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return a.rawValue > b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds two `Unsigned`s, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.add(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return add(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.sub(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return sub(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return sub(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\r\n        // stored internally as a uint256 ~10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\r\n        // would round to 3, but this computation produces the result 2.\r\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\r\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\r\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\r\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\r\n        if (mod != 0) {\r\n            return Unsigned(mulFloor.add(1));\r\n        } else {\r\n            return Unsigned(mulFloor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\r\n        return Unsigned(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\r\n        // 10^41 is stored internally as a uint256 10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\r\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\r\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a uint256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.div(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a uint256 numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return div(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\r\n        uint256 divFloor = aScaled.div(b.rawValue);\r\n        uint256 mod = aScaled.mod(b.rawValue);\r\n        if (mod != 0) {\r\n            return Unsigned(divFloor.add(1));\r\n        } else {\r\n            return Unsigned(divFloor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a uint256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\r\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\r\n        // This creates the possibility of overflow if b is very large.\r\n        return divCeil(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\r\n     * @dev This will \"floor\" the result.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a uint256 denominator.\r\n     * @return output is `a` to the power of `b`.\r\n     */\r\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\r\n        output = fromUnscaledUint(1);\r\n        for (uint256 i = 0; i < b; i = i.add(1)) {\r\n            output = mul(output, a);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/implementation/MultiRole.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\nlibrary Exclusive {\r\n    struct RoleMembership {\r\n        address member;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.member == memberToCheck;\r\n    }\r\n\r\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\r\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\r\n        roleMembership.member = newMember;\r\n    }\r\n\r\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\r\n        return roleMembership.member;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\r\n        resetMember(roleMembership, initialMember);\r\n    }\r\n}\r\n\r\n\r\nlibrary Shared {\r\n    struct RoleMembership {\r\n        mapping(address => bool) members;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.members[memberToCheck];\r\n    }\r\n\r\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\r\n        require(memberToAdd != address(0x0), \"Cannot add 0x0 to a shared role\");\r\n        roleMembership.members[memberToAdd] = true;\r\n    }\r\n\r\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\r\n        roleMembership.members[memberToRemove] = false;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\r\n        for (uint256 i = 0; i < initialMembers.length; i++) {\r\n            addMember(roleMembership, initialMembers[i]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Base class to manage permissions for the derived class.\r\n */\r\nabstract contract MultiRole {\r\n    using Exclusive for Exclusive.RoleMembership;\r\n    using Shared for Shared.RoleMembership;\r\n\r\n    enum RoleType { Invalid, Exclusive, Shared }\r\n\r\n    struct Role {\r\n        uint256 managingRole;\r\n        RoleType roleType;\r\n        Exclusive.RoleMembership exclusiveRoleMembership;\r\n        Shared.RoleMembership sharedRoleMembership;\r\n    }\r\n\r\n    mapping(uint256 => Role) private roles;\r\n\r\n    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\r\n    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\r\n    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the specified roleId.\r\n     */\r\n    modifier onlyRoleHolder(uint256 roleId) {\r\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\r\n     */\r\n    modifier onlyRoleManager(uint256 roleId) {\r\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\r\n     */\r\n    modifier onlyExclusive(uint256 roleId) {\r\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\r\n     */\r\n    modifier onlyShared(uint256 roleId) {\r\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `memberToCheck` is a member of roleId.\r\n     * @dev Reverts if roleId does not correspond to an initialized role.\r\n     * @param roleId the Role to check.\r\n     * @param memberToCheck the address to check.\r\n     * @return True if `memberToCheck` is a member of `roleId`.\r\n     */\r\n    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\r\n        Role storage role = roles[roleId];\r\n        if (role.roleType == RoleType.Exclusive) {\r\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\r\n        } else if (role.roleType == RoleType.Shared) {\r\n            return role.sharedRoleMembership.isMember(memberToCheck);\r\n        }\r\n        revert(\"Invalid roleId\");\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\r\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\r\n     * initialized, ExclusiveRole.\r\n     * @param roleId the ExclusiveRole membership to modify.\r\n     * @param newMember the new ExclusiveRole member.\r\n     */\r\n    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\r\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current holder of the exclusive role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\r\n     * @param roleId the ExclusiveRole membership to check.\r\n     * @return the address of the current ExclusiveRole member.\r\n     */\r\n    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\r\n        return roles[roleId].exclusiveRoleMembership.getMember();\r\n    }\r\n\r\n    /**\r\n     * @notice Adds `newMember` to the shared role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\r\n     * managing role for `roleId`.\r\n     * @param roleId the SharedRole membership to modify.\r\n     * @param newMember the new SharedRole member.\r\n     */\r\n    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.addMember(newMember);\r\n        emit AddedSharedMember(roleId, newMember, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\r\n     * managing role for `roleId`.\r\n     * @param roleId the SharedRole membership to modify.\r\n     * @param memberToRemove the current SharedRole member to remove.\r\n     */\r\n    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\r\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes caller from the role, `roleId`.\r\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\r\n     * initialized, SharedRole.\r\n     * @param roleId the SharedRole membership to modify.\r\n     */\r\n    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\r\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\r\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if `roleId` is not initialized.\r\n     */\r\n    modifier onlyValidRole(uint256 roleId) {\r\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if `roleId` is initialized.\r\n     */\r\n    modifier onlyInvalidRole(uint256 roleId) {\r\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\r\n     * `initialMembers` will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createSharedRole(\r\n        uint256 roleId,\r\n        uint256 managingRoleId,\r\n        address[] memory initialMembers\r\n    ) internal onlyInvalidRole(roleId) {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Shared;\r\n        role.managingRole = managingRoleId;\r\n        role.sharedRoleMembership.init(initialMembers);\r\n        require(\r\n            roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \"Attempted to use an invalid role to manage a shared role\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\r\n     * `initialMember` will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createExclusiveRole(\r\n        uint256 roleId,\r\n        uint256 managingRoleId,\r\n        address initialMember\r\n    ) internal onlyInvalidRole(roleId) {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Exclusive;\r\n        role.managingRole = managingRoleId;\r\n        role.exclusiveRoleMembership.init(initialMember);\r\n        require(\r\n            roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \"Attempted to use an invalid role to manage an exclusive role\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/common/implementation/Withdrawable.sol\r\n\r\n/**\r\n * Withdrawable contract.\r\n */\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Base contract that allows a specific role to withdraw any ETH and/or ERC20 tokens that the contract holds.\r\n */\r\nabstract contract Withdrawable is MultiRole {\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 private roleId;\r\n\r\n    /**\r\n     * @notice Withdraws ETH from the contract.\r\n     */\r\n    function withdraw(uint256 amount) external onlyRoleHolder(roleId) {\r\n        Address.sendValue(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws ERC20 tokens from the contract.\r\n     * @param erc20Address ERC20 token to withdraw.\r\n     * @param amount amount of tokens to withdraw.\r\n     */\r\n    function withdrawErc20(address erc20Address, uint256 amount) external onlyRoleHolder(roleId) {\r\n        IERC20 erc20 = IERC20(erc20Address);\r\n        erc20.safeTransfer(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method that allows derived contracts to create a role for withdrawal.\r\n     * @dev Either this method or `_setWithdrawRole` must be called by the derived class for this contract to function\r\n     * properly.\r\n     * @param newRoleId ID corresponding to role whose members can withdraw.\r\n     * @param managingRoleId ID corresponding to managing role who can modify the withdrawable role's membership.\r\n     * @param withdrawerAddress new manager of withdrawable role.\r\n     */\r\n    function _createWithdrawRole(\r\n        uint256 newRoleId,\r\n        uint256 managingRoleId,\r\n        address withdrawerAddress\r\n    ) internal {\r\n        roleId = newRoleId;\r\n        _createExclusiveRole(newRoleId, managingRoleId, withdrawerAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method that allows derived contracts to choose the role for withdrawal.\r\n     * @dev The role `setRoleId` must exist. Either this method or `_createWithdrawRole` must be\r\n     * called by the derived class for this contract to function properly.\r\n     * @param setRoleId ID corresponding to role whose members can withdraw.\r\n     */\r\n    function _setWithdrawRole(uint256 setRoleId) internal onlyValidRole(setRoleId) {\r\n        roleId = setRoleId;\r\n    }\r\n}\r\n\r\n// File: contracts/common/implementation/Timer.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Universal store of current contract time for testing environments.\r\n */\r\ncontract Timer {\r\n    uint256 private currentTime;\r\n\r\n    constructor() public {\r\n        currentTime = now; // solhint-disable-line not-rely-on-time\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the current time.\r\n     * @dev Will revert if not running in test mode.\r\n     * @param time timestamp to set `currentTime` to.\r\n     */\r\n    function setCurrentTime(uint256 time) external {\r\n        currentTime = time;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\r\n     * Otherwise, it will return the block timestamp.\r\n     * @return uint256 for the current Testable timestamp.\r\n     */\r\n    function getCurrentTime() public view returns (uint256) {\r\n        return currentTime;\r\n    }\r\n}\r\n\r\n// File: contracts/common/implementation/Testable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Base class that provides time overrides, but only if being run in test mode.\r\n */\r\nabstract contract Testable {\r\n    // If the contract is being run on the test network, then `timerAddress` will be the 0x0.\r\n    // Note: this variable should be set on construction and never modified.\r\n    address public timerAddress;\r\n\r\n    /**\r\n     * @notice Constructs the Testable contract. Called by child contracts.\r\n     * @param _timerAddress Contract that stores the current time in a testing environment.\r\n     * Must be set to 0x0 for production environments that use live time.\r\n     */\r\n    constructor(address _timerAddress) internal {\r\n        timerAddress = _timerAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if not running in test mode.\r\n     */\r\n    modifier onlyIfTest {\r\n        require(timerAddress != address(0x0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the current time.\r\n     * @dev Will revert if not running in test mode.\r\n     * @param time timestamp to set current Tesable time to.\r\n     */\r\n    function setCurrentTime(uint256 time) external onlyIfTest {\r\n        Timer(timerAddress).setCurrentTime(time);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\r\n     * Otherwise, it will return the block timestamp.\r\n     * @return uint for the current Testable timestamp.\r\n     */\r\n    function getCurrentTime() public view returns (uint256) {\r\n        if (timerAddress != address(0x0)) {\r\n            return Timer(timerAddress).getCurrentTime();\r\n        } else {\r\n            return now; // solhint-disable-line not-rely-on-time\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/oracle/interfaces/StoreInterface.sol\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Interface that allows financial contracts to pay oracle fees for their use of the system.\r\n */\r\ninterface StoreInterface {\r\n    /**\r\n     * @notice Pays Oracle fees in ETH to the store.\r\n     * @dev To be used by contracts whose margin currency is ETH.\r\n     */\r\n    function payOracleFees() external payable;\r\n\r\n    /**\r\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\r\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\r\n     * @param erc20Address address of the ERC20 token used to pay the fee.\r\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\r\n     */\r\n    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;\r\n\r\n    /**\r\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\r\n     * @param startTime defines the beginning time from which the fee is paid.\r\n     * @param endTime end time until which the fee is paid.\r\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\r\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\r\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\r\n     * @return latePenalty for paying the fee after the deadline.\r\n     */\r\n    function computeRegularFee(\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        FixedPoint.Unsigned calldata pfc\r\n    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\r\n\r\n    /**\r\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\r\n     * @param currency token used to pay the final fee.\r\n     * @return finalFee amount due.\r\n     */\r\n    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\r\n}\r\n\r\n// File: contracts/oracle/implementation/Store.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title An implementation of Store that can accept Oracle fees in ETH or any arbitrary ERC20 token.\r\n */\r\ncontract Store is StoreInterface, Withdrawable, Testable {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using FixedPoint for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /****************************************\r\n     *    INTERNAL VARIABLES AND STORAGE    *\r\n     ****************************************/\r\n\r\n    enum Roles { Owner, Withdrawer }\r\n\r\n    FixedPoint.Unsigned public fixedOracleFeePerSecondPerPfc; // Percentage of 1 E.g., .1 is 10% Oracle fee.\r\n    FixedPoint.Unsigned public weeklyDelayFeePerSecondPerPfc; // Percentage of 1 E.g., .1 is 10% weekly delay fee.\r\n\r\n    mapping(address => FixedPoint.Unsigned) public finalFees;\r\n    uint256 public constant SECONDS_PER_WEEK = 604800;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event NewFixedOracleFeePerSecondPerPfc(FixedPoint.Unsigned newOracleFee);\r\n    event NewWeeklyDelayFeePerSecondPerPfc(FixedPoint.Unsigned newWeeklyDelayFeePerSecondPerPfc);\r\n    event NewFinalFee(FixedPoint.Unsigned newFinalFee);\r\n\r\n    /**\r\n     * @notice Construct the Store contract.\r\n     */\r\n    constructor(\r\n        FixedPoint.Unsigned memory _fixedOracleFeePerSecondPerPfc,\r\n        FixedPoint.Unsigned memory _weeklyDelayFeePerSecondPerPfc,\r\n        address _timerAddress\r\n    ) public Testable(_timerAddress) {\r\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\r\n        _createWithdrawRole(uint256(Roles.Withdrawer), uint256(Roles.Owner), msg.sender);\r\n        setFixedOracleFeePerSecondPerPfc(_fixedOracleFeePerSecondPerPfc);\r\n        setWeeklyDelayFeePerSecondPerPfc(_weeklyDelayFeePerSecondPerPfc);\r\n    }\r\n\r\n    /****************************************\r\n     *  ORACLE FEE CALCULATION AND PAYMENT  *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Pays Oracle fees in ETH to the store.\r\n     * @dev To be used by contracts whose margin currency is ETH.\r\n     */\r\n    function payOracleFees() external override payable {\r\n        require(msg.value > 0, \"Value sent can't be zero\");\r\n    }\r\n\r\n    /**\r\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\r\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\r\n     * @param erc20Address address of the ERC20 token used to pay the fee.\r\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\r\n     */\r\n    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external override {\r\n        IERC20 erc20 = IERC20(erc20Address);\r\n        require(amount.isGreaterThan(0), \"Amount sent can't be zero\");\r\n        erc20.safeTransferFrom(msg.sender, address(this), amount.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\r\n     * @dev The late penalty is similar to the regular fee in that is is charged per second over the period between\r\n     * startTime and endTime. The late penalty percentage increases over time as follows:\r\n     * - 0-1 week since startTime: no late penalty\r\n     * - 1-2 weeks since startTime: 1x late penalty percentage is applied\r\n     * - 2-3 weeks since startTime: 2x late penalty percentage is applied\r\n     * - ...\r\n     * @param startTime defines the beginning time from which the fee is paid.\r\n     * @param endTime end time until which the fee is paid.\r\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\r\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\r\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\r\n     * @return latePenalty penalty percentage, if any, for paying the fee after the deadline.\r\n     */\r\n    function computeRegularFee(\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        FixedPoint.Unsigned calldata pfc\r\n    ) external override view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) {\r\n        uint256 timeDiff = endTime.sub(startTime);\r\n\r\n        // Multiply by the unscaled `timeDiff` first, to get more accurate results.\r\n        regularFee = pfc.mul(timeDiff).mul(fixedOracleFeePerSecondPerPfc);\r\n\r\n        // Compute how long ago the start time was to compute the delay penalty.\r\n        uint256 paymentDelay = getCurrentTime().sub(startTime);\r\n\r\n        // Compute the additional percentage (per second) that will be charged because of the penalty.\r\n        // Note: if less than a week has gone by since the startTime, paymentDelay / SECONDS_PER_WEEK will truncate to\r\n        // 0, causing no penalty to be charged.\r\n        FixedPoint.Unsigned memory penaltyPercentagePerSecond = weeklyDelayFeePerSecondPerPfc.mul(\r\n            paymentDelay.div(SECONDS_PER_WEEK)\r\n        );\r\n\r\n        // Apply the penaltyPercentagePerSecond to the payment period.\r\n        latePenalty = pfc.mul(timeDiff).mul(penaltyPercentagePerSecond);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\r\n     * @param currency token used to pay the final fee.\r\n     * @return finalFee amount due denominated in units of `currency`.\r\n     */\r\n    function computeFinalFee(address currency) external override view returns (FixedPoint.Unsigned memory) {\r\n        return finalFees[currency];\r\n    }\r\n\r\n    /****************************************\r\n     *   ADMIN STATE MODIFYING FUNCTIONS    *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Sets a new oracle fee per second.\r\n     * @param newFixedOracleFeePerSecondPerPfc new fee per second charged to use the oracle.\r\n     */\r\n    function setFixedOracleFeePerSecondPerPfc(FixedPoint.Unsigned memory newFixedOracleFeePerSecondPerPfc)\r\n        public\r\n        onlyRoleHolder(uint256(Roles.Owner))\r\n    {\r\n        // Oracle fees at or over 100% don't make sense.\r\n        require(newFixedOracleFeePerSecondPerPfc.isLessThan(1), \"Fee must be < 100% per second.\");\r\n        fixedOracleFeePerSecondPerPfc = newFixedOracleFeePerSecondPerPfc;\r\n        emit NewFixedOracleFeePerSecondPerPfc(newFixedOracleFeePerSecondPerPfc);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a new weekly delay fee.\r\n     * @param newWeeklyDelayFeePerSecondPerPfc fee escalation per week of late fee payment.\r\n     */\r\n    function setWeeklyDelayFeePerSecondPerPfc(FixedPoint.Unsigned memory newWeeklyDelayFeePerSecondPerPfc)\r\n        public\r\n        onlyRoleHolder(uint256(Roles.Owner))\r\n    {\r\n        require(newWeeklyDelayFeePerSecondPerPfc.isLessThan(1), \"weekly delay fee must be < 100%\");\r\n        weeklyDelayFeePerSecondPerPfc = newWeeklyDelayFeePerSecondPerPfc;\r\n        emit NewWeeklyDelayFeePerSecondPerPfc(newWeeklyDelayFeePerSecondPerPfc);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a new final fee for a particular currency.\r\n     * @param currency defines the token currency used to pay the final fee.\r\n     * @param newFinalFee final fee amount.\r\n     */\r\n    function setFinalFee(address currency, FixedPoint.Unsigned memory newFinalFee)\r\n        public\r\n        onlyRoleHolder(uint256(Roles.Owner))\r\n    {\r\n        finalFees[currency] = newFinalFee;\r\n        emit NewFinalFee(newFinalFee);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"_fixedOracleFeePerSecondPerPfc\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"_weeklyDelayFeePerSecondPerPfc\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_timerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMember\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"AddedSharedMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"newFinalFee\",\"type\":\"tuple\"}],\"name\":\"NewFinalFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"newOracleFee\",\"type\":\"tuple\"}],\"name\":\"NewFixedOracleFeePerSecondPerPfc\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"newWeeklyDelayFeePerSecondPerPfc\",\"type\":\"tuple\"}],\"name\":\"NewWeeklyDelayFeePerSecondPerPfc\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMember\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"RemovedSharedMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMember\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ResetExclusiveMember\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SECONDS_PER_WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"computeFinalFee\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"pfc\",\"type\":\"tuple\"}],\"name\":\"computeRegularFee\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"regularFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"latePenalty\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"finalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedOracleFeePerSecondPerPfc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"}],\"name\":\"getMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"memberToCheck\",\"type\":\"address\"}],\"name\":\"holdsRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payOracleFees\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"amount\",\"type\":\"tuple\"}],\"name\":\"payOracleFeesErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"memberToRemove\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"}],\"name\":\"renounceMembership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"resetMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setCurrentTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"newFinalFee\",\"type\":\"tuple\"}],\"name\":\"setFinalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"newFixedOracleFeePerSecondPerPfc\",\"type\":\"tuple\"}],\"name\":\"setFixedOracleFeePerSecondPerPfc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"newWeeklyDelayFeePerSecondPerPfc\",\"type\":\"tuple\"}],\"name\":\"setWeeklyDelayFeePerSecondPerPfc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weeklyDelayFeePerSecondPerPfc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Store","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"ipfs://f974beca201b19450df2c17ff4b940833eedd16785e35ff3343c5c43558f5645"}]}