{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\npragma experimental ABIEncoderV2;\n// File: contracts/Types.sol\n/*\n  Copyright 2019 Swap Holdings Ltd.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n/**\n  * @title Types: Library of Swap Protocol Types and Hashes\n  */\nlibrary Types {\n  bytes constant internal EIP191_HEADER = \"\\x19\\x01\";\n  struct Order {\n    uint256 nonce;                // Unique per order and should be sequential\n    uint256 expiry;               // Expiry in seconds since 1 January 1970\n    Party signer;                 // Party to the trade that sets terms\n    Party sender;                 // Party to the trade that accepts terms\n    Party affiliate;              // Party compensated for facilitating (optional)\n    Signature signature;          // Signature of the order\n  }\n  struct Party {\n    bytes4 kind;                  // Interface ID of the token\n    address wallet;               // Wallet address of the party\n    address token;                // Contract address of the token\n    uint256 param;                // Value (ERC-20) or ID (ERC-721)\n  }\n  struct Signature {\n    address signatory;            // Address of the wallet used to sign\n    address validator;            // Address of the intended swap contract\n    bytes1 version;               // EIP-191 signature version\n    uint8 v;                      // `v` value of an ECDSA signature\n    bytes32 r;                    // `r` value of an ECDSA signature\n    bytes32 s;                    // `s` value of an ECDSA signature\n  }\n  bytes32 constant internal DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\n    \"EIP712Domain(\",\n    \"string name,\",\n    \"string version,\",\n    \"address verifyingContract\",\n    \")\"\n  ));\n  bytes32 constant internal ORDER_TYPEHASH = keccak256(abi.encodePacked(\n    \"Order(\",\n    \"uint256 nonce,\",\n    \"uint256 expiry,\",\n    \"Party signer,\",\n    \"Party sender,\",\n    \"Party affiliate\",\n    \")\",\n    \"Party(\",\n    \"bytes4 kind,\",\n    \"address wallet,\",\n    \"address token,\",\n    \"uint256 param\",\n    \")\"\n  ));\n  bytes32 constant internal PARTY_TYPEHASH = keccak256(abi.encodePacked(\n    \"Party(\",\n    \"bytes4 kind,\",\n    \"address wallet,\",\n    \"address token,\",\n    \"uint256 param\",\n    \")\"\n  ));\n  /**\n    * @notice Hash an order into bytes32\n    * @dev EIP-191 header and domain separator included\n    * @param order Order The order to be hashed\n    * @param domainSeparator bytes32\n    * @return bytes32 A keccak256 abi.encodePacked value\n    */\n  function hashOrder(\n    Order calldata order,\n    bytes32 domainSeparator\n  ) external pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\n      EIP191_HEADER,\n      domainSeparator,\n      keccak256(abi.encode(\n        ORDER_TYPEHASH,\n        order.nonce,\n        order.expiry,\n        keccak256(abi.encode(\n          PARTY_TYPEHASH,\n          order.signer.kind,\n          order.signer.wallet,\n          order.signer.token,\n          order.signer.param\n        )),\n        keccak256(abi.encode(\n          PARTY_TYPEHASH,\n          order.sender.kind,\n          order.sender.wallet,\n          order.sender.token,\n          order.sender.param\n        )),\n        keccak256(abi.encode(\n          PARTY_TYPEHASH,\n          order.affiliate.kind,\n          order.affiliate.wallet,\n          order.affiliate.token,\n          order.affiliate.param\n        ))\n      ))\n    ));\n  }\n  /**\n    * @notice Hash domain parameters into bytes32\n    * @dev Used for signature validation (EIP-712)\n    * @param name bytes\n    * @param version bytes\n    * @param verifyingContract address\n    * @return bytes32 returns a keccak256 abi.encodePacked value\n    */\n  function hashDomain(\n    bytes calldata name,\n    bytes calldata version,\n    address verifyingContract\n  ) external pure returns (bytes32) {\n    return keccak256(abi.encode(\n      DOMAIN_TYPEHASH,\n      keccak256(name),\n      keccak256(version),\n      verifyingContract\n    ));\n  }\n}\n","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"version\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"}],\"name\":\"hashDomain\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"param\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"signer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"param\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"kind\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"param\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Party\",\"name\":\"affiliate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"version\",\"type\":\"bytes1\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Types.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"}],\"name\":\"hashOrder\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Types","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://dda790056b307e8933d9a27927972bc0cd487bb5932a2f5775560f83ff7611ad"}]}